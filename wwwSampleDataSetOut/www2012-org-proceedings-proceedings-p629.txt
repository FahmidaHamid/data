Counting Beyond a Yottabyte, or how SPARQL 1.1

Property Paths will Prevent Adoption of the Standard

Marcelo Arenas

Sebastián Conca

Jorge Pérez

Department of Computer Science

Department of Computer Science

Department of Computer Science

PUC Chile

marenas@ing.puc.cl

PUC Chile

saconca@puc.cl

Universidad de Chile

jperez@dcc.uchile.cl

ABSTRACT
SPARQL –the standard query language for querying RDF– pro-
vides only limited navigational functionalities, although these fea-
tures are of fundamental importance for graph data formats such as
RDF. This has led the W3C to include the property path feature in
the upcoming version of the standard, SPARQL 1.1.

We tested several implementations of SPARQL 1.1 handling prop-
erty path queries, and we observed that their evaluation methods
for this class of queries have a poor performance even in some
very simple scenarios. To formally explain this fact, we conduct
a theoretical study of the computational complexity of property
paths evaluation. Our results imply that the poor performance of
the tested implementations is not a problem of these particular sys-
tems, but of the speciﬁcation itself. In fact, we show that any im-
plementation that adheres to the SPARQL 1.1 speciﬁcation (as of
November 2011) is doomed to show the same behavior, the key
issue being the need for counting solutions imposed by the current
speciﬁcation. We provide several intractability results, that together
with our empirical results, provide strong evidence against the cur-
rent semantics of SPARQL 1.1 property paths. Finally, we put our
results in perspective, and propose a natural alternative semantics
with tractable evaluation, that we think may lead to a wide adoption
of the language by practitioners, developers and theoreticians.

Categories and Subject Descriptors
H.2.3 [Languages]: Query Languages

Keywords
SPARQL 1.1, property paths, bag semantics, counting complexity

INTRODUCTION

1.
It has been noted that, although RDF is a graph data format, its
standard query language, SPARQL, provides only limited naviga-
tional functionalities. This has led the W3C to include the property-
path feature in the upcoming version of the standard, SPARQL 1.1.
Property paths are essentially regular expressions that retrieve pairs
of nodes of an RDF graph that are connected by paths conform-
ing to those expressions. In this paper, we study the semantics of
property paths and the complexity of evaluating them. We per-
form this study both from a theoretical and a practical point of
view, and provide strong arguments against the current semantics
of SPARQL 1.1 property paths.

We began our study by testing several SPARQL 1.1 implementa-
tions, and we were faced with an intriguing empirical observation:
all these implementations of SPARQL 1.1 fail to give an answer

Copyright is held by the International World Wide Web Conference Com-
mittee (IW3C2). Distribution of these papers is limited to classroom use,
and personal use by others.
WWW 2012, April 16–20, 2012, Lyon, France
ACM 978-1-4503-1229-5/12/04.

1000

100

10

1

×

2

+ + + + + +
∗
× × × ×
2
2
∗
∗
2

2
∗
4

2
∗

×
2

∗
6

+

ARQ
RDFQ
KGram
Sesame

+
×
∗
2

×

×

2

∗

∗

+

+

+

10

12

14

16

×

2

+
∗

8

Figure 1: Time in seconds for processing Cliq-1 w.r.t. the clique
size n (time axis in log-scale)

@prefix : <http://example.org/> .
:a0 :p :a1, :a2, :a3, :a4, :a5, :a6, :a7 .
:a1 :p :a0, :a2, :a3, :a4, :a5, :a6, :a7 .
:a2 :p :a0, :a1, :a3, :a4, :a5, :a6, :a7 .
:a3 :p :a0, :a1, :a2, :a4, :a5, :a6, :a7 .
:a4 :p :a0, :a1, :a2, :a3, :a5, :a6, :a7 .
:a5 :p :a0, :a1, :a2, :a3, :a4, :a6, :a7 .
:a6 :p :a0, :a1, :a2, :a3, :a4, :a5, :a7 .
:a7 :p :a0, :a1, :a2, :a3, :a4, :a5, :a6 .

Figure 2: RDF graph representing a clique with 8 nodes

in a reasonable time (one hour) even for small input graphs and
very simple property path expressions. We conduct two sets of
experiments, the clique experiments and the foaf experiments, test-
ing four implementations: ARQ [22], RDF::Query [24], KGRAM-
Corese [23], and Sesame [25]. For the ﬁrst experiment, we con-
sider RDF graphs representing cliques (complete graphs) of dif-
ferent sizes. For example, Figure 2 shows a clique with 8 nodes
in N3 notation. In this scenario, we tested the performance of the
implementations by using a very simple query:

Cliq-1:

SELECT * WHERE { :a0 (:p)* :a1 }

that essentially asks for paths of arbitrary length between two ﬁxed
nodes. The experimental behavior for this query was quite sur-
prising: no implementation was able to handle a clique with 13
nodes. That is, all implementations fail to give an answer after
one hour for an input RDF graph with only 156 triples and 970
bytes of size on disk. In particular, Sesame fails for a clique with
10 nodes, KGRAM and RDF::Query for 12 nodes, and ARQ for
13 nodes. Our experiments show that for all implementations, the
time needed to process Cliq-1 seems to grow doubly-exponentially
w.r.t. the input data ﬁle (see the graph in Figure 1, which is in log-
arithmic scale). We also tested queries with nested stars, showing
that nesting has an unexpected impact in query evaluation. In par-
ticular, we tested the query:

WWW 2012 – Session: Ontology Representation and Querying: RDF and SPARQLApril 16–20, 2012, Lyon, France629Input
9.2KB
10.9KB
11.4KB
13.2KB
14.8KB
17.2KB
20.5KB
25.8KB

ARQ RDFQ Kgram Sesame
–
5.13
–
8.20
65.87
–
–
292.43
–
–
–
–
–
–
–
–

313.37
–
–
–
–
–
–
–

75.70
325.83
–
–
–
–
–
–

Input
9.2KB
10.9KB
11.4KB
13.2KB
14.8KB
17.2KB
20.5KB
25.8KB

ARQ
2.24
2.60
6.88
24.42
–
–
–
–

RDFQ Kgram Sesame
–
47.31
–
204.95
3222.47
–
–
–
–
–
–
–
–
–
–
–

2.37
6.43
80.73
394.61
–
–
–
–

Psparql Gleen
1.39
1.32
1.34
1.38
1.38
1.42
1.50
1.52

0.29
0.30
0.30
0.31
0.33
0.35
0.44
0.45

Table 1: Time in seconds for processing query Foaf-1

Table 2: Time in seconds for processing Foaf-1D

Cliq-2:

SELECT * WHERE { :a0 ((:p)*)* :a1 },

for which no implementation was able to handle even a clique with
8 nodes. That is, the implementations fail for the input graph shown
in Figure 2 (which occupied only 378 bytes on disk).

To show that this behavior also appears with real data, we de-
vised an experiment with data crawled from the Web. We con-
structed RDF graphs from foaf documents crawled by following
foaf:knows links starting from Axel Polleres’ foaf document. We
considered several test cases of increasing size, from 9.2 KB (38
nodes and 119 triples) to 25.8 KB (76 nodes and 360 triples), and
we tested the following simple query asking for the network of
friends of Axel Polleres1:

Foaf-1: SELECT * WHERE { axel:me (foaf:knows)* ?x }.

As in the previous case, the results are striking. For query Foaf-1 all
the implementations exceeded the timeout for an input RDF graph
of 14.8 KB (with only 54 nodes and 201 triples). Table 1 shows the
behavior of the different implementations for different input sizes.
The “–” symbol in the table means timeout (one hour).

As our experiments show, for the tested implementations, prop-
erty path evaluation is essentially infeasible in practice. But, what
is the reason for this behavior? Is this only a problem of the par-
ticular implementations that we tested? Or is there a fundamental
problem in the SPARQL 1.1 speciﬁcation? Our theoretical results
show that this last question is the key to understand this issue. In
fact, we formally prove that, essentially, any implementation that
follows the SPARQL 1.1 speciﬁcation (as of November 2011) [10]
will be doomed to show the same behavior.

We begin our theoretical study by formalizing the semantics of
property paths. SPARQL 1.1 deﬁnes a bag (or multiset) semantics
for these expressions. That is, when evaluating property-path ex-
pressions one can obtain several duplicates for the same solution,
essentially one duplicate for every different path in the graph satis-
fying the expression. For example, every solution of query Cliq-1 is
an empty tuple that can have several duplicates in the output. ARQ
for instance, represents this empty tuple as | |, and for query
Cliq-1 it returns several copies of |
|. Since RDF graphs con-
taining cycles may lead to an inﬁnite number of paths, the ofﬁcial
speciﬁcation deﬁnes the semantics by means of a particular count-
ing procedure, which handles cycles in a way that ensures that the
ﬁnal count is ﬁnite. We formalize this procedure, and some other
alternative semantics, and prove theoretical bounds on the compu-
tational complexity of the evaluation problem, showing that the bag
semantics for property paths is the main reason for the infeasibility
of the evaluation of property paths in SPARQL 1.1.

Our theoretical study allowed us to prove some extremely large
lower bounds for property-path evaluation: for query Cliq-2 and
the RDF graph in Figure 2, we show that every implementation that
strictly adheres to the SPARQL 1.1 speciﬁcation should provide as
output a ﬁle of size more than 79 Yottabytes! It should be noticed

that some studies estimate that the cumulative capacity of all the
digital stores in the world in 2011 is less than 1 Yottabyte [8] 2.

We study the computational complexity of the setting for prop-
erty paths proposed by the W3C, as well as for several alternative
settings. Given the bag semantics of property paths, we measure the
complexity in terms of counting complexity classes. The most stud-
ied and used intractable counting class is #P [19], which is, intu-
itively, the counting class associated to the NP problems: while the
prototypical NP-complete problem is checking if a propositional
formula is satisﬁable (SAT), the prototypical #P-complete problem
is counting how many truth assignments satisfy a propositional for-
mula (COUNTSAT). We also make a distinction between data com-
plexity and combined complexity. Data complexity is the complex-
ity of evaluating a query on a database instance assuming that the
query is ﬁxed, that is, the complexity is measured only in terms of
the size of the database. Combined complexity considers both the
query and the database instance as input of the problem [20].

We prove several complexity results. In particular, one of our
main results states that property-path evaluation according to the
W3C semantics is #P-complete in data complexity. Moreover, we
prove that the combined complexity of this problem is not even
inside #P.
It has been argued that a possibility to deal with the
problem of counting paths in the presence of cycles is to consider
only simple paths (a simple path is a path with no repeated nodes).
We prove that for this alternative semantics the problem is still
#P-complete for data complexity, and remains in #P for combined
complexity. Thus, although the evaluation problems for these two
semantics are intractable, the one based on simple paths has lower
combined complexity.

All our results indicate that evaluating property-path queries ac-
cording to the ofﬁcial SPARQL 1.1 semantics is essentially infeasi-
ble. But not all are bad news. A possible solution to this problem is
to not use a semantics that considers duplicates, but instead a more
traditional existential semantics for path queries, as it has been done
for years in graph databases [13, 4, 3], in XML [12, 9], and even
on RDF [1, 16] previous to SPARQL 1.1. It is well-known that for
this semantics the evaluation problem is tractable, and even linear
in data complexity.

As our ﬁnal theoretical result, we prove that the existential se-
mantics for property paths is equivalent to the SPARQL 1.1 se-
mantics when duplicates are eliminated. Notice that the language
has a special feature for this: SELECT DISTINCT. Thus, since the
existential semantics can be efﬁciently evaluated, one would ex-
pect implementations to take advantage of the SELECT DISTINCT
feature. Unfortunately, as our ﬁnal experiments show, no signif-
icant improvement in performance can be observed in the tested
implementations when the SELECT DISTINCT feature is used. For
example, consider the following query:

Foaf-1D: SELECT DISTINCT *

WHERE { axel:me (foaf:knows)* ?x }.

1

axel: preﬁx is <http://www.polleres.net/foaf.rdf#>.

21 Yottabyte (YB) = 1 trillion Terabytes.

WWW 2012 – Session: Ontology Representation and Querying: RDF and SPARQLApril 16–20, 2012, Lyon, France630Although the tested implementations spent less time processing
some inputs, none of them was able to process an input ﬁle of
14.8 KB (Table 2). As a comparison, we also tested two imple-
mentations of existential paths in SPARQL 1.0: Psparql [1] and
Gleen [27], which return the same answers as the other tested im-
plementations for the queries using the SELECT DISTINCT fea-
ture. The numbers speak for themselves (Table 2).

Organization of the paper: Section 2 presents our experiments.
Sections 3 and 4 present the formalization of SPARQL 1.1 and
property paths. Section 5 presents our main complexity results. In
Section 6, we study alternative semantics for counting paths. Sec-
tion 7 introduces the existential semantics and provide some exper-
imental and theoretical results. Finally, we outline in Section 8 a
proposal for a semantics with tractable query evaluation.

2. EXPERIMENTS
In this section, we describe our experimental setting and present
more details about the data and results described in the introduc-
tion. We assume some familiarity with RDF and the most simple
SPARQL features, in particular, with the SELECT and FILTER key-
words [10], and we only treat property paths at an intuitive level
(we formalize the language in Sections 3 and 4).

As described in the current SPARQL 1.1 speciﬁcation, “a prop-
erty path is a possible route through a graph between two graph
nodes [...] (and) query evaluation determines all matches of a path
expression [...]” [10]. More speciﬁcally, property-path expressions
are regular expressions over properties (edge labels) in the graph.
For example, if :p is a property, then (:p)* is a property-path
expression that matches pairs of nodes that are connected by a se-
quence of zero or more :p properties in the graph. The star oper-
ator (*) and its derivatives (like the one or more construct) are the
only operators that add expressiveness to the language. The ofﬁ-
cial semantics of the other property-path constructors are deﬁned
in terms of SPARQL 1.0 operators [10] (and thus, can be simulated
in the previous version of the SPARQL standard). Hence, our tests
focus on the star operator, and, in particular, on the most simple
expressions that can be generated by using this construct.

2.1 Experimental setting
All our experiments are repeatable; the tools that we implemented
for them as well as the data and queries that we used are available at
http://www.dcc.uchile.cl/~jperez/papers/www2012/.
In our tests,
we consider the following SPARQL 1.1 implementations:

ARQ – version 2.8.8, 21 April 2011 [22]: ARQ is a java imple-
mentation of SPARQL for Jena [5]. When testing ARQ, we use the
command-line tool sparql provided in the standard distribution.

RDF::Query – version 2.907, 1 June 2011 [24]: RDF::Query is
a perl module implementing SPARQL 1.1, and we test it with the
executable tool query.pl provided with the standard distribution.

KGRAM – version 3.0, September 2011 [23]: KGRAM [6] pro-
vides a set of java libraries that implements SPARQL. To test this
engine, we implemented a command-line tool kgsparql.java.

Sesame – version 2.5.1, 23 September 2011 [25]: Sesame pro-
vides a set of java libraries to execute SPARQL 1.1 queries. To
test Sesame, we implemented a command-line tool sesame.java.

We run all our tests in a dedicated machine with the following con-
ﬁguration: Debian 6.0.2 Operating System, Kernel 2.6.32, CPU
Intel Xeon X3220 Quadcore with 2.40GHz, and 4GB PC2-5300
RAM. Whenever we run a java program, we set the java virtual

n
5
6
7
8
9
10
11
12
13

ARQ
1.18
1.19
1.37
1.73
2.31
4.15
31.21
1422.30
–

RDFQ Kgram Sesame
0.76
1.24
2.36
9.09
165.28
–
–
–
–

0.57
0.60
0.95
1.38
5.38
228.68
–
–
–

0.90
1.44
5.09
34.01
295.88
2899.41
–
–
–

Solutions
16
65
326
1,957
13,700
109,601
986,410
9,864,101
–

Table 3: Time in seconds and number of solutions for query
Cliq-1 (CliqF-1 for RDF::Query)

n
2
3
4
5
6

ARQ RDFQ
0.76
1.40
0.84
1.19
19.38
1.65
–
97.06
–
–

Sol.
1
6
305
418,576
–

n
2
3
4

ARQ RDFQ
0.77
1.20
6.85
1.42
–
–

Sol.
1
42
–

Table 4: Time in seconds and number of solutions for queries
Cliq-2 (left) and Cliq-3 (right)

machine to be able to use all the available RAM (4 GB). All tests
were run considering main memory storage. This should not be
considered as a problem since the maximum size of the input RDF
graphs that we used was only 25.8 KB. We considered a timeout
of 60 minutes. For each test, the number reported is the average
of the results obtained by executing the test (at least) 4 times. No
experiment showed a signiﬁcant standard deviation.

2.2 The clique experiment
In our ﬁrst experiment, we considered cliques (complete graphs) of
different sizes, from a clique with 2 nodes (containing 2 triples) to
a clique with 13 nodes (156 triples). Query Cliq-1 described in the
introduction was the ﬁrst query to be tested. Since this query has
no variables, the solution is an empty tuple, which, for example,
in ARQ is represented by the string |
|, and in Sesame by the
string [] (when the query solution is printed to the standard out-
put). RDF::Query does not support queries without variables, thus
for this implementation we tested the following query:

CliqF-1: SELECT * WHERE
{ :a0 (:p)* ?x

FILTER (?x = :a1) }.

Table 3 shows the result obtained for this experiment in terms of the
time (in seconds) and the number of solutions produced as output,
when the input is a clique with n nodes. The symbol “–” in the
table means timeout of one hour. Notice that this table contains a
tabular representation of the numbers shown in Figure 1.

We also tested the impact of using nested stars. In particular, we

consider query Cliq-2 described in the introduction and query

Cliq-3:

SELECT * WHERE { :a0 (((:p)*)*)* :a1 }

For these expressions containing nested stars, Sesame produces a
run-time error (we have reported this bug in the Sesame’s mailing
list), and KGRAM does not produce the expected output according
to the ofﬁcial SPARQL 1.1 speciﬁcation [10]. Thus, for these cases
it is only meaningful to test ARQ and RDF::Query (we use FILTER
for RDF::Query, as we did for the case of query CliqF-1). The
results are shown in Table 4.

As described in the introduction, our results show the infeasibil-
ity of evaluating property paths including the star operator in the
the four tested implementations. We emphasize only here the un-
expected impact of nesting stars: for query Cliq-3 both implemen-
tations that we tested fail for an RDF graph representing a clique

WWW 2012 – Session: Ontology Representation and Querying: RDF and SPARQLApril 16–20, 2012, Lyon, France631File
A
B
C
D
E
F
G
H

#nodes

#triples

size (N3 format)

38
43
47
52
54
57
68
76

119
143
150
176
201
237
281
360

9.2KB
10.9KB
11.4KB
13.2KB
14.8KB
17.2KB
20.5KB
25.8KB

Table 5: Description of the ﬁles (name, number of nodes, num-
ber of RDF triples, and size in disk) used in the foaf experiment.

File
A
B
C
D
E

ARQ RDFQ Kgram Sesame
5.13
–
–
8.20
–
65.87
–
292.43
–
–

313.37
–
–
–
–

75.70
325.83
–
–
–

Solutions Size (ARQ)
2MB
8.4MB
120MB
587MB
–

29,817
122,631
1,739,331
8,511,943
–

Table 6: Time in seconds, number of solutions, and output size
for query Foaf-1

with only 4 nodes, which contains only 12 triples and has a size of
126 bytes in N3 notation. Although in this example the nesting of
the star operator does not seem to be natural, it is well known that
nesting is indeed necessary to represent some regular languages [7].
It is also notable how the number of solutions increase w.r.t. the in-
put size. For instance, for query Cliq-1, ARQ returns more than 9
million solutions for a clique with 12 nodes (ARQ’s output in this
case has more than 9 million lines containing the string |

|).

2.3 The foaf experiment
For our second experiment, we use real data crawled from the Web.
We decided to consider the foaf:knows property, as it has been
used as a paradigmatic property for examples regarding path queries
(notice that it is in all the examples used to describe property paths
in the ofﬁcial SPARQL 1.1 speciﬁcation [10]).

To construct our datasets we use the SemWeb Client Li-
brary [28], which provides a command-line tool semwebquery that
can be used to query the Web of Linked Data. The tool receives as
input a SPARQL query Q, an integer value k and a URI u. When
executed, it ﬁrst retrieves the data from u, evaluates Q over this
data, and follows the URIs mentioned in it to obtain more data. This
process is repeated k times (see [11] for a description of this query
approach). We use a CONSTRUCT query to retrieve URIs linked by
foaf:knows properties with Axel Polleres’ foaf document as the
starting URI. We set the parameter k as 3, which already gave us a
ﬁle of 1.5MB containing more than 33,000 triples. To obtain a ﬁle
of reasonable size, we ﬁrst ﬁltered the data by removing all triples
that mention URIs from large Social Networks sites (in particular,
we remove URIs from MyOpera.com and SemanticTweet.com),
and then we extracted the strongly connected component to which
Axel Polleres’ URI belongs, obtaining a ﬁle of 25.8 KB. From this
ﬁle, we constructed several test cases by deleting subsets of nodes
and then recomputing the strongly connected component. With
this process we constructed 8 different test cases from 9.2 KB to
25.8 KB. The description of these ﬁles is shown in Table 5. Just
as an example of the construction process, ﬁle D is constructed
from ﬁle E by deleting the node corresponding to Richard Cygani-
ack’s URI, and then computing the strongly connected component
to which Axel’s URI belong. All these ﬁles can be downloaded
from http://www.dcc.uchile.cl/~jperez/papers/www2012/.

We tested query Foaf-1 described in the introduction, which asks
for the network of friends of Axel Polleres. Since the graphs in our
test cases are strongly connected, this query retrieves all the nodes
in the graph (possibly with duplicates). The time to process the

query, the number of solutions produced, and the size of the output
produced by ARQ are shown in Table 6 (ﬁle E is the last ﬁle shown
in the table, as all implementations exceed the timeout limit for the
larger ﬁles). As for the case of the clique experiment, one of the
most notable phenomenon is the large increase in the output size.

In the following sections, we provide theoretical results that ex-
plain the behavior showed by our tests. We begin by formalizing
the SPARQL language and the ofﬁcial semantics of property paths.

3. FORMALIZING SPARQL 1.1
In the following sections, we formalize the semantics of property
paths proposed by the W3C [10], and then study the complexity
of evaluating property paths under such semantics. To this end,
we present in this section an algebraic formalization of the core
operators in SPARQL 1.1, which follows the approach given in [14,
15]. Start by assuming there are pairwise disjoint inﬁnite sets I
(IRIs), B (blank nodes) and L (literals). A tuple (s, p, o) ∈ (I ∪
B) × I × (I ∪ B ∪ L) is called an RDF triple, where s is the
subject, p is the predicate and o is the object. A ﬁnite set of RDF
triples is called an RDF graph. Moreover, assume the existence
of an inﬁnite set V of variables disjoint from the above sets, and
assume that every element in V starts with the symbol ?.

A SPARQL 1.1 graph pattern expression is deﬁned recursively
as follows: (1) A tuple from (I ∪ L ∪ V) × (I ∪ V) × (I ∪ L ∪ V)
is a graph pattern (a triple pattern); (2) if P1 and P2 are graph pat-
terns, then (P1 AND P2), (P1 OPT P2), (P1 UNION P2) and
(P1 MINUS P2) are graph patterns; and (3) if P is a graph pat-
tern and R is a SPARQL 1.1 built-in condition, then the expression
(P FILTER R) is a graph pattern. In turn, a SPARQL 1.1 built-in
condition is constructed using elements of the set (I ∪ V), equality,
logical connectives and some built-in predicates [17]. In this paper,
we restrict to the fragment where a built-in condition is a Boolean
combination of terms constructed by using = and predicate bound,
that is, (1) if ?X, ?Y ∈ V and c ∈ I, then bound(?X), ?X = c
and ?X =?Y are built-in conditions; and (2) if R1 and R2 are built-
in conditions, then (¬R1), (R1 ∨ R2) and (R1 ∧ R2) are built-in
conditions. Finally, if P is a graph pattern and W is a set of vari-
ables, then (SELECT W P ), (SELECT DISTINCT W P ),
(SELECT * P ) and (SELECT DISTINCT * P ), are queries
in SPARQL 1.1.

To deﬁne the semantics of SPARQL 1.1 queries, we borrow some
terminology from [17, 15]. A mapping µ is a partial function
µ : V → (I ∪ L). Abusing notation, given a ∈ (I ∪ L) and
a mapping µ, we assume that µ(a) = a, and for a triple pattern
t = (s, p, o), we assume that µ(t) = (µ(s), µ(p), µ(o)). The
domain of µ, denoted by dom(µ), is the subset of V where µ
is deﬁned. Two mappings µ1 and µ2 are compatible, denoted by
µ1 ∼ µ2, when for all x ∈ dom(µ1) ∩ dom(µ2), it is the case that
µ1(x) = µ2(x), i.e. when µ1 ∪ µ2 is also a mapping. The map-
ping with empty domain is denoted by µ∅ (notice that this mapping
is compatible with any other mapping). Finally, given a mapping
µ and a set W of variables, the restriction of µ to W , denoted
by µ|W , is a mapping such that dom(µ|W ) = dom(µ) ∩ W and
µ|W (?X) = µ(?X) for every ?X ∈ dom(µ) ∩ W . Notice that if
W = ∅, then µ|W = µ∅.

The semantics of a SPARQL 1.1 query is deﬁned as a bag (or
multiset) of mappings [10], which is a set of mappings in which ev-
ery element µ is annotated with a positive integer that represents the
cardinality of µ in the bag. Formally, we represent a bag of map-
pings as a pair (Ω, cardΩ), where Ω is a set of mappings and cardΩ
is a function such that cardΩ(µ) is the cardinality of µ in Ω (we as-
sume that cardΩ(µ) > 0 for every µ ∈ Ω, and cardΩ(µ′) = 0
for every µ′ 6∈ Ω). With this notion, we have the necessary ingre-

WWW 2012 – Session: Ontology Representation and Querying: RDF and SPARQLApril 16–20, 2012, Lyon, France632dients to deﬁne the semantics of SPARQL 1.1 queries. As in [14,
15], this semantics is deﬁned as a function J · KG that takes a query
and returns a bag of mappings. More precisely, the evaluation of a
graph pattern P over an RDF graph G, denoted by JP KG, is deﬁned
recursively as follows (for the sake of readability, the semantics of
ﬁlter expressions is presented separately).
• If P is a triple pattern t, then JP KG = {µ | dom(µ) = var(t)
and µ(t) ∈ G}, where var(t) is the set of variables mentioned
in t. Moreover, for every µ ∈ JP KG: cardJP KG (µ) = 1.

• If P is (P1 AND P2), then JP KG = {µ1 ∪ µ2 | µ1 ∈ JP1KG,
µ2 ∈ JP2KG and µ1 ∼ µ2}. Moreover, for every µ ∈ JP KG we
have that cardJP KG (µ) is given by the expression:

Xµ1∈JP1KG

2
664

Xµ2∈JP2KG

µ=µ1∪µ2

„cardJP1KG (µ1) · cardJP2KG (µ2)«3
775

.

• If P is (P1 OPT P2), then JP KG = J(P1 AND P2)KG ∪ {µ ∈
JP1KG | ∀µ′ ∈ JP2KG : µ 6∼ µ′}. Moreover, for every
µ ∈ JP KG, if µ ∈ J(P1 AND P2)KG, then cardJP KG (µ) =
cardJ(P1 AND P2)KG (µ), and if µ 6∈ J(P1 AND P2)KG, then
cardJP KG (µ) = cardJP1KG (µ).

• If P is (P1 UNION P2), then JP KG = {µ | µ ∈ JP1KG or

µ ∈ JP2KG}. Moreover, for every µ ∈ JP KG:

Thus, from a syntactical point of view, property paths are regular
expressions over the vocabulary I, being | disjunction, / concate-
nation and ( )∗ the Kleene star. It should be noticed that the deﬁni-
tion of property paths in [10] includes some additional features that
are common in regular expressions, such as p? (zero or one occur-
rences of p) and p+ (one or more occurrences of p). In this paper,
we focus on the core operators |, / and ( )∗, as they sufﬁce to prove
the infeasibility of the evaluation of property paths in SPARQL 1.1.
A property-path triple is a tuple t of the form (u, p, v), where
u, v ∈ (I ∪ V) and p is a property path. SPARQL 1.1 includes
as atomic formulas triple patterns and property-path triples. Thus,
to complete the deﬁnition of the semantics of SPARQL 1.1, we
need to specify how property-path triples are evaluated over RDF
graphs, that is, we need to extend the deﬁnition of the function J·KG
to include property-path triples.

To deﬁne the semantics of property-path triples we follow closely
the standard speciﬁcation [10]. Assume that u, v ∈ (I ∪ V), W =
({u, v} ∩ V) and p is a property path. Notice that if u, v ∈ I, then
W = ∅. Then the evaluation of property-path triple t = (u, p, v)
over an RDF graph G, denoted by JtKG, is deﬁned recursively as
follows.
If p = a, where a ∈ I, then (u, p, v) is a triple pat-
tern and JtKG is deﬁned as in Section 3. Otherwise, we have that
either p = p1|p2 or p = p1/p2 or p = p∗
1, where p1, p2 are prop-
erty paths, and JtKG is deﬁned as follows. First, if p = p1|p2,
then JtKG is deﬁned in [10] as the result of evaluating the pattern
((u, p1, v) UNION (u, p2, v)) over G. Thus, we have that:

cardJP KG (µ) = cardJP1KG (µ) + cardJP2KG (µ).

JtKG = {µ | µ ∈ J(u, p1, v)KG or µ ∈ J(u, p2, v)KG},

• If P is (P1 MINUS P2), then JP KG = {µ ∈ JP1KG | ∀µ′ ∈
JP2KG : µ 6∼ µ′ or dom(µ) ∩ dom(µ′) = ∅}. Moreover, for
every µ ∈ JP KG, it holds that cardJP KG (µ) = cardJP1KG (µ).
The evaluation of a SPARQL 1.1 query Q over an RDF graph G,
denoted by JQKG, is deﬁned as follows. If Q is a SPARQL 1.1
query (SELECT W P ), then JQKG = {µ|W | µ ∈ JP KG} and
for every µ ∈ JQKG:

cardJQKG (µ) =

Xµ′∈JP KG : µ=µ′

|W

cardJP KG (µ′).

If Q is a SPARQL 1.1 query (SELECT * P ), then JQKG = JP KG
and cardJQKG (µ) = cardJP KG (µ) for every µ ∈ JQKG.
If
Q is a SPARQL 1.1 query (SELECT DISTINCT W P ), then
JQKG = {µ|W | µ ∈ JP KG} and for every µ ∈ JQKG, we
have that cardJQKG (µ) = 1. Finally, if Q is a SPARQL 1.1 query
(SELECT DISTINCT * P ), then JQKG = JP KG and for every
µ ∈ JQKG, we have that cardJQKG (µ) = 1.

To conclude the deﬁnition of the semantics of SPARQL 1.1, we
need to deﬁne the semantics of ﬁlter expressions. Given a mapping
µ and a built-in condition R, we say that µ satisﬁes R, denoted by
µ |= R, if (omitting the usual rules for Boolean connectives): (1)
R is bound(?X) and ?X ∈ dom(µ); (2) R is ?X = c, ?X ∈
dom(µ) and µ(?X) = c; (3) R is ?X =?Y , ?X ∈ dom(µ),
?Y ∈ dom(µ) and µ(?X) = µ(?Y ). Then given an RDF graph
G and a graph pattern expression P = (P1 FILTER R), we have
that JP KG = {µ ∈ JP1KG | µ |= R}, and for every µ ∈ JP KG, we
have that cardJP KG (µ) = cardJP1KG (µ).

4. PROPERTY PATHS
In this section, we use the framework presented in the previous sec-
tion to formalize the semantics of property paths in SPARQL 1.1.
According to [10], a property paths is recursively deﬁned as fol-
lows: (1) if a ∈ I, then a is a property path, and (2) if p1 and p2
are property paths, then p1|p2, p1/p2 and p∗
1 are property paths.

and for every µ ∈ JtKG, we have that:

cardJtKG (µ) = cardJ(u,p1,v)KG (µ) + cardJ(u,p2,v)KG (µ).

Second, if p = p1/p2, then assuming that ?X is a variable such
that ?X 6∈ W , we have that JtKG is deﬁned in [10] as the result
of ﬁrst evaluating the pattern ((u, p1, ?X) AND (?X, p2, v)) over
G, and then projecting over the variables of property-path triple t
(and, thus, projecting out the variable ?X). Thus, we have that:

JtKG = {(µ1 ∪ µ2)|W

| µ1 ∈ J(u, p1, ?X)KG,
µ2 ∈ J(?X, p2, v)KG and µ1 ∼ µ2},

and for every µ ∈ JtKG, we have that:

cardJtKG (µ) =

Xµ2∈J(?X,p2,v)KG

µ=(µ1∪µ2)|W

»

Xµ1∈J(u,p1,?X)KG
„cardJ(u,p1,?X)KG (µ1)·cardJ(?X,p2,v)KG (µ2)«–.

Finally, if p = p∗
procedures COUNT and ALP shown in Figure 3. More precisely,

1, then JtKG is deﬁned in [10] in terms of the

JtKG = {µ | dom(µ) = W and

COUNT(µ(u), p1, µ(v), G) > 0}.

Moreover, for every µ ∈ JtKG, it holds that

cardJtKG (µ) = COUNT(µ(u), p1, µ(v), G).

Procedure ALP in Figure 3 is taken from [10]. It is important to
notice that lines 5 and 6 in ALP formalize, in our terminology,
the use of a procedure call eval in the deﬁnition of ALP in [10].
According to [10], procedure ALP has to be used as follows to
compute cardJtKG (µ), where t = (u, p∗
1, v). Assuming that Result
is the empty list and Visited is the empty set, ﬁrst one has to invoke

WWW 2012 – Session: Ontology Representation and Querying: RDF and SPARQLApril 16–20, 2012, Lyon, France633Function COUNT(a, path, b, G)
Input: a, b ∈ I, path is a property path and G is an RDF graph.
1: Result := empty list
2: Visited := empty set
3: ALP(a, path, Result, Visited, G)
4: n := number of occurrences of b in Result
5: return n
Procedure ALP(a, path, Result, Visited, G)
Input: a ∈ I, path is a property path, Result is a list of elements
from I, Visited is a set of elements from I and G is an RDF graph.
1: if a ∈ Visited then
2:
3: end if
4: add a to Visited, and add a to Result
5: Ω := J(a, path, ?X)KG
6: let Next be the list of elements b = µ(?X) for µ ∈ Ω, such

return

that the number of occurrences of b in Next is cardΩ(µ)

ALP(c, path, Result, Visited, G)

7: for each c ∈ Next do
8:
9: end for
10: remove a from Visited

Figure 3: Procedures used in the evaluation of property-path
triples of the form (u, path∗, v).

ALP(µ(u), p, Result, Visited, G), then one has to check whether
µ(v) appears in the resulting list Result, and if this is the case then
cardJtKG (µ) is set as the number of occurrences of µ(v) in the list
Result. For the sake of readability, we have encapsulated in the
auxiliary procedure COUNT these steps to compute cardJtKG (µ)
from procedure ALP, and we have deﬁned JtKG by using COUNT,
thus formalizing the semantics proposed by the W3C in [10].

The idea behind algorithm ALP is to incrementally construct
paths that conform to a property path of the form p∗
1, that is, to
construct sequences of nodes a1, a2, . . ., an from an RDF graph G
such that each node ai+1 is reachable from ai in G by following
the path p1, but with the important feature (implemented through
the use of the set Visited) that each node ai is distinct from all the
previous nodes aj selected in the sequence (thus avoiding cycles in
the sequence a1, a2, . . ., an).

5.

INTRACTABILITY OF SPARQL 1.1 IN
THE PRESENCE OF PROPERTY PATHS
In this section, we study the complexity of evaluating property
paths according to the semantics proposed by the W3C. Specif-
ically, we study the complexity of computing cardJtKG (·), as this
computation embodies the main task needed to evaluate a property-
path triple. For the sake of readability, we focus here on computing
such functions for property-path triples of the form (a, p, b) where
a, b ∈ I. Notice that this is not a restriction, as for every prop-
erty path triple t and every mapping µ whose domain is equal to
the set of variables mentioned in t, it holds that cardJtKG (µ) =
cardJµ(t)KG (µ∅) (recall that µ∅ is the mapping with empty do-
main). Thus, we study the counting problem COUNTW3C, whose
input is an RDF graph G, elements a, b ∈ I and a property path p,
and whose output is the value cardJ(a,p,b)KG (µ∅).

It is important to notice that property paths are part of the input
of the previous problem and, thus, we are formalizing the combined
complexity of the evaluation problem [20]. As it has been observed
in many scenarios, and, in particular, in the context of evaluating
SPARQL [15], when computing a function like cardJ(a,p,b)KG (·),
it is natural to assume that the size of p is considerably smaller than

the size of G. This assumption is very common when studying the
complexity of a query language. In fact, it is named data complexity
in the database literature [20], and it is deﬁned in our context as
the complexity of computing cardJ(a,p,b)KG (·) for a ﬁxed property-
path p. More precisely, assume given a ﬁxed property path p. Then
COUNTW3C(p) is deﬁned as the problem of computing, given an
RDF graph G and elements a, b ∈ I, the value cardJ(a,p,b)KG (µ∅).

5.1 Property path evaluation
To pinpoint the complexity of COUNTW3C and COUNTW3C(p),
where p is a property path, we need to consider the complexity class
#P mentioned in the introduction (we refer the reader to [19] for its
formal deﬁnition). A function f is said to be in #P if there exists
a non-deterministic Turing Machine M that works in polynomial
time such that for every string w, the value of f on w is equal to
the number of accepting runs of M with input w. As mentioned in
the introduction, a prototypical #P-complete problem is the prob-
lem of computing, given a propositional formula ϕ, the number of
truth assignments satisfying ϕ. Clearly #P is a class of intractable
computation problems [19].

Our ﬁrst result shows that property path evaluation is intractable.

Theorem 5.1 COUNTW3C(p) is in #P for every property path p.
Besides, COUNTW3C(c∗) is #P-complete, where c ∈ I.
Theorem 5.1 shows that the problem of evaluating property paths
under the semantics proposed by the W3C is intractable in data
complexity. In fact, it shows that one will not be able to ﬁnd efﬁ-
cient algorithms to evaluate even simple property paths such as c∗,
where c is an arbitrary element of I.

We now move to the study of the combined complexity of the
problem COUNTW3C. In what follows, we formalize the clique
experiment presented in Section 2.2, and then provide lower bounds
in this scenario for the number of occurrences of a mapping in the
result of the procedure (ALP) used by the W3C to deﬁne the se-
mantics of property paths [10]. Interestingly, these lower bounds
show that the poor behavior detected in the experiments is not a
problem with the tested implementations, but instead a characteris-
tic of the semantics of property paths proposed in [10]. These lower
bounds provide strong evidence that evaluating property paths un-
der the semantics proposed by the W3C is completely infeasible,
as they show that COUNTW3C is not even in #P.

Fix an element c ∈ I and an inﬁnite sequence {ai}i≥1 of
pairwise distinct elements from I, which are all different from c.
Then for every n ≥ 2, let clique(n) be an RDF graph form-
ing a clique with nodes a1, . . . , an and edge label c,
that is,
clique(n) = {(ai, c, aj) | i, j ∈ {1, . . . , n} and i 6= j}. More-
over, for every property path p, deﬁne COUNTCLIQUE(p, n) as
cardJ(a1,p,an)Kclique(n) (µ∅). Then we have that:
Lemma 5.2 For every property path p and n ≥ 2:

COUNTCLIQUE(p∗, n) =

n−1

Xk=1

(n − 2)! · COUNTCLIQUE(p, n)k

(n − k − 1)!

Let p0 = c and ps+1 = p∗
and p3 = ((c∗)∗)∗. From Lemma 5.2, we obtain that:

s, for every s ≥ 0. For example, p1 = c∗

COUNTCLIQUE(ps+1, n) =

n−1

Xk=1

(n − 2)! · COUNTCLIQUE(ps, n)k

(n − k − 1)!

,

(1)

for every s ≥ 0. This formula can be used to obtain the number
of occurrences of the mapping with empty domain in the answer to
the property-path triple (a1, ps, an) over the RDF graph clique(n).

WWW 2012 – Session: Ontology Representation and Querying: RDF and SPARQLApril 16–20, 2012, Lyon, France634s
1
2
3
4
1
2
3
4

COUNTCLIQUE(ps, n)
2
6
42
1806
5
305
56931605

n
3
3
3
3
4
4
4
4 > 1023

s
1
2
3
4
1
2
3
4

COUNTCLIQUE(ps, n)
n
16
5
418576
5
5 > 1023
5 > 1093
6
6
6 > 1053
6 > 10269

65
28278702465

Table 7: Number of occurrences of the mapping with empty do-
main in the answer to property-path triple (a1, ps, an) over the
RDF graph clique(n), according to the semantics for property
paths proposed by the W3C in [10].

For instance, the formula states that if a system implements the se-
mantics proposed by the W3C in [10], then with input clique(8)
and (a1, (c∗)∗, a8), the empty mapping would have to appear more
than 79·1024 times in the output. Thus, even if a single byte is used
to store the empty mapping3, then the output would be of more than
79 Yottabytes in size! Table 7 shows more lower bounds obtained
with formula (1). Notice that these numbers coincide with the re-
sults obtained in our experiments (Tables 3 and 4). Also notice
that, for example, for n = 6 and s = 2 the lower bound is of more
than 28 billions, and for n = 4 and s = 3 is of more than 56
millions, which explains why the tested implementations exceeded
the timeout for queries Cliq-2 and Cliq-3 (Table 4). Most notably,
Table 7 allows us to provide a cosmological lower bound for eval-
uating property paths: if one proton is used to store the mapping
with empty domain, with input clique(6) (which contains only 30
triples) and (a1, (((c∗)∗)∗)∗, a6), every system implementing the
semantics proposed by the W3C [10] would have to return a ﬁle
that would not ﬁt in the observable universe!

From Lemma 5.2, we obtain the following double-exponential

lower bound for COUNTCLIQUE(ps, n).

Lemma 5.3 For every n ≥ 2 and s ≥ 1:

COUNTCLIQUE(ps, n) ≥ (n − 2)!(n−1)s−1

From this bound, we obtain that COUNTW3C is not in #P. Besides,
from the proof of Theorem 5.1, we obtain that COUNTW3C is in
the complexity class #EXP, which is deﬁned as #P but considering
non-deterministic Turing Machines that work in exponential time.

Theorem 5.4 COUNTW3C is in #EXP and not in #P.

It is open whether COUNTW3C is #EXP-complete.

5.2 The complexity of the entire language
We consider now the data complexity of the evaluation problem for
the entire language. More precisely, we use the results proved in the
previous section to show the major impact of using property paths
on the complexity of evaluating SPARQL 1.1 queries. The eval-
uation problem is formalized as follows. Given a ﬁxed SPARQL
1.1 query Q, deﬁne EVALW3C(Q) as the problem of computing,
given an RDF graph G and a mapping µ, the value cardJQKG (µ).
It is easy to see that the data complexity of SPARQL 1.1 with-
out property paths is polynomial. However, from Theorem 5.1, we
obtain the following corollary that shows that the data complexity
is considerably higher if property paths are included, for the case
of the semantics proposed by the W3C [10]. In this corollary, we
show that EVALW3C(Q) is in the complexity class FP#P, which is
the class of functions that can be computed in polynomial time if

3Recall that the empty mapping µ∅ is represented as the four-bytes
string | | in ARQ, and as the two-bytes string [] in Sesame.

one has access to an efﬁcient subroutine for a #P-complete problem
(or, more formally, one has an oracle for a #P-complete problem).
Corollary 5.5 EVALW3C(Q) is in FP#P, for every SPARQL 1.1
query Q. Moreover, there exists a SPARQL 1.1 query Q0 such that
EVALW3C(Q0) is #P-hard.

6.

INTRACTABILITY FOR ALTERNATIVE
SEMANTICS THAT COUNT PATHS

The usual graph theoretical notion of path has been extensively and
successfully used when deﬁning the semantics of queries including
regular expressions [13, 4, 1, 16, 3]. Nevertheless, given that the
W3C SPARQL 1.1 Working Group is interested in counting paths,
the classical notion of path in a graph cannot be naively used to de-
ﬁne a semantics for property-path queries, given that cycles in an
RDF graph may lead to an inﬁnite number of different paths. In this
section, we consider two alternatives to deal with this problem. We
consider a semantics for property paths based on classical paths that
is only deﬁned for acyclic RDF graphs, and we consider a general
semantics that is based on simple paths (which are paths in a graph
with no repeated nodes). In both cases, we show that query evalua-
tion based on counting is intractable. Next we formalize these two
alternative semantics and present our complexity results.

A path π in an RDF graph G is a sequence a1, c1, a2, c2, . . . ,
an, cn, an+1 such that n ≥ 0 and (ai, ci, ai+1) ∈ G for every
i ∈ {1, . . . , n}. Path π is said to be from a to b in G if a1 = a and
an+1 = b, it is said to be nonempty if n ≥ 1, and it is said to be
a simple path, or just s-path, if ai 6= aj for every distinct pair i, j
of elements from {1, . . . , n + 1}. Finally, given a property path p,
path π is said to conform to p if c1c2 · · · cn is a string in the regular
language deﬁned by p.

6.1 Classical paths over acyclic RDF graphs
We ﬁrst deﬁne the semantics of a property-path triple considering
classical paths, that we denote by J·Kpath
G . Notice that we have to
take into consideration the fact that the number of paths in an RDF
graph may be inﬁnite, and thus we deﬁne this semantics only for
acyclic graphs. More precisely, an RDF graph G is said to be cyclic
if there exists an element a mentioned in G and a nonempty path
π in G from a to a, and otherwise it is said to be acyclic. Then
assuming that G is acyclic, the evaluation of a property-path triple
t over G in terms of classical paths, denoted by JtKpath
G , is deﬁned
as follows. Let t = (u, p, v) and W = ({u, v} ∩ V), then

JtKpath

G = {µ | dom(µ) = W and there exists a

path from µ(u) to µ(v) in G that conforms to p},

and for every µ ∈ JtKpath
the number of paths from µ(u) to µ(v) in G that conform to p.

G , the value cardJtKpath

(µ) is deﬁned as

G

Similarly as we deﬁned the problem COUNTW3C in Section 5,
we deﬁne the problem COUNTPATH as the problem of computing
(µ∅) given as input an acyclic RDF graph G, ele-
cardJ(a,p,b)Kpath
ments a, b ∈ I, and property path p. We also deﬁne, given a ﬁxed
property path p, the problem COUNTPATH(p) as the the problem of
computing, given an acyclic RDF graph G and elements a, b ∈ I,
the value cardJ(a,p,b)Kpath

(µ∅).

G

G

To pinpoint the exact complexity of the problems COUNTPATH
and COUNTPATH(p), we need to consider two counting complex-
ity classes: #L and SPANL. We introduce these classes here, and
we refer the reader to [2] for their formal deﬁnitions. #L is the
counting class associated with the problems that can be solved in
logarithmic space in a non-deterministic Turing Machine (NTM).

WWW 2012 – Session: Ontology Representation and Querying: RDF and SPARQLApril 16–20, 2012, Lyon, France635In fact, a function f is said to be in this class if there exists an NTM
M that works in logarithmic space such that for every string w, the
value of f on w is equal to the number of accepting runs of M
with input w. A prototypical #L-complete problem is the problem
of computing, given a deterministic ﬁnite automaton A and a string
w, the number of strings that are accepted by A and whose length is
smaller than the length of w [2]. SPANL is deﬁned in a similar way
to #L, but considering logarithmic-space NTMs with output. More
precisely, a function f is said to be in this class if there exists such
TM M such that for every string w, the value of f on w is equal
to the number of different outputs of M with input w. A prototyp-
ical SPANL-complete problem is the problem of computing, given
a non-deterministic ﬁnite automaton A and a string w, the number
of strings that are accepted by A and whose length is smaller than
the length of w [2]. Although classes #L and SPANL look alike,
they are quite different in terms of complexity: #L is known to be
included in FP, the class of functions that can be computed in poly-
nomial time, while it is known that SPANL is a class of intractable
computation problems, if SPANL ⊆ FP, then P = NP.

Our ﬁrst result shows that even for the simple case considered in
this section, the problem of evaluating property paths is intractable.

Theorem 6.1 COUNTPATH is SPANL-complete.

Interestingly, our second complexity result shows that at least in
terms of data complexity, the problem of evaluating property paths
is tractable if their semantics is based on the usual notion of path.

Moreover,

Theorem 6.2 COUNTPATH(p) is in #L for every property path
p.
there exists a property path p0 such that
COUNTPATH(p0) is #L-complete.
Although COUNTPATH(p) is tractable, it only considers acyclic
RDF graphs, and thus leaves numerous practical cases uncovered.

6.2 Simple paths
We continue our investigation by considering the alternative se-
mantics for property paths that is deﬁned in terms of simple paths.
Notice that even for cyclic RDF graphs, the number of simple paths
is ﬁnite, and thus, this semantics is properly deﬁned for every RDF
graph. Formally, assume that G is an RDF graph, t = (u, p, v) is
a property-path triple and W = ({u, v} ∩ V). The evaluation of t
over G in terms of s-paths, denoted by JtKs-path

, is deﬁned as:

G

JtKs-path

G

= {µ | dom(µ) = W and there exists an s-path

from µ(u) to µ(v) in G that conforms to p},

G

G

, the value cardJtKs-path

and for every µ ∈ JtKs-path
(µ) is deﬁned as
the number of s-paths from µ(u) to µ(v) in G that conform to p.
For the case of s-paths, we deﬁne the problem COUNTSIMPLEPATH
as follows. The input of this problem is an RDF graph G, ele-
ments a, b ∈ I and a property path p, and its output is the value
(µ∅). As for the previous problems, we deﬁne
cardJ(a,p,b)Ks-path
COUNTSIMPLEPATH(p) as COUNTSIMPLEPATH for a ﬁxed prop-
erty path p. The following result shows that these problems are also
intractable.

G

Theorem 6.3 COUNTSIMPLEPATH is in #P. Moreover, if c ∈ I,
then COUNTSIMPLEPATH(c∗) is #P-complete.
Notice that the data complexity of evaluating property paths ac-
cording to the s-path semantics is the same as evaluating them ac-
cording to the W3C semantics. The difference is in the combined
complexity that is radically higher for the W3C semantics: for the
case of the semantics based on s-paths the combined complexity is
in #P, while for the W3C semantics it is not in #P.

7. AN EXISTENTIAL SEMANTICS

TO THE RESCUE

We have shown in the previous section that evaluating property-
path triples according to the semantics proposed in [10] is essen-
tially infeasible, being the core of this problem the necessity of
counting different paths. We have also shown that the version in
which one counts simple-paths is infeasible too. A possible solu-
tion to this problem is to not use a semantics that requires count-
ing paths, but instead a more traditional existential semantics for
property-path triples. That is, one just checks if two nodes are con-
nected (or not) by a path that conforms to a property-path expres-
sion. This existential semantics has been used for years in graph
databases [13, 4, 3], in XML [12, 9], and even on RDF [1, 16]
previous to SPARQL 1.1. In this section, we introduce this seman-
tics and study the complexity of evaluating property paths, and also
SPARQL 1.1 queries, under it. We also compare this proposal with
the current ofﬁcial semantics for property paths, and present some
experimental results that validate our proposal.

The most natural way to deﬁne an existential semantics for prop-
erty paths is as follows. Assume that u, v ∈ (I ∪ V), W =
({u, v} ∩ V), t = (u, p, v) is a property-path triple, and G is an
RDF graph. Then deﬁne JtK∃(path)

as:

G

JtK∃(path)

G

= {µ | dom(µ) = W and there exists a path

from µ(u) to µ(v) in G that conforms to p}.

G

Moreover, deﬁne the cardinality of every mapping µ in JtK∃(path)
just as 1. Notice that with the semantics JtK∃(path)
, we are essen-
G
tially discarding all the duplicates from JtKpath
G . This allows us to
consider general graphs (not necessarily acyclic graph as in Sec-
tion 5). To study the complexity of evaluating property paths un-
der this semantics, we deﬁne the decision problem EXISTSPATH,
whose input is an RDF graph G, elements a, b ∈ I and a property-
path triple t = (a, p, b), and whose output is the answer to the ques-
tion: is card
(µ∅) = 1? That is, the problem EXISTSPATH
is equivalent to checking whether µ∅ ∈ JtK∃(path)

∃(path)
G

Notice that with EXISTSPATH, we are measuring the combined
complexity of evaluating paths under the existential semantics. The
following result shows that EXISTSPATH is tractable. This is a
corollary of some well-known results on graph databases (e.g. see
Section 3.1 in [16]). In the result, we use |G| to denote the size of
an RDF graph G and |p| to denote the size of a property-path p.

JtK

G

.

Proposition 7.1 EXISTSPATH can be solved in time O(|G| · |p|).

7.1 Discarding duplicates from the standard

and simple-paths semantics

A natural question at this point is whether there exists a relationship
between the existential semantics deﬁned in the previous section
and the semantics that can be obtained by discarding duplicates
from JtKG and JtKs-path
for a property-path triple t. We formalize
and study these two semantics in this section.

G

Assume that G is an RDF graph and t is a property-path triple.
Then we deﬁne JtK∃
G as having exactly the same mappings as in
JtKG, but with the cardinality of every mapping in JtK∃
G deﬁned just
as 1. Similarly, we deﬁne JtK∃(s-path)
as having exactly the same
mappings as in JtKs-path
, but with the cardinality of every mapping
in JtK∃(s-path)
deﬁned as 1. In this section, we study the decision
problem EXISTSW3C, whose input is an RDF graph G, elements
a, b ∈ I and a property-path triple t = (a, p, b), and whose output
is the answer to the question: is cardJ(a,p,b)K∃
(µ∅) = 1? We also

G

G

G

G

WWW 2012 – Session: Ontology Representation and Querying: RDF and SPARQLApril 16–20, 2012, Lyon, France636instead of J·K∃
G.

study the complexity of the decision problem EXISTSSIMPLEPATH,
which is deﬁned as EXISTSW3C but considering the semantics
J·K∃(s-path)

G coincides with J·K∃(path)

G
Our ﬁrst result shows that, somehow surprisingly, the seman-
tics J·K∃
. Thus, even though the ofﬁcial
semantics of property paths is given in terms of a particular pro-
cedure [10], when one does not count paths, it coincides with the
classical existential semantics based on the usual notion of path.

G

Theorem 7.2 For every RDF graph G, mapping µ and property-
path triple t: µ ∈ JtK∃
As a corollary of Propositions 7.1 and Theorem 7.2, we obtain that:

G if and only if µ ∈ JtK∃(path)

G

.

Theorem 7.3 EXISTSW3C can be solved in time O(|G| · |p|).

The situation is radically different for the case of simple paths.
From some well-known results on graph databases [13], one can
prove that EXISTSSIMPLEPATH is an intractable problem, even for
a ﬁxed property-path. More precisely, for a ﬁxed property-path
p, the decision problem EXISTSSIMPLEPATH(p) has as input an
RDF graph G and elements a, b ∈ I, and the question is whether
card

(µ∅) = 1.

J(a,p,b)K

∃(s-path)
G

Proposition 7.4 EXISTSSIMPLEPATH is in NP.
EXISTSSIMPLEPATH((c/c)∗) is NP-complete, where c ∈ I.

Moreover,

7.2 Existential semantics and SPARQL 1.1
We have shown that when bags are considered for the semantics
of property paths, the evaluation becomes intractable, even in data
complexity. However, the previous version of SPARQL, that did
not include path queries, considered a bag semantics for the map-
ping operators (AND, OPT, UNION, FILTER and SELECT),
which has proved to be very useful in practice. Thus, a natural
question is whether one can construct a language with function-
alities to express interesting queries about paths in RDF graphs,
with bag semantics for the mappings operators, and that, at the
same time, can be efﬁciently evaluated. In this section, we give
a positive answer to this question. We show that if one combines
existential semantics for property paths and bag semantics for the
SPARQL 1.1 operators, one obtains the best of both worlds and still
has tractable data complexity.

G

G

G

and JQK∃(path)

G, JQK∃(path)

We start by formalizing this alternative way of evaluating
SPARQL 1.1 queries that considers existential semantics for
property-path triples. Given a SPARQL 1.1 query Q, deﬁne JQK∃
G
exactly as JQKG is deﬁned in Sections 3 and 4, but evaluating
property-paths triples according to the semantics J·K∃
G deﬁned in
Section 7.1 (that is, JtKG is replaced by JtK∃
G if t is a property-
path triple), and likewise for JQK∃(s-path)
. Notice
G
and JQK∃(s-path)
that for the three semantics JQK∃
,
we are not discarding all duplicates but only the duplicates that
are generated when evaluating property paths. Thus, these se-
mantics are still bag semantics, and therefore we consider the
following computation problems. We deﬁne ﬁrst the compu-
tation problem EVALEXISTSW3C(Q), whose input is an RDF
graph G and a mapping µ, and whose output
is the value
(µ). Moreover, we also consider the computation prob-
cardJQK∃
lems EVALEXISTSSIMPLEPATH(Q) and EVALEXISTSPATH(Q),
that have the same input as EVALEXISTSW3C(Q) and are de-
(µ) and
ﬁned as the problems of computing card
(µ), respectively. Notice that in these three prob-
card
lems, we are considering the data complexity of SPARQL 1.1 under
the respective semantics.

∃(s-path)
G

∃(path)
G

JQK

JQK

G

Notably, the next result shows that the just deﬁned semantics

G

G and J·K∃(path)

J·K∃
are tractable, in terms of data complexity. This
result is a consequence of Theorem 7.3 and Proposition 7.1. In the
formulation of this result we use the class FP, which is deﬁned as
the class of all functions that can be computed in polynomial time
(and thus, it is a class of tractable functions).

Theorem 7.5 EVALEXISTSW3C(Q) and EVALEXISTSPATH(Q)
are in FP for every SPARQL 1.1 query Q.

G

We conclude this section by showing that for the case of the se-
mantics J·K∃(s-path)
, the data complexity is unfortunately still high.
To study this problem we need the complexity classes FPkNP and
FPNP[O(log n)], which are deﬁned in terms of oracles as for the case
of the complexity class FP#P used in Corollary 5.5. More precisely,
the class FPkNP contains all the functions that can be computed in
polynomial time by a procedure that is equipped with an efﬁcient
subroutine (oracle) for an NP-complete problem, with the restric-
tion that all the calls to the subroutine should be made in parallel,
that is, no call to the subroutine can depend on the result of a previ-
ous call to this subroutine [21]. The class FPNP[O(log n)] is deﬁned
in the same way, but with the restriction that the subroutine for an
NP-complete problem can be called only a logarithmic number of
times. Both classes FPNP[O(log n)] and FPkNP are considered to be
intractable. Moreover, it is known that FPNP[O(log n)] ⊆ FPkNP,
but it is open whether this containment is strict [18].

Theorem 7.6 EVALEXISTSSIMPLEPATH(Q) is in FPkNP for ev-
ery SPARQL 1.1 query Q. Moreover, there exists a query Q0 such
that EVALEXISTSSIMPLEPATH(Q0) is FPNP[O(log n)]-hard.

Theorem 7.6 shows that simple paths are not a good option even if
duplicates are not considered.

G

G and J·K∃(path)

7.3 Experiments for the existential semantics
In the previous section, we showed that SPARQL 1.1 is tractable
in terms of data complexity if one considers the existential seman-
tics J·K∃
for property paths. The goal of this sec-
tion is to show the impact of using these semantics in practice, by
conducting a ﬁnal experiment with two implementations that ex-
tends SPARQL 1.0 with existential path semantics: Psparql (ver-
sion 3.3) [26], and Gleen (version 0.6.1) [27]. These two imple-
mentations evaluate SPARQL queries according to J·K∃(path)
, al-
though they use a slightly different syntax for path queries (see
http://www.dcc.uchile.cl/~jperez/papers/www2012/ for the deﬁni-
tions of these queries).

G

In our experiments, we use the following result that allows us to
compare SPARQL 1.1 implementations mentioned in Section 2.1
with Psparql and Gleen. It is important to notice that this result
is of independent interest, as it shows that the implementations of
SPARQL 1.1 that follow the ofﬁcial speciﬁcation [10] can be highly
optimized when using the SELECT DISTINCT feature.

Theorem 7.7 Let P be a SPARQL 1.1 graph pattern, G an RDF
graph and W a set of variables. Then we have that:

J(SELECT DISTINCT W P )KG =

J(SELECT DISTINCT * P )KG =

J(SELECT DISTINCT W P )K∃(path)

G

J(SELECT DISTINCT * P )K∃(path)

G

In view of this theorem, we consider all the queries in Section 2,
but this time using the SELECT DISTINCT feature:

WWW 2012 – Session: Ontology Representation and Querying: RDF and SPARQLApril 16–20, 2012, Lyon, France637n

8
9
10
11
12
13

ARQ
1.68
2.00
3.65
29.71
1394.06
–

RDFQ
32.61
213.99
2123.90
–
–
–

Kgram Sesame
9.08
166.82
–
–
–
–

1.39
5.34
227.66
–
–
–

Cliq-1D

Psparql
0.18
0.20
0.20
0.23
0.24
0.27

Gleen
1.24
1.23
1.25
1.25
1.24
1.24

n

2
3
4
5
6
7

ARQ
1.40
1.19
1.65
97.06
–
–

RDFQ
0.76
0.84
19.38
–
–
–

Cliq-2D

Psparql
0.14
0.14
0.14
0.15
0.16
0.16

Gleen
1.23
1.23
1.23
1.22
1.23
1.23

n

2
3
4
5
6
7

ARQ
1.18
1.41
–
–
–
–

RDFQ
0.77
6.78
–
–
–
–

Psparql
0.14
0.14
0.15
0.15
0.16
0.16

Gleen
1.24
1.23
1.24
1.24
1.24
1.24

Cliq-3D

Table 8: Time in seconds for queries Cliq-1D, Cliq-2D, and Cliq-3D (symbol “–” means one-hour timeout).

Cliq-1D:
Cliq-2D:
Cliq-3D:
Foaf-1D:

SELECT DISTINCT * WHERE { :a0 (:p)* :a1 }
SELECT DISTINCT * WHERE { :a0 ((:p)*)* :a1 }
SELECT DISTINCT * WHERE { :a0 (((:p)*)*)* :a1 }
SELECT DISTINCT *
WHERE { axel:me (foaf:knows)* ?x }

Tables 2 and 8 show the results of this experiment. Although the
tested systems return the same results for these queries, the differ-
ences in efﬁciency between the SPARQL 1.1 implementations and
the implementations that use an existential semantics are dramatic.

8. OUR RESULTS IN PERSPECTIVE:

A PROPOSAL

Our results pose a strong argument against the current semantics of
property paths, from both, theory and practice. We have made clear
that the main problem is the necessity of counting paths imposed
by the current SPARQL 1.1 speciﬁcation. Our investigation raises
several questions, being one of the most important whether there
exists such a strong use case for counting paths that will make the
designers of the language to stick with the current semantics, even
knowing that in simple and natural cases it will lead to completely
impractical evaluation procedures. We have searched in the ofﬁcial
document and also in the discussions around the design of the lan-
guage, and to the best of our knowledge, there is no strong use case
for counting paths. It should also be noticed that this counting func-
tionality has not been used as a primitive in previous navigational
languages for graph structured data.

On the positive side, we have shown that a semantics based on
checking the existence of paths (without counting them), has sev-
eral advantages: it can be easily deﬁned and understood, it is based
on years of research and practical experience, and, most impor-
tantly, it can be efﬁciently evaluated. In view of our result that DIS-
TINCT can be used to go from the counting semantics to the exis-
tential semantics, one might be tempted to think that users not inter-
ested in counting paths can use DISTINCT in queries. We strongly
disagree with this view. Bag semantics for relational queries has
proved to be essential in practice. Thus, a good language should be
able to deal with both characteristics: being able to search for paths
using an existential semantics, and, at the same time, having bag
semantics for relational-like operators (such as AND and OPT).
Our proposal is to have such a semantics for SPARQL 1.1, which
corresponds to the semantics J·K∃
G deﬁned in Section 7.1, and pro-
vide a special feature such as ALL-PATHS, for users that would
like to count paths and know the implications of this action.

Although SPARQL is still in its infancy, the increasing interest in
managing RDF data is making this language to become more and
more popular. To maintain and even increase its adoption rate, the
group in charge of the upcoming version of SPARQL should con-
sider all the possible inputs regarding the language. We do think
that for the case of property-path evaluation, our proposal, as op-
posed to the current ofﬁcial semantics, would lead to a wide adop-
tion of the language by practitioners, developers and theoreticians.
Acknowledgments Arenas was supported by Fondecyt-1090565,
and Pérez by Fondecyt-11110404 and by VID grant U-Inicia 11/04,
Universidad de Chile.

9. REFERENCES

[1] F. Alkhateeb, J.-F. Baget, and J. Euzenat. Extending SPARQL with
regular expression patterns (for querying RDF). JWS, 7(2):57–73,
2009.

[2] C. Àlvarez and B. Jenner. A very hard log-space counting class.

Theor. Comput. Sci., 107(1):3–30, 1993.

[3] P. Barceló, C. A. Hurtado, L. Libkin, and P. T. Wood. Expressive
languages for path queries over graph-structured data. In PODS,
pages 3–14, 2010.

[4] D. Calvanese, G. D. Giacomo, M. Lenzerini, and M. Y. Vardi.

Rewriting of regular expressions and regular path queries. In PODS,
pages 194–204, 1999.

[5] J. J. Carroll, I. Dickinson, C. Dollin, D. Reynolds, A. Seaborne, and

K. Wilkinson. Jena: implementing the semantic web
recommendations. In WWW (Alternate Track Papers & Posters),
pages 74–83, 2004.

[6] O. Corby and C. Faron-Zucker. The KGRAM abstract machine for

knowledge graph querying. In Web Intelligence, pages 338–341,
2010.

[7] L. Eggan. Transition graphs and the star-height of regular events.

The Michigan mathematical journal, 10(4):385–397, 1963.

[8] J. Gantz et al. The diverse and exploding digital universe: An

updated forecast of worldwide information growth through 2011.
International Data Corporation, White Paper, 2008.

[9] G. Gottlob, C. Koch, and R. Pichler. Efﬁcient algorithms for

processing XPath queries. TODS, 30(2):444–491, 2005.

[10] S. Harris and A. Seaborne. SPARQL 1.1 query language. W3C

Working Draft 12 May 2011,
http://www.w3.org/TR/2011/WD-sparql11-query-20110512/.

[11] O. Hartig, C. Bizer, and J. C. Freytag. Executing SPARQL queries

over the Web of Linked Data. In ISWC, pages 293–309, 2009.

[12] M. Marx. Conditional XPath. TODS, 30(4):929–959, 2005.
[13] A. O. Mendelzon and P. T. Wood. Finding regular simple paths in

graph databases. SIAM J. Comput., 24(6):1235–1258, 1995.

[14] J. Pérez, M. Arenas, and C. Gutierrez. Semantics of SPARQL.

Technical Report, U. de Chile TR/DCC-2006-17, October 2006.

[15] J. Pérez, M. Arenas, and C. Gutierrez. Semantics and complexity of

SPARQL. TODS, 34(3), 2009.

[16] J. Pérez, M. Arenas, and C. Gutierrez. nSPARQL: A navigational

language for RDF. JWS, 8(4):255–270, 2010.

[17] E. Prud’hommeaux and A. Seaborne. SPARQL query language for

RDF. W3C Recommendation 15 January 2008,
http://www.w3.org/TR/rdf-sparql-query/.

[18] A. L. Selman. A taxonomy of complexity classes of functions. J.

Comput. Syst. Sci., 48(2):357–381, 1994.

[19] L. G. Valiant. The complexity of computing the permanent. Theor.

Comput. Sci., 8:189–201, 1979.

[20] M. Y. Vardi. The complexity of relational query languages (extended

abstract). In STOC, pages 137–146, 1982.

[21] K. W. Wagner. More complicated questions about maxima and

minima, and some closures of NP. Theor. Comput. Sci., 51:53–80,
1987.

[22] ARQ. http://sourceforge.net/projects/jena/ﬁles/ARQ/.
[23] KGRAM. http://www-sop.inria.fr/edelweiss/software/corese/.
[24] RDF::Query. http://search.cpan.org/~gwilliams/RDF-Query/.
[25] Sesame. http://sourceforge.net/projects/sesame/.
[26] Psparql. http://exmo.inrialpes.fr/software/psparql/.
[27] Gleen. http://sig.biostr.washington.edu/projects/ontviews/gleen/.
[28] Semantic Web Client Library.

http://www4.wiwiss.fu-berlin.de/bizer/ng4j/semwebclient/.

WWW 2012 – Session: Ontology Representation and Querying: RDF and SPARQLApril 16–20, 2012, Lyon, France638