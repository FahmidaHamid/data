Extracting Client-side Web Application Code

Josip Maras
University of Split

Split, Croatia

josip.maras@fesb.hr

Jan Carlson, Ivica Crnkovi´c

Mälardalen University

Västerås, Sweden

{jan.carlson, ivica.crnkovic}@mdh.se

ABSTRACT
The web application domain is one of the fastest growing
and most wide-spread application domains today. By uti-
lizing fast, modern web browsers and advanced scripting
techniques, web developers are developing highly interactive
applications that can, in terms of user-experience and re-
sponsiveness, compete with standard desktop applications.
A web application is composed of two equally important
parts: the server-side and the client-side. The client-side
acts as a user-interface to the application, and can be viewed
as a collection of behaviors. Similar behaviors are often
used in a large number of applications, and facilitating their
reuse oﬀers considerable beneﬁts. However, due to client-
side speciﬁcs, such as multi-language implementation and
extreme dynamicity, identifying and extracting code respon-
sible for a certain behavior is diﬃcult.
In this paper we
present a semi-automatic method for extracting client-side
web application code implementing a certain behavior. We
show how by analyzing the execution of a usage scenario,
code responsible for a certain behavior can be identiﬁed,
how dependencies between diﬀerent parts of the application
can be tracked, and how in the end only the code responsi-
ble for a certain behavior can be extracted. Our evaluation
shows that the method is capable of extracting stand-alone
behaviors, while achieving considerable savings in terms of
code size and application performance.

Categories and Subject Descriptors
D.2.7 [Software Engineering]: Distribution, Maintenance,
and Enhancement—Restructuring, reverse engineering, and
reengineering

General Terms
Algorithms, Theory

Keywords
Web applications, Slicing, Code extraction, Reuse

1.

INTRODUCTION

Highly interactive web applications that oﬀer user expe-
rience and responsiveness of standard desktop applications
are becoming increasingly popular. They are composed out

Copyright is held by the International World Wide Web Conference Com-
mittee (IW3C2). Distribution of these papers is limited to classroom use,
and personal use by others.
WWW 2012, April 16–20, 2012, Lyon, France.
ACM 978-1-4503-1229-5/12/04.

of two equally important parts: the server side, realized as
a sequential application implementing data-access and busi-
ness logic, and the client side, realized as an event-driven ap-
plication representing the user-interface (UI). On the client
side, a web page structure is deﬁned with HTML code, pre-
sentation with CSS (Cascading Style Sheets), and behavior
with JavaScript code. Alongside code, a web page usually
contains resources such as images, videos, or fonts. All this
code and resources are transfered to and evaluated in the
user’s web browser, and the interplay of these basic elements
produces the end result.

From the UI perspective, a web page can be viewed as
a collection of visually and behaviorally distinct elements,
the so called UI controls. However, this distinctiveness does
not usually exist in code, since there is no predeﬁned way of
organizing code into neatly packed components.

A client side web application can also be viewed as a col-
lection of behaviors: from simple behaviors implementing a
single functionality, through complex UI behaviors provided
by UI controls, all the way to a single, complex behavior
that represents the functionality of the whole page. Similar
behaviors are often used in a large number of web applica-
tions, and facilitating their reuse oﬀers signiﬁcant beneﬁts.
However, this is a challenging task. Due to the underlying
event-driven paradigm and the fact that a single behavior
can be implemented with a combined eﬀect of three diﬀerent
languages (HTML, CSS, and JavaScript) based on entirely
diﬀerent paradigms, it is diﬃcult to identify code responsible
for a certain behavior. This is especially true, because the
most complex language – JavaScript is an dynamic script-
ing language. In addition to facilitating reuse the ability to
set code into relation to behavior can also be used to detect
and remove dead code. On top of increasing code maintain-
ability, dead code removal also has a positive eﬀect on web
application performance, because all code is transfered and
interpreted in the user’s web browser.

In this paper we present a method for extracting client-
side web application code. Our main contribution is a code
extraction method based on the analysis of application ex-
ecution traces recorded while demonstrating a web applica-
tion usage scenario. In order to be able to extract the code
that implements a certain behavior we have to identify it.
We deﬁne a client-side web application dependency graph,
describe how it is constructed, and show how it can be used
to locate and extract code responsible for a certain behav-
ior. Our work is motivated by three diﬀerent usages: i) ex-
tracting library functionality, ii) extracting UI controls, and
iii) removing dead code. We have evaluated the approach

WWW 2012 – Session: Web Engineering 1April 16–20, 2012, Lyon, France819for each one, and have found out that considerable savings in
terms of code size and performance can be made, while still
being able to reproduce the demonstrated usage scenario.

The paper is organized as follows: in Section 2 we deﬁne
the overall approach, and give a short introduction to the
inner workings of client-side web applications necessary to
understand the extraction algorithm. Section 3 gives a more
detailed description of each step of the approach, deﬁnes the
dependency graph, its construction, and shows how it can
be used to locate code implementing a demonstrated us-
age scenario. Section 4 shows the results of the evaluation,
while Section 5 describes related approaches. Section 6 gives
the conclusion and presents possible continuation of the re-
search.

2. THE OVERALL APPROACH

Our goal is to provide a method for extracting behaviors
from client-side web applications: from a single functional-
ity mapped to a function call, through complex UI behaviors
implemented by UI controls, all the way to the behavior of
the whole web page. Ideally the code implementing a cer-
tain behavior would be identiﬁed with static analysis, which
would guaranty the completeness of the behavior, but in an
environment as dynamic as the client side web application,
this is not possible. Because of the extreme dynamicity of
JavaScript, the underlying event-driven paradigm, and the
fact that a behavior is usually deﬁned through the interplay
of diﬀerent web page elements, it is diﬃcult to make a con-
nection between a behavior and the implementing code. For
these reasons we have based our approach on the analysis of
usage scenarios. The main advantages of the approach are:
i) it does not require any speciﬁcation of the behavior to be
extracted and ii) the analysis of the application execution
trace recorded while demonstrating the usage scenario en-
ables us to dynamically track code dependencies (something
that cannot be accurately done statically for a language as
dynamic as JavaScript). The downside is that the accuracy
and completeness of the captured behavior in terms of how
much it relates to the desired behavior is completely depen-
dent on the developer demonstrating the usage scenario.

Figure 1: The Extraction process

The overall extraction process is shown in Figure 1, and

goes as follows. Phase 1 – Interaction recording – requires
input from the developer in a sense that he/she has to choose
the HTML node the process should focus on (because the
goal is to track UI modiﬁcations), and demonstrate the us-
age scenario while in the background the application exe-
cution trace is being recorded. In Phase 2 – Reinterpreta-
tion – the whole web application code is reinterpreted, and
code dependencies are tracked with the application execu-
tion trace as a guideline. When the reinterpretation reaches
a point in the execution trace that changes the structure of
the HTML node we are interested in, the reinterpretation
pauses and the process enters Phase 3 – Code marking. In
this phase, starting from the code expression making the
modiﬁcation, all dependencies are traversed, and all code
that directly or indirectly inﬂuences the modiﬁcation code
expression are marked as important. Once the dependency
traversal is done, the process again resumes the reinterpre-
tation in Phase 2. This cycle is repeated as long as there
are node modiﬁcations in the application execution trace.
When the reinterpretation is done the process enters the
ﬁnal phase, Phase 4 – Code extraction – where the code
of the entire web application is traversed; code expressions
identiﬁed in the code marking phase are kept, while the rest
are removed – the end result being a subset of the original
application still able to reproduce the demonstrated usage
scenario.

The main component of the process is the tracking of de-
pendencies between diﬀerent parts of the web page. To
better understand the whole process, we give a short web
application primer.

2.1 A Web Application Primer

A client-side web application is, in its essence, an HTML
page that includes JavaScript code, CSS code and various
resources such as images or fonts. The HTML code deﬁnes
the structure of a web page, JavaScript code the behavior,
and CSS (Cascading Style Sheets) code the presentation.
The interplay of these basic elements produces the end re-
sult displayed in the user’s web browser. JavaScript is a
weakly typed, imperative, object-oriented script language
with prototype based delegation inheritance. It has no type
declarations and has only run-time checking of calls and ﬁeld
accesses. Functions are ﬁrst-class objects, and can be ma-
nipulated and passed around like other objects. JavaScript
is also a dynamic language: everything can be modiﬁed at
runtime, from ﬁelds and methods of an object to its pro-
totype. As many other script languages, it oﬀers the eval
function which can execute an arbitrary string of JavaScript
code. CSS is a declarative language used to specify the pre-
sentational aspects of HTML nodes. The CSS code of the
application is composed out of CSS rules, each rule consist-
ing of a CSS selector and a set of property-value pairs. A
CSS selector is used to specify to which HTML nodes the
given property-value pairs will be applied to.

Client-side web applications are mostly event-driven UI
applications, and majority of the code is executed as a re-
sponse to user-generated events. The life-cycle of the appli-
cation can be divided into two phases: i) page initialization
and ii) event-handling phase. The main purpose of the page
initialization phase is to build the UI of the web page. The
browser achieves this by parsing the HTML code and build-
ing an object-oriented representation of the HTML docu-
ment – the Document Object Model (DOM). When parsing

WWW 2012 – Session: Web Engineering 1April 16–20, 2012, Lyon, France820the HTML code the DOM is ﬁlled one HTML node at a
time. There are two special types of HTML nodes that the
browser can reach: i) the style and link nodes, that enable
the inclusion of CSS code, and ii) the script node that en-
ables the inclusion of JavaScript code.

When the browser reaches either the style or the link node
it parses the included CSS code and constructs a set of pre-
sentational rules. Each rule has a CSS selector specifying to
which HTML nodes the rule will be applied to at any point
of application execution. If the browser reaches the script
node it suspends the DOM building process and enters the
JavaScript interpretation process. In this phase this means
sequentially executing the given JavaScript code. One im-
portant purpose of this code is to register event-handlers,
which deﬁne how events are handled later during the sec-
ond phase of the execution. Once the JavaScript code in
that node is executed, the process again resumes the DOM
building phase. After the last HTML node is parsed and the
whole UI is built, the application enters the event-handling
phase, where code is executed as a response to events. All
updates to the UI are done by JavaScript modiﬁcations of
the DOM, which can go as far as completely reshaping the
DOM, or even modifying the code of the application.

A web page is a collection of UI controls, which communi-
cate with the user by modifying their UI. Each UI control is
deﬁned with a set of HTML nodes (the UI control’s DOM), a
set of CSS rules applied to those nodes, and JavaScript code
that implements the behavior. All modiﬁcations of the UI
are done with JavaScript modiﬁcations of the UI control’s
DOM, and a single UI behavior is often implemented with
multiple DOM modiﬁcations.

3. THE EXTRACTION PROCESS

The extraction process will be illustrated with a running
example shown in Listing 1. The UI of the web application
is initially composed out of two squares: a top red one, and a
bottom blue one, and two behaviors: i) when the top square
is clicked for the ﬁrst time, a smaller blue square is created
inside it; and ii) when a bottom square is clicked it changes
its color (from blue to red, and vice versa). Throughout
this section we will show how the code necessary only for
the execution of the ﬁrst behavior is extracted. A common
approach is by building a dependency graph.
3.1 The Dependency Graph

The client-side web application code is composed of three
diﬀerent parts: CSS, HTML and JavaScript, that are inter-
twined and must be studied as a part of the same whole.
Because of this, we deﬁne the client-side dependency graph
consisting of three types of nodes: HTML nodes, CSS nodes
and JavaScript nodes; and three types of edges: structural
dependency edges, data ﬂow edges, and control ﬂow edges.
Also, since the client-side of the web application is extremely
dynamic (e.g. new HTML nodes are regularly created by
JavaScript code and inserted into the DOM of the applica-
tion, but also new JavaScript and CSS code can be dynam-
ically created with JavaScript code), for each node type we
also diﬀerentiate between static and dynamic nodes. A node
is static if it is directly present in the source code of the ap-
plication, while it is considered dynamic if it is dynamically
constructed with JavaScript code. Also, the DOM structure
can be rearranged with JavaScript code, this is why there
also exist two types of structural dependency edges (static

< style >

/* 01 */ < html >
/* 02 */ < head >
/* 03 */
/* 04 */
/* 05 */
/* 06 */
/* 07 */
/* 08 */
/* 09 */ </ head >
/* 10 */ < body >
/* 11 */
/* 12 */
/* 13 */
/* 14 */
/* 15 */
/* 16 */

</ style >

. bgRd { background - color : red ;}
. bgBl { background - color : blue ;}
div { height :60 px ; width :60 px }
span { height :30 px ; width :30 px }

< div class = " bgRd " id = " frSq " > </ div >
< br / >
< div class = " bgBl " id = " scSq " > </ div >
< script >

function c h a n g e C o l o r ( elem ) {

elem . cl a s s N a me = elem . c l a s s N am e

== " bgRd " ? " bgBl " : " bgRd " ;}

/* 17 */

var frSq = document .

g e t E l e m e n t B y I d ( " frSq " ) ;

/* 18 */

var scSq = document .

g e t E l e m e n t B y I d ( " scSq " ) ;

/* 19 */
/* 20 */
/* 21 */

frSq . onclick = function () {

if ( frSq . children . length == 0) {

var sml = document .

c r e a t e E l e m e n t ( " span " ) ;

sml . cl a s s N a me = " bgBl " ;
frSq . a p p e n d C h i l d ( sml ) ;}

scSq . onClick = function () {

c h a n g e C o l o r ( scSq ) ; };

};

/* 22 */
/* 23 */
/* 24 */
/* 25 */
/* 26 */
/* 27 */
/* 28 */ </ body >
/* 29 */ </ html >

</ script >

Listing 1: Example application

and dynamic). Table 1 shows the deﬁnition of the diﬀerent
edge types, where edges marked s, d and c represent struc-
tural dependencies, data dependencies and control ﬂow, re-
spectively. H denotes HTML nodes, J JavaScript nodes, C
CSS nodes, and N denotes a node of arbitrary type.

Table 1: Edges in the client side dependency graph

Condition

J writes data to N .

Edge
s−→ N2 N1 is a child of N2.
d−→ J
d−→ N
d−→ C
c−→ J2

J reads data from N .

J2 is executed after J1.

C style is applied to H.

N1

N

J

H

J1

Because of the inherent hierarchical organization of HTML
documents the HTML layout translates very naturally to
a graph representation. Except for the top one, each el-
ement has exactly one parent element, and can have zero
or more child elements. The parent-child relation is the
basis for forming dependency edges between H-nodes. A
directed structural dependency edge between two H-nodes
represents a parent-child relationship from a child to the

WWW 2012 – Session: Web Engineering 1April 16–20, 2012, Lyon, France821parent. A dependency graph subgraph composed only of
H-nodes matches the DOM of the web page.

C-nodes represent CSS rules applied to speciﬁed HTML
nodes. All CSS code is contained in a HTML node, so each
C node has a structural dependency towards the parent H-
node. Also, since a CSS style can be created with JavaScript
code, there can exist a structural dependency between a C-
node and a J-node. The main goal of a CSS style is to deﬁne
styling parameters of HTML nodes that satisfy certain con-
ditions, for this reason, there can exist a data dependency
between an H-node and the C-node.

J-nodes represent JavaScript code construct that occur
in the program (a simpliﬁed Abstract Syntax Tree). All
JavaScript code is contained in an HTML node, so each J-
node has a structural dependency towards the parent HTML
node. Two J-nodes can also have structural dependencies
between themselves denoting that one code construct is con-
tained within the other (e.g. a relationship between a func-
tion and a statement contained in its body). J-nodes can
form data-dependency edges with all types of nodes: a data
dependency from one J-node to another denotes that the
former is using the values set in the latter; an edge from a
J-node to an H-node that the J-node is reading data, while
an edge from the H-node to the J-node means that the J-
node is writing data to the H-node. An edge from a J-node
to a C-node means that the JavaScript code is reading data
from the C-node.

Example. Figure 2 shows the graph built while reinter-
preting the web application code based on the execution
trace shown in the usage scenario. The circle nodes repre-
sent H-nodes, the square nodes C-nodes, and the rectangle
nodes J-nodes. The numbers near each node represent the
ﬂow of control, the full lines represent structural dependen-
cies, while the dotted lines represent data dependencies.
3.2

Interaction recording

The whole process is based on the analysis of applica-
tion traces recorded by communicating with the JavaScript
debugger while demonstrating the chosen behavior. The
recording application is realized as a Firefox extension.

Example. The developer wants to extract the ﬁrst behav-
ior (creating a square within a square), so he selects the part
of the UI on which the extraction process will be focused on
– the HTML node with the id “frSq” and demonstrates the
following usage scenario: click on the bottom square, caus-
ing it to change its color from blue to red (even though this is
not required from the perspective of the ﬁrst behavior), and
clicking on the top square which results with the creation of
a smaller blue square within it (the desired behavior).
3.3 Reinterpretation

After the application execution trace has been recorded,
the process enters the second phase – Reinterpretation. As
an input this phase receives the web page code, the node
selected for extraction, and a recorded execution trace. The
algorithm is shown in Algorithm 1, and has two phases: page
initialization (line 1) and event-handling (lines 2–4). The
basis of the algorithm is the process by which the browser
executes the web page (described in Section 2.1.).

Building HTML and CSS nodes
In the initialization phase, for each encountered HTML code
node a matching static H-node is created (Algorithm 2).

Algorithm 1 reinterpret(webPageCode, extractionNode,
appExeTrace)
1: createHChildNodes(createStatHNode(),

createCodeTree(webPageCode),
appExeTrace, extractionNode)

2: for all event : appExeTrace do
3:

interpretJs(getCode(event), getNode(event),

getExecs(event))

4: end for

When an HTML with CSS code is reached, for each CSS
rule a static C-node with structural dependencies to the con-
taining H-node is created. On each DOM change, CSS rules
are traversed and if an HTML node satisﬁes a CSS rule, a
data dependency from the H-node to the C-node is created.
Example. The algorithm starts by creating the three H-
nodes: html, head, and style node, where the head node has
a structural dependency towards the html node, and the
style node towards the head node. Since the style node is a
special type of node, the process starts creating C-nodes –
four static C-nodes are created based on four CSS rules, and
each CSS node has a static structural dependency towards
the parent style node. Next, the DOM building phase is con-
tinued, and the process creates the following H-nodes: body,
div, br, div, and script and marks the necessary structural
dependencies (body → html; div, br, div, script → body).
Since the creation of each static node initiates the search
for a matching CSS rule, when the ﬁrst div node is created,
data dependencies from that node to the ﬁrst and the third
C-node are created (since the HTML node satisﬁes those
two CSS selectors), and when the second div node is cre-
ated, data dependencies from the second div to the second
and the third C-node are also created (top middle and top
left part of the graph in Figure 2).

Algorithm 2 createHChildNodes(hNode, htmlCodeElem,
appExeTrace, extrNode)
1: for all codeChild : getChildren(htmlCodeElem) do
2:
3:
4:
5:
6:
7:

hChldNode ← createStatHNode(codeChild )
appendChild(hNode, hChldNode)
addStatStrucDep(hChldNode, hNode)
traverseCNodesAndCreateDependencies()
if codeChild is HTMLScriptNode then

interpretJs(codeChild.text, hChldNode,

8:
9:
10:
11:
12:
13:
14:

getScriptExe(appExeTrace), extrNode)

for all cssRule : parseCss(htmlChldNode.text) do

else if codeChild is HTMLCssNode then
cNode ← createStatCNode(cssRule)
addStatStrucDep(cNode, hChldNode)

end for

else

createHChildNodes(hChldNd, codeChild, appExe-
Trace)

15:
end if
16: end for

Building JavaScript nodes
When the process encounters an HTML node containing
JavaScript code, it switches to the creation of code construct
nodes, and the process enters the execution-trace guided in-

WWW 2012 – Session: Web Engineering 1April 16–20, 2012, Lyon, France822Figure 2: Dependency graph of the web application from Listing 1 (@ - denotes the line number of the code
construct)

terpretation mode – code nodes are created as each code ex-
pression is evaluated (Algorithm 3). If the evaluated expres-
sion reads identiﬁers (a term encompassing objects, proper-
ties, and functions), then a data dependency from the cur-
rent node to the node matching the last assignment of the
identiﬁer is created. Currently, we do not slice arrays, so
if the accessed object is an array, data-dependencies from
the current node to all nodes that match the modiﬁcation
expressions of that array object are also created. Also, some
of the evaluated code expressions can create dynamic nodes,
and in that case a data-dependency is created from the dy-
namic node to the currently evaluated JavaScript node.

Example. The process has reached the script node in line
14 and is entering the JavaScript interpretation mode (mid-
dle and the top right part of the graph in Figure 2), and
a function declaration node from line 15 is created. Next,
the control ﬂow reaches the variable declaration in line 17,
and the matching node is created. On the right hand side
there is a method call on the document object (which is spe-
cial object provided by the browser, acting as an interface to
the DOM). The method invocation returns an HTMLObject
mapped to the HTML node with the id “frSq” (the ﬁrst div),
so a data dependency from the call expression to the H-node
is created. Also since this is a variable declaration expres-
sion, a data dependency from the identiﬁer “frSq” to the
call expression is created. Similarly the nodes and matching
data dependencies for line 18 are created. For line 19 an
assignment expression node is created. The right hand side

creates a function expression, and the left hand side a mem-
ber expression. The member expression accesses the object
referenced with the id “frSq” so it has a data dependency to-
wards the variable declaration and the call expression in line
17 (because that is where the value has come from). Also,
since the object whose property is being set is an HTML
object, and since the “onclick” property is a property used
to set an event-handler, a dependency from the matching
H node to this assignment expression is created. A similar
procedure is repeated for line 25. Since there is no more
JavaScript code for sequential execution, the process exits
the interpretation mode. Also, all H-nodes have been cre-
ated and the page initialization phase is ﬁnished.

Event handling
Once the whole code ﬁle has been traversed, and all con-
tained JavaScript code executed in a sequential fashion the
graph construction enters the event-handling phase (Algo-
rithm 1). Information about each event is read from the ex-
ecution trace, and the dependency from the event handling
function code node to the HTML node causing the event
created. JavaScript nodes are created for each expression
executed as a part of the event-handler code (Algorithm 3).
In the demonstrated usage scenario, the ﬁrst
raised event was the click on the bottom square. The pro-
cess reads the application execution trace and ﬁnds that the
function in line 25 was executed as a click event-handler
on an HTML node with id “scSq” (bottom left and bottom

Example.

WWW 2012 – Session: Web Engineering 1April 16–20, 2012, Lyon, France823Algorithm 3 interpretJs( code, hNode, currExecs, progra-
mAst, extrNd )
1: for all step in curExecs do
2:
3:
4:
5:
6:
7:

currAstNd ← getAstNode(step)
jNode ← createJNode(currAstNd )
addStaticStructDep(jNode, hNode)
evldAstNd ← evalute(currAstNd )
if isAccessingIdentiﬁers(evaldAstNd ) then

create data dependencies from the jNode to the iden-
tiﬁer’s last assignment expression

8:
9:
10:

11:
12:
13:

14:
15:
16:
17:
18:

19:
20:
21:
22:
23:

24:
25:
26:
27:
28:

end if
if isReadingArrayObject(evaldAstNd ) then

add data dependencies from the jNode to all expres-
sions that have modiﬁed the array

end if
if isEnteringFunction(evaldAstNd ) then

add dependency from the jNode to the call expres-
sion

else if isReturnFromCallExpr(evaldAstNd ) then

add data dependency from jNode to retrnExpr

end if
if isInLoopOrInIfStatement(evaldAstNd ) then

add data dependency from jNode to conditionExpr
node
end if
if isCreatingJsCode(evldAstNd ) then

parse the newly added code and add AST node

else if isCreatingHtmlNode(evldAstNd ) then

create a dynamic H-node with a dataDepend to jN-
ode
traverseCNodesAndCreateDependencies()
else if isCreatingCssNode(evldAstNd ) then

create a dynamic C-node with dataDepend to jNode

else if isRearrangingDOM(evldAstNd ) then

remove dynamic struct dependency of the target H-
node; add a new dynamic struct dependency from
the target H-node to the new parent node
traverseCNodesAndCreateDependencies()
if aﬀected nodes are descendants of extrNd then

29:
30:
31:
32:
33:
end if
34: end for

end if

createCodeMarkings(jNode)

right of Figure 2). This creates a data dependency from
the function expression construct towards the H-node. The
function body is interpreted and all data dependencies for
the executed code are created. The procedure is repeated
for the second event that was raised as a response to click-
ing on the ﬁrst square, and goes similarly to the body of
the if statement. In line 21, a new HTML element is cre-
ated. This causes the creation of a new dynamic H-node
with a data dependency towards the call expression in line
21. Also, since this a DOM modifying expression, the search
for the matching CSS rules, is also initiated, which in this
situation, creates dependencies from the dynamic H-node to
the fourth C-node. In line 22, the DOM of the newly created
node is modiﬁed, so a data dependency from that H-node to
the assignment expression, and to the second C-node is cre-
ated. In line 23 the HTML node is inserted into the DOM
of the ﬁrst div (a node chosen for extraction). This raises

the DOM modiﬁed event, and the process enters the code
marking phase (Algorithm 4).
3.4 Code Marking

As the application code is being interpreted and code de-
pendencies built, it is important to identify executed code
constructs that will be used as a basis for code extraction.
Since we are dealing with UI applications, these important
code constructs are the ones that are modifying the UI. All
UI modiﬁcations on the client-side are done by modifying the
DOM of the web application, so we track dependencies from
DOM modifying statements. The main idea is that when
the code interpretation algorithm raises the DOM modifying
event, the dependency graph is traversed starting from the
HTML node being modiﬁed by following all dependencies
(Algorithm 4). When a static node is reached its matching
code construct is marked as important.

Example. The call expression in line 23 is modifying the
DOM of the node chosen for extraction, so the process en-
ters the marking phase which causes the traversal of the
dependency graph. The call expression in line 23 is marked
because it is causing the DOM modiﬁcation. Next, the iden-
tiﬁer “sml” is marked, which leads to the marking of the
variable declaration in line 21. The value of the identiﬁer
matches the dynamically created HTML span node, so its
dependencies are also traversed (but the node itself is not
included). This causes the inclusion of the assignment ex-
pression in line 22, and the second and the fourth C-node
(and the style node, and the head node because of structural
dependencies). Since the node whose DOM is being modi-
ﬁed is the one chosen for extraction, it, and its dependencies,
are also included (the ﬁrst div node, the parent body node,
the parent html node, the ﬁrst and the third C-node, and
the assignment expression in line 17). The if statement in
line 20, and the script node are also included since there are
statements included within them.

Algorithm 4 createCodeMarkings(topNode)
1: codeNode ← getCodeNode(topNode)
2: if isStaticNode(codeNode) then
3: markAsImportant(codeNode)
4: end if
5: if topNode is JNode then
6:
7:

if node is Break OR Continue
OR (ConditionExpr AND
areOnSameLvl(topNode, node)) then

for all node : getCntrlDepInCurrCntxt(topNode) do

end if
end for

createCodeMarkings(node);

8:
9:
10:
11: end if
12: for all node in getStrucAndDataDep(topNode) do
13:
14: end for

nodes.push(node)

3.5 Code Extraction

After the whole application execution trace has been rein-
terpreted, the process goes into the last phase – Code extrac-
tion, where the web applications code tree is traversed and
where code is generated from all static nodes marked as im-
portant in the code marking phase.

WWW 2012 – Session: Web Engineering 1April 16–20, 2012, Lyon, France824Example. The extraction result for the example is shown
in Listing 2. Even though the function changeColor was
executed, and has modiﬁed the UI of the second square, it
is not present in the ﬁnal, extracted code, simply because
it did not modify the part of the UI we were interested in
(node – “frSq”).

. bgRd { background - color : red }
. bgBl { background - color : blue }
div { height :60 px ; width :60 px }
span { height :30 px ; width :30 px }

< style >

/* 01 */ < html >
/* 02 */ < head >
/* 03 */
/* 04 */
/* 05 */
/* 06 */
/* 07 */
/* 08 */
/* 09 */ </ head >
/* 10 */ < body >
/* 11 */
/* 12 */
/* 13 */

</ style >

< div class = " bgRd " id = " frSq " > </ div >
< script >

var frSq = document .

g e t E l e m e n t B y I d ( " frSq " ) ;

/* 14 */
/* 15 */
/* 16 */

frSq . onclick = function () {

if ( frSq . children . length == 0) {

var sml = document .

c r e a t e E l e m e n t ( " span " ) ;

sml . cl a s s N a me = " bgBl " ;
frSq . a p p e n d C h i l d ( sml ) ;}

/* 17 */
/* 18 */
/* 19 */
/* 20 */
/* 21 */ </ body >
/* 22 */ </ html >

};

</ script >

Listing 2: Extracted example application

4. EVALUATION

We have evaluated the approach based on three applica-
tions of the method: i) extracting library code, ii) extracting
UI controls, and iii) removing dead code of web applications.
The evaluation is based on two metrics: lines of code (LOC)
and the number of execution steps (EXE). For the LOC we
use two baselines: total LOC of the entire application, and
the executed LOC (ExLOC). The eﬀectiveness of the ap-
proach is then measured by comparing the baselines with
the extracted LOC (ExtLOC). For the total LOC, in order
to better compare the results we reformat the application
source code in the same format the extracted code will be in
(e.g. by removing comments, braking lines according to same
rules, etc.). Executed code lines represent a very simple, but
straightforward extraction approach. They are derived from
the application execution trace, without any analysis, sim-
ply by keeping all uniquely executed lines while maintaining
syntactical correctness. This code version does not include
lines that were not executed, and is capable of replicating
the starting usage scenario. It is important to note that not
all executed code is important from the perspective of the
target behavior (e.g. some of it might do initialization, or im-
plement functionality that is irrelevant from the perspective
of the target behavior). This is why we measure the eﬀec-
tiveness of our approach by comparing the extracted LOC
with the executed LOC. We also report the diﬀerence in the
number of execution steps when executing the usage scenario
in the context of the full web application code (ExEXE), and
when executed in the context of extracted code (ExtEXE).
This diﬀerence represents the performance gains that can be

achieved by using our method, because the same behavior is
realized with less execution steps. All used test applications
can be downloaded from www.fesb.hr/˜jomaras/www2012.
The data presented in this evaluation was gathered by a
tool developed as a Firefox extension – all tracing data is
Firefox speciﬁc, and results could be diﬀerent in another
browser. However, we do not believe that considerably dif-
ferent results would be attained with other modern web
browsers.
4.1 Extracting Library Code

For extracting library code we have evaluated the approach
by extracting functionalities from an open-source vector and
matrix math library – Sylvester1. It includes functions for
working with vectors, matrices, lines and planes. As with
other libraries, if we only use a small subset of its functional-
ity, then a lot of library code will be irrelevant from our ap-
plication’s point of view. Based on the public API given on
the homepage of the library, we have developed use-cases for
a subset of the public methods. We have recorded the execu-
tion of those use-cases, with the following results: from the
total of 130 methods spread over 1400 lines of code we have
extracted 27 methods in a way that alongside each method
only the code that is essential for the stand-alone function-
ing of the method is extracted.
In all cases the method
extraction was successful, meaning that the use-case could
be repeated with the same result for the extracted code.
Table 2 presents the experimental data. For each tested
method it provides information about the total number of
uniquely executed code lines during the execution of a use
case (ExLOC), the number of lines that were included in
the extracted code (ExtLOC), number of executions gener-
ated while executing the usage scenario in the context of
the whole web application code (ExEXE), and the number
of execution steps when repeating the usage scenario in the
context of the extracted code (ExtEXE). As can be seen,
each method executes from around 17%–27% of the total
library code, and out of that executed code the extraction
process extracts anywhere from 5%–65%, which constitutes
the part of the code required to implement the target be-
havior. In terms of the overall number of execution steps,
the savings range from 42% to 97%. It is important to note
that savings are the greatest in simple methods, where the
overall number of execution steps performed in the method
is signiﬁcantly smaller than executions generated in the ini-
tialization phase. As a base line we present the number of ex-
ecuted lines and executions recorded while just including the
library, without explicitly executing any methods. Even in
that case the library has 241 executed LOC and 2279 execu-
tion steps, the reason being that all included code generates
executions (e.g registering function or variable declarations,
performing initialization, etc.).
4.2 Extracting UI Controls and Dead Code Re-

moval

The goal of the UI control extraction functionality is to ex-
tract only the HTML, CSS, and JavaScript code that build
the UI control, while in the case of dead code elimination we
want to remove JavaScript code that is not necessary from
the behavior’s perspective. These two usages of the method
have been evaluated on the same test data (Table 3): eight

1http://sylvester.jcoglan.com/

WWW 2012 – Session: Web Engineering 1April 16–20, 2012, Lyon, France825Table 2: Experimental results on extracting API
functions from the Sylvester math library

Method
No method
V.create
V.cross
V.dot
V.random
V.zero
V.add
V.dimensions
V.distanceFrom
V.isParallelTo
V.max
V.modulus
V.multiply
V.rotate
V.angleFrom
M.add
M.determinant
M.isSingular
M.multiply
M.minor
M.subtract
M.transpose
L.contains
L.distanceFrom
L.intersection
L.intersects
L.pointClosest
L.rotate

ExLOC ExtLOC ExEXE ExtEXE

241
241
247
241
250
241
269
244
266
280
258
241
267
299
276
312
330
338
321
298
312
298
269
265
350
326
394
359

0
14
20
26
24
24
43
18
38
51
31
30
42
77
43
76
90
98
83
62
76
62
84
76
157
133
210
236

2279
2230
2464
2441
2421
2427
2456
2335
2515
2804
2477
2449
2553
2668
2549
3679
3385
4023
4071
5571
3679
3322
2867
2833
3698
3768
5501
4621

0
68
189
174
160
166
275
75
243
409
192
185
289
406
261
1340
1032
1590
1729
3198
1340
1066
582
544
1584
1385
2973
2151

Whole Library LOC: 1417

medium-sized web applications, the ﬁrst two being stan-
dard web applications, and six being openly available smaller
demo applications (examples of UI controls). None of the
applications communicates asynchronously with the server
side – all behavior is realized on the client-side. All evalu-
ated applications, except the “checkbox-radioBox” applica-
tion, use the jQuery library, the most wide-spread library for
simplifying client-side scripting [12]. jQuery is a complex li-
brary, with about 9000 LOC, and provides functionality for
simplifying work with multiple browsers, selecting DOM el-
ements, animations, etc. For each test application, Table 3
shortly describes the interaction we record.

Example.The process will be illustrated with an example
application that we have developed for another project –
http://www.idt.mdh.se/pride/ (Figure 3). Apart from the
presentational aspects this web page also has one imple-
mented behavior: in the central part there exist a UI control
with two buttons. When the user clicks on a button, the cur-
rent image and caption change with a fade eﬀect. We will
use this example with a slight modiﬁcation for both usages.

Extracting UI controls
The result of the UI control extraction is a web page which
contains only the selected UI control with all necessary code
and resources required for its stand-alone functioning.
In
this evaluation, from the eight web applications we were
able to successfully extract eleven stand-alone UI controls.

Table 3: Web applications

web page
idt.mdh.se/pride
druckbar.info

accordion

Target behavior
Go through all items by clicking
1. Wait for all image replacement
2. Mouse hover over a single item
Cycle through all items by clicking
on each header
Go through items by clicking
Go through items by clicking
Wait page load, eﬀect ﬁnish

slider1
slider2
humanTypist
checkbox radioBox Click two times on each checkbox

iPhone buttons

click once on each radio box
Click on enable, disable; on, oﬀ

Example. In the example application (Figure 3), the de-
veloper demonstrates the following behavior: he/she selects
the HTML node encompassing the whole UI control, waits
for the page to load, clicks on the second button and waits
for the image-caption change eﬀect to ﬁnish. When this is
done, the developer clicks on the ﬁrst button, and also waits
for the end of the eﬀect. When analyzing this execution
trace, code dependencies are traversed and important code
constructs marked when the structure of the selected HTML
node (or the structure of its descendants) is being modiﬁed.
The end result is the UI control from Figure 4.

Dead Code Removal
In the case of removing dead code, Table 4 shows the exper-
imental results gained when removing dead code based on
the behaviors shown in Table 3. In addition to the informa-
tion described in the introduction of this section, for this set
of data, we also present gains achieved in terms of page load-
ing time (GPLT), which is measured by loading an uncached
page from the local machine. This was done in order to re-
duce the inﬂuence of the connection speed on the end results.
Loading time is an important piece of information because
the longer the page loading time, the higher the probability
that the user will abandon the web page [2]. As can be seen,
considerable savings can be achieved in terms of page load-
ing time (25,5% on average), and LOC (33,5% compared to
executed LOC, or even 73,8% if compared with the original

Figure 3: Pride home page; 1 – the dashed blue
square marks the UI control, 2 – clickable buttons,
3 – image, 4 – captions

WWW 2012 – Session: Web Engineering 1April 16–20, 2012, Lyon, France826can have diﬀerent forms: a Flow Graph in original Weis-
ner’s form, a Program Dependence Graph (PDG) [5] where
it shows both data and control dependencies for each evalu-
ated expression, or a System Dependence Graph (SDG) [6]
which extends the PDG to support procedure calls rather
than only monolithic programs. The SDG has also been later
expanded in order to support object-oriented programs [7].
In the web domain Tonella and Ricca [11] deﬁne web ap-
plication slicing as a process which results in a portion of
a web application which still exhibits the same behavior as
the initial web application in terms of information of interest
to the user. They present a technique for web application
slicing in the presence of dynamic code generation by build-
ing an SDG for server-side web applications. Even though
the server-side and the client-side applications are parts of
the same whole, they are based on diﬀerent development
paradigms, and cannot be treated equally.

There are also two tools that facilitate the understanding
of dynamic web page behavior: Script InSight [8] and Fire-
Crystal [10]. Script InSight helps to relate the elements in
the browser with the lower-level JavaScript syntax. It uses
the information gathered during the script’s execution to
build a dynamic, context-sensitive, control-ﬂow model that
summaries tracing information. FireCrystal facilitates the
understanding of interactive behaviors in dynamic web pages
by recording interactions and logging information about DOM
changes, user input events, and JavaScript executions. After
the recording phase, the user can use an execution time-line
to see the code that is of interest for the particular behavior.
Compared to our approach they make no attempts to track
data dependencies between diﬀerent code expressions, nor
to extract the analyzed code.

In the more general domain of Java applications, G&P [4]
is a reuse environment composed of two tools: Gilligan and
Procrustes, that facilitates pragmatic reuse tasks. Gilligan
allows the developer to investigate dependencies from a de-
sired functionality and to construct a plan about their reuse,
while Procrustes automatically extracts the relevant code
from the originating system, transforms it to minimize the
compilation errors and inserts it into the developer’s system.
This work was further expanded [3] with the possibility to
automatically recommend elements to be reused based on
their structural relevance and cost-of-reuse.

This work is the continuation of our previous work [9]
where we have shown how web application UI controls can be
reused. However in that work, for relating code and behavior
we have used only the executrion trace data – all visited
lines have been extracted, and there were no attempts to
identify data dependencies between code constructs. As our
experiments indicate, by also taking data dependencies into
account, we are able able to achieve additional savings - from
5.3% to 64.6% in the number of code lines, and from 22,5%
to 57,5% in the number of executions.

6. CONCLUSIONS AND FUTURE WORK
In this work we have shown how web application code
implementing a certain behavior can be extracted from the
whole web application code by dynamically analyzing appli-
cation execution traces. We have demonstrated how, even in
this highly dynamic, multi-paradigm, multi-language envi-
ronment of the web application client side, dependencies can
be tracked by constructing a client-side dependency graph,
and how by using that graph only the code responsible for

Figure 4: The UI control extracted from the Pride
home page

LOC), while still being able to reproduce the behavior of the
web page. These results indicate that, in general, web appli-
cations contain more code than is actually needed by their
behavior, and that considerable savings could be achieved
by applying this extraction method. However, in order to
strongly claim this fact, a more extensive web application
test suite will have to be created.

Example. The functionality described in the previous sec-
tion (Extracting UI controls) actually captures all complex
behaviors in the example application (Figure 3), and can be
used for dead code removal. The functionality is realized
with the jQuery library. However, since this is not a large
application, it only uses a subset of the library. This means
that every time, when a user accesses the page, unnecessary
code is transfered and interpreted in the browser. This leads
to slower pages and increases web server traﬃc.

When re-executing the behavior described in the Extract-
ing UI controls section, we get the following data (Table 4,
ﬁrst row): application behavior is implemented with 5730
JavaScript LOC (5610 jQuery, and 120 in the home page),
and the average loading time is 268,9 ms2. Out of these
5730 LOC, in this scenario, the web application control goes
through 2059 LOC. After the extraction process is ﬁnished,
we end up with only 1458 LOC. This decrease in the total
LOC, also decreases the loading time to 220,3 ms (18,7%
faster loading time).

5. RELATED WORK

The work that we have presented in this paper is closely
related to program slicing, which is deﬁned by Weisner [13]
as a method that starting from a subset of a program’s be-
havior, reduces that program to a minimal form which still
produces that behavior. In its original form, a program is
sliced statically, for all possible program inputs. Static slic-
ing can be diﬃcult, and can lead to slices that are larger
than necessary, especially in the case of pointer usage (e.g.
in C). Further research has lead to development of dynamic
slicing [1] in which a program slice is composed of state-
ments that inﬂuence the value of a variable occurrence for
speciﬁc program inputs – only the dependencies that occur
in a speciﬁc execution of a program are studied.

Program slicing is usually based on some form of a Depen-
dency Graph – a graph that shows dependencies between
code constructs. Depending on the area of application, it

2averaged on 10 uncached, local page loadings, on an Intel
Core i7, 1.73 GHz

WWW 2012 – Session: Web Engineering 1April 16–20, 2012, Lyon, France827Table 4: Experimental results on dead code removal from the test applications: LOC (Original LOC), ExLOC
(Executed), ExtLOC (Extracted), GPLT (page loading time gains ), GLOC (extracted vs executed code gains)

Page
pride
druckbar
accordion
slider1
slider2
humanTypist
check, radioBox
iPhone buttons

LOC ExLOC ExtLOC GLOC(vsOrig) GLOC(vsExe) GPLT ExEXE ExtEXE GEXE
25,2%
5730
24,2%
5694
28,5%
6214
5656
33,5%
40%
5855
57,5%
5686
22,5%
45,8%

29,2%
27,4%
20,8%
42,4%
35%
64,6%
5,3%
43,2%

74,6%
77%
70,5%
80,7%
75,2%
91,7%
37,7%
83%

52374
38564
68669
44793
28734
21446
1214
27531

39137
29232
49100
29779
17226
9122
941

14929

1458
1305
1833
1092
1451
473
53
957

2059
1798
2315
1897
2233
1338

56

1687

85

5627

18,7%
12,8%
23,5%
30%
23,4%
54,6%

7%

34,3%

a certain behavior can be extracted. We have shown how
this extraction process can be used for diﬀerent purposes:
extracting library code, extracting UI controls, and remov-
ing dead code. Based on these three applications we have
evaluated the approach and have reached two conclusions:
i) the performed method can correctly extract stand-alone
behaviors by analyzing web application traces, and ii) con-
siderable savings in terms of the number of executions, page
loading time, and code size, can be achieved while still being
able to reproduce the demonstrated behavior.

For future work we plan to extend the process to also
support the analysis of server side code and resources. The
client-side and the server-side of the web application, even
though based on completely diﬀerent paradigms, are parts of
the same whole, and should be studied together. Web appli-
cations are based on a request-response paradigm: a request
is sent to the server, the server processes it, accesses some
data (stored in ﬁles, or in a database) and creates a response
that is sent to the client. The response is usually a combi-
nation of HTML, CSS, and JavaScript that will be executed
in the web browser (the client-side of the application). This
is why, in order to enable complete behavior extraction, we
have to extend the process to track dependencies between
the generated, client-side code, and the code and resources
responsible for its generation on the server-side. Also, in this
work we have considered only behaviors that result with a UI
modiﬁcation, but there are also behaviors that result with
a message exchange with the server-side (downloading data,
or sending information to the server-side), so the process has
to be expanded to support them, too.

We are in the process of setting up a more extensive test
suite of web applications to test that the extracted code al-
ways correctly implements the desired behavior. Also, the
currently performed evaluation can not be used to strongly
claim that web applications contain much more code than is
actually needed by their behavior. This is why the evalua-
tion is being set up to generally determine how much code,
on average, is unnecessarily included in web applications.

7. REFERENCES
[1] H. Agrawal and J. R. Horgan. Dynamic program
slicing. In Conference on Programming language
design and implementation, PLDI ’90, pages 246–256,
New York, NY, USA, 1990. ACM.

[2] S. Galbraith. Quantifying the relationship between
website download time and abandonment by users.
”http://www.simple-talk.com/dotnet/.net-tools/the-
cost-of-poor-website-performance/”.

[3] R. Holmes, T. Ratchford, M. Robillard, and R. J.

Walker. Automatically Recommending Triage
Decisions for Pragmatic Reuse Tasks. In International
Conference on Automated Software Engineering. IEEE
Computer Society, 2009.

[4] R. Holmes and R. J. Walker. Semi-Automating

Pragmatic Reuse Tasks. In International Conference
on Automated Software Engineering, pages 481–482.
IEEE Computer Society, 2008.

[5] S. Horwitz, J. Prins, and T. Reps. Integrating

noninterfering versions of programs. ACM Trans.
Program. Lang. Syst., 11:345–387, July 1989.

[6] S. Horwitz, T. Reps, and D. Binkley. Interprocedural

slicing using dependence graphs. SIGPLAN Not.,
23:35–46, June 1988.

[7] L. Larsen and M. J. Harrold. Slicing object-oriented

software. In International conference on Software
engineering, ICSE ’96, pages 495–505, Washington,
DC, USA, 1996. IEEE Computer Society.

[8] P. Li and E. Wohlstadter. Script insight: Using models

to explore javascript code from the browser view. In
International Conference on Web Engineering, ICWE
’9, pages 260–274, Berlin, Heidelberg, 2009.
Springer-Verlag.

[9] J. Maras, M. ˇStula, and J. Carlson. Reusing web

application user-interface controls. In International
conference on Web engineering, ICWE’11, pages
228–242, Berlin, Heidelberg, 2011. Springer-Verlag.
[10] S. Oney and B. Myers. FireCrystal: Understanding

interactive behaviors in dynamic web pages. In
Symposium on Visual Languages and Human-Centric
Computing, pages 105–108. IEEE Computer Society,
2009.

[11] P. Tonella and F. Ricca. Web Application Slicing in

Presence of Dynamic Code Generation. Automated
Software Engg., 12(2):259–288, 2005.

[12] W3Techs. Usage statistics and market share of
javascript libraries for websites, October 2011.
w3techs.com/technologies/overview/javascript library/all/.

[13] M. Weiser. Program slicing. In International

Conference on Software engineering, pages 439–449.
IEEE Press, 1981.

WWW 2012 – Session: Web Engineering 1April 16–20, 2012, Lyon, France828