Online Team Formation in Social Networks∗

Aris Anagnostopoulos1
aris@dis.uniroma1.it

Luca Becchetti1

becchett@dis.uniroma1.it

Carlos Castillo2
chato@acm.org

Aristides Gionis2

gionis@yahoo-inc.com

1Sapienza University of

Rome, Italy

Stefano Leonardi1

leon@dis.uniroma1.it
2Yahoo! Research
Barcelona, Spain

ABSTRACT
We study the problem of online team formation. We con-
sider a setting in which people possess diﬀerent skills and
compatibility among potential team members is modeled by
a social network. A sequence of tasks arrives in an online
fashion, and each task requires a speciﬁc set of skills. The
goal is to form a new team upon arrival of each task, so that
(i) each team possesses all skills required by the task, (ii)
each team has small communication overhead, and (iii) the
workload of performing the tasks is balanced among people
in the fairest possible way.

We propose eﬃcient algorithms that address all these re-
quirements: our algorithms form teams that always sat-
isfy the required skills, provide approximation guarantees
with respect to team communication overhead, and they are
online-competitive with respect to load balancing. Experi-
ments performed on collaboration networks among ﬁlm ac-
tors and scientists, conﬁrm that our algorithms are success-
ful at balancing these conﬂicting requirements.

This is the ﬁrst paper that simultaneously addresses all
these aspects. Previous work has either focused on minimiz-
ing coordination for a single task or balancing the workload
neglecting coordination costs.

Categories and Subject Descriptors: F.2.2 [Analysis
of Algorithms and Problem Complexity]: Nonnumer-
ical Algorithms and Problems – Sequencing and scheduling

General Terms: Algorithms

Keywords: Team formation, Task assignment, Scheduling

1.

INTRODUCTION

We consider the problem of forming teams on a networked
community of people with diverse skill sets. The goal is to
assemble teams to deal with an incoming stream of tasks
that are not known in advance. Each task requires a set
of skills that must be covered by members of the assembled
team. Each team should have small coordination cost, that
is, it should be well-connected according to the underlying

∗The research leading to these results has received funding
from the EU FP7 Project N. 255403 SNAPS; the Spanish
Ministry of Science and Innovation (project CEN-20101037
Social Media and Torres Quevedo programme); and the
PRIN 2008 research projects COGENT.

Copyright is held by the International World Wide Web Conference Com-
mittee (IW3C2). Distribution of these papers is limited to classroom use,
and personal use by others.
WWW 2012, April 16–20, 2012, Lyon, France.
ACM 978-1-4503-1229-5/12/04.

social network. Finally, this allocation should be fair, in the
sense that no one should be overloaded with tasks or unfairly
singled out.

In previous works (i) Lappas et al. [14] considered the
team-formation problem for a single task with the objec-
tive of minimizing the coordination cost, but ignored the
issue of balancing the workload, and (ii) Anagnostopoulos
et al. [2] considered the formation of teams with the objec-
tive of balancing the workload, but ignored the coordination
costs. According to our observations (detailed in Section 6)
focusing exclusively on one of these aspects can lead to an
unfair allocation of work or poorly connected teams.

Contributions. In this paper we propose the ﬁrst online
algorithms that assemble teams to deal with tasks, in a way
that keeps coordination costs bounded and results in a fair
allocation of the workload. Speciﬁcally:

– we introduce the Balanced Social Task Assignment
problem and consider several variants, that include the prob-
lems studied by Lappas et al. [14] and Anagnostopoulos et
al. [2] as special cases;

– we provide online competitive algorithms [21] with prov-
able performance guarantees for these variants, noting that
all of them are NP-hard;

– we demonstrate the eﬀectiveness of our approach on
two real-world datasets; compared with solutions that ignore
user workloads, our algorithms achieve a signiﬁcant decrease
in the unbalance of the workload (60%–70%) with a small
increase on the coordination overhead (5%–10%).

Roadmap. The next section discusses related work. Sec-
tion 3 describes the general framework we use. Sections 4
and 5 describe our methods, which are tested experimentally
in Section 6. The last section presents our conclusions.

2. RELATED WORK

Scheduling with load balancing: A well-studied problem
since the work of Graham [12], is the scheduling of jobs on
a set of machines with the goal of minimizing the maximum
load on a machine. The setting has been extended to the
restricted-assignment problem, in which the goal of balanc-
ing the workload is kept but additionally each job can only
be processed by a subset of the available machines. The lat-
ter problem is NP-hard and has competitive ratio O(ln k)
(where k is the number of jobs), shown to be asymptoti-
cally tight even for randomized online algorithms [4,5]. Our
work deals with a problem harder than restricted assign-
ment, since forming a team entails solving a set-cover prob-

WWW 2012 – Session: Collaboration in Social NetworksApril 16–20, 2012, Lyon, France839lem, which has additional logarithmic lower-bound factors
even in the oﬄine case [22].
Matching people to tasks: Refereed conferences and
journals require submissions to be reviewed by members of a
program committee. This is a matching problem for which
several systems have recently been proposed, for instance
Easychair.org, Linklings.com and SoftConf.com. Easychair
is currently based on a preliminary bidding process where
reviewers rank papers into three classes. The problem of
providing eﬃcient solutions in the bidding model has re-
cently been addressed by Mehlhorn [17]. Our work does not
use explicit bids and is based on solving a covering problem
instead of a matching problem. We also have the additional
requirement of optimizing the coordination cost of formed
teams.
Agent-organized team formation: Gaston et al. [11]
study the team-formation problem in a setting where net-
worked agents form teams in a decentralized manner. Agents
are able to locally rewire their social network. We consider
a setting where the social network is given, and also load
balancing is taken into account.
Team formation with coordination costs: Lappas et
al. [14] introduce the problem of team formation in social
networks. The objective is to minimize the coordination
cost, for example, in terms of diameter or weight of the
minimum spanning tree for the team. This problem has
been extended to cases in which potentially more than one
member possessing each skill is required, and where density-
based measures are used as objectives [9,15]. It has also been
extended to allow partial coverage of the required skills, in-
troducing a multi-objective optimization problem that is op-
timized using simulated annealing [8]. More recently, Kar-
gar and An [13], consider a variation with a diﬀerent cost
model: when a user who participates in a task contributes
with a variety of his skills (more on this in Section 3), the
contribution to the cost is independent for each skill. Apart
from modeling diﬀerent scenarios with respect to the rest
of previous (and our) work, technically this model simpliﬁes
the problem as it avoids the “set-covering” aspect of it.
Team formation with load balancing: In our previous
work [2] we studied oﬄine and online versions of the problem
of allocating teams to tasks with the objective of balancing
workload, but ignoring coordination costs.

3. PROBLEM DEFINITION

In this section, we present our framework and notation
and formally deﬁne the problem that we study. Our notation
is also summarized in Table 1.
3.1 Tasks, Skills, People and Teams
Tasks. We denote by J = {Jj; j = 1, 2, . . . , k} a set of
tasks (or jobs). In the online setting that we consider, the
jth task arrives at the jth time step and is assigned to a
team of experts before the arrival of the (j + 1)th task.

Skills. Each task requires a subset of the m available skills
to be completed. We use the notion of skill space S =
{0, 1}m, which is the space that contains the possible ways
that m skills combine to form a task, so, each task is a point
in the skill space: Jj ∈ S. We use Jj
i = 1 to denote that
ith skill is required by the jth task, while Jj
i = 0 otherwise.
Thus, we have Jj = (Jj

2, . . . , Jj

1, Jj

m).

P
S
J
pj
Jj

d(pj , pj 0
d(j, j0)

pj
i
Jj
i
Qj
qj
qj
i
L(p)
L(Q)
c(Q)
c(T )
a(Q)
a(pj )

Table 1: Notation

n Number of people
m Number of skills
k Number of tasks

Set of people
Set of skills
Set of tasks
jth person
jth task

) Distance between persons j and j0

)

d(pj , pj 0
ith skill of jth person
ith skill of jth task
Team assigned to jth task
Skill proﬁle of team j
ith skill of proﬁle of team j
Load of person p
Load of team Q
Coordination cost of team Q
Coordination cost of subgraph T
Allocation cost of team Q
Allocation cost of person j

People. We consider a set of people (or experts) P =
{pj ; j = 1, 2, . . . , n}. Each expert has a subset of skills in
her proﬁle, so she is also represented by a point in the skill
space: pj ∈ S. We use pj
i = 1 to denote that the jth person
has the ith skill, while pj
i = 0 otherwise. Thus, we have
pj = (pj

2, . . . , pj

1, pj

m).

Teams. Each task needs to be assigned to a team of experts.
We let Qj ⊆ P denote the team assigned to the jth task.
We use qj
i = 1 to denote that the ith skill is covered by
the jth team, so we have qj = (qj
m). For each
team Qj we compute its team proﬁle qj ∈ S in the additive
skill model [2] that deﬁnes the expertise of the team as the
(binary) sum of the skills of each individual:

2, . . . , qj

1, qj

i = min{ X
qj
p`∈Qj

p`

i , 1}i=1,...,m.

In other words, a skill is covered by the team if there exists
at least one member who has that skill. We refer to a team
for task Jj by using the notation qj and Qj interchangeably.
Given a team Q with proﬁle q assigned to task J, we
deﬁne cov(q, J) ∈ {0, 1} to be 1 if and only if qj
i , ∀i =
1, . . . , m and we say that the team Q covers the task J.
Note that this happens if every skill required by the task is
possessed by the team.
3.2 Optimization Goals

i ≥ Jj

We aim to form teams that can accomplish the speci-
ﬁed tasks while optimizing two, possibly conﬂicting, goals:
achieving a fair allocation of the overall workload among
people and forming teams that have the lowest possible co-
ordination cost. We now make these notions more precise.

Load. The ﬁrst quantity we want to optimize is the load
L(p) of an expert p, which we deﬁne to be the number of
In
particular, as in our previous work [2], we are interested in
minimizing the maximum load over all the experts.

tasks in which p participates: L(p) = (cid:12)(cid:12){j; p ∈ Qj}(cid:12)(cid:12).

Coordination cost. In practice, team work faces coordi-
nation costs. Such costs limit the size of organizations, as
formalized in the seminal work of Coase [7]. In our setting,
the coordination overhead in collaboration may nullify the
potential advantages of a larger expertise coverage.

WWW 2012 – Session: Collaboration in Social NetworksApril 16–20, 2012, Lyon, France840We model coordination costs by means of a social network
over the set of people, G = (P, E), and assume a metric dis-
tance function d : E → R+ on the edges of the network. This
function may model preferences based on past interactions,
geographical proximity, compatibility in collaborating, dis-
tance in a company’s hierarchy, and so on. We extend the
deﬁnition of the distance function d(·, ·) to any pair of peo-
ple in the network, by considering the sum of the distances
along a shortest path connecting the two people.

There are many ways of deﬁning the coordination cost
of a team as a function of the pairwise distances among
the people in the social network. Before describing speciﬁc
coordination-cost measures, we ﬁrst consider two natural op-
tions with respect to deﬁning the “underlying network” of the
team.

Implicitly Connected Teams (ICT). In this model we do
not require each team Q to form a connected graph; we only
ask for communication paths between people in the team
through other members of the social network (not necessar-
ily present in Q). This model is realistic if the existence of
a short chain of acquaintances is enough to declare people
as “compatible.”

Explicitly Connected Teams (ECT). This follows the
approach of Lappas et al. [14] and requires that each team
Q forms a connected graph using the set of edges T =
{(pi, pj ) : pi, pj ∈ Q}. We also denote by d the distances
computed in subgraph (Q, T ).

The diﬀerence between the ICT and ECT cases is the
subgraph over which the coordination cost is computed. In
the ICT case, it is computed over the whole social network;
in the ECT case, over the subgraph induced by the team.
In both cases we use the following measures of coordination
cost, which are the ones considered by Lappas et al. [14]

1. Steiner tree: Steiner(Q) is the cost of the min cost
Steiner tree T that has as terminal nodes the team
members.

∈Q dj(i, i0)

2. Diameter: Diam(Q) = maxpi ,pi0
In general, we denote by c(Q) the coordination cost of
team Q, which we also write as c(T ) if the set of edges T
connecting team members is given. We have also studied
the sum-of-distances cost,1 however due to lack of space we
omit the results from this version.

3.3 Problem Statement

Assembling teams while accounting for two objective func-
tions, coordination cost and load, leads to a bi-criteria ob-
jective, which in general is hard to analyze, especially if
we seek for theoretical guarantees. A principled approach
that is usually adopted in the literature [19, 20] to address
bi-criteria optimization problems is to bound the cost on
one objective function and optimizing on the other. This
allows to turn the bi-criteria optimization problem into an
optimization problem for a single objective function. In our
case, we put a bound B on the coordination cost for each job
Jj and we optimize the maximum load of a person, with the
interpretation that B is a bound on the coordination cost
that we are willing to accept for the particular application.
In this spirit, we consider the following generic optimiza-
tion problem, which we call Balanced Social Task As-
signment. It consists in minimizing the maximum load of

1Sum(Q) = Ppi ,pi0

∈Q dj (i, i0)

Table 2: Notation for analysis

solution for modiﬁed

Optimal solution for the Social
Task Assignment problem
Optimal
problem instance with ratio λ
Optimal cost for modiﬁed prob-
lem instance with ratio λ
γ-approximate solution for modi-
ﬁed problem instance with ratio λ
γ-approximate cost for modiﬁed
problem instance with ratio λ

(Q∗, T ∗)

(Qopt, T opt) = (Qopt

λ , T opt
λ )

f opt(λ) = λa(Qopt) + c(T opt)

(Qapx, T apx) = (Qapx

λ , T apx
λ )

f apx(λ) = λa(Qapx) + c(T apx)

λ∗ = c(T ∗)/a(Q∗)

a person while assigning each job to a team that covers all
the skills of the job, with a bounded coordination cost:

min max
i∈P

L(pi)

cov(Jj, qj) = 1
c(Qj) ≤ B

∀j ∈ J

∀j ∈ J .

In the next section we propose algorithms with theoretical
guarantees for this problem under diﬀerent coordination cost
functions in the online setting.

Another option would be to attempt to bound the maxi-
mum load and minimize the coordination cost. Note though
that such an attempt is more unnatural in our online set-
ting. Since we do not know a priori the number of tasks it is
hard to set a bound on the total maximum load. Instead it
is more sensible to preset an acceptable level of coordination
and attempt to minimize the load as new tasks keep arriv-
ing. However, despite the choice to set up a ﬁxed bound B
on the coordination cost for analysis reasons, in Sections 5
and 6 we observe that by weighing diﬀerently the load and
the coordination costs we can tradeoﬀ between those two
objectives.

4. ALGORITHMS

In this section, we introduce and analyze the performance
of a general online algorithm for Balanced Social Task
Assignment that can be applied to a variety of coordina-
tion cost functions. For easy reference, we summarize our
notation in Table 2.
4.1 The General Online Algorithm

Our online algorithm works as follows: upon arrival of a
new task J, a team is formed for task J by solving a suitably-
deﬁned instance of the (oﬄine) Social Task Assignment
problem. The Social Task Assignment subproblem for
task J consists in selecting the team Q that minimizes a
speciﬁc cost allocation function a(Q) subject to a constraint
on the coordination cost c(Q). The problem for task J is as
follows:

min

Q

a(Q)

cov(J, q) = 1
c(Q) ≤ B.

The Social Task Assignment problem depends on the
speciﬁc coordination cost c(Q) and allocation cost a(Q) that
we adopt. As we mentioned in the previous section for the
coordination cost we consider two measures for Q: Steiner(Q)
and Diam(Q).

WWW 2012 – Session: Collaboration in Social NetworksApril 16–20, 2012, Lyon, France841Allocation cost function. The allocation function a(·)
used in the Social Task Assignment instance depends on
the individual loads on the persons, as they have resulted
from the previous allocation of the ﬁrst j − 1 tasks. Diﬀer-
ent choices of the allocation cost function aﬀect the perfor-
mance of the overall online algorithm. There exist several
natural allocation cost functions one can consider, such as
minimizing the team size, the maximum load, or the total
load; in our previous work [2] we analyze such functions ex-
plicitly, and we have shown that their performance, in terms
of balancing workload, is not as good as the ExpLoad allo-
cation cost function that we describe below. The ExpLoad
function is motivated by research in online scheduling, and
is proven to be eﬀective when the coordination cost is not
taken into account [2]. Here we extend the results by show-
ing that ExpLoad is an eﬀective allocation cost function also
when coordination cost is taken into account.

Let us denote by L(pi) the load of person i when task
J is presented, and let Λ be an appropriately chosen value
that depends on the cost of the optimal solution. Then, the
ExpLoad function is deﬁned as follows:

a(Q) = X
pi∈Q

(2n)

L(p

i)
Λ .

Details on how to adaptively estimate Λ during the execu-
tion of the algorithm can be found in our previous work [2].
Using ExpLoad guarantees eﬀective algorithms both in the-
ory and in practice.
4.2 Competitive Analysis

For evaluating the performance of online algorithms we
resort to the notion of competitive analysis [21]. Compet-
itive analysis compares an online algorithm against an of-
ﬂine adversary who knows the entire input sequence in ad-
vance and serves it optimally. An online algorithm is c-
competitive if for any input sequence it provides a solution
with cost bounded by c times the optimal cost. Observe
that even an online algorithm that optimally solves the So-
cial Task Assignment problem for each task may not pro-
vide an optimal solution for the overall problem, given the
lack of information about future tasks. The following re-
sult, proven similarly to [3], shows that using the ExpLoad
allocation cost function guarantees the optimal asymptotic
performance possible. The full proof will be included in an
extended version of this work.

Theorem 1. Consider the Balanced Social Task As-
signment problem and assume the corresponding Social
Task Assignment problem using the ExpLoad allocation
cost function can be solved optimally. Then this algorithm is
Θ(ln k)-competitive. In addition this is the best competitive
ratio possible.

However, the Social Task Assignment problem can not
be solved optimally eﬃciently unless P = NP, since it en-
tails the set-cover and the Steiner-tree problems.
Bi-criteria approximation guarantee. Every algorithm
A for Social Task Assignment returns for a task J a pair
(QA, T A), where T A is a subset of edges used to connect the
members of team QA and c(T A) is the coordination cost.
Let (Qopt, T opt) be the optimal solution to the problem of
minimizing a(Q) subject to coordination cost being bounded
by B. The performance of the algorithm on a single instance

of Social Task Assignment will be measured through a
bi-criteria approximation guarantee:

Definition 1. An (α, β) bi-criteria approximation algo-
rithm for the Social Task Assignment problem for a task
J will return in polynomial time a pair (Q, T ) such that: (i)
a(Q) ≤ α · a(Qopt) and (ii) c(T ) ≤ βB.

The values of the approximation factors α and β depend
on the speciﬁc coordination cost c(T ) that we consider. Next
we show how a bi-criteria algorithm for the Social Task
Assignment problem, together with the ExpLoad cost allo-
cation function, can yield an online algorithm for the Bal-
anced Social Task Assignment problem. The proof is
similar to the proof of Theorem 3 in [2] and will be included
in an extended version of this paper.

Theorem 2. Assume that there exists an (α, β) bi-criteria
approximation algorithm for the Social Task Assignment
problem with the ExpLoad allocation cost function and with
a coordination cost function c(T ). Then there exists a poly-
nomial time algorithm for the Balanced Social Task As-
signment problem that is Θ(α ln k)-competitive and for each
task J attains a coordination cost c(T ) ≤ βB.

Remarks. Theorem 2 shows that the competitive ratio of
the overall online algorithm depends on how closely we ap-
proximate the optimum of the Social Task Assignment
instances.
In the remainder of this section we provide al-
gorithms with provable performance for the Social Task
Assignment problem under the Steiner and Diam coor-
dination cost functions in the ICT model. Heuristics to solve
this problem (and, thus, the overall scheduling problem) in
the ECT model are described in Section 5.
4.3 The Steiner-Tree Coordination Cost

In this section we describe an approach that guarantees
a solution for the Balanced Social Task Assignment
problem with an optimal competitive ratio in the case of
Steiner cost and implicitly connected teams. Given Theo-
rem 2, we need to provide a solution to the following Social
Task Assignment problem:
Q X
min

a(pi)

pi∈Q

cov(J, q) = 1
c(Q) ≤ B,

L(p

i )

Λ , so that a(Q) = Ppi∈Q a(pi).

where we deﬁne a(pi) = (2n)
The constraint c(Q) ≤ B speciﬁes that the Steiner-tree cost
of the nodes in the selected team Q has to be at most B. This
constraint, along with the coverage constraint cov(J, q) = 1,
deﬁne a group Steiner tree problem [6, 10]. Note that the
connection to the group Steiner tree was also considered by
Lappas et al. [14] for the algorithms they developed.

In the group Steiner tree problem, we are given a network
G = (V, E), where |V | = n, with a distance function d : E →
R+, and a family G = {g1, . . . , g`} of groups of nodes, with
gi ⊂ V . The objective is to ﬁnd a minimum-cost subtree T
of G that contains at least one node from each group gi. This
problem has a γ = O(ln2 n ln ln n ln `) approximation [6].

In fact, our problem is more complicated as we need to
ﬁnd an algorithm A that returns a pair (QA, T A) that not

WWW 2012 – Session: Collaboration in Social NetworksApril 16–20, 2012, Lyon, France842Algorithm 1 The Steiner coordination-cost algorithm.

1. Function findGroup(J)
2. /* Find the best group for task J. For upperBound see

the text. */

3.
4.

5.
6.

λA←binarySearch(J, 0, upperBound)
/* Estimate the threshold; we ﬁnd the largest value
below the threshold with an accuracy of . */
(QA, T A) ←findGroupForGivenLambda(J, λA)
return (QA, T A)

1. Function binarySearch(J, λ1, λ2)
2. /* Return the highest value between λ1 and λ2 for which

c(Q) is below the threshold, with an accuracy gap
of . */

if (λ2 − λ1 <  · λ2)

/* The two endpoint are very close; value found */
return λ1

3.
4.
5.
6.
7.
8.
9.
10.
11.
12.
13.

end if
λ ← (λ1 + λ2)/2
(Qapx
λ , T apx
if (c(Qapx

λ )←findGroupForGivenLambda(J, λ)
λ ) < 2γB)

return binarySearch(J, λ, λ2)

else

return binarySearch(J, λ1, λ)

end if

1. Function findGroupForGivenLambda(J, λ)
2. /* Find the best group on the modiﬁed graph for the

given value of λ */

G0 ←createModifiedGraph(λ)
(Qλ, Tλ) ←solveGroupSteinerTree(G0 , J)
return (Qλ, Tλ)

3.
4.
5.

1. Function createModifiedGraph(λ)
2. /* Return the modiﬁed graph instance using the value of

λ. */

V 0 ← A copy of V
E0 = {ei = (i, i0); i ∈ V, i0 ∈ V 0, w(ei) = c(i) · λ}
i0 ∈ V 0 belongs to group j iﬀ user i possess skill j
G0 = (V ∪ V, E ∪ E0, w)
return G0

3.
4.
5.
6.
7.

only satisﬁes the group Steiner tree constraints, but that
also minimizes the cost allocation function a(Q) over the
nodes returned. Let (Q∗, T ∗) be the optimal solution to our
Social Task Assignment problem.

The description of the algorithm findGroup(J), which
solves the Social Task Assignment problem for task J,
is in Algorithm 1. Our high-level strategy to solve the So-
cial Task Assignment problem is the following: (i) First
we deﬁne a family of problem instances, which we call the
modiﬁed problem instances, parametrized by a value λ ∈ R+.
Each of the modiﬁed problem instances will be an instance
of the group Steiner tree problem. We can also show that
there is a value λ = λ∗ such that the solution to the modiﬁed
problem instance is an approximate solution to the original
Social Task Assignment problem. (ii) Next we show that
although it is hard to compute the value λ∗ exactly, we are
able to compute eﬃciently an approximate value that yields
an approximate solution to the original problem. We now
proceed with the details.

(i) Build modiﬁed problem instance. For a given value
of parameter λ we construct the following modiﬁed problem
instance (see Figure 1).
If the initial graph is G = (V =
P, E) we create a new graph G0 = (V ∪ V 0, E ∪ E0) with a
new ﬁctitious node i0 ∈ V 0 for each node i ∈ V , and with
a new edge ei = (i, i0) ∈ E0 of cost λa(i), for each node

i

d(i, j)

j

a(i) · l
i

d(i, j)

a( j) · l

j

(a) Original network

(b) Modiﬁed problem
instance

Figure 1: The original network on which we want to
solve the Social Task Assignment problem and the
modiﬁed problem instance on which we solve the
group Steiner tree problem. With bold we can see
an example solution (Q, T ). Notice that the cost of
the solution is the coordination cost c(T ) (of the orig-
inal network) and the cost of the new edges, which
is equal to the cost allocation a(Q).

i ∈ V . We then consider the group Steiner tree problem on
this modiﬁed instance, in which each skill required by the
arrived task corresponds to a group and a node i0 belongs to
the rth group if the corresponding expert i possesses the rth
skill. A solution to the group Steiner tree on the modiﬁed
problem instance is a pair (Q, T ) where Q is the set of nodes
selected that cover all the groups (skills) and T a subtree
that connects the nodes in Q. Note that the cost of the
solution (Q, T ) on the modiﬁed instance is given by

f (Q, T, λ) = λa(Q) + c(T ).

For a given algorithm A, let us deﬁne the cost of the solution
(QA, T A) that it outputs as

f A(λ) = λa(QA) + c(T A),

with the understanding that if A is a randomized algorithm
then f A(λ) is the expected cost of its solution. Let also
opt = optλ be the optimal algorithm for the given modiﬁed
problem instance so that f opt(λ) is the cost of its optimal
solution (Qopt, T opt). Similarly, for a γ-approximation al-
gorithm apx = apxλ, we have that f apx(λ) is the cost of
the solution (Qapx, T apx) produced by apx. When we want
to explicitly specify the value of λ for which the solution
is optimal or approximate we will write (Qopt
λ ) and
(Qapx

λ , T apx
Recall that (Q∗, T ∗) is the optimal solution to the Social

λ , T opt

λ ).

Task Assignment problem. Let us deﬁne

λ∗ =

c(T ∗)
a(Q∗)

.

It turns out that the value λ∗ is the value of λ for which
we would like to solve our problem, as the solution to the
modiﬁed problem for λ = λ∗ provides an approximation
solution to the STA problem, as one can see in the following
proposition, whose proof is straightforward and omitted for
the sake of space.

Proposition 3. The following are true.

1. c(T opt

λ∗ ) ≤ 2B.

2. a(Qopt

λ∗ ) ≤ 2a(Q∗).

WWW 2012 – Session: Collaboration in Social NetworksApril 16–20, 2012, Lyon, France843(ii) Estimating λ∗. Until now we have shown that if we
know the value λ∗ then we can deﬁne the appropriate mod-
iﬁed problem instance to solve, which in turn can give us an
approximate solution to the original Social Task Assign-
ment problem. The second claim that we need to show is
that we can ﬁnd the value λ∗ eﬃciently. Actually, since we
cannot solve the group Steiner tree on the modiﬁed problem
instances exactly, we cannot compute the value λ∗ exactly.
However, we can estimate it and we will show that our es-
timate will provide a bi-criteria approximate solution to the
original problem. To estimate the value λ∗ we exploit the
fact that the function f opt(λ) is a monotone function of λ,
as we show in the next key lemma (whose proof we defer
to an extended version of this paper). This will allow us
to estimate λ∗ using a binary search. Also it will allow us
to show that having only an estimate of λ∗ can provide a
bi-criteria approximation.

Lemma 4. The following hold:

1. The function f opt(λ) is nondecreasing in λ.
2. Assume that λ1 < λ2. Then we have that a(Qopt
λ1

a(Qopt
λ2

) and c(T opt
λ1

) ≤ c(T opt
λ2

).

) ≥

Recall that (Qopt

In essence, this lemma allows us to estimate λ∗ with the
required accuracy, using a binary search, each iteration of
which involves solving an instance of the modiﬁed problem
for some value λ. The exact description is in Algorithm 1.
Note that our technique is an example of the parametrized-
search approach for the solution of constrained optimization
problems, originally proposed by Megiddo [16] and used in
subsequent work (see for example [19] for its application to
bi-criteria spanning tree problems). Care needs to be taken
because we cannot solve each problem instance optimally
when performing the binary search, but only approximately.
λ ) is the optimal solution of the mod-
iﬁed problem instance for parameter λ (i.e., the value that
minimizes f (Q, T, λ)). To obtain an understanding of our
algorithm, it is easier to describe a version where we could
solve optimally the modiﬁed problem instance for any value
of λ. Then we estimate the value λ∗ by performing a binary
search. In every step of the binary search we pick the value
of λ that is the average of the two endpoints λ1 and λ2 and
we solve the modiﬁed problem instance. Throughout the
entire execution we maintain the invariant that c(T opt
) < B
λ1
and c(T opt
) ≥ B. We stop when λ1 and λ2 are close to each
λ2
other, and the second claim of Lemma 4 guarantees that
λ1 ≤ λ∗ ≤ λ2.

λ , T opt

Since we can only solve the modiﬁed problem with an
approximation of γ, we cannot compute the value λ∗. In-
stead we modify the search to ﬁnd a value that satisﬁes the
constraint allowing for room because of the approximation
ratio. For the sake of brevity, let A denote Algorithm find-
Group so that the solution it returns is (QA, T A), and let λA
the estimate of λ∗ computed by A. The above considera-
tions are at the basis of the following theorem, whose proof
is omitted for the sake of space. The result establishes that
our algorithm is an (O(γ), O(γ)) bi-criteria approximation
algorithm for the Social Task Assignment problem.

Theorem 5. For any task J, Algorithm findGroup(J)

returns a solution (QA, T A) such that:

1. c(T A) ≤ 2γB.
2. a(QA) ≤ 2γ

1− a(Q∗).

r ← arg mini∈S Pj∈P pj
/* r now is (one of ) the rarest skill */
QA ← ∅
foreach (` such that p`

Algorithm 2 The diameter algorithm.
1. Function findGroup(J)
2. /* Find the best group for task J */
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.
13.

U ← {pj ; d(p`, pj ) ≤ B}
Q ← greedyWeightedSetCover(U )
if (a(Q) < a(QA)

end foreach
return QA

QA ← Q

r = 1)

i

end if

Combining Theorems 1, 2, and 5 it follows that there ex-
ists a bi-criteria approximation algorithm for the Balanced
Social Task Assignment problem (recall that n is the
number of people, m the number of skills, and k the number
of tasks):

Theorem 6. There exists an O(ln2 n ln ln n ln m ln k)-

competitive algorithm for the Balanced Social Task As-
signment problem, which for each task attains a Steiner-tree
coordination cost bounded by O(B ln2 n ln ln n ln m).

Running time. It is easy to see that the complexity of the
algorithm 1 is polynomial. This follows because (i) every
invocation of findGroupForGivenLambda runs in polynomial
time [6] and (ii) the function binarySearch) is invoked a
polynomial number of times.

To see why (ii) holds, note that the parameter upperBound
in line 3 of the algorithm is set to the largest possible value of
the ratio c(T )/a(Q). Note that c(T ) ≤ Ppj ,p` ∈P d(pj, p`).
Moreover, a trivial lower bound to a(Q) is 1 (the load on
every person is 0 when the ﬁrst task is allocated and the
team size is 1). The claim then follows since binarySearch
is invoked a number of times that is at most logarithmic in
upperBound, for a constant .

Notice however that, although polynomial, the cost of the
algorithm can be high in practice, due to the super-linear
cost of the group Steiner tree algorithm [6]. For this reason,
in Section 5, we consider computationally less demanding
heuristics to implement findGroupForGivenLambda.
4.4 The Diameter Coordination Costs

For the diameter coordination cost (Diam) we follow a
diﬀerent, simpler approach, which we present in Algorithm 2.
Similar to the previous coordination cost functions, we try
to ﬁnd a team of users Q with diameter at most γB (it turns
out that for the diameter we can obtain γ = 2) that min-
imizes a(Q). However, in this case we do not build a new
problem instance to combine the load with the social cost
function. Instead we solve the problem directly.

Our results are summarized in the following theorem, whose

proof will be given in the full version of the paper.

Theorem 7. There exists an O(ln m ln k)-competitive al-
gorithm for the Balanced Social Task Assignment prob-
lem, which for each task attains a diameter coordination cost
bounded by 2B.

Running time. The running time of the algorithm is obvi-
ously polynomial: the main loop (lines 6–12 of Algorithm 2)

WWW 2012 – Session: Collaboration in Social NetworksApril 16–20, 2012, Lyon, France844is executed at most n times, while each execution requires
a run of the (polynomial) greedy heuristics for weighted set
cover.
4.5 The Sum-of-Distances Coordination Cost
For the sum-of-distances coordination cost (Sum) we can
apply a similar technique, and deﬁne an appropriate mod-
iﬁed problem instance. Due to lack of space we will in-
clude the details in an extended version of this work. We
only mention that to solve it we deﬁne an appropriate class
of modiﬁed problem instances that we solve by formulating
them as a convex program and rounding it performing ran-
domized rounding. This allows us to obtain results along
the lines of Theorems 6 and 7.

5.

IMPLEMENTATION AND HEURISTICS
In the previous section we developed algorithms that prov-
ably approximate the optimal solution in the online case and
also run in polynomial time. These algorithms are speciﬁ-
cally suited for the implicitly connected team (ICT) model.
For the explicitly connected team (ECT) model, we note
that the problem is as hard: for example, the explicitly con-
nected version for the Steiner coordination cost is as hard as
the node-weighted group Steiner tree problem that is strictly
harder than the edge-weighted group Steiner tree problem.
Moreover, it still relies on an approximation algorithm for
the group Steiner tree problem.

In this section we address several issues regarding the
practicality of our approach. In particular, to be able to for-
mulate an optimization problem that addresses the multi-
criteria objectives, we attempt to minimize the maximum
load, while keeping the coordination cost bounded by a con-
stant B (see Section 3.3). Second, to provide approxima-
tion guarantees we need to employ theoretical results for
the group Steiner tree problem. For the Diam coordination
cost this is not an issue, since the approach that we describe
in Section 4.4 is eﬃcient both in theory and in practice.

The theoretical algorithm used for the group Steiner tree
problem [6], while it provides asymptotic guarantees, is not
practical; it involves a probabilistic embedding of the graph
to a tree, solving a linear program and appropriate round-
ing. Therefore, in our experiments we apply some simpler
heuristics. One heuristic is the approach used by Lappas
et al. [14], which is based on the creation of (yet) another
graph instance, on which the Steiner tree problem is solved.
Brieﬂy, for each skill (group), we create a new node that
is connected to all the experts that possess it with a large
cost D. Then we compute the Steiner tree that connects the
required skills. For the latter task we employ the minimum
spanning-tree heuristic.

We also develop a second algorithm, which we call the
set-cover heuristic and we present in detail in Algorithm 3.
We will represent the allocation costs (appropriately scaled
by λ) on the nodes of the social network and social costs on
the edges of the social network. Since we want to produce
solutions that are close to the optimum, we assume that our
algorithm’s solution shares at least one expert with the team
of the optimal solution. This is obtained by trying as roots
all the experts that possess the rarest skill of the the task
(i.e., the skill owned by the least number of experts). Let
Q and T be the team and Steiner tree constructed so far
in the execution of the algorithm. In line 8, gain(pj) is set
to the number of required skills owned by expert pj that

Algorithm 3 The set-cover Steiner algorithm.
1. Function findGroupForGivenLambda-setCover(J, λ)
2. /* Find the best group for task J using the set-cover

heuristic. */

Q ← ∅
T ← ∅

3.
4.
5. while (∃i s.t. (Ji − qi)+ > 0)
6.
7.
8.

mostCostEﬀective ← 0
foreach (pj ∈ P \ Q)
i=1 1

9.
10.
11.
12.
13.
14.
15.
16.
17.

gain(pj ) ← Pm
j
{p
i =1 ∧ Ji=1 ∧ qi=0}
loss(pj ) ← cost in G for adding pj in Q
costEﬀectiveness ← gain(pj )/ loss(pj )
if (costEﬀectiveness > maxCostEﬀectiveness)

maxCostEﬀectiveness ← costEﬀectiveness
mostCostEﬀective ← j

end if

end foreach
T ← T ∪“shortest path from pmostCostEﬀective to T”
Q ← Q ∪ {pmostCostEﬀective} /* This is for the ICT
model. For the ECT model we add all the experts
of the path. See the text for more details. */

18.
19.

end while
return (Q, T )

are not covered yet by Q.
(The notation 1A denotes the
indicator function for A.) To see why this is the case, note
that expert pj contributes to the ith skill if and only if he
possesses the skill (pj
i = 1), the skill is required (Ji = 1),
but not yet covered (qi = 0). In line 9 we set loss(pj) to
the cost of adding expert pj to team Q as we discuss in the
next paragraph. Then, at each step of the algorithm we add
to Q the most cost-eﬀective expert, where cost-eﬀectiveness
is deﬁned by the ratio gain(pj )
loss(pj ) . The algorithm terminates
when all skills of the task are covered.

).

∈Q `s(pj , pj 0

We deﬁne loss(pj) = minpj0

The algorithms for the diﬀerent notions of coordination
cost and for the models ICT and ECT diﬀer only in the
deﬁnition of the costs loss(pj ). Denote by `s(pj, pj 0
) the
length of the min cost path ps(pj , pj 0
) in social network
N that connects pj to pj 0
plus the (appropriately scaled)
allocation costs of all the people on the path, excluding pj 0
.
In the ICT
model once we ﬁnd the most cost-eﬀective people pj , we add
path ps(pj , pj 0
) to T and expert pj is included in team Q. In
the ECT model, once we ﬁnd the most cost-eﬀective expert
pj , we add path ps(pj, pj 0
) to T and team Q is extended to
include all experts on the path, to ensure the team result-
ing team is a connected subgraph. Therefore, in this case,
`s(pj , pj 0
) takes into account the cost of including these ex-
perts as well. We note that in the ECT model, experts on
path ps(pj , pj 0
) may contribute not only by connecting oth-
ers but often provide additional skills for the task, that are
considered covered by those experts given that they will be
part of the generated team.

Now we address the ﬁrst issue that we raised in the be-
ginning of the section, which is that in our modeling we
choose to optimize the cost allocation subject to an upper
bound B in the coordination cost for the reasons explained
in Section 3.3. While for the theoretical analysis we wrote a
principled version of the problem, in many practical appli-
cations, the upper bound B on the coordination cost is nei-
ther explicitly given nor clearly deﬁned. Another approach
to bi-criteria optimization problems is to compute the set of

WWW 2012 – Session: Collaboration in Social NetworksApril 16–20, 2012, Lyon, France845Table 3: Summary statistics of datasets.
Dataset
Bibsonomy
n (people)
816
m (skills)
793
2 000
k (tasks)
7.64
Average skills per expert
4.44
Average skills per task
Average degree soc. net.
5.53
1.60
Power-law parameter α
0.70
Average edge distance
St. dev. of edge distance
0.28

IMDB
725
21
1 000
2.96
11.10
17.10
0.99
0.66
0.11

Pareto optimal solutions [18], which are those solutions that
are not outperformed by other solutions on both allocation
and coordination costs. The set of all Pareto-optimal solu-
tions usually form a convex curve that deﬁnes a clear trade-
oﬀ between allocation and social cost. It is of course highly
desirable that the Pareto curve is not far from the point in
the space with coordinates equal to the minimum coordina-
tion cost and the minimum allocation cost of any solution.
The two approaches are tightly related and algorithms for
one problem can be used for solving the other problem. If
the underlying optimization problems are NP-hard we can
only hope to ﬁnd in polynomial time Pareto-nearly-optimal
solutions, which are solutions that are provably not outper-
formed from other solutions in all objectives for more than
a limited amount [18].

The idea of the algorithms developed in Section 4 is that
the right trade-oﬀ between allocation and coordination cost
is given by the ratio λ∗ between coordination and alloca-
tion costs in the optimal solution. The problem is therefore
reduced to solving the Social Task Assignment prob-
lem with allocation cost scaled by λ∗. An algorithm A
will return a solution (QA, T A) that minimizes f A(λ) =
λa(QA) + c(T A). Given that we do not assume in practice
a bound on the coordination cost, we do not compute the
proﬁle of the Pareto solutions. Rather, we proceed with the
optimization of f A(λ) for diﬀerent scaling factors λ. This
will allow us to identify the best trade-oﬀ between social
and allocation cost. Nevertheless, note that to solve (ap-
proximately) the optimization problem as formulated in Sec-
tion 3.3 it suﬃces to observe only the values of λ that are
requested by the algorithms in Section 4.

6. EXPERIMENTS

Finding datasets that reﬂect the application scenarios of
team formation is challenging, as such systems are not yet
in wide-spread use, and most data from them is not pub-
licly available. For this reason, we follow the approach of
previous work [2,13,14], and we use bibliography and movie
datasets that can demonstrate the eﬀectiveness of our ap-
proach. Summary statistics from these datasets are included
in Table 3. We expect that emerging crowdsourcing and la-
bor marketplaces will provide in the future more realistic
datasets for this line of research.
6.1 Datasets

IMDB. Our ﬁrst dataset is extracted from the Internet Movie
Database. We focus on two types of movie personnel, di-
rectors and actors. For skills we use the movie genres. We
assume that the set of genres of the movies that a person has

participated make the set of skills for that person. For exam-
ple, Alfred Hitchcock has the skills {comedy, crime, ﬁlm-noir,
mystery, romance, thriller}. We run our algorithms so that
directors represent experts and actors represent tasks, where
a random subset of 1000 actors was sampled. Our setting
simulates an imaginary scenario in which people who have
directed a movie create small committees to audition actors.
We do not consider actors who have only one skill, because
those can be assigned to a single director, which is not an
interesting case.

Next, we deﬁne a social graph among the directors. Since,
typically movies are directed by only one director, we “con-
nect” directors using actors as intermediaries: we form an
edge between two directors if they have directed at least
two distinct actors in common. The cost of the edge is set
to e−rD, where D is the number of distinct actors directed
by the two directors. The distance function e−rD takes val-
ues between 0 and 1, and it approaches very fast the value 0
as the number of commonly directed actors D between two
directors increases. We select the value of parameter r = 1
10 ,
for which we experimentally verify that it yields an intuitive
range of values for the distance values on the edge weights.

Bibsonomy. Our second dataset is extracted from bibson-
omy [1], a social-bookmarking and publication-sharing sys-
tem. The dataset contains a large number of computer-
science related publications. Each publication is written by
a set of authors. The bibsonomy website is visited by a large
community of users who use tags to annotate the publica-
tions, for example, theory, software, or ontology. We use the
set of tags associated with the papers of an author to repre-
sent the set of skills for that author. We partition the set of
authors into two sets: one set representing the experts and
another set representing the tasks. This setting simulates a
scenario where committees of scientists interview other sci-
entists, say, for a job position. We consider the experts to
be the most proliﬁc authors in the dataset, and this explains
why in Table 3 the number of skills per expert is higher than
the number of skills per task. For the set of authors who rep-
resent the tasks, we sample 2000 authors, and as before, we
do not consider authors who have only one skill.

For creating a social graph among the experts we use co-
authorship: two authors are connected with an edge if they
have written at least one paper together. The cost of an edge
is set to e−rD, where D is the number of common papers
coauthored by the two authors, and we set again r = 1
10 .

6.2 Results

We implement the algorithms discussed in Section 5 in the
cases where the coordination cost is the Steiner-tree cost and
the diameter. Tasks arrive sequentially and at each point
the state of the system is described by the allocation cost
a(p) for each person p ∈ P, which is set according to the
ExpLoad strategy based on the number of teams in which p
has participated so far. The allocation costs reﬂect the load
of people due to the previous tasks. Given a new task J our
heuristic returns a sub-graph having nodes Q and edges T
with the goal of minimizing f (λ) = λa(Q) + c(T ).

Following the discussion of Section 5, we study the behav-
ior of our algorithm as we vary the parameter λ. We start
with a very small value of λ, which down-weights the load-
balancing factor and emphasizes the coordination cost, and
we increase λ exponentially, so that load balancing becomes
more important. The results are shown in Figure 2 for the

WWW 2012 – Session: Collaboration in Social NetworksApril 16–20, 2012, Lyon, France846IMDB − explicitly connected

IMDB − implicitly connected

Bibsonomy − explicitly connected

Bibsonomy − implicitly connected

0.0001

0.0001

 

SC
LLT

0.0001

0.0001

 

SC
LLT

6.4

6.4

0.35

0.3

0.25

0.2

0.15

0.1

0.05

d
a
o

l
 
x
a
m

d
a
o

l
 
x
a
m

0.6

0.4

0.2

0

 

6.4

6.4

0.5

1

1.5

2

2.5

3

0.5

1

1.5

2

2.5

coordination cost (Steiner)
(a) Steiner cost vs. load on IMDB dataset

coordination cost (Steiner)

0.0001

0.0001

 

0.2

0.0001

6.4

SC
LLT

6.4

2.8

0.15

0.1

d
a
o

l
 
x
a
m

0.05

 

 

1.8

2

2.6
coordination cost (Steiner)

2.2

2.4

0.0001

6.4

2

2.5

coordination cost (Steiner)

(b) Steiner cost vs. load on Bibsonomy dataset

 

SC
LLT

6.4

3

d
a
o

l
 
x
a
m

0.6

0.4

0.2

0

 

i

e
z
s
 
m
a
e

t

5.5

5

4.5

4

3.5

3

 

IMDB − explicitly connected

IMDB − implicitly connected

Bibsonomy − explicitly connected

Bibsonomy − implicitly connected

 

6.4

SC
LLT

i

e
z
s
 
m
a
e

t

3

5.5

5

4.5

4

3.5

3

 

0.0001

0.0001

6.4

0.5

1

2.5
coordination cost (Steiner)

1.5

2

0.0001

0.0001

6.4

0.5

1

2.5
coordination cost (Steiner)

1.5

2

 

6.4

SC
LLT

i

e
z
s
 
m
a
e

t

3.7

3.6

3.5

3.4

3.3

3.2

3.1

3

 

1.8

0.0001

 

SC
LLT

0.0001

6.4

2

2.6
coordination cost (Steiner)

2.2

2.4

6.4

2.8

i

e
z
s
 
m
a
e

t

3.6

3.5

3.4

3.3

3.2

3.1

3

 

0.0001

0.0001

6.4

2

2.5

coordination cost (Steiner)

 

SC
LLT

6.4

3

(c) Steiner cost vs. average team size on IMDB dataset

(d) Steiner cost vs. average team size on Bibsonomy dataset

Figure 2: Trade-oﬀs between Steiner coordination cost vs. max load and average team size. For computing
the group Steiner tree on a task instance, two algorithms are used, the set-cover heuristic proposed in this
paper (SC) and the heuristic proposed by Lappas et al. (LLT). The label next to the ﬁrst and last data points
shows the value of λ. For the in-between points shown in the curve the value of λ increases exponentially.

IMDB − explicitly connected

IMDB − implicitly connected

Bibsonomy − explicitly connected

Bibsonomy − implicitly connected

d
a
o

l
 
x
a
m

0.45

0.4

0.35

0.3

0.25

0.2

0.15

1.1

0.0001

0.0001

d
a
o

l
 
x
a
m

0.1

0.08

0.06

0.04

6.4

1.6

1.2

1.2
coordination cost (diameter)

1.3

1.4

1.5

1.3

1.4

1.5

1.6

coordination cost (diameter)

d
a
o

l
 
x
a
m

0.36

0.34

0.32

0.3

0.28

0.26

0.24

6.4

1.7

0.0001

0.024

0.0001

d
a
o

l
 
x
a
m

0.022

0.02

0.018

0.016

2.7

6.4

6.4

2.75

2.85
coordination cost (diameter)

2.8

2.75

2.8

2.85

coordination cost (diameter)

2.9

(a) Diameter vs. max load on IMDB dataset

(b) Diameter vs. max load on Bibsonomy dataset

Figure 3: Trade-oﬀ between diameter and max load. The label next to the ﬁrst and last data points shows
the value of λ. For the in-between points shown in the curve the value of λ increases exponentially.

Steiner cost, and in Figure 3 for the diameter cost. The plots
show the trade-oﬀs among coordination cost, team size, and
maximum load obtained in diﬀerent runs of the algorithm
parametrized by λ. In these plots one can see clearly that
our heuristic exploits nicely the trade-oﬀ between load and
coordination cost, making it possible to choose this param-
eter according to application-dependent objectives.

The results also indicate that ignoring the coordination
costs (λ → ∞) as in [2] yields solutions that have high coor-
dination costs. Conversely, ignoring the workload (λ → 0) as
in [14] yields solutions that generate imbalanced schedules.
Improvements from these extremes in one of the components
of the cost (coordination cost or load balance) can be ob-
tained by paying a moderate price in the other component.

Steiner cost. For the Steiner coordination cost, in addition
to the set-cover heuristic discussed in Section 5, we also im-
plement and compare with the group Steiner heuristic pro-
posed by Lappas, Liu and Terzi [14], which we consequently
refer to as the LLT heuristic. Figures 2(a) and 2(b) show

the trade-oﬀ between Steiner cost and max load, as obtained
by our online algorithm with call to the two diﬀerent Steiner
heuristics. Similarly, Figures 2(c) and 2(d) show the trade-
oﬀ between Steiner cost and average team size. We see that
in almost all cases the set-cover heuristic is better that the
LLT heuristic. For the IMDB dataset, the set-cover heuristic
produces solutions that dominate the LLT heuristic in terms
of coordination cost and load. Also the LLT heuristic gives
teams of signiﬁcantly larger size.

For the Bibsonomy dataset the diﬀerence between the two
heuristics is not so clear. First we see that in the case of
implicitly-connected teams, the LLT heuristic outperforms
slightly the set-cover heuristic in the coordination-cost vs.
max-load space. On the other hand, in the case of explicitly-
connected teams, the LLT heuristic performs signiﬁcantly
worse than the set-cover heuristic.
In terms for average
team size, for the smaller values of λ the two heuristics pro-
duce solutions that do not dominate each other, while the
LLT heuristic produces very similar solutions to each other.

WWW 2012 – Session: Collaboration in Social NetworksApril 16–20, 2012, Lyon, France847However, for the larger vales of λ, for the same coordination
cost the set-cover heuristic gives smaller teams than the LLT
heuristic.

Overall, the set-cover heuristic explores better the coordination-

cost vs. max-load trade-oﬀ as a function of λ, it gives smaller
teams, and produces solutions that in most cases dominate
the solutions produced by the LLT heuristic.

Diameter. Our results for the diameter coordination cost
on our two datasets (Figure 3) show the trade-oﬀ of diame-
ter vs. maximum load for the IMDB dataset. We see that the
dependency of the solution variables to the parameter λ is
similar as in the case of Steiner cost, however the range of
values is smaller than the corresponding values in the Steiner
case, and the curves are less smooth, especially on the Bib-
sonomy dataset. One characteristic of the solutions we ob-
tain for the diameter is that the average team size remains
constant for all values of λ. For the IMDB dataset it is about
4.5 for the explicitly-connected teams, and about 3.3 for the
implicitly-connected teams. For the Bibsonomy dataset it is
about 7.5 for the explicitly-connected teams, and about 2.5
for the implicitly-connected teams. Note also the strange ar-
tifact that in some few cases (e.g., in Figure 3(b)) we obtain
solutions that have both higher cost and load by increasing
the λ. This is due to the limitation that we can obtain only
an approximate solution to the Social Task Assignment
problem, and while rare, it demonstrates how the hardness
of the problem can lead to suboptimal solutions.

Alternative load measure. Measuring the load of the
single most-loaded person is a measure that may be sensitive
to outliers. For this reason we computed an alternative,
most robust, measure, which is the average load of the 10%
most-loaded people. We report here that the behavior of
this measure is identical to the max-load measure, however,
we omit the plots for lack of space.

Running time. Overall, our method is also eﬃcient in
practice: we observe running times of 4-5 seconds per task
for the Steiner cost, and 9-10 seconds per task for the di-
ameter. These times are recorded on a 4GB RAM, 2.5 GHz
laptop.

7. CONCLUSIONS AND FUTURE WORK

We consider the problem creating teams of experts and as-
signing tasks to these teams, taking into account the require-
ments of every task, the work load of the experts, and their
potential to collaborate or coordinate with each other. We
develop approximation algorithms with provable theoretical
guarantees, and our experiments demonstrate the ability of
our solutions to keep low coordination costs and to balance
the workload simultaneously also in practice.

The potential applications of the framework are numerous,
resulting to a large number of diﬀerent future directions. In
this work we have assumed that we know the social network
as well as the skill proﬁles of people. In practice, this in-
formation needs to be learned, for example, from observed
data. It is also worth exploring how well teams can be cre-
ated across diﬀerent social networks exhibiting varying de-
grees of homophily. For instance, if the only connections
are among experts with similar skills, covering a large set of
skills with a tightly connected group may be diﬃcult.

We have used two diﬀerent measures of coordination cost;
further results, not included here, indicate that similar ideas
can be applied to the case where coordination cost is mea-

sured as the diameter of a team. We have also assumed
that we want teams of people that are close to each other.
The converse can be true in other settings, for instance if
we want to create a panel or jury of experts from which we
want independent opinions—here we probably want them to
be far apart in the social network.

Finally, in this paper we have presented a static social net-
work, while in practice people arrive and leave continually
while the strength of their connections changes over time. In
addition, we have assumed that the strength of the connec-
tions are independent of the individual task. Note that our
algorithms and our results hold for all these settings as well.
In future work we would like to evaluate the performance of
our algorithms in such dynamic settings.

Key references: [2, 14]

8. REFERENCES
[1] Knowledge and Data Engineering Group, University of
Kassel, Benchmark Folksonomy Data from BibSonomy.
2007.

[2] A. Anagnostopoulos, L. Becchetti, C. Castillo, A. Gionis,

and S. Leonardi. Power in unity: Forming teams in
large-scale community systems. In CIKM, 2010.

[3] J. Aspnes, Y. Azar, A. Fiat, S. Plotkin, and O. Waarts.

On-line routing of virtual circuits with applications to load
balancing and machine scheduling. J. ACM, 44(3):486–504,
1997.

[4] Y. Azar. On-line load balancing. In Theoret. Comp. Sci.,

1992.

[5] Y. Azar, J. Naor, and R. Rom. The competitiveness of

on-line assignments. In SODA, 1992.

[6] C. Chekuri, G. Even, and G. Kortsarz. A greedy

approximation algorithm for the group steiner problem.
Discrete Applied Mathematics, 154(1):15–34, 2006.
[7] R. H. Coase. The Nature of the Firm. Economica,

4(16):386–405, November 1937.

[8] C. Dorn and S. Dustdar. Composing near-optimal expert

teams: a trade-oﬀ between skills and connectivity. In
CoopIS, 2010.

[9] A. Gajewar and A. D. Sarma. Multi-skill Collaborative

Teams based on Densest Subgraphs. In SDM, 2012.

[10] N. Garg, G. Konjevod, and R. Ravi. A polylogarithmic

approximation algorithm for the group steiner tree
problem. In SODA, 1998.

[11] M. E. Gaston and M. des Jardins. Agent-organized

networks for dynamic team formation. In AAMAS, 2005.
[12] R. L. Graham. Bounds on multiprocessing anomalies and

related packing algorithms. In AFIPS, 1972.

[13] M. Kargar and A. An. Discovering top-k teams of experts
with/without a leader in social networks. In CIKM, 2011.

[14] T. Lappas, K. Liu, and E. Terzi. Finding a team of experts

in social networks. In KDD, 2009.

[15] C.-T. Li and M.-K. Shan. Team Formation for Generalized

Tasks in Expertise Social Networks. In SocialCom, 2010.
[16] N. Megiddo. Applying parallel computation algorithms in

the design of serial algorithms. JACM, 30, 1983.

[17] K. Mehlhorn. Assigning papers to referees. In ICALP, 2009.
[18] C. H. Papadimitriou and M. Yannakakis. On the

approximability of trade-oﬀs and optimal access of web
sources. In FOCS, 2000.

[19] R. Ravi and M. X. Goemans. The constrained minimum

spanning tree problem (extended abstract). In SWAT, 1996.
[20] R. Ravi, M. V. Marathe, S. S. Ravi, D. J. Rosenkrantz, and
H. B. Hunt, III. Many birds with one stone: multi-objective
approximation algorithms. In STOC, 1993.

[21] D. D. Sleator and R. E. Tarjan. Amortized eﬃciency of list

update and paging rules. CACM, 28(2), 1985.

[22] V. V. Vazirani. Approximation algorithms. 2001.

WWW 2012 – Session: Collaboration in Social NetworksApril 16–20, 2012, Lyon, France848