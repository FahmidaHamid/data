Composite Events for XML

Martin Bernauer
Institute for Software

Technology and Interactive
Systems, Vienna University

of Technology, Austria

Gerti Kappel

Institute for Software

Technology and Interactive
Systems, Vienna University

of Technology, Austria

Gerhard Kramler
Institute for Software

Technology and Interactive
Systems, Vienna University

of Technology, Austria

bernauer@big.tuwien.ac.at

gerti@big.tuwien.ac.at

kramler@big.tuwien.ac.at

ABSTRACT
Recently, active behavior has received attention in the XML ﬁeld
to automatically react to occurred events. Aside from proprietary
approaches for enriching XML with active behavior, the W3C stan-
dardized the Document Object Model (DOM) Event Module for the
detection of events in XML documents. When using any of these
approaches, however, it is often impossible to decide which event
to react upon because not a single event but a combination of mul-
tiple events, i.e., a composite event determines a situation to react
upon. The paper presents the ﬁrst approach for detecting composite
events in XML documents by addressing the peculiarities of XML
events which are caused by their hierarchical order in addition to
their temporal order. It also provides for the detection of satisﬁed
multiplicity constraints deﬁned by XML schemas. Thereby the ap-
proach enables applications operating on XML documents to react
to composite events which have richer semantics.

Categories and Subject Descriptors
E.1 [Data]: Data Structures; H.2.3 [Database Management]:
Languages; H.2.4 [Database Management]: Systems—Rule-
based databases

General Terms
Languages

Keywords
XML, Composite Event, Event Algebra, Active Behavior, Event-
Condition-Action Rule

1.

INTRODUCTION

Recently, active behavior has received attention in the XML ﬁeld
after being widely used in other ﬁelds such as database systems [15]
and workﬂow management [14]. Various proprietary approaches
for active XML [2, 3, 4, 5, 6, 16] show how event-condition-action
(ECA) rules can be used to automatically react to an occurred event
by executing an action if a condition applies. Events that can be
reacted on are modiﬁcations of XML data, such as the insertion
of an element with a certain name, and invocations of operations
against XML data in [16].

In parallel to these efforts, the W3C standardized the Document
Object Model (DOM) Event Module [20]. It provides for detection
of events in DOM documents so that application programs can re-
act accordingly. Deﬁned events comprise among others mutation
Copyright is held by the author/owner(s).
WWW2004, May 17–22, 2004, New York, New York, USA.
ACM 1-58113-844-X/04/0005.

events, which are events that represent modiﬁcations of XML data.
The Event Module may thus be used to provide the proprietary ap-
proaches mentioned before and custom applications with mutation
events.

When using any of the approaches [2, 3, 4, 5, 6, 20] it is some-
times impossible to decide upon which event to react. The reason
is that often not a single event but a combination of multiple events
determines a situation where some action has to be executed. A
potential work-around in such a situation is to use the event that
always occurs at last of multiple events or to use another event that
usually occurs after multiple events. Using such a work-around,
however, makes rules dependent on applications which deﬁne the
order of event occurrences.

Obviously, a technique is needed to detect occurrences of combi-
nations of multiple events, i.e., to detect so called composite events.
This has long been studied in the active database literature where
event algebras have been proposed for the description of composite
events (e.g., cf. [8, 11, 13, 22, 23]) and several techniques for re-
alizing detection of composite events have been proposed, namely
event graphs [7], state automata [13], and petri nets [12].

Events in XML, however, differ from the concept of events in

literature as follows:

(1) XML events are not only ordered by time but also by hierar-
chical structure. It is mostly undesired to use hierarchically
unrelated events to form composite events as previous ap-
proaches do.

(2) An XML schema may constrain the number of element and
attribute occurrences in documents. Existing approaches do
not support the detection of when such constraints are satis-
ﬁed.

(3) Event types, which are descriptions of events at the schema
level, are hierarchically related as their events are. This al-
lows for more expressive and more reusable event type deﬁ-
nitions than in previous approaches.

Due to the above peculiarities of XML events, existing ap-
proaches for detecting composite events, such as [8, 11, 13, 22,
23], cannot be reasonably employed for XML events because one
encounters the following problems: (i) depending on the order of
multiple modiﬁcations that all result in the same XML data differ-
ent composite events are detected, (ii) most of the detected compos-
ite events are meaningless since they are not hierarchically related,
they have to be ﬁltered out by application code, (iii) it cannot be
detected when multiplicity constraints deﬁned by an XML schema
are satisﬁed, and (iv) event types are unrelated and their extents are
disjunct, limiting expressiveness and reusability of composite event

175type deﬁnitions. For a motivating example that shows problems i
and ii when using a reﬁned existing approach see Section 2.3.

The contribution of the paper is to present an approach to detect
composite events in XML that takes the above peculiarities of XML
events into account. It reﬁnes an event algebra known from litera-
ture by deﬁning the employed abstract model for XML data, XML
events, and XML event types. Thereby it provides for more expres-
sive and reusable event type deﬁnitions (addressing peculiarity 3).
Moreover, it extends the semantics of the reﬁned event algebra by
introducing the hierarchical context to combine events according
to hierarchy (addressing peculiarity 1), by introducing the multi-
plicity operator to detect when multiplicity constraints are satisﬁed
(addressing peculiarity 2), and by introducing operator modiﬁers to
provide for more expressive event type deﬁnitions.

In particular, the presented approach reﬁnes and extends the
event algebra Snoop [7, 8], because it is both extensible and well
suited for XML. Snoop is extensible because it uses contexts to
deﬁne the semantics of an event expression, thus by deﬁning a
new context semantics can be extended. Snoop is well suited for
XML because event trees are used to realize event expressions and
demonstrate event detection. Event trees ﬁt well for processing
XML events because they are hierarchically ordered as well. More-
over, Snoop is used in the Sentinel active DBMS, is prominent
among [11, 13, 22, 23] according to CiteSeer1, and is still subject
to active research [1].

The paper is structured as follows. The reﬁnement of the event
algebra and a motivating example is shown in Section 2, the alge-
bra’s extension in Section 3. Section 4 brieﬂy discusses the im-
plementation of a proof-of-concept prototype, and ﬁnally Section 5
concludes the paper.

2. REFINED EVENT ALGEBRA

This section shows how the event algebra Snoop is reﬁned so
that it can be used with XML events. First it presents the employed
abstract model for XML data, a syntax for referrers to portions of
XML data at the schema and instance level, and operators on refer-
rers in Section 2.1. Second, an abstract model for events and event
types is introduced in Section 2.2. Finally, Section 2.3 brieﬂy in-
troduces Snoop and shows an example that uses the reﬁned event
algebra with contexts from Snoop.
2.1 Path Types and Path Instances

An XML document is represented by a tree of nodes where an
XML document’s elements, attributes and text is represented by the
tree using element, attribute, and text nodes respectively. As such
it is a subset of the XML Infoset [18]. Each node has an identiﬁer.
A path type identiﬁes a node of a tree by using type information,
i.e., independently of concrete documents. A path type accords to
a restricted XPath expression [17] that refers to either element, at-
tribute, or text nodes in each of its steps via respective axis and node
tests. A path type is absolute or relative with respect to the root
of the tree, e.g., =order=item=price denotes an absolute path type
while item=price denotes a relative path type to element price. Path
type pt is a tuple comprising a kind 2 fabsolute; relativeg and an
ordered set of steps, thus pt = hkind; stepsi or pt = null. Two
single steps are equal if they equal in their respective axis (child or
attribute) and node test (test for an XML-QName or text()).

A path instance identiﬁes a node of a tree representing a concrete
document. For node price1 its path instance comprises an ordered
set of identiﬁers that starts with the identiﬁer of the tree’s root node
and ends with price1’s identiﬁer and is thus always absolute. A path

1http://citeseer.nj.nec.com

instance is denoted similar to a path type by using “/” to separate
nodes, e.g., =order1=item1=price1 denotes a path instance to node
price1. Path instance pi is a tuple comprising its absolute path type
and an ordered set of node identiﬁers, thus pi = hpt; idsi or pi =
null.

To compare and operate on path types, operators for testing
for equality (=), containment ((cid:26)), ending ((cid:26)e), and intersection
(\lb, \ab) are deﬁned. The operators complement the ones de-
ﬁned by XPath which operate on path instances only, such as =
[17] and intersection [21]. The result of applying operators on
path types are deﬁned as follows (where m = jpt1:stepsj and
n = jpt2:stepsj):

(cid:15) pt1 = pt2

Path type pt1 equals pt2 iff pt1:kind = pt2:kind ^ m =
n ^ 81 (cid:20) i (cid:20) m : pt1:steps[i] = pt2:steps[i].
Example 1.

item=price = item=price,
=order = =order,
order 6= =order.

(cid:15) pt1 (cid:26) pt2

Path type pt2 uniquely contains path type pt1 iff 81 (cid:20) i (cid:20)
m : pt1:steps[i] = pt2:steps[c + i] where c is a constant
offset and m + c (cid:20) n. No c0 6= c may exist for which the
expression above applies as well. Additionally, if pt1 and
pt2 are both absolute c = 0 ^ m < n must apply, if both are
relative only m < n must apply. A relative path type cannot
contain an absolute one.
Example 2.

item=price (cid:26) =order=item=price,
order=item (cid:26) =order=item=price,
=order 6(cid:26) order=item.

(cid:15) pt1 (cid:26)e pt2

Relative path type pt1 ends path type pt2 if the end of
pt2:steps contains pt1:steps and pt2 is more special than
pt1, i.e., pt1 (cid:26)e pt2 iff pt1:kind = relative ^ (m <
n _ (pt2:kind = absolute ^ m = n)) ^ 81 (cid:20) i (cid:20) m :
pt1:steps[i] = pt2:steps[n (cid:0) m + i].
Example 3.

item=price (cid:26)e =order=item=price,
price (cid:26)e item=price,
order=item 6(cid:26)e =order=item=price.

(cid:15) r := pt1 \lb pt2

The left-bound intersection operator is commutative and de-
termines for path types pt1 and pt2 equal steps at the begin-
ning of pt1:steps and pt2:steps. If pt1:kind = pt2:kind,
r:kind := pt1:kind, otherwise it is absolute. Result-
ing r:steps := fpt1:steps[i]jpt1:steps[i] = pt2:steps[i]g
where 1 (cid:20) i (cid:20) j where j is either the largest index for
which pt1:steps[j] = pt2:steps[j] applies or the minimum
out of m and n. The result is null if pt1 = null _ pt2 =
null _ pt1:steps[1] 6= pt2:steps[1].
Example 4. order=item \lb =order=billTo = =order,

item=@partnum \lb item = item,
order \lb item = null.

(cid:15) r := pt1 \ab pt2

The absolute-path intersection is not commutative and makes
path type pt1 absolute according to absolute path type pt2. If
pt1 (cid:26) pt2 _ pt1 = pt2, r is deﬁned by r:kind := absolute
and r:steps := fpt2:steps[i]j1 (cid:20) i (cid:20) jg where j is the last
index where pt2 contains pt1. The result is null if pt1 =
null _ pt2 = null _ (pt1 6(cid:26) pt2 ^ pt1 6= pt2).

176Example 5.

item \ab =order=item=price = =order=item,
item \ab =order = null.

To compare and operate on path instances, operators for testing
for equality (=) and projection ((cid:25)) are deﬁned. The result of ap-
plying operators on path instances are deﬁned as follows:

(cid:15) pi1 = pi2

Two path instances pi1 and pi2 equal iff pi1:pt = pi2:pt ^
81 (cid:20) i (cid:20) jpi1:idsj : pi1:ids[i] = pi2:ids[i].
Example 6. =order1=item1 = =order1=item1.

(cid:15) r := (cid:25)pt(pi)

A projection of path instance pi on path type pt is a path in-
stance if pt (cid:26) pi:pt _ pt = pi:pt. Then r:pt := pt and
r:ids := fpi:ids[i]jj (cid:20) i (cid:20) kg where j and k are the in-
dexes between which pi:pt:steps contains pt:steps. The re-
sult is null if pi = null _ pt = null _ (pt 6(cid:26) pi:pt ^ pt 6=
pi:pt).
Example 7. (cid:25)item(=order1=item1=price1) = item1,

(cid:25)=order(=order1=item1) = =order1,
(cid:25)item(=order1) = null.

2.2 Event Types and Events

The DOM Event Module deﬁnes among others event types for
mutation events, which reﬂect modiﬁcations of DOM documents’
data. They basically comprise one event type for the insertion of
nodes, one for the deletion of nodes, one for manipulation of at-
tributes, and one for manipulations of text nodes.

While the DOM event types are sufﬁcient for a procedural han-
dling of occurred events, they are too coarse grained for a declar-
ative handling by an event algebra. Hence, for every path type pt
the presented approach distinguishes three primitive event types,
denoted as ins(pt), upd(pt), and del(pt). Like in the DOM Event
Module, ins and del events reﬂect insertions and deletions of el-
ement, attribute, and text nodes, while upd events reﬂect modiﬁ-
cations of text nodes and attribute nodes. Moreover, instead of an
operation wildcard “(cid:3)” can be used. The path type deﬁnes where
events of that type occur. It can be relative or absolute. Primitive
event type et is a tuple comprising an operation, which is one of
fins; upd; del; (cid:3)g, and a path type, thus et = hop; pti.

A primitive event occurs whenever a node is manipulated. Prim-
itive event e is represented by a tuple comprising its identiﬁer id,
timestamp ts, event type et, and path instance pi which identiﬁes
the manipulated node, thus e = hid; ts; et; pii. The event type’s
operation does not equal wildcard “(cid:3)”, its path type is absolute,
and the path instance’s path type pi:pt equals et:pt.

A composite event type, i.e., the event type of a composite event,
is a tuple that comprises a unique name and a path type, thus et =
hname; pti. Wildcard “(cid:3)” can be used instead of a name, referring
to any composite event type having the path type. A composite
event type is denoted as name(pt) analogously to a primitive one.
The path type of a composite event type deﬁnes, like the path type
of a primitive event type, where events of that type occur. It can be
relative or absolute.

A composite event is formed by combining primitive and other
composite events, which are referred to as constituent events. Com-
posite event ec is represented by a tuple comprising its identiﬁer id,
composite event type et, path instance pi, which identiﬁes where
the event occurred, and a set of constituent events cevts, thus
ec = hid; et; pi; cevtsi. The composite event type’s name does
not equal wildcard “(cid:3)”, its path type is absolute, and the path in-
stance’s path type ec:pi:pt equals ec:et:pt.

The clock for measuring the timestamps of primitive events is a
logical one, i.e., a counter. Primitive events occur at distinct points
in time and for simplicity it is assumed that the detection of com-
posite events takes no time. Therefore one primitive and multiple
composite events may be detected at a single point in time.

Primitive as well as composite event types are hierarchically re-
lated via their path type and lead to more expressive composite
event type deﬁnitions than in Snoop. Most important this allows to
constrain the combination of event types by an operator to related
event types. For the constraints on operator nodes see Section 3.1.
An event can be an instance of more than one event type, pro-
viding for more reusable composite event type deﬁnitions than in
Snoop. Event e is a direct instance of its type e:et and an indi-
rect instance of event types eti 6= e:et to which the event’s type
is compatible to, denoted by e:et (cid:23) eti (not commutative). Prim-
itive event type et1 is compatible to primitive event type et2, i.e.,
et1 (cid:23) et2 iff ((et1:op = et2:op) _ (et2:op =“(cid:3)”)) ^ ((et2:pt (cid:26)e
et1:pt) _ (et2:pt = et1:pt)). Analogously, for two compos-
ite event types etc
2:name) _
(etc
1:pt)).
For more details on reuse see Section 3.1, especially Examples 13
and 14.

1 (cid:23) etc
2:name =“(cid:3)”)) ^ ((etc

1:name = etc
1:pt) _ (etc

2 iff ((etc
2:pt (cid:26)e etc

2:pt = etc

Example 8. Primitive event ep1 reﬂecting an insertion in path
type ep1 :et:pt = =order=item=price is an instance of event types
such as E1 = ins(=order=item=price) and E2 = (cid:3)(price) since
ep1 :et (cid:23) E1 and ep1 :et (cid:23) E2. Analogously, composite event
ec
h1 with path type ec
h1 :et:pt = =order=item and name Nm is an
instance of composite event types such as Ec
1 = Nm(=order=item)
h1 :et (cid:23) Ec
and Ec
1 and ec
2.

2 = (cid:3)(item) since ec

h1 :et (cid:23) Ec

Like in Snoop, composite event types are deﬁned by event ex-
pressions according to an event algebra. An expression combines
events by the algebra’s operators. The presented approach uses op-
erators 4, 5, and ; from Snoop to form conjunction, disjunction,
and sequence of events. An expression is realized by an event tree,
e.g., Figure 1 depicts the event tree that realizes the expression de-
scribed in Section 2.3.

An event tree comprises event type nodes and operator nodes.
An event type node is a tuple het; evtsi which stores a set of events
evts. All events in evts are a direct or indirect instance of event
type et. An operator node combines events from child nodes nds
to events of composite event type et according to operator opr and
stores them in a set of composite events evts, and is thus a tuple
hopr; nds; et; evtsi. Leaf nodes in an event tree are event type
nodes while inner nodes are operator nodes.

In the presented approach the event type of an event tree node can
be compared to the static type of a variable in strongly typed object-
oriented programming languages (e.g., Java), while the event type
of an event can be compared to the dynamic type of an expression,
e.g., an object. An occurred event is stored in all leaf nodes that
have a compatible event type. By using the ending operator in the
deﬁnition of type compatibility a leaf node only stores events that
occur directly in the node’s path type and not in descendants.

Example 9. Continuing Example 8, when primitive event ep1
with (dynamic) event type ep1 :et occurs, it is stored in event type
nodes that have compatible (static) event types such as E1 and E2.
Analogously, when composite event ec
h1 is raised, it is stored in
event type nodes that have event types such as Ec

1 and Ec
2.

2.3 Example

This section exempliﬁes the need for composite events in XML
and demonstrates the application of the reﬁned event algebra. Con-
sider an XML document that represents a purchase order (doc-
ument element order) comprising items to be ordered (element

177Table 1: Raised composite events when using contexts from Snoop

-

S1
S2
S3
S4

S1
S2
S3
S4

S1
S2
S3
S4

t1

t2

t3

ei1
ei1
ei1
ei1

ei1
ei1
ei1
ei1

ei1
ei1
ei1
ei1

ep1
ei2
ei2
ei2

ep1
ei2
ei2
ei2

ep1
ei2
ei2
ei2

eq1 ; fei1 ep1 eq1 gc

ep1
ep1
ep1

eq1 ; fei1 ep1 eq1 gc

ep1
ep1
ep1

eq1 ; fei1 ep1 eq1 gc

ep1
ep1
ep1

t4

ei2
ep2

Cumulative Context

t5

ep2

eq1 ; fei1 ei2 ep1 ep2 eq1 gc

eq1 ; fei1 ei2 ep1 eq1 gc
eq2 ; fei1 ei2 ep1 eq2 gc

Chronicle Context

ep2
ep2

ep2

ei2
ep2

eq1 ; fei1 ep1 eq1 gc
eq2 ; fei1 ep1 eq2 gc

eq1 ; fei1 ep1 eq1 gc

ep2
ep2

Recent Context

ei2
ep2

eq1 ; fei2 ep1 eq1 gc
eq2 ; fei2 ep1 eq2 gc

ep2 ; fei2 ep2 eq1 gc
eq1 ; fei2 ep2 eq1 gc
ep2 ; fei2 ep2 eq1 gc
ep2 ; fei2 ep2 eq2 gc

Continuous Context

t6

eq2 ; fei2 ep2 eq2 gc

eq2

eq2 ; (fep2 eq2 gc)
eq1 ; (fep2 eq1 gc)

eq2 ; fei2 ep2 eq2 gc
eq2 ; fei2 ep2 eq2 gc
eq2 ; fei2 ep2 eq2 gc
eq1 ; fei2 ep2 eq1 gc

eq2 ; fei2 ep2 eq2 gc
eq2 ; fei2 ep2 eq2 gc
eq2 ; fei2 ep2 eq2 gc
eq1 ; fei2 ep2 eq1 gc

eq2 ; (fep2 eq2 gc)

eq2

eq1 ; fei1 ep1 eq1 gc

ei1
ei1
ei1
ei1

ep1
ei2
ei2
ei2

S1
S2
S3
S4
y1: fei1 ep1 eq1 gc; fei1 ep2 eq1 gc; fei2 ep1 eq1 gc; fei2 ep2 eq1 gc y2: fei1 ep1 eq1 gc; fei2 ep1 eq1 gc y3: fei1 ep1 eq2 gc; fei2 ep1 eq2 gc

ep2 ; (fep2 eq1 gc)
ep2 ; (fep2 eq2 gc)

eq2 ; (fep2 eq2 gc)
eq1 ; (fep2 eq1 gc)

ei2
ep2

eq1 ; y2
eq2 ; y3

ep2 ; fei2 ep2 eq1 gc

eq1 ; y1

ep1
ep1
ep1

item), each in turn described by a price (element price) and a quan-
tity (element quantity). When deﬁning a rule that reacts on the
insertion of an item and re-calculates the overall order value by
multiplying price by quantity of each item and summing it up, one
encounters the problem to decide which event to react on. Upon
the insertion of element item it does not comprise any of the nec-
essary child elements, and upon the insertion of element price the
quantity element may not be available and vice versa.

The problem can be overcome by using composite events. A
composite event is raised according to its deﬁnition after certain
events have occurred. In the example, a composite event should oc-
cur after the occurrence of events reﬂecting insertions of an item, a
price, and a quantity element (where the latter two are children of
the ﬁrst) so that a rule can be deﬁned on it. This can be achieved
by event expression “Ei ; (Ep 4 Eq)”, where Ei := ins(item),
Ep := ins(item=price), and Eq := ins(item=quantity).

The event tree realizing the example’s expression is depicted
in Figure 1. The event tree’s behavior when using contexts from
Snoop, i.e., its processing of four sequences of primitive events
S1::S4 is shown in Table 1. The sequences reﬂect the insertions of
item (abbreviated as in), price (pn), and quantity (qn) elements.
Numerical index n of an element represents its hierarchical po-
sition, meaning that elements with the same numerical index are
hierarchically related, e.g., p1 is a child of i1. In case two numer-
ical indices are separated by a dot, the ﬁrst number represents the
element’s hierarchical position and the second one the time of its
insertion, e.g., the insertion of q1:1 occurs before the insertion of
q1:2.

Brieﬂy and informally introducing the contexts from Snoop, a
composite event is raised by a conjunction operator node as soon
as a child node’s set of stored events is modiﬁed, i.e., an event is
added (the so called “terminator”) and every child node contains
at least one event. Note that only the conjunction operator is de-
scribed here, however, sequence and disjoint operator are deﬁned
analogously. A raised composite event’s constituent events are de-
ﬁned as follows:

(cid:15) in cumulative context they comprise all events from every

child node wherefrom they are removed.

(cid:15) in chronicle context they comprise the oldest event from ev-
ery child node wherefrom they are removed, i.e., all con-
stituent events are consumed in chronological order of oc-
currence.

(cid:15) in recent context they comprise the most recent event from
each child node. All events that cannot be the earliest con-
stituent event of subsequently raised composite events (i.e.,
that cannot be an “initiator”) are removed from child nodes.

(cid:15) in continuous context its constituent events comprise the ter-
minator and the most recent event from every child node ex-
cept the one of the terminator. Subsequently all constituent
events are removed from child nodes except the terminator.
The procedure is repeated until there are no events left to
be combined with the terminator. Finally the terminator is
removed if it cannot be an initiator of subsequently raised
composite events.

The rationale of Table 1 is to introduce the unfamiliar reader to
Snoop’s contexts and to exemplify that incorrect composite events
are raised when any of Snoop’s contexts is used (for which one fal-
sifying event sequence would sufﬁce). Incorrect events are raised
because events are selected only by their occurrence time and not
their hierarchical position. Where under a correct composite event
it is referred to a composite event whose constituent events are hi-
erarchically related. Composite events raised by the root of the tree
are shown by their constituent events, e.g., fei1 ep1 eq1 gc. Uncon-
sumed composite events that remain in the tree after t6 are shown
at the time they are raised, but in brackets, e.g., (fep2 eq2 gc). The
table does not show the unrestricted context which basically forms
the cartesian product of all events. Naturally, it raises even more
incorrect composite events.

Summarized, the reﬁned event algebra as presented in this sec-
tion is still not applicable to detect composite events in XML when

178used with contexts from Snoop. The reason is that the require-
ments on applications using such an event algebra are inadequate,
which would have to use the unrestricted context and ﬁlter out huge
amounts of incorrect events or manipulate XML data in a deﬁned
temporal order so that some context only detects correct events.
And still, the satisfaction of multiplicity constraints cannot be de-
tected using the reﬁned algebra.

3. EXTENDED EVENT ALGEBRA

This section presents an extension to the reﬁned event algebra.
The extension comprises the hierarchical context presented in Sec-
tion 3.1, the multiplicity operator in Section 3.2, and operator mod-
iﬁers in Section 3.3. Event trees which are generated from event ex-
pressions are used for presentational purposes throughout the sec-
tion.
3.1 Hierarchical Context

The hierarchical context is introduced since it is necessary to
combine events according to their hierarchical position, which is
not supported by existing contexts. It raises only correct composite
events, i.e., composite events whose constituent events are hierar-
chically related.

To combine events according to their hierarchical position an
event tree maintains data concerning hierarchy. Therefore, as
mentioned earlier, every node n in an event tree has an assigned
path type n:et:pt. Naturally, an event type node speciﬁes a path
type, however, the path type of an operator node, if not speciﬁed
by the event expression, has to be derived from its child nodes
c1; c2; :::; cn by evaluating c1:et:pt \lb c2:et:pt \lb ::: \lb cn:et:pt
(left-bound intersection is used for simplicity). The derivation of
path types for all operator nodes is done bottom up. For an event
tree to be valid, every node n must have a non-null path type whose
steps are not empty and do not violate the constraints on child nodes
(cf. later in this section).

Example 10.

Figure 1 shows an exemplary event tree on the
left deﬁning composite event type Ec
:= Ei ; (Ep 4 Eq) for
i
the insertion of item elements and the derivation of path types
for operator nodes on the right. The derivation is done bot-
tom up, step 1 determines the path type of operator node 4 by
evaluating item=price \lb item=quantity = item. Subsequently,
step 2 determines the path type of operator node ; by evaluating
item \lb item = item.

Figure 1: Derivation of operator nodes’ path types

An operator node raises a composite event by selecting events
from its child nodes that satisfy certain conditions. Basically, (a)
at least one child node of a disjunction operator node must hold an
event, (b) all child nodes of a conjunction operator node must hold
an event, and (c) all child nodes of a sequence operator node must
hold an event and they must have occurred in the speciﬁed order.

If operator node o combines multiple events from child nodes
they must all have the same ancestor node, i.e., 81 (cid:20) i (cid:20) m (cid:0) 1 :

(cid:25)o:et:pt(ei:pi) = (cid:25)o:et:pt(ei+1:pi) where m is the number of
events in o’s child nodes that are to be combined. Events for which
the projection evaluates to null are not combined. Raised com-
posite event ec’s path instance, which must be absolute, is derived
from constituent events by (cid:25)o:et:pt\abe1 :pi:pt(e1:pi). Event e1 is
the ﬁrst constituent event, however, any other constituent event ei
could be used instead because if all constituent events ei equal in
(cid:25)o:et:pt(ei:pi) they equal in (cid:25)o:et:pt\abei :pi:pt(ei:pi) as well.

Example 11. How the event tree in Figure 1 forms compos-
ite events in hierarchical context is shown in Figure 2. Its status
after the occurrence of the event sequence ei1 ; ei2 ; ep1 ; ep2 ; eq1 is
shown on the left. In path instances and event indices, o abbrevi-
ates order, i abbreviates item, p abbreviates price, q abbreviates
quantity, and the numerical index indicates the hierarchical posi-
tion, e.g., p1 is a child of i1. Events ep1 and eq1 are combined
by operator 4 to form composite event ec
h1, since (cid:25)item(ep1 :pi) =
(cid:25)item(eq1 :pi) (= i1). With the creation of ec
h1 the two primitive
events are consumed (step 1). Subsequently, ei1 and ec
h1 are com-
bined by operator ; since (cid:25)item(ei1 :pi) = (cid:25)item(ec
h1 :pi) (= i1)
(step 2). Upon the occurrence of eq2 later on the same combination
process starts over again.

Figure 2: Event selection and event consumption in hierarchi-
cal context

Constraints on operator node o’s path type are enforced so that
the projection of an event’s path instance on o’s path type is likely
to return a non-null value, i.e., so that for child event ej expression
(cid:25)o:et:pt(ej:pi) 6= null applies. The constraints seek a compromise
between the operator’s expressiveness for the reuse of event trees
(cf. later in this section) and restrictions on child nodes and do thus
not guarantee a non-null value. They are as follows (where Ej
refers to a child node’s event type): (a) if both o:et:pt and Ej:pt
are absolute, o:et:pt\lb Ej:pt 6= null must apply, (b) if only Ej:pt
is absolute, o:et:pt (cid:26) Ej:pt must apply. If Ej:pt is relative no con-
straints must apply so that it may contain only a single step that is
not contained in o:et:pt. In such cases one must rely that an event’s
(dynamic) event type is compatible to the operator’s (static) event
type so that the event’s path instance can be projected on the oper-
ator’s path type. This can be compared to a type-cast in strongly
typed object-oriented programming languages where an object’s
dynamic type must be compatible to the static casted type which
can only be determined at runtime. For examples see Example 13
and 14.

Operators combine events with interval-based semantics not
detection-based semantics, since composite events detected with
the latter are not always exactly as, presumably, intended (cf. [1,
10]). Basically, this means that operators do not combine events ac-
cording to their detection time but take the intervals during which
the events occurred into account. A primitive event detected at td
occurs in interval [td; td], and a composite event starts at the be-
ginning of the smallest interval and ends at the end of the latest
one. Comparing intervals, [t0
b. Interval-

b ] iff t00

a < t0

a; t00

a] < [t0

b; t00

179i
n
s
(
i
t
e
m
)
i
n
s
(
i
t
e
m
/
p
r
i
c
e
)
;
i
n
s
(
i
t
e
m
/
q
u
a
n
t
i
t
y
)
i
t
e
m
i
t
e
m
/
p
r
i
c
e
;
i
t
e
m
/
q
u
a
n
t
i
t
y
i
t
e
m
i
t
e
m
(
1
)
(
2
)
E
p
E
i
E
q
E
i
c
e
v
e
n
t
 
t
y
p
e
 
n
o
d
e
o
p
e
r
a
t
o
r
 
n
o
d
e
e
 
 
=
i
n
s
(
/
o
1
/
i
1
/
p
1
)
e
 
 
=
i
n
s
(
/
o
1
/
i
2
/
p
2
)
;
e
 
=
i
n
s
(
/
o
1
/
i
1
)
e
 
=
i
n
s
(
/
o
1
/
i
2
)
e
 
 
=
i
n
s
(
/
o
1
/
i
1
/
q
1
)
e
 
 
=
e
;
e
e
 
=
(
1
)
(
2
)
h
1
h
1
e
h
1
i
1
i
1
i
2
e
 
=
i
n
s
(
/
o
1
/
i
1
)
e
 
=
i
n
s
(
/
o
1
/
i
2
)
i
1
i
2
p
1
p
2
p
1
q
1
e
q
1
e
p
1
e
q
1
e
 
i
1
e
 
i
1
;
(
e
p
1
e
q
1
)
c
c
c
c
e
 
 
=
i
n
s
(
/
o
1
/
i
2
/
p
2
)
p
2
based semantics only affect the sequence operator, so that expres-
sion Ei;Ej combines two hierarchically matching events ei and
ej only if the occurrence interval of the former is smaller than the
other.

The hierarchical context is orthogonal to existing contexts from
Snoop, because selection by XML hierarchy is orthogonal to selec-
tion by time. Thus it can be combined with any existing context,
acting like a ﬁlter. For operator node o, ﬁrst the hierarchical context
groups all events from child nodes according to o’s path type, and
second o selects and consumes events within each group according
to its context from Snoop.

Example 12. To detect when both price and quantity information
of an order item are modiﬁed, event expression (cid:3)(item=quantity)
4 upd(item=price) can be used. Table 2 shows raised composite
events, represented by their constituent events. for the above ex-
pression in the hierarchical variants of Snoop’s contexts. Events
that remain in the event graph after t5 are shown in the rightmost
column for completeness.

A composite event type deﬁnition can reuse other, existing event
type deﬁnitions, i.e., and event tree can reuse other event trees. All
event trees together form the event graph. A tree that deﬁnes com-
posite event type Ec
i is reused in another tree through an event type
node with event type Ec
j . Then it may be the case
that the node’s parent operator node o’s path type o:et:pt cannot be
derived from its child nodes, because the left-bound intersection of
Ec
j :pt with the path types of o’s other child nodes is null, e.g., if
their path types are of different kind or Ec
j :pt contains only a single
step. In either case o’s path type must be speciﬁed explicitly.

i (cid:23) Ec

j iff Ec

b and Ec

Example 13. The order element has aside from item elements
a billTo and a shipTo child element. When two composite event
types Ec
s for complete insertions of the latter two elements
are deﬁned in addition to Ec
i (from Example 10), a fourth composite
event type can use the three to deﬁne a composite event that occurs
after both addresses and at least one item have been inserted by
Ec
b:pt = item \lb
shipTo\lb billTo = null, the conjunction operator’s path type must
be speciﬁed explicitly, e.g., as order. Because the (dynamic) event
types of occurred events have absolute path types, the projection of
their path instances on order is not null.

b. Since, e.g., Ec

i :pt \lb Ec

s :pt \lb Ec

i 4 Ec

s 4 Ec

Reuse of event type deﬁnitions is facilitated by using type com-
patibility instead of type equality for storing occurred events in
event type nodes, as mentioned before and in Section 2.2. The
reason is that the more leaf nodes with “general” event types an
event tree has (i.e., nodes with event types that have relative path
types and/or wildcard “(cid:3)” as operator or name), the more events
will be stored in it because an event’s “special” event type (i.e., one
with absolute path type and given operation) may be compatible to
a general one but not to another special one. The more events are
stored, the more composite events are raised, and the more the tree,
i.e., the event deﬁnition is reusable.

Figure 3: Reuse of event trees

Example 14. The order’s shipTo and billTo elements both have
an address child element that comprises other elements such as
street and city. By deﬁning composite event type Ec
a for the inser-
tions of address elements and using only relative path types that
start with address, the according event tree in Figure 3 raises com-
posite events for complete insertions of address elements as childs
of both shipTo and billTo. Thus Ec
b and
Ec

a can be reused by both Ec

s from Example 13.

3.2 Multiplicity Operator

Because an XML schema can deﬁne multiplicity constraints on
XML elements and attributes it is desirable to be able to detect
when multiplicity constraints are satisﬁed by observing occurred
events. A multiplicity constraint is deﬁned by lower bound l and
upper bound u (l (cid:20) u), meaning that between l and u child el-
ements or attributes with the same name may occur as child of a
parent element. After l events reﬂecting insertions the multiplic-
ity constraint is satisﬁed (if the parent element did not contain any
such child elements before). The operator from Snoop that closest
resembles the required functionality is the ANY operator. It detects
a ﬁxed number > 0 of events of distinct event types, however, in
XML the required number is (cid:21) 0, since 0 events reﬂect optional
elements, and the events are of the same event type.

To detect when multiplicity constraints are satisﬁed unary multi-
plicity operator “(cid:2)” is introduced, denoted as (cid:2)[l; u]Ei. It raises a
composite event as soon as l events of Ei occurred, thereby indicat-
ing the constraint’s satisfaction. The consumption of the composite
event, however, may take place after other events of Ei occurred.
To provide composite events with most extensive sets of constituent
events, the multiplicity operator has integrative semantics.

Event integration starts after composite event ec

1 is raised upon
the occurrence of the lth event of Ei. A subsequently occurring
event gives rise to the new composite event ec
2 which integrates
ec
1’s constituent events. Event ec
1 is waived because it has been in-
tegrated and is thus assumed not to be of interest any longer. If u is
reached or the integrating composite event is consumed, integration
is suspended and starts over after the lth occurrence of Ei.

When employed in a hierarchical context, the multiplicity oper-
ator shows the above behavior for every distinct path instance of its
path type. If not speciﬁed explicitly, a multiplicity operator’s path
type is set to the child node’s path type omitting the last step. The
same constraints on a multiplicity operator’s path type must apply
as on other operator’s path types (cf. Section 3.1). Multiplicity op-
erator o raises a composite event ec
1 as soon as there exist l child
events that equal in (cid:25)o:et:pt(eij :pi) for 1 (cid:20) j (cid:20) l. Thereafter it
raises new composite event ec
2 upon the occurrence of child event
eik where (cid:25)o:et:pt(eik :pi) = (cid:25)o:et:pt(ec
1 has not been
consumed yet, where ec
1:cevts
and eik .

2:cevts is deﬁned by the union of ec

1:pi) if ec

Example 15. The event tree depicted in Figure 4 allows multiple
insertions of quantity elements as childs of element item. For two
insertions of quantity elements eq1:1 and eq1:2 the multiplicity op-
erator ﬁrst raises composite event ec
q1 upon the occurrence of eq1:1 .
If ec
q1 has not been consumed upon the occurrence of eq1:2 new
composite event ec
q2 :cevts = feq1:1 ; eq1:2 g,
and ec
q1 has been consumed
new composite ec
q2 :cevts =
feq1:2 g.

q2 is raised as well, however, with ec

q1 is waived. Otherwise, i.e., if ec

q2 is raised, where ec

A multiplicity operator in hierarchical context with a lower
bound of zero raises a composite event without the occurrence of
a child event. Instead, composite event ec
1 is raised with the event
representing the creation of (absolute) path instance pi that satis-
ﬁes the constraint of multiplicity operator o by having o:et:pt (cid:26)e

180;
E
a
(
a
d
d
r
e
s
s
)
c
i
n
s
(
a
d
d
r
e
s
s
)
.
.
.
i
n
s
(
a
d
d
r
e
s
s
/
s
t
r
e
e
t
)
i
n
s
(
a
d
d
r
e
s
s
/
c
i
t
y
)
;
E
s
(
s
h
i
p
T
o
)
c
i
n
s
(
s
h
i
p
T
o
)
;
E
b
(
b
i
l
l
T
o
)
c
i
n
s
(
b
i
l
l
T
o
)
E
a
(
s
h
i
p
T
o
/
a
d
d
r
e
s
s
)
c
E
a
(
b
i
l
l
T
o
/
a
d
d
r
e
s
s
)
c
e
v
e
n
t
s
e
v
e
n
t
s
.
.
.
Table 2: Combination of the hierarchical context with contexts from Snoop

-

t1

t2

t3

t4

t5

unconsumed events

S5

eq1:1

eq2

eq1:2

ep2 ; fep2 eq2 gc

ep1 ; fep1 eq1:1 eq1:2 gc

–

Hierarchical Cumulative Context

S5

eq1:1

eq2

eq1:2

ep2 ; fep2 eq2 gc

ep1 ; fep1 eq1:1 gc

eq1:2

Hierarchical Chronicle Context

Hierarchical Recent Context

S5

eq1:1

eq2

eq1:2

ep2 ; fep2 eq2 gc

ep1 ; fep1 eq1:2 gc

ep1 ; eq1:2 ; ep2 ; eq2

S5

eq1:1

eq2

eq1:2

ep2 ; fep2 eq2 gc

ep1 ; fep1 eq1:1 gc; fep1 eq1:2 gc

ep1 ; ep2

Hierarchical Continuous Context

p. If it is non-local, ec

mination mode is earliest, composite event ec
i is raised with the
detection of potential composite event ec
i is
raised after the detection of ec
p and the ﬁrst occurrence of event ej,
where (cid:25)o:et:pt(ec
p:pi) 6= (cid:25)o:et:pt(ej:pi). This means that operator
node o waits until an event occurs that reﬂects a manipulation in
another subtree of the document, i.e., it assumes that the manipula-
tion of a document is done hierarchically. If the termination mode
is custom, composite events are raised upon ﬂushing or closing the
event tree (cf. later in this section).

Example 17. For the event tree depicted in Figure 4 and four
exemplary event sequences S6::S9 Table 3 shows when composite
events are raised depending on the termination mode of (i) the con-
junction operator node and (ii) the multiplicity operator node of the
quantity element. The other two operator nodes have termination
mode earliest. To clearly point out the consequences of termina-
tion modes the table shows composite events raised by any opera-
tor node. A composite event is denoted by ec with an alphabetical
index indicating its event type and a numerical index indicating its
hierarchical position. Note that due to the order of occurred events
in S6::S9 the same composite events are raised irrespective of the
context from Snoop that is combined with the hierarchical context.
Second, the termination condition must be fulﬁlled for a com-
posite event to be raised. It is a condition on the subtree of the
XML document with root node ec
p:pi in the form of an arbitrary
XPath expression that evaluates to boolean. The termination con-
dition differs from operators and termination modes in that it is
used to test the document and not events, e.g., to test if text nodes
contain any or certain text.

for

Example 18.

the insertion of

tree depicted in Figure 4,

Instead of adding event
test

type nodes and
text nodes to
operator nodes that
the event
termination condition
“item=price (cid:21) 0 ^ item=quantity > 0” can be deﬁned on the root
node so that a composite event is only raised when both price and
quantity element contain a value that is a number. This has also
the advantage that text nodes can be arbitrarily inserted, updated,
and deleted because its their value that matters, not the operations
that lead to it.

An event tree can be opened, ﬂushed, and closed by an appli-
cation. After opening it stores occurring primitive and composite
events. If it is ﬂushed, remaining composite events are raised by
operator nodes with non-local or custom termination mode. Clos-
ing an event tree ﬁrst ﬂushes it and afterwards takes it out of order,
e.g., when an XML document is closed after manipulation.

4.

IMPLEMENTATION

The implemented proof-of-concept prototype extends the DOM
event module of Apache’s Xerces [9] and thus provides Java appli-
cations with composite events. This section brieﬂy describes the
prototype’s execution model.

Figure 4: Event tree using a multiplicity operator

pi:pt _ o:et:pt = pi:pt. It does not comprise any constituent event,
its path type is set to pi:pt, and its path instance to pi. When event
ei with (cid:25)o:et:pt(ei:pi) = (cid:25)o:et:pt(ec
1:pi) subsequently occurs in o’s
child node before ec
2 which
integrates ec
2 is consumed later on
and ec
3 is raised since o’s
constraints are still satisﬁed.

2:pi still exists, new composite event ec

1 is consumed, new composite event ec

1 is raised. If composite event ec

Example 16. The event tree depicted in Figure 4 allows optional
element comment as child of element item. With the insertion
of item element i1 composite event ec
c1 :et:pt =
=order=item and ec
c1 :pi = =o1=i1. Thereafter, the conjunction op-
erator raises composite event ec
h1 as soon as matching events are
stored in its other child nodes, i.e., as soon as p1 and q1 are inserted
as childs of i1. If matching comment element c1 is inserted before
both elements p1 and q1 are inserted, event ec
c1 is
raised which becomes a part of ec

c1 occurs with ec

c2 integrating ec

h1 later on.

3.3 Operator Modiﬁers

To enrich the expressiveness of event type deﬁnitions, opera-
tor nodes are parameterized by two modiﬁers to exactly deﬁne the
points in time when composite events are raised. When an oper-
ator node detects events in child nodes that satisfy the operator’s
semantics, a “potential composite event”, which is not stored in the
tree, is detected. A composite event, which is stored in the tree, is
raised with the detection of the potential event or is deferred to a
later date. This is of importance, e.g., when a multiplicity operator
or the hierarchical cumulative context is used, because the later a
composite event is raised the more constituent events it will possi-
bly have. Thus applications can react to deferred composite events
comprising a rich set of constituent events and can determine the
net-effect [15], i.e., overall effect of multiple events more easily.

First, the termination mode determines when a composite event
is raised relative to the detection of a potential event. If the ter-

181i
n
s
(
i
t
e
m
/
c
o
m
m
e
n
t
)
x
[
0
,
1
]
i
n
s
(
i
t
e
m
)
i
n
s
(
i
t
e
m
/
p
r
i
c
e
)
;
i
n
s
(
i
t
e
m
/
q
u
a
n
t
i
t
y
)
x
[
1
,
 
 
]
(
1
)
 
t
m
:
e
a
r
l
i
e
s
t
(
2
)
 
t
m
:
n
o
n
-
l
o
c
a
l
(
a
)
 
t
m
:
e
a
r
l
i
e
s
t
 
(
b
)
 
t
m
:
n
o
n
-
l
o
c
a
l
E
q
E
c
E
h
E
i
c
c
c
c
o
o
t
m
:
e
a
r
l
i
e
s
t
t
m
:
e
a
r
l
i
e
s
t
t
m
 
.
.
.
 
t
e
r
m
i
n
a
t
i
o
n
 
m
o
d
e
Table 3: Raised composite events in hierarchical context when different termination modes are used

t3

t4

(1a) 4 : earliest; (cid:2)[1; 1] : earliest

eq1 ; ec

c
i1

q1 ; ec
ec1 ; ec

h1 ; e
c1:2
q1:1 ; ec
ei2 ; ec
c2

eq1:1 ; ec

h1 ; e

c
i1

eq1 ; ec

ei2 ; ec
c2
q1 ; ec
h1 ; e
ec1 ; ec
c1:2
ep2

c
i1

(1b) 4 : earliest; (cid:2)[1; 1] : non-local

ei2 ; ec
c2
eq1:2 ; ec
q1 ; ec

q1:2
h1 ; e

eq1 ; ec

–
c2 ; ec
q1 ; ec

h1 ; e

ei2 ; ec

t5

–

eq1:2
eq1

–

c
i1

ei2 ; ec

h1 ; e
q1:2

c2 ; ec
eq1:2 ; ec
eq1 ; ec
q1

t6

–
–

c
i1

ei2 ; ec
c2
q2 ; ec
h2 ; e

eq2 ; ec

c
i2

c
i1

c
i1

–
–
c2 ; ec
q1 ; ec

h1 ; e

eq2 ; ec

q1 ; ec

h1 ; e

c
i1

ei2 ; ec

–
–

ei2 ; ec

c2 ; ec

h1 ; e

c
i1

eq2 ; ec

h1 ; e

c
i1

–
–
q1 ; ec
c2 ; ec

h1 ; e

eq2 ; ec

q1 ; ec

h1 ; e

c
i1

ei2 ; ec

c
i1

c
i1

-

S6
S7
S8
S9

S6
S7
S8
S9

S6
S7
S8
S9

S6
S7
S8
S9

t1

ei1 ; ec
c1
ei1 ; ec
ei1 ; ec
ei1 ; ec
c1

c1:1

c1:1

ei1 ; ec
c1
ei1 ; ec
ei1 ; ec
ei1 ; ec
c1

c1:1

c1:1

ei1 ; ec
c1
ei1 ; ec
ei1 ; ec
ei1 ; ec
c1

c1:1

c1:1

ei1 ; ec
c1
ei1 ; ec
ei1 ; ec
ei1 ; ec
c1

c1:1

c1:1

t2

ep1
ep1
ep1
ep1

ep1
ep1
ep1
ep1

ep1
ep1
ep1
ep1

ep1
ep1
ep1
ep1

eq1
ec1 ; ec
eq1:1
ei2 ; ec
c2

c1:2

eq1 ; ec
q1
ec1 ; ec
eq1:1 ; ec
ei2 ; ec
c2

c1:2

q1:1

ei2 ; ec

h1 ; e

c
i1

c2 ; ec
q1 ; ec
eq1
ec1 ; ec
ep2

c1:2

c
i1

ei2 ; ec

c2 ; ec
h1 ; e
eq1 ; ec
q1
ec1 ; ec
ep2

c1:2

(2a) 4 : non-local; (cid:2)[1; 1] : earliest

(2b) 4 : non-local; (cid:2)[1; 1] : non-local

eq1
ec1 ; ec
eq1:1
ei2 ; ec
c2

c1:2

ei2 ; ec

h1 ; e

c
i1

c2 ; ec
q1 ; ec
eq1
ec1 ; ec
ep2

c1:2

–
c2 ; ec
q1 ; ec

h1 ; e

ei2 ; ec

eq1:2
eq1

Every occurred primitive event is inserted into the event graph,
which is processed to detect composite events. To determine the
order in which the event trees of the graph are processed, which re-
mains the same as long as neither the graph nor the trees are mod-
iﬁed, the notion of event tree dependency is introduced. Event tree
tb directly depends on event tree ta, denoted as ta ! tb, iff tb uses
composite event type etb to which event type eta deﬁned by ta is
compatible to, i.e., if eta (cid:23) etb. An event tree may not depend
directly or indirectly on itself.

Algorithm processGraph for processing event graph G upon
the occurrence of primitive event e is shown below. It processes
every event tree of the graph exactly once. Line #1 determines the
ordered set of event trees that do not directly depend on any other
event tree and assigns it to T . Subsequently, the set of occurred
and raised events E is initialized to e (line #2). While there are
event trees left that need to be processed (line #3), every event tree
ti 2 T is processed (line #4–#5, see later in this section), where
ti denotes the ith element of T . Subsequently, all event trees that
directly depend on any t 2 T and thus need to be processed are
determined and assigned to T (line #6). Finally, T is purged (line
#7, see later in this section).

processGraph(e)
#1 T := ft 2 Gj 6 9u 2 G : u ! tg
#2 E := feg
#3 while T 6= ; do
#4
#5
#6
#7

T := ft0 2 Gj9t 2 T : t ! t0g
purge(T )

for i = 1 to jT j do

E := processTree(ti, E)

Algorithm processTree(t,E) processes event tree t with
the set of events E as follows. The tree is traversed in postorder (a
form of depth-ﬁrst traversal) during which (a) every visited event
type node n is tested for type compatibility with the event type of
every event e 2 E and if they are compatible, i.e., e:et (cid:23) n:et, e is
stored in n:evts (but not taken out of E), and (b) every visited oper-

ator node o is evaluated if (i) an event was stored in a (direct) child
node, (ii) if o speciﬁes a termination condition and for the primitive
event e 2 E it applies that o:et:pt (cid:26) e:pt _ o:et:pt = e:pt, (iii) if
o has non-local termination mode, or (iv) if o is a multiplicity op-
erator node with l = 0 and for the primitive event e 2 E it applies
that o:et:pt (cid:26)e e:pt _ o:et:pt = e:pt. Finally, composite events
that are raised in the root node of event tree t are added to E to be
processed by dependent event trees later on.

Algorithm purge(T ) removes every event tree tk 2 T from
T if it is contained in the closure of another event tree tj 2 T ,
where the closure of a tree refers to the set of trees that directly
and indirectly depend on it. This guarantees that an event tree is
processed exactly once at the latest time possible.

5. CONCLUSIONS

We have presented the ﬁrst approach to detect composite
events in XML, which reﬁnes and extends the event algebra
Snoop to take the peculiarities of events in XML into ac-
count and provide for the detection of satisﬁed multiplicity con-
straints. Moreover, the introduced concept of compatibility of
event types makes event expressions more expressive and reusable.
The prototype including additional examples is available on
the Web at http://www.big.tuwien.ac.at/research/
prototypes/composite-events. Naturally our approach
is independent of an implementation and can be used by any appli-
cation in need of composite events in XML, presumably, such as
[2] and [6].

The presented approach is fully compatible with Snoop and thus
provides for combined expressiveness. First, the hierarchical con-
text presented herein is orthogonal to Snoop’s contexts and can thus
be arbitrarily combined with the latter, providing for simultaneous
event combination by hierarchical position and time. Second, com-
posite XML event types can be combined by operators from Snoop,
providing for subsequent event detection based on time (e.g., NOT
detects non-occurrences of events in intervals).

Our ongoing research concentrates on the automatic derivation
of event expressions from XML schemas (i.e., schemas expressed

182in XML Schema [19]) to provide a set of composite event type def-
initions an application engineer can start working with. We assume
that if schemas use XML schema concepts such as type deﬁnitions,
type hierarchies and model groups in a meaningful way, derived
composite event type deﬁnitions will be meaningful as well.

6. ACKNOWLEDGMENTS

We want to thank Jan Wenger for implementing the prototype
and giving valuable feedback and Elke Michlmayr for carefully
reading the paper and giving helpful comments.

7. REFERENCES
[1] R. Adaikkalavan and S. Chakravarthy. Event Operators:

Formalization, Algorithms, and Implementation. Technical
Report CSE-2002-3, Department of Computer Science and
Engineering, University of Texas at Arlington, 2002.

[2] J. Bailey, A. Poulovassilis, and P. T. Wood. An

Event-Condition-Action Language for XML. In Proceedings
of the 11th International Conference on World Wide Web
(WWW11), Honolulu, USA, pages 486–495. ACM Press,
2002.

[3] J. Bailey, A. Poulovassilis, and P. T. Wood. Analysis and
Optimisation of Event-Condition-Action Rules on XML.
Computer Networks, 39(3):239–259, 2002.

[4] A. Bonifati, D. Braga, A. Campi, and S. Ceri. Active

XQuery. In Proceedings of the 18th International Conference
on Data Engineering (ICDE), San Jose, USA, 2002.

[5] A. Bonifati, S. Ceri, and S. Paraboschi. Active Rules for

XML: A New Paradigm for E-Services. The VLDB Journal,
10(1):39–47, 2001.

[6] A. Bonifati, S. Ceri, and S. Paraboschi. Pushing Reactive

Services to XML Repositories using Active Rules. In
Proceedings of the 10th International World Wide Web
Conference (WWW10), Hong Kong, China, pages 633–641.
ACM Press, 2001.

[7] S. Chakravarthy, V. Krishnaprasad, E. Anwar, and S.-K.

Kim. Composite Events for Active Databases: Semantics,
Contexts and Detection. In Proceedings of the 20th
International Conference on Very Large Data Bases (VLDB),
Santiago de Chile, Chile, pages 606–617. Morgan
Kaufmann, 1994.

[8] S. Chakravarthya and D. Mishra. Snoop: An Expressive

Event Speciﬁcation Language for Active Databases. Data &
Knowledge Engineering, 14(1):1–26, Nov. 1994.

[9] A. S. Foundation. Xerces-Java.

http://xml.apache.org/xerces2- j/, 2003.
[10] A. Galton and J. C. Augusto. Two Approaches to Event

Deﬁnition. In Proceedings of the 13th International
Conference on Database and Expert Systems Applications
(DEXA), Aix-en-Provence, France, number 2453 in LNCS,
pages 547–556. Springer, 2002.

[11] S. Gatziu and K. R. Dittrich. Events in an Active

Object-Oriented Database System. In Proceedings of the 1st
Intl. Workshop on Rules in Database Systems (RIDS),
Edinburgh, Scotland, pages 23 – 29. Springer, 1993.

[12] S. Gatziu and K. R. Dittrich. Detecting Composite Events in
Active Database Systems Using Petri Nets. In Proceedings of
the 4th Intl. Workshop on Research Issues in Data
Engineering (RIDE): Active Database Systems, Houston,
Texas, 1994.

[13] N. H. Gehani, H. V. Jagadish, and O. Shmueli. Composite

Event Speciﬁcation in Active Databases: Model &
Implementation. In Proceedings of the 18th International
Conference on Very Large Databases (VLDB), 1992.

[14] G. Kappel, S. Rausch-Schott, and W. Retschitzegger. A

Framework for Workﬂow Management Systems Based on
Objects, Rules and Roles. ACM Computing Surveys
Electronic Symposium on Object-Oriented Application
Frameworks, 32(1), Mar. 2000.

[15] N. Paton and O. Diaz. Active Database Systems. ACM

Computing Surveys, 31(1):63–103, Mar. 1999.

[16] M. Schreﬂ and M. Bernauer. Active XML Schemas. In
Proceedings of the Workshop on Conceptual Modeling
Approaches for e-Business (eCOMO) at the International
Conference on Conceptual Modeling (ER), Yokohama,
Japan, volume 2465 of LNCS. Springer, 2001.

[17] W3C. XML Path Language (XPath), W3C Recommendation.

http://www.w3.org/TR/xpath, Nov. 1999.

[18] W3C. XML Information Set, W3C Recommendation.

http://www.w3.org/TR/xml-infoset, Oct. 2001.

[19] W3C. XML Schema Part 1: Structures, W3C

Recommendation.
http://www.w3.org/TR/xmlschema-1, May 2001.

[20] W3C. Document Object Model (DOM) Level 3 Events

Speciﬁcation.
http://www.w3.org/TR/DOM-Level-3-Events/,
Mar. 2003.

[21] W3C. XQuery 1.0 and XPath 2.0 Functions and Operators,

W3C Working Draft.
http://www.w3.org/TR/xpath- functions, May
2003.

[22] R. J. Zhang and E. A. Unger. Event Speciﬁcation and
Detection. Technical Report CS-96-8, Department of
Computing and Information Sciences, Kansas State
University, 1996.

[23] D. Zimmer and R. Unland. On the Semantics of Complex

Events in Active Database Management Systems. In
Proceedings of the 15th International Conference on Data
Engineering (ICDE), Sydney, Australia, pages 392–399.
IEEE Computer Society Press, 1999.

183