Enforcing Strict Model-View Separation in

Template Engines

Terence Parr

University of San Francisco

parrt@cs.usfca.edu

ABSTRACT
The mantra of every experienced web application developer is the
same: thou shalt separate business logic from display. Ironically,
almost all template engines allow violation of this separation prin-
ciple, which is the very impetus for HTML template engine devel-
opment. This situation is due mostly to a lack of formal deﬁnition
of separation and fear that enforcing separation emasculates a tem-
plate’s power. I show that not only is strict separation a worthy de-
sign principle, but that we can enforce separation while providing
a potent template engine. I demonstrate my StringTemplate en-
gine, used to build jGuru.com and other commercial sites, at work
solving some nontrivial generational tasks

My goal is to formalize the study of template engines, thus, pro-
viding a common nomenclature, a means of classifying template
generational power, and a way to leverage interesting results from
formal language theory.
I classify three types of restricted tem-
plates analogous to Chomsky’s type 1..3 grammar classes and for-
mally deﬁne separation including the rules that embody separation.
Because this paper provides a clear deﬁnition of model-view sep-
aration, template engine designers may no longer blindly claim en-
forcement of separation. Moreover, given theoretical arguments
and empirical evidence, programmers no longer have an excuse to
entangle model and view.

Categories and Subject Descriptors
D.3.4 [Programming Languages]: Processors—Code generation;
D.2.11 [Software Engineering]: Software Architectures—Domain-
speciﬁc architectures, Patterns, Languages; D.1.1 [Programming
Techniques]: Applicative (Functional) Programming

General Terms
Languages

Keywords
Template engines, Web applications, Model-View-Controller

INTRODUCTION

1.
The need for dynamically-generated web pages, such as the book
description pages at Amazon.com, has led to the development of
numerous template engines in an attempt to make web application
development easier, improve ﬂexibility, reduce maintenance costs,
and allow parallel code and HTML development. These enticing
beneﬁts, which have driven the proliferation of template engines,
Copyright is held by the author/owner(s).
WWW2004, May 17–20, 2004, New York, New York, USA.
ACM 1-58113-844-X/04/0005.

derive entirely from a single principle: separating the speciﬁcation
of a page’s business logic and data computations from the speci-
ﬁcation of how a page displays such information. With separate
encapsulated speciﬁcations, template engines promote component
reuse, pluggable site “looks”, single-points-of-change for common
components, and high overall system clarity.

I have discussed the principle of separation with many experi-
enced programmers and have examined many commonly-available
template engines used with a variety of languages including Java,
C, and Perl. Without exception, programmers espouse separation
of logic and display as an ideal principle.
In practice, however,
programmers and engine producers are loath to enforce separation,
fearing loss of power resulting in a crucial page that they can-
not generate while satisfying the principle. Instead, they encour-
age rather than enforce the principle, leaving themselves a gaping
“backdoor” to avoid insufﬁcient page generation power.

Unfortunately, under deadline pressure, programmers will use
this backdoor routinely as an expedient if it is available to them,
thus, entangling logic and display. One programmer, who is re-
sponsible for his company’s server data model, told me that he had
3 more days until a hard deadline, but it would take 10 days to
coerce programmers around the world to change the affected mul-
tilingual page displays. He had the choice of possibly getting ﬁred
now, but doing the right thing for future maintenance, or he could
keep his job by pushing out the new HTML via his data model into
the pages, leaving the entanglement mess to some vague future time
or even to another programmer.

The opposite situation is more common where programmers em-
bed business logic in their templates as an expedient to avoid hav-
ing to update their data model. Given a Turing-complete template
programming language, programmers are tempted to add logic di-
rectly where they need it in the template instead of having the data
model do the logic and passing in the boolean result, thereby, de-
coupling the view from the model. For example, just about every
template engine’s documentation shows how to alter the display ac-
cording to a user’s privileges. Rather than asking simply if the user
is “special”, the template encodes logic to compute whether or not
the user is special. If the deﬁnition of special changes, potentially
every template in the system will have to be altered. Worse, pro-
grammers will forget a template, introducing a bug that will pop up
randomly in the future. These expedients are common and quickly
result in a fully entangled speciﬁcation.

Is the ideal possible? That is, can one enforce separation with-
out emasculating the power of the template engine? Does a strict
engine result in some pages that are incomputable? As usual, the-
ory and practice disagree. Theory dictates that a Turing-complete
template engine can generate any page and is strictly stronger than a
restricted template engine. In practice, my experience building web

224servers, such as jGuru.com (110k lines), provides strong evidence
that programmers can in fact get the best of both worlds: separa-
tion and sufﬁcient power. For the past ﬁve years, I have essentially
conducted an experiment in software design while building sites
and tweaking my template engine called StringTemplate, rigidly
avoiding logic and computation in my templates. Still, this anec-
dotal evidence does not prove my restricted engine is sufﬁcient.
On the other hand, while most template engines can approximate
sin(x) via a Taylor series, I’m unconvinced a designer will need
the ability.

The trick is to provide sufﬁcient power in a template engine with-
out providing constructs that allow separation violations. After ex-
amining hundreds of template ﬁles used in my sites, I conclude
that one only needs four template constructs: attribute reference,
conditional template inclusion based upon presence/absence of an
attribute, recursive template references, and most importantly, tem-
plate application to a multi-valued attribute similar to lambda func-
tions and LISP’s map operator.

My goal here is to show that strict enforcement of separation is
not only a worthy design principle, but that it is realistically achiev-
able through the appropriate choice of template constructs. Section
2 describes how template engines evolved from previous strate-
gies to solve very real design issues. Section 3 explicitly states
the beneﬁts of separation. Section 4 shows how the model-view-
controller pattern very naturally applies to server design and how it
helps visualize separation of logic (model) and display (view). Sec-
tions 5 and 6 formally deﬁne templates and three restricted template
classes. Sections 7 and 8 deﬁne strict model-view separation and
how to avoid entanglement. Finally, Section 9 demonstrates the
StringTemplate engine solving some nontrivial HTML tasks.

2. EVOLUTION OF TEMPLATE ENGINES
Generating dynamic pages implies a server no longer maps a URL
to an HTML ﬁle on the disk. Instead the server must map URLs to a
chunk of code that spits out the appropriate HTML containing data
and associated display instructions. I will describe the evolution
of Java engines in particular here, though all the concepts apply to
Perl, VisualBasic, and so on.

Java began supporting server development with Servlets [15],
which amounted to methods that respond to HTTP GET and POST
commands by generating HTML via print statements. For exam-
ple, here is the core of a simple servlet that generates a page saying
“hello” to the URL parameter called name.

out.println("<html>");
out.println("<body>");
out.println("<h1>Servlet test</h1>");
String name = request.getParameter("name");
out.println("Hello, "+name+".");
out.println("</body>");
out.println("</html>");

The problem is that specifying HTML in Java code is tedious,
error-prone, and cannot be written by a graphics designer. To im-
prove the situation, programmers can try to factor out common
HTML output elements into Java rendering objects like Table and
BulletList, but they are still embedding HTML all through their
servlets.

The next stage of evolution was the introduction of Java Server
Pages (JSP) [6], which at ﬁrst glance seemed to be a big step for-
ward. JSP ﬁles are essentially inside-out servlets, HTML ﬁles with
embedded Java code. JSP ﬁles are automatically translated to serv-
lets by the server. The same “hello” page looks like the following
in JSP:

<html>
<body>
<h1>JSP test</h1>
Hello, <%=request.getParameter("name")%>.
</body>
</html>

JSP ﬁles may start out as HTML ﬁles with simple references to
data, as in this example, but they quickly degenerate into fully en-
tangled code and HTML speciﬁcations like Servlets. In practice,
graphics designers also cannot modify JSP ﬁles. Most importantly
JSP encourages bad object-oriented design. For example, an in-
clude ﬁle is a poor substitute for class inheritance. JSP pages may
not be subclassed, which makes it hard for programmers to factor
out common code and HTML. Hunter [5] summarizes a few other
problems with JSP such as JSP’s inelegant looping mechanism to
display lists.

While JSP was not the answer, it did put the idea of a template
into programmers’ minds. A template is an HTML document with
“holes” in it that can be ﬁlled with data or the results of simple
actions. Unfortunately, just about every template engine repeats
the mistakes of JSP; they provide a Turing-complete tool-speciﬁc
programming language embedded in HTML. As with JSP, then,
designers are forced to imagine the emergent behavior of a program
rather than looking at a page exemplar.

While template engines have ﬁxed some of the annoying issues
with JSP, most fail to address the primary reason why JSP is a dis-
aster for large systems.1 A template should merely represent a view
of a data set and be totally divorced from the underlying data com-
putations whose results it will display. If the template language is
too powerful, template designers risk entangling template and busi-
ness logic. The following section details why such entanglement
should be avoided.

3. MOTIVATIONS FOR SEPARATION
The primary goal behind using a template engine is to separate
logic and data computations from the display of such data in both
thought and mechanism.
In the case of web site development,
this means roughly that there should be no code in HTML and no
HTML in code. Here some really good reasons why programmers
and designers want the separation:

1. encapsulation: the look of a site is fully contained within
templates and, likewise, the business logic is located entirely
in the data model. Each speciﬁcation is a complete entity.

2. clarity: a template is not a program whose emergent behav-
ior is an HTML page; a template is an HTML ﬁle that a de-
signer or programmer can read directly.

3. division of labor: a graphics designer can build the site
templates in parallel with the coders’ development efforts.
This reduces the load on programmers not only by having a
(usually less expensive) designer building the templates, but
by reducing communication costs; designers can tweak the
HTML without having to talk to a programmer. At jGuru.com
we repeatedly veriﬁed our ability to have our graphics de-
signer operate independently from our coders.

4. component reuse: just as programmers break large methods
down into smaller methods for clarity and reusability, de-
signers can easily factor templates into various sub-templates
1While the page URLs at jGuru.com end in .jsp, they are not JSP
ﬁles at all. After departing from JSP, we left the page names for
backward link compatibility.

225such as gutters, navigation bars, search box, data lists, and so
on. Entangled templates tend to be difﬁcult to factor and can-
not be reused with other data sources.

5. single-point-of-change: by being able to factor templates,
the designer can abstract out small elements like links and
larger items like user record views. In the future, to change
how every list of users, for example, appears on a site, the
designer simply changes one template ﬁle. This also avoids
the errors introduced by having multiple places to change a
single behavior. Having a single place to change a single be-
havior in the model is also important. Logic in the template
is to be avoided because “is admin user” logic is repeated in
many templates.

6. maintenance: changing the look of a site requires a tem-
plate change not a program change. Changing a program is
always much riskier than changing a template. In addition,
template changes do not require restarting a live, currently-
in-use server application whereas code changes normally re-
quire recompilations and restarts.

7. interchangeable views: with an entangled data model and
display, the designer cannot easily swap in a new look for
such things as site “skins.” At jGuru.com, each site look is a
collection of templates called a group. Some groups are rad-
ically different (as opposed to just changing some color pref-
erences and font sizes). A simple pointer tells the page con-
troller which template group to use when displaying pages.

8. security:

templates for page customization are commonly

made available to bloggers but, like macros in Microsoft Word,
unrestricted templates pose a serious security risk. After suf-
fering numerous attacks related to bloggers invoking class
loaders, squarespace.com switched from using Velocity [19]
to using StringTemplate. One could also imagine a sim-
ple, but effective attack in the form of an inﬁnite loop. Strictly
isolating the model from the view and disallowing control
structures, as championed in this paper, equals security.

Programmers often view strict separation as costing more time
and hassle. While this may be true in the small, such as adding a
new piece of data to a view, my experience is that projects progress
much faster in the long run and result in much more ﬂexible, robust
code speciﬁcally because of the signiﬁcant beneﬁts listed in this
section.

4. MODEL VIEW CONTROLLER PATTERN
The well-known model-view-controller pattern [9] applies nicely to
web server design and identiﬁes three general “realms” where var-
ious pieces of the page generation process belong. At the coarsest
level, the view represents a page’s template or templates, the con-
troller represents both the server’s dispatch infrastructure that maps
a URL to a code snippet and the code snippet itself, and the model
represents an application’s data (the “state”), most of the business
logic, and any model-related computations.

Unfortunately, programmers cannot agree precisely where to draw
the lines separating the three realms. A mailing list thread from
2002 entitled “separating C from V in MVC” [12] is representa-
tive of these arguments. This uncertainty arises mostly because the
boundaries between controller and model are usually blurred. In
contrast, there is widespread agreement that keeping the view as
simple and free from entanglements with model and controller as
possible is a worthwhile ideal to strive for.

In my experience, the controller should be as lightweight as pos-
sible. The controller acts like an event manager, dictating when a
page’s code is executed. The various page code snippets are also
part of the controller and should limit their activities to pulling the
appropriate data from the model, session, or parameters then push-
ing that data into the view. If the page is the target of an HTTP POST
or other processing page, the page triggers actions in the model. A
page may include some data processing speciﬁc to that page, but
in general it is best to factor out code from the page into the model
that affects the model or embodies a common operation. Long se-
quences of method calls to the model from a page should also be
extracted and refactored as a single method in the model. For ex-
ample, a page can do simple ﬁltering of data (probably using a
general purpose ﬁlter mechanism provided by the model) but an
operation like “process forum entry submission” should be coded
in the model and merely invoked by a processing page.

The model contains all of the business logic, computations, and
“state” (the persistence layer such as a database). I have seen stu-
dent projects and commercial programmers’ applications with SQL
statements in their controllers and, shockingly, in their views. Any
change to the schema forces changes to all SQL spread throughout
pages and views. SQL tables are rarely the appropriate level of ab-
straction anyway; a model should process raw database data into
objects and relationships between objects. The model also encap-
sulates commonly-executed operations such as “purchase book” or
“register and send email.”

The view should only specify how to display data processed by
the model and made available by the controller. A graphics de-
signer should feel very comfortable writing and manipulating view
speciﬁcations. The view should not be part of the program, mean-
ing that it should not alter the model nor process data. A good test
of how well the view is isolated is whether or not the view could
be used in another application. For example, if a template displays
a list of elements in a table, could the template be reused it in a
bookstore application or a forum hosting site?

Where to draw the line between the controller and model is some-
times fuzzy and depends on the application, but the line separating
them from the view is clear.

5. TEMPLATE DEFINITION
A literature search does not reveal a formal deﬁnition of a template
and, indeed, Hunter [5] lists this as one problem with the template
engine market. While the notion of a template is straightforward, a
formal treatment will provide a common nomenclature and a means
of classifying template engines and their generational power.

Fundamentally, an output template differs from a program that
generates output in that the template is an exemplar whereas the
program’s computation results in the output. A template is an out-
put document with embedded actions that the engine evaluates when
rendering the template. A JSP ﬁle is example of an unrestricted
template.

DEFINITION 1. An unrestricted template, T , is an alternating

list of output literals, ti, and action expressions, ei:

t0e0...tieiti+1...tnt ene

where any ti may be the empty string and ei is unrestricted compu-
tationally and syntactically. If there are no ei in T then T is just a
single literal, t0.

THEOREM 1. An unrestricted template is equivalent to an un-
restricted Chomsky type 0 grammar and, hence, may generate the
recursively enumerable languages.

226PROOF. Because ei is unrestricted computationally, it may em-
body a Turing machine and, thus, may generate the type 0 lan-
guages all by itself.

This result is self-evident and not very interesting, but it is worth
stating explicitly that unrestricted templates are the most powerful
and can generate any desirable output (i.e., anything a Turing ma-
chine can compute).

Generating a document in some language L may require multi-
ple, nested templates, therefore, individual literals ti and the output
of individual templates may or may not conform to L or even sub-
sentences of L.

Most often the literals are separated lexically from the expres-
sions with special symbols. For example, here is a simple template
using HTML::Template [18] that generates an HTML body:

<p>Hello, [% user %].

where t0 = “<p>Hello, ”, e0 = “$user$”, and t1 = “.”. The
expressions are embedded between literals and lexically-delimited
via [%...%], in this case.

A template may encode expressions using the surrounding lan-
guage’s lexicon in order to conform to L. For example, XMLC [2],
uses the HTML SPAN tag:

<p>Hello <SPAN id="user">Sample name</SPAN>.

Unrestricted templates can alter the model and can compute any
computable function. They can also use context information to al-
ter the output. For example, a template could specify that the color
of a table row i be a function of sin(i) with sin(i) being computed
using a Taylor series approximation coded inside the template it-
self.

Interestingly, by this deﬁnition of a template, XSL [20] style
sheets are not templates at all because style sheets specify a set
of XSLT tree transformations whose emergent behavior is an XML
or HTML document. XSL style sheets are programs like servlets,
albeit declarative in nature rather than imperative.

It is worthwhile to point out ﬁnally that, just because templates
are speciﬁed with a textual speciﬁcation, templates are not lim-
ited to generating text. For example, before generating text, many
source-to-source translators perform a series of tree transforma-
tions. Here is a template for an assignment tree using (an exper-
imental version of) ANTLR’s [14] LISP-like tree notation:

#(ASSIGN <ID> <expr>)

where ASSIGN is a literal root with two expressions for children,
<ID> and <expr>, whose values are computed and ﬁlled in before
constructing the tree.

6. RESTRICTED TEMPLATE CLASSES
Unrestricted templates are extremely powerful, but there is a direct
relationship between a template’s power and its ability to entan-
gle model and view. The more powerful a template, the closer it
becomes to a Turing-complete language. Further there is an in-
verse relationship between power and template suitability for non-
programmers such as graphics designers.

One of the biggest entanglement problems faced by unrestricted
templates is that a template can affect the model.
If a template
can modify the model, it is part of the program, hence, separating
model from view should begin by restricting a template to oper-
ate on a set of incoming read-only data values, called attributes,
that are computed by the model. Attributes may be single-valued

like 4521, multi-valued like as [Jim, Frank, John], or aggre-
gates like (name=Tom,ext=5322). References to undeﬁned/unset
attributes evaluate to the empty string.

Once templates are restricted to operate on a set of attributes to
prevent side-effects, the similarity to generational grammars leaps
out. Attributes are just the terminals (vocabulary) of a generational
grammar and templates are productions (rules). This connection
yields some interesting and useful results by leveraging work from
formal languages. For example, XML document type deﬁnitions
(DTDs) are essentially context-free grammars [8], therefore, a tem-
plate with the power of a context-free grammar can generate any
XML document deﬁnable with a DTD. It is satisfying to note that
a very simple template engine emulating a push down automaton
can generate XML documents and by design, as shown in section
8, enforces strict separation of model and view.

This section deﬁnes restricted classes of templates correspond-
ing to the Chomsky type 1..3 generational grammars [1]: context-
sensitive, context-free, and regular. Let’s start with the weakest
template class, type 3 regular grammars [16].

DEFINITION 2. A regular template is restricted to 0, 1, or 2
symbols. The ﬁrst symbol is either a literal t or an attribute ref-
erence a. The second symbol, if present, must be a reference to a
regular template. A regular template may be the empty string, . In
other words, templates are of the form t, a, tτ , aτ , or  where τ is
a template reference action. Attribute and template references are
side-effect free.

THEOREM 2. Regular templates generate the regular languages.

PROOF. Mirrors proof of Theorem 3 for context-free templates;
just restrict the derivation tree shape to have rule references and
corresponding template references only at the right edge of sub-
trees.

The more common regular expression equivalent provides an
easier way to think about regular templates. Templates may iterate
over a set of attributes and literals: ai and ti. In practice, templates
loop over a multi-valued attribute to display lists. The surprising
fact is that these minimal templates can do a lot. For example, the
following example, in the pseudo-regular expression notation of a
ﬁctional template engine, generates a <br> separated list of users:

( $names "<br>" )+

where the (...)+ “one or more” operator would know to walk
through the multiple values of the names attribute. Most template
engines would actually use a FOR-loop type structure like the fol-
lowing Velocity [19] template:

#foreach( $n in $names )
$n<br>
#end

To apply a template to each name in the list, however, requires
that the programmer reference another template in a loop in order
to apply the template to the list elements. That is a template must
be invoked at a non-right edge position. Imagine a designer wants
to factor out a list item template called item:

<li>$attr$</li>

where $attr$ is a reference to the attribute to which item is being
applied ($attr$ analogous to the this pointer in object-oriented
methods). A template can then apply the item sub-template to each
attribute in names with the following StringTemplate notation:

227<ul>
$names:item()$
</ul>

While one can express this particular output language using a
regular template, in general, there are output languages that reg-
ular templates cannot generate, since we know from formal lan-
guages [16] that there are languages that are inherently nonregular.
A template that supports general references to other templates cor-
responds to the context-free generational grammars.

DEFINITION 3. A context-free template is a template whose ac-
tions are limited to referencing attributes, ai and templates. A
context-free template may be empty. Actions are side-effect free.

THEOREM 3. Context-free templates generate the context-free

languages.

PROOF. (sketch) One can show equivalence of a context-free
grammar’s derivation tree for any sentence to a nested template tree
structure. The derivation tree for a context-free grammar has termi-
nal references at the leaves and nonterminals at the subtree roots. A
subtree corresponds to a rule application and has children that are
either terminals or other nonterminal subtrees. A template is a list
of literals, attribute references, and template references. By equat-
ing a template’s attributes and literals to terminals and template
references to nonterminals, one sees that there is always an equiv-
alent template for a derivation tree and vice versa. If a context-free
template is equivalent to a context-free grammar, the template gen-
erates the context-free languages.

To get an idea of the generational power of context-free gram-
mars, recall that parsers for most programming languages are im-
plemented via grammars accepted by LL- and LR-based parser
generators, which are subsets of the context-free grammars [17].
Therefore, a context-free template is sufﬁcient to generate output
conforming to the syntax of common programming languages.

Of more interest to the reader is that context-free templates can
generate any XML ﬁle conforming to a DTD, as DTDs are context-
free grammars. What about SGML? With its DTD exceptions, an
SGML DTD may indicate when a named element may appear or
not appear [8]. In a template, what if the designer needs to alter
output based upon context information? For example, a submenu
should only appear if the parent menu is active. Allowing context
to dictate when a template element may appear adds a great deal of
generational power and brings us to the context-sensitive template
class analogous to the context-sensitive grammars.

DEFINITION 4. A context-sensitive template is context-free tem-
plate augmented to allow predicated template application; that is,
a template augmented to allow template references or inclusion of
subtemplates only in certain grammatical context. Actions are at-
tribute references and template references. Predicates operate on
ai and the template tree structure itself. Actions and predicates are
side-effect free.

By limiting predicates to operations on ai and surrounding tem-
plate tree structure, predicates are limited to testing grammatical
context.
I suspect one could show an exact equivalence to the
context-sensitive grammars given the proper computation limita-
tions on actions, but these templates are of theoretical interest only.
In practice, it is best to avoid entanglement by performing all com-
putations in the model and pushing results into the template via
attributes. Once in the model, computations are unrestricted, there-
fore, template power moves directly from the context-free class to

the unrestricted class in practice. Milton and Fischer [11] claim
an analogous result that their predicated LL(k) parsers are Turing
complete because any predicate is Turing complete.

In the next section, I lay out the strict rules of separation and il-
lustrate illegal template constructs. Then in Section 8 I show which
template classes inherently enforce separation by design.

7. FORMAL SEPARATION
While programmers value simplicity, they more often value pow-
erful functionality and amazing “one-liners,” incurring the cost of
complexity. I cite the 29 parameters to Linux’s copy program, cp,
as an example. Existing templates engines burst with features and
power. Some [10] have tags built into the view that let programmers
send email and most others even provide (indirect) SQL access to a
database! These are obvious cases where the view has merged with
the model. Beyond the obvious, however, are numerous seemingly-
innocuous template features that entangle the view with the model
just as effectively.

Due to lack of formal deﬁnition of separation, template engines
provide functionality that allows programmers to violate separa-
tion routinely and, hence, template engines do not solve the prob-
lem that drove their development, losing all beneﬁts of separation
described above. For example, to support harmless functionality
such as “make all negative numbers red,” engines support attribute
value testing, which leads to egregious violations such as “if user is
James and host is wraith”. While many template features have both
harmless and improper uses, these features will inevitably be used
to violate separation either unwittingly or as an expedient.

Most engines provide only, admittedly useful and convenient,
organization of dynamic pages at the cost of learning a new pro-
gramming language or tool. Without strict enforcement of separa-
tion, a template engine provides tasty icing on the same old stale
cake. Consequently, do not consider an engine’s expressivity and
power. Consider, rather, how well it enforces separation. My goal
over the past ﬁve years building sites as well as the template engine
that drives them has been to toss out the stale cake, providing sufﬁ-
cient power while ruthlessly enforcing separation even though it is
annoying sometimes.

This section lists the rules that ensure separation of view from
model and controller, derived from an academic’s eye slugging
through the development of a large commercial server application.
While a programmer or designer may follow these rules using any
template engine without relying on enforcement, it requires ex-
treme discipline and exacts a high cognitive load.

Before formalizing my intuition, I kept a few simple rules and
tests in mind to evaluate entanglement. Could I reuse this template
with a completely different model? Could a designer understand
this template? If it looks like a program, it probably is.
If the
template can modify the model, it’s part of the program. If order
of execution is important, it’s part of the program. If the template
has computations or logic dependent on model data, it’s part of the
program. If types are important, the template is a program.

My approach to deﬁning separation is to ﬁrst dictate generally
which pieces belong in the model and which in the view in order to
make them self-contained or encapsulated. Then, I deﬁne the rules
concerning the interaction of model and view that prevent entan-
glement.

DEFINITION 5. A model is encapsulated if all logic and com-

putations dependent upon data values are done in the model.

Notice what this does not say. The view is not precluded from
computing sin(i) for row i in the template, for example. Model

228encapsulation simply means that the model must contain all com-
putations that are dependent on model data.

DEFINITION 6. A view is encapsulated if all layout and display

information is speciﬁed in the view.

There can be nothing in the model that indicates how the data

will be displayed by the view.

DEFINITION 7. Model and view are strictly separated if both
are encapsulated and, further, if the view cannot modify the model
and the view makes no assumptions about the types of model data.

This deﬁnition is distilled to the essential restrictions prevent-
ing entanglement, but in practice, strict separation has widespread
implications about what can and cannot be done in a model and
template.
In more concrete terms, here are the rules implied by
strict separation:

1. the view cannot modify the model either by directly al-
tering model data objects or by invoking methods on the
model that cause side-effects. That is, a template can access
data from the model and invoke methods, but such references
must be side-effect free. This rule arises partially because
data references must be order-insensitive. See Section 7.1.

2. the view cannot perform computations upon dependent
data values because the computations may change in the fu-
ture and they should be neatly encapsulated in the model in
any case. For example, the view cannot compute book sale
prices as “$price*.90”. To be independent of the model,
the view cannot make assumptions about the meaning of data.

3. the view cannot compare dependent data values, but can
test the properties of data such as presence/absence or length
of a multi-valued data value. Tests like
$bloodPressure<120
must be moved to the model as doctors like to keep reduc-
ing the max systolic pressure on us. Expressions in the view
must be replaced with a test for presence of a value simulat-
ing a boolean such as
$bloodPressureOk!=null
Template output can be conditional on model data and com-
putations, the conditional just has to be computed in the model.
Even simple tests that make negative values red should be
computed in the model; the right level of abstraction is usu-
ally something higher level such as “department x is losing
money.”

4. the view cannot make data type assumptions. Some type
assumptions are obvious when the view assumes a data value
is a date, for example, but more subtle type assumptions ap-
pear: If a template assumes $userID is an integer, the pro-
grammer cannot change this value to be a non-numeric in the
model without breaking the template. This rule forbids array
indexing such as colorCode[$topic] and $name[$ID]
The view further cannot call methods with arguments be-
cause (statically or dynamically) there is an assumed argu-
ment type, unless one could guarantee the model method
merely treated them as objects. Besides graphics designers
are not programmers; expecting them to invoke methods and
know what to pass is unrealistic.

5. data from the model must not contain display or layout
information. The model cannot pass any display informa-
tion to the view disguised as data values. This includes not
passing the name of a template to apply to other data values.

By dependent values, these rules refer to not only direct model
data references like $user or $model.getUser(), but also to lo-
cal template variables altered by logic dependent on model data.
For example,

#set interest = 0.08
#if ( $risk < 0.5 )

#set interest = 0.065

#endif
#set interestRate = interest*100

Here, variables interest and interestRate depend on model
data value $risk. Dependencies can clearly sneak up on you.

What about URLs? Is it proper to hard code URLs into tem-
plates? Strictly speaking, the URL structure of a site belongs to the
controller and should not be referenced as literals in templates.

The next section describes how a common strategy for template
data access is inherently unsafe, providing hidden “land mines” for
the template designer to step on inadvertently.
7.1 Pull Strategy Violates Separation
Consider a simple HTML page where the application needs to pull
a list of names from a database and display them; afterwards it
prints the number of elements in the list. The following template
pulls data from the model:

<html>
<body>
Names:
<p>
$model.getNames()
<p>
There were $model.getNumberOfNames() names.
</body>
</html>

the list

where $model.getNames() invokes a method on the model that
computes the list of names and pulls it into the template. The
$model.getNumberOfNames() reference asks the model to com-
pute and return the number of names. Because getNames() was
invoked ﬁrst,
length are available and
getNumberOfNames() can simply return the number. Now, what
if the designer wants to have the number of names in the <title>
of the page? That is, what if getNumberOfNames() must be called
ﬁrst? The model has not yet computed the list. At best the template
gets an invalid number; at worst, an exception. The only way to
remove this order dependency is to make getNumberOfNames()
call getNames() also.

and its

So, this simple data reference move in the template, which a
graphics designer would make without thinking, forces a dramatic
implementation change in the model. Similarly, changes in the de-
pendency graph caused by model code changes can break previously-
correct views. Unless a development team has extremely good test-
ing, which is very difﬁcult for dynamic web sites, changing the
model will inevitably and secretly break some site pages.

To avoid data reference order dependencies, use a push strategy.

DEFINITION 8. A template uses the push strategy if all data
used by the template is computed prior to template evaluation and
is available as a set of attributes ai.

Attributes are “pushed” into a template like a stream of tokens. In
contrast, an unrestricted template may pull from a data model via
functions.

DEFINITION 9. A template uses the pull strategy if any data
used by the template is computed on demand by invoking model
functions.

229THEOREM 4. A safe pull strategy degenerates to push in the

worst case.

PROOF. Model data values, hereafter referred to simply as at-
tributes, often depend on the values of other attributes. These de-
pendencies form a DAG, a directed acyclic graph. The graph is
acyclic in order to be well-deﬁned; for example, attribute ai can-
not depend on itself. To preserve correctness (to be safe), the view
may not request attributes from the model in an order that violates
a dependency in the graph.

In the worst case, the topologically sorted attribute dependency
DAG has a unique order. That is, the DAG forms a chain where
attribute ai depends on ai−1 (ai−1 → ai) and, hence, indirectly
an depends on all a1..an−1:

a1 → a2 → ... → an−1 → an

To compute an means the model must compute all other attributes
to preserve correctness. Because the designer might request an
ﬁrst thing in the view, the model must ﬁrst compute a1..an−1 and
then an. If an is the ﬁrst template expression e0, an is also com-
puted before the template generates any output text. Hence, all
attributes are computed a priori. Pull degenerates to push in the
worst case.
7.2 Entanglement Index
When evaluating template engines, it is useful to rank them accord-
ing to the level of entanglement allowed by the tool.

DEFINITION 10. A template engine’s entanglement index is the
number of separation rules that a template may violate. There are
5 separation rules and therefore the index runs from 1..5. The min-
imum index is 1 because there is no way to prevent attributes from
containing display and layout information.

StringTemplate makes it impossible to violate (decidable) sep-
aration by design and has the minimum index of 1. While working
on a template survey paper, I found that only HTML::Template
[18] and XMLC [2] have an index of 1. In contrast, the following
template engines have entanglement indices greater than 1: Tapestry,
WebMacro, Velocity, PTG, UniT, Tea, WebObjects, FreeMarker,
ColdFusion, Template Toolkit, and Mason.

FreeMarker has an entanglement index of 5 because it allows
arbitrary method calls into the model, violating rules 1 and 4. It
allows business logic in the template, violating rule 3. Finally, it
allows computations on attributes, violating rule 2.

Struts, a popular web application control framework, has no en-
tanglement index because it is not itself a template engine; it is
designed to work with other view systems like XSLT, Velocity,
JSP, and JSP Tag Libraries. A Struts-StringTemplate duo could
prove a useful combination.

Interestingly, there does not seem to be a middle ground. I have
concluded that engines are polarized either at index 1 or 5. This
implies adding engine features is a “slippery slope” and must be
done with care. Once an engine allows a violation, it must violate
others. For example, to allow method calls to the model (potentially
violating the side-effect free rule), an engine must violate the type
independence rule for the arguments.

8. ENFORCING SEPARATION
The rules of separation are strict, far-reaching, and seemingly ex-
tremely conﬁning. Two questions immediately come to mind: 1)
can we enforce the rules and 2) is the resulting template engine
useful?

In principle, an engine can enforce all rules except for one: it is
impossible to police the incoming attributes to determine whether

a model or controller is passing display information or links into
a template. For example, is attribute value Red a color or a man’s
name?

As for the other four separation rules, one could retroﬁt unre-
stricted template engines with a combination of static and run-time
checks in an attempt to catch violations and warn the program-
mer, but my intuition is that there are lots of undecidable prob-
lems. A better approach is to start with an overly-restricted tem-
plate and gradually add power ensuring constructs adhere to the
separation principle. This section mirrors the evolution path fol-
lowed by StringTemplate.

Start with a text document ﬁlled with “holes” where a program-
mer or designer can stick single or multi-valued read-only data val-
ues called attributes. This single assumption, that templates op-
erate purely on attributes, allows us to relate templates to formal
language grammars, provides data reference order independence
since data references cannot have side-effects, and ensures tem-
plates cannot modify the model. By deﬁnition, this template allows
no computations. Attributes are inert stones dropped in a soup. To
use an analogy from chemistry, data should mix and not react with
the surrounding template. A document with attribute references is
a regular template.

Factoring a large template into subtemplates is useful and clearly
safe, so engines can support includes. A more sophisticated version
of an include is a macro invocation because macros have named
parameters that ﬁll holes in the included template. The parameters
naturally are just another scope of attributes sent into the subtem-
plate. As a trivial example, consider deﬁning a template called
bold:
<b>$attr$</b>

The template can call bold like a macro: bold(attr=name). A
slight notation change allows “template application” functionality,
leading to the equivalent operation: name:bold(). If name were
multi-valued, bold would be applied to each element in the list
resulting in another list of, altered, attributes like LISP’s map. This
construct eliminates the need for explicit FOR-loops.

Add recursion so that a template can invoke itself directly or in-
directly and the template arrives at the context-free class. With just
attribute reference, template application, and template recursion, an
application can, thus, generate any XML document that has a DTD
without violating any rules of separation.

Do we need more power? That is, do we need the power of
context-sensitive templates? Context-sensitive templates are useful
for tasks such as switching in a logged in or logged out version of
a gutter and, more importantly, for handling conditionally included
literals (or subtemplates) such as

$if(title)$
<h1>$title$</h1>
$endif$

The <h1> tags should appear only if the title attribute is present.
A template can only test the presence or absence of attributes
rather than full expressions because tests against attribute values
violate separation. These restricted IF constructs deﬁnitely pull
templates beyond context-free templates into the context-sensitive
range, but how far? Surely full expressions are more powerful. In-
deed they are, but programmers can always compute whatever they
want in the model and set an attribute or leave it empty, simulating
a boolean with the same result as if they had computed the expres-
sion in the view.

By adding an IF construct that can test results of unrestricted
computations in the model, it is likely that the separated model-
view duo is as powerful as an unrestricted template. So, in answer

230to the second question regarding usefulness, yes: a model-view duo
achieves essentially unrestricted power without violating any rules
of separation.

8.1 Attribute Rendering
Benjamin Geer [4], the original author of FreeMarker [3], posed
a seemingly unresolvable conundrum for an engine enforcing sep-
aration. Consider the escape of “<” characters to HTML format,
“&lt;”, exemplifying a common class of rendering operations such
as string abbreviation, date formatting, and case conversion. The
model may not escape a data string a priori and send it to the tem-
plate without violating separation because “&lt;” is clearly display
information. The template may not examine an incoming string
looking for “<” characters to do the necessary replacements. The
template also may not invoke a method on the model that computes
escaped strings. How then does one escape strings, a common and
necessary operation?

The inescapable fact is that there must be some Java code some-
where that computes HTML escape sequences because the compu-
tation cannot be done in the template. Besides, Java already pro-
vides heavy support, such as the java.text package, for dealing
with text, numbers, dates, and so on. Since neither the model nor
the controller may contain this computation, the code must exist
elsewhere. It turns out that there is a silent partner in the MVC
pattern at work already where these types of attribute rendering op-
erations properly belong.

To expose the silent partner, consider that for every integer at-
tribute passed to a template, the template engine implicitly calls
the attribute’s toString() method with our tacit approval. The
collection of toString() methods of all incoming attribute types
embody an aspect [7], perhaps suggesting a more complete design
pattern name when referring to HTML page generation: MVCR
(model-view-controller-renderer) where the renderer encapsulates
the conversion of objects to displayable character strings.

There is a subtle, but critical distinction between view and ren-
derer. A template is mainly concerned with page and attribute lay-
out plus text properties like color and size. The renderer, on the
other hand, is concerned with converting attributes (or, in the case
of aggregates, the constituent components) to displayable strings
of characters. For example, the renderer decides whether to render
negative integers as (23) instead of -23, but the template decides
where on the page the number goes, how big it is, what color it is,
whether it is a link, etc...

To solve the HTML character escape paradox, then, the con-

troller can simply wrap string attributes with an object whose
toString() method escapes special characters. When the tem-
plate renders to text, strings will be escaped properly. For other
attributes, wrappers might delegate to standard Java libraries. The
controller acts like a station in an assembly line from the model to
the view that adds a paint job to certain objects. The toString()
methods in standard types and in all wrapper objects used by an
application embody the renderer.
It makes sense to encapsulate
wrapper objects in, say, an enclosing HTMLRenderer class. The
fact that this class can be reused with just about any web applica-
tion lends credence to the fact that the rendering code is not part of
a particular application’s model.

Each template may have its own renderer. The controller can as-
sign different renderers in response to page requests from different
locales. In addition, a view-renderer pair could automatically per-
form routine operations like escaping strings, thus, often relieving
the controller from having to speciﬁcally wrap attributes.

Asking an attribute to render itself ﬁts nicely within our object-
oriented mindset and establishes a boundary that cleaves the con-

ventional view component into both view and renderer, yielding
the MVCR pattern. The renderer neatly solves Geer’s conundrum
and comparable problems. Just as a template may access an unre-
stricted model computation through the decoupling mechanism of
testing the presence/absence of an attribute, templates may access
unrestricted rendering computations performed in the renderer via
the narrow conduit of the toString() method without violating
model-view separation.

Some readers will argue that the MVCR pattern is merely a clev-
erly worded disguise, opening a potential loophole for violations of
model-view separation. A renderer will contain code using string
literals containing display information and, worse, a renderer could
potentially contain code that modiﬁed an application’s model. First,
recognize that there is no way around allowing objects to render
themselves with the toString() method. Either integers get con-
verted from 32-bit binary words to strings of digit characters or
servers cannot generate web pages, using templates or otherwise.
Preventing abuse of this mechanism is undecidable and engines al-
ready take a hit for this vulnerability, accounted for in the minimum
entanglement index of 1; though, one should consider factoring out
HTML literals even in the renderer into ﬁne-grained templates to
completely avoid HTML in code. Second, formalizing the ren-
derer and encapsulating rendering operations into an application
independent service allows the renderer for a given target language
such as HTML to be supplied with an engine. Because the ren-
derer will not be part of a speciﬁc application, it cannot constitute
an entanglement of an application’s model and view. Technically a
programmer could alter the HTML renderer or attach a ”malicious”
renderer that altered a speciﬁc model’s data, but that risk already
exists: someone could easily alter the source for a strict engine to
allow violations.
8.2 Enforcement vs Encouragement
Programmers crave ﬂexibility. Whether they sacriﬁce a little ﬂex-
ibility in order to enforce valuable principles depends on their ex-
perience and philosophy derived from that experience. If they have
learned the hard way that sometimes even geniuses make mistakes
or do the expedient thing, they will ﬁght to make mechanisms work
correctly by design. Remember that Murphy’s original law, “if it
can be done wrong, it will be done wrong,” arose from someone
installing accelerometers the wrong way during a rocket sled test,
unnecessarily stressing the test pilot’s body. The reader may also
recall computers in the 1980’s where the keyboard and modem con-
nectors were identical; many people fried their keyboard by acci-
dent.

It is wiser to enforce rather than merely encourage good behav-
ior even if the imposed restrictions chafe a little. The main reason
programmers have moved to new template engines in the ﬁrst place
is to avoid the entanglements found with original systems like JSP
and the ilk. I submit that re-implementing JSP and adding a com-
ment in the manual encouraging un-JSP like behavior is insufﬁ-
cient. My philosophy with StringTemplate has been to build
outwards from safety, adding functionality while adhering strictly
to my principles.

9. STRINGTEMPLATE
StringTemplate [13] is a template library carefully designed by
myself and Tom Burns (CEO, jGuru.com) over many years of ex-
perience building commercial sites including jGuru.com, knows-
pam.net, and antlr.org. StringTemplate evolved from a sim-
ple “document with holes” to a sophisticated template engine that,
much to my surprise, has a distinctly functional programming ﬂa-
vor. While functional programming languages have never been my

231forte, StringTemplate’s language evolved naturally according to
my needs: side effect-free expressions, expression order indepen-
dence, template application to a list of data objects, nested (that
is, recursive) application of templates, and simplicity to make tem-
plates accessible to my graphics designer. StringTemplate’s de-
sign is optimized for enforcement of separation not for Turing com-
pleteness nor amazingly-expressive “one-liners”. The simple name
StringTemplate reﬂects my minimalist approach (its jar is about
120k with source and binaries).

StringTemplate enforces separation of model and view with
the exceptions that it cannot enforce the undecidable problem of
passing display information to the view via attributes. We repeat-
edly veriﬁed that a nonprogrammer graphics designer can operate
independently from the site coders. Once our designer knew what
templates she could ﬁll in and what attributes she could reference,
she was able to build multiple site looks (branding for customers)
totally independently.

In addition to the power of its template expression language,
StringTemplate promotes heavy site component reuse, supports
multiple site “skins” (a skin is simply a group of templates), pro-
vides template inheritance between skins so the designer can build
new site skins as they differ from existing skins, allows site designs
to be updated on a live server, and alleviates the need for controller
page code to manually generate HTML or subtemplates.

When discussing template engines, programmers will ask how a
particular engine handles some interesting output tasks. The next
sections demonstrate how StringTemplate expresses ﬁlling a ta-
ble, alternating the row colors in a table, and generating hierarchi-
cal menus. The examples illustrate the two crucial features that
alleviate the need for looping constructs and just about every other
common language construct: template application to a multi-valued
attribute (like LISP’s map) and template recursion.
9.1 Fill a table example
Imagine we have objects of type User that we will pull from a
simulated database:
public class User {

String name;
int age;
...

}
static User[] list = new User[] {

new User("Boris", 39),
...

};

Push the user list as attribute users into a template, say st, with
the following Java code:

st.setAttribute("users", list);

To generate a table like this:

<table border=1>
<tr><td>Boris</td><td>39</td></tr>
<tr><td>Natasha</td><td>31</td></tr>
...
</table>

apply an anonymous template to each user object:

where attr is the default attribute name that varies automatically
as StringTemplate iterates over users. attr.name accesses
the name property of the incoming User object via the getName()
method. The anonymous row template can also be factored out into
a template called row:

<tr><td>$attr.name$</td><td>$attr.age$</td></tr>

reducing the main template to the more readable:

<table border=1>
$users:row()$
</table>

The result of a template application is another list. Templates can
be applied to the results of other template applications. In the fol-
lowing example, each element of a list is bolded and then made a
<ul> bullet item.

<ul>
$aList:{<b>$attr$</b>}:{<li>$attr$</li>}$
</ul>
9.2 Alternating table row colors
Graphics designers often format lists with alternating element back-
ground color:

<table border=1>
<tr><td>Boris</td><td>39</td></tr>
<tr><td bgcolor=#F6F6F6>Natasha</td><td>31</td></tr>
<tr><td>Jorge</td><td>25</td></tr>
...
</table>

Rather than resort to a FOR-loop with a nested IF, just provide a
comma-separated list of templates to apply round-robin to the list
elements.

<table border=1>
$users:rowBlue(), rowGreen()$
</table>
9.3 Hierarchical menus
Why would anyone ever need recursion in a template? Consider
doing hierarchical menus. Without recursion, the template needs
complicated nested FOR loops and IF structures. A hierarchy is
a recursive structure and cries out for recursion to walk the tree.
An engine without recursion will simply not deal naturally with
recursive data structures. For our purposes, assume each item in a
menu has a title, a url, a possible list of submenu items, and whether
a particular submenu is active:
public class TreeMenuItem {

String title;
String url;
boolean active = false;
List submenu;
...

}

In the gutter of the overall page template, apply template menuItem

to the main list of choices:

$choices:menuItem()$

<table border=1>
$users:{
<tr><td>$attr.name$</td><td>$attr.age$</td></tr>
}$
</table>

A non-recursive template that generates only the top layer as a

list of links looks like this:

<a href=$attr.url$>$attr.title$</a>

232Output might look like:

<a href=/>home</a>
<a href=/news>news</a>
...

To handle submenus, have the template iterate (tail-recursively)
over the list of submenu items if that menu is active.

<a href=$attr.url$>$attr.title$</a>
$if(attr.active)$
$attr.submenu:menuItem()$
$endif$

While the table ﬁlling examples use only context-free template con-
structs, this recursive menu example requires context-sensitivity in
order to show only active submenus. Also note that no display in-
formation needs to be passed in as an attribute.

Programmers often ask how to encode a complicated algorithm
in a template. The key lesson shown in this hierarchical menu
example is that messy computations and control-ﬂow constructs
are easily avoided in a template through judicious choice of data-
structure, mirroring the relationship, say, between a state machine’s
trivial engine and its highly-interconnected state network. For ex-
ample, language parser state machine construction is not easy, but
walking the resulting states to actually parse sentences is very easy.
Indeed the code to construct states dwarfs the tiny parsing engine.
Parser construction is analogous to the controller-model pair orga-
nizing a data structure or structures; the template engine is analo-
gous to the parsing engine.

10. CONCLUSIONS
Strictly separating model and view is an extremely desirable goal
because it increases ﬂexibility, reduces maintenance costs, and al-
lows coders and designers to work in parallel. Template engines
evolved in response to previous technologies such as JSP and the ilk
that entangle model and view. Unfortunately, engines merely en-
courage separation while still supporting constructs that allow pro-
grammers to violate separation. Programmers will often use these
constructs as an expedient or because of lack of experience, thus,
current engines provide unclear advantages over JSP (although most
engines provide very handy frameworks besides templates for build-
ing web applications).

Existing engines do not enforce separation because there was no
formal deﬁnition of separation nor list of rules to guide them. It
is also against a programmer’s nature to limit functionality, fearing
that enforcing separation implies a critically weak engine. I also
wonder if engine designers get caught up having fun implementing
languages without regard to overall principles.

I have shown that we can, in fact, build a template engine that
strictly enforces all decidable rules of separation by design.
StringTemplate is sufﬁciently powerful empirically to generate
numerous complicated sites such as jGuru.com and, moreover, the
pages are simple and sufﬁciently unentangled to be built by a graph-
ics designer not a programmer.

By showing the relationship between restricted templates and
generational grammars, I conclude that restricted templates can
generate interesting classes of languages such as those described by
XML DTDs and beyond into the context-sensitive and unrestricted
languages.

Given a clear deﬁnition of model-view separation, template en-
gine designers may no longer claim enforcement of separation with-
out an entanglement index of 1. More importantly, given theoret-
ical arguments and empirical evidence, engines no longer have an
excuse to support entanglement, fearing weak generational power.

I am currently investigating the use of template engines to sup-
port powerful and reusable language translators for the next genera-
tion of the ANTLR parser generator. StringTemplate is released
under the BSD license at http://www.stringtemplate.org

11. ACKNOWLEDGEMENTS
I would like thank to John Witchel for motivating me to formalize
my thoughts regarding MVC separation and Monty Zukowski for
planting the template “meme” in my head back in 1995. I thank
Chris Brooks and David Galles for their detailed reviews. Matthew
Ford provided very valuable feedback on both the ideas contained
herein and the source code for my engine. I thank Benjamin Geer
for his review work and for pointing out ﬂaws in my arguments.

12. REFERENCES
[1] N. Chomsky. Aspects of the Theory of Syntax. MIT Press,

1965.

[2] Enhydra. XMLC.

http://xmlc.enhydra.org/project/aboutProject/index.html.

[3] FreeMarker. http://freemarker.sourceforge.net.
[4] B. Geer. Private communications.
[5] J. Hunter. The problems with JSP.

http://www.servlets.com/soapbox/problems-jsp.html.

[6] JSP. http://java.sun.com/products/jsp.
[7] G. Kiczales, J. Lamping, A. Menhdhekar, C. Maeda,

C. Lopes, J.-M. Loingtier, and J. Irwin. Aspect-oriented
programming. In Proceedings European Conference on
Object-Oriented Programming, volume 1241, pages
220–242. Springer-Verlag, 1997.

[8] P. Kilpelainen and D. Wood. SGML and XML document
grammars and exceptions. Information and Computation,
169(2):230–251, 2001.

[9] G. Krasner and S. Pope. A description of the

model-view-controller user interface paradigm in the
smalltalk-80 system. Journal of Object Oriented
Programming, 1(3):26–49, 1988.

[10] Macromedia. Coldfusion.

http://www.macromedia.com/software/coldfusion.

[11] D. R. Milton and C. N. Fischer. LL(k) parsing for attributed

grammars. In International Conference on Automata,
Languages, and Programming, pages 422–430, 1979.

[12] Separating C from V in MVC.

http://mathforum.org/epigone/modperl/jilgygland, 2002.

[13] T. Parr. StringTemplate documentation.

http://www.antlr.org/stringtemplate/index.tml, September
2003.

[14] T. J. Parr and R. W. Quong. ANTLR: A predicated-LL(k)

parser generator. Software Practice and Experience,
25(7):789–810, 1995.

[15] Servlets. http://java.sun.com/products/servlet/.
[16] S. Sippu and E. Soisalon-Soininen. Parsing Theory I.

Springer-Verlag, 1988.

[17] S. Sippu and E. Soisalon-Soininen. Parsing Theory II.

Springer-Verlag, 1988.

[18] S. Tregar. HTML::Template.

http://html-template.sourceforge.net.

[19] Velocity. http://jakarta.apache.org/velocity/index.html.
[20] XSL style sheets. http://www.w3.org/Style/XSL/.

233