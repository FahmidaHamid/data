Augmenting Semantic Web Service Description With

Compositional Speciﬁcation

Monika Solanki
Software Technology
Research Laboratory

The Gateway

Leicester LE1 9BH, UK
monika@dmu.ac.uk

Antonio Cau

Software Technology
Research Laboratory

The Gateway

Leicester LE1 9BH, UK
acau@dmu.ac.uk

Hussein Zedan
Software Technology
Research Laboratory

The Gateway

Leicester LE1 9BH, UK
zedan@dmu.ac.uk

ABSTRACT
Current ontological speciﬁcations for semantically describing prop-
erties of Web services are limited to their static interface descrip-
tion. Normally for proving properties of service compositions, map-
ping input/output parameters and specifying the pre/post conditions
are found to be sufﬁcient. However, these properties are assertions
only on the initial and ﬁnal states of the service respectively. They
do not help in specifying/verifying ongoing behaviour of an indi-
vidual service or a composed system. We propose a framework
for enriching semantic service descriptions with two compositional
assertions: assumption and commitment that facilitate reasoning
about service composition and veriﬁcation of their integration. The
technique is based on Interval Temporal Logic(ITL): a sound for-
malism for specifying and proving temporal properties of systems.
Our approach utilizes the recently proposed Semantic Web Rule
Language.

Categories and Subject Descriptors
D.3.2 [Language Classiﬁcations]: Constraint and logic languages;
F.4.1 [Mathematical Logic]: Temporal Logic; D.3.3 [Programming
Languages]: General—standards

General Terms
Languages, Theory, Veriﬁcation

Keywords
Semantic Web services, Web services, Interval Temporal Logic,
OWL, OWL-S, SWRL, Assumption - Commitment

1.

INTRODUCTION AND MOTIVATION

Markup languages for speciﬁcations of Web services are set to
play an important role in enabling dynamic service discovery and
composition by human users and software agents. There is a plethora
of languages proposed by academic and industrial research groups
for service description, discovery and composition with XML as
their backbone. The semantic web has contributed substantially via
providing ontology description languages like OWL [12]. Promi-
nent efforts can be seen in the form of OWL-S [23]: an ontology
for describing proﬁle, process and grounding models for a service.
Related work is also being done in the form of IRS (Internet Rea-
soning Services) [19].
Copyright is held by the author/owner(s).
WWW2004, May 17–22, 2004, New York, New York, USA.
ACM 1-58113-844-X/04/0005.

The Current Web service description languages however suffer
from the lack of their ability to provide constructs and concepts
that enable reasoning about runtime service behaviour. Languages
like WSDL [21] and BPEL4WS [24] do not have the provision for
specifying the conditions a service provider would want to impose
on its environment to guarantee a valid service execution. Similarly
there are no ways for the service provider to describe what asser-
tions would be true once the service has been executed. OWL-S
does provide concepts like preconditions and conditional effects.
The WSMF [5] deﬁnes pre- and post-conditions for services. These
contribute to some extent towards their behavioural description.
However pre/post-conditions and effects are limited to static de-
scriptions. They are required to hold only at the initial and ﬁnal
states of the service execution.

In a scenario where Web services are black boxes and the client
or the service requester (human/agent) has no control over the var-
ious stages of service execution, it becomes necessary to enrich
the service description with certain properties which would enable
reasoning about service behaviour while it is in execution. The
need for such rich speciﬁcations becomes evident while reasoning
about the composition of services and veriﬁcation of the composi-
tion. Current composition planners/engines [25, 22] use input/out-
put mapping, type characteristics of these parameters and initial,
ﬁnal state predicates to generate compositions/plans. However, to
ensure a sound composition, services need to be composed using a
speciﬁcation technique that characterizes ongoing behaviour of the
service.

Further, since Web services abstract implementation details, com-
posing agents (human/software) have no means to validate an on-
going composition and take appropriate measures in case the speci-
ﬁcations cease to be satisﬁed. Behavioural speciﬁcation of services
should include assertions that not only validate their initial and ﬁ-
nal states, but also their intermediate states. These states could be
critical decision making stages during computation or the states at
which messages are exchanged between the services. The ration-
ale for these additional observables become more apparent while
composing services that execute concurrently as the possibility of
synchronization and communication between the services make the
intermediate states as important as the initial and ﬁnal one. More-
over with such properties in hand, veriﬁcation of the composition
at runtime is reduced to checking the assertions required to hold
by every service in the composition using an engine designed to
handle temporal properties.

We propose a methodology to augment the semantic description
of a service with temporal properties formally called assumption

544and commitment1. The properties are speciﬁed in Interval Temporal
Logic(ITL) [17, 18, 16, 2], our underlying formalism for reasoning
about service behaviour over periods of time. These assertions are
speciﬁed using predicates in ﬁrst order logic with temporal opera-
tors only over their observable behaviour and do not depend on any
additional knowledge about the underlying execution mechanism
of the services. Further, we show that such assertional speciﬁca-
tions are compositional and this strategy can be effectively applied
for the veriﬁcation of a composed service on the basis of the spec-
iﬁcation of the individual services. The formalism thus provides a
powerful technique for reasoning about service composition, exe-
cution and runtime veriﬁcation of service behaviour.

We choose OWL-S: an OWL ontology as our starting point for
specifying these properties. OWL-S scores highly in expressive-
ness over other languages. OWL has well-deﬁned semantics in
description logic. OWL-S has operational semantics deﬁned in
Petri Nets [20] and subtype polymorphism [4]. Although other lan-
guages for Web service descriptions claim to have semantics de-
ﬁned in Pi-calculus/Petri nets, there are no documents supporting
the same. Recently a preliminary proposal for a rule language has
been put forward to express rules and constraints [9] in the frame-
work of the OWL language. This allows us to express property
predicates as an OWL ontology. In this paper we show how the
compositional properties of A - C can be expressed as a SWRL on-
tology. This representation can be made a part of the process model
in OWL-S. Our approach differs from conventional approaches as
we consider validation and veriﬁcation to be an integral part of ser-
vice composition. This also makes it readily applicable to the exe-
cution monitoring model proposed in OWL-S.

The paper is structured as follows: Section 2 describes the princi-
ple of Compositionality. Section 3 discusses the “A - C” paradigm.
Section 4 describes the ITL formalization of A - C and its appli-
cation to Web services. Section 5 discusses OWL-S and SWRL.
Section 6 describes how the A - C properties can be expressed as
a SWRL representation. Section 5 proposes composition rules and
their proof obligations for introducing compositionality in service
speciﬁcations. Section 8 presents an example of an auction service.
Section 9 discusses runtime veriﬁcation techniques using AnaTem-
pura. Section 10 outlines conclusion and future work.

2. COMPOSITIONALITY

Compositionality [6] refers to the technical property that enables
reasoning about a composed system on the basis of its constituent
parts without any additional need for information about the imple-
mentation of those parts. The notion of compositionality is very
important in computer science as it facilitates modular design and
maintenance of complex systems. Compositionality is also a de-
sired criterion for veriﬁcation methodologies, particularly for the
development and analysis of large scale systems. The idea was ﬁrst
formulated by Edsger W. Dijkstra [7]. For reasoning satisfacto-
rily about composed system, we only require that systems and their
components are speciﬁed using predicates. The principle of com-
positionality can be readily applied to Web services. Reasoning
about compositions is facilitated using compositional principles,
rules and their proof obligations, on the predicates derived from
service descriptions stored in some repository by a preprocessor or
a reasoning engine.

1also referred to as A - C.

φ

A

k

C

k+1

ψ

Figure 1: Assumption-Commitment

3. THE ASSUMPTION - COMMITMENT

PARADIGM

The A - C framework is a compositional speciﬁcation method-
ology. It was ﬁrst discovered by Jayadev Misra and Mani Chandy
[13] as a proof technique for networks of processes executing con-
currently via synchronous message passing. A related technique for
shared variable concurrency was proposed by Cliff Jones in [11].
The objective is to specify a process within a network. Formally an
A - C formula has the following form:

(A, C) : {φ}P {ψ}

(1)

where P denotes a process and A, φ, ψ, C denote predicates. In-
formally an A - C formula has the following meaning:
if φ holds in the initial state, including the communication history
in which P starts its execution then

• C holds initially and C holds after every communication pro-

vided A holds after all preceding communication and

• If P terminates and A holds after all previous communica-
tion (including the last one) then ψ holds in the ﬁnal state
including the ﬁnal communication history

An equivalent deﬁnition for (1) using induction (ref. Fig. 1) can be
deﬁned as :

1. if φ holds initially in P then C holds initially in P .

2. if φ holds initially in P and A holds upto the kth point in P ,

then C holds up to the k + 1th point for all k ≥ 0 and,

3. if φ holds initially in P and A holds at all times during P ,

and P terminates, then ψ holds on termination.

Here A expresses an assumption describing the expected behaviour
of the environment of P . C expresses a commitment which is guar-
anteed by the process P as long as the environment does not vio-
late the assumption A and φ and ψ express pre- and post-conditions
upon the state of P . A and C are required to hold for both termi-
nated and nonterminated computation.

4. FORMALISING ASSUMPTION-

COMMITMENT IN ITL

ITL is a ﬂexible notation for both propositional and ﬁrst-order
reasoning about periods of time. Tempura: an executable subset
of ITL, provides a framework for developing, analysing and ex-
perimenting with suitable ITL speciﬁcations. The syntax of ITL
is deﬁned in Fig. 2 where µ is an integer value, a is a static vari-
able (doesn’t change within an interval), A is a state variable (can
change within an interval), v a static or state variable, g is a func-
tion symbol and p is a predicate symbol.

ITL contains conventional propositional operators such as ∧, ¬
and ﬁrst order ones such as ∀ and =. There are temporal operators
like “; (chop)”, “* (chopstar)” and “skip”. Additionally in ITL,

545Expressions

Formulae

e ::= µ | a | A | g(e1, . . . , en) | ıa : f
f ::= p(e1, . . . , en) | ¬f | f1 ∧ f2 | ∀v q f | skip | f1 ; f2 | f ∗

Figure 2: Syntax of ITL

there are temporal operators like (cid:13) and 2. Expressions and For-
mulae are evaluated relative to the beginning of an interval.

The informal semantics of the most interesting constructs are as

follows:

• ia : f : the value of a such that f holds.

• skip : unit interval ( length 1).

• f1; f2 : holds if the interval can be chopped into a preﬁx and
a sufﬁx interval such that f1 holds over the preﬁx and f2 over
the sufﬁx.

• f ∗ : holds if the interval is decomposable into a number of

intervals such that for each of them f holds.

Some of the frequently used abbreviations are listed in
Table 1.

Table 1: Frequently used temporal abbreviations

b= skip ; f
(cid:13)f
more b= (cid:13)true
empty b= ¬more
b= ﬁnite ; f
3f
b= ¬3¬f
2f
b= 2(empty ⊃ f )
ﬁn f
(cid:13)w f
b= ¬ (cid:13)¬f
b= f ; true
3i f
b= ¬(3i ¬f )
2i f
b= ﬁnite ; f ; true
3a f
b= ¬(3a ¬f )
2a f

next
non-empty interval
empty interval
sometimes
always
ﬁnal state
weak next
some initial subinterval
all initial subintervals
some subinterval
all subintervals

4.1 Application to Web services

Composed Web services are independently executing compo-
nents communicating via message passing to yield the desired be-
haviour. Since the A - C paradigm offers compositional proof tech-
niques for specifying and verifying composed system, communi-
cating via message passing, it lends itself readily for application
in the domain of Web services. For our purpose we need to use a
variant of the formalism which is somewhat different in spirit from
the classical compositional reasoning. We redeﬁne the paradigm as
below:

TheAssumption-Commitmentparadigmisacomposi-
tionalspeciﬁcationandveriﬁcationtechniquethatcan
be applied to services or networks of services, com-
posed to execute sequentially or concurrently. The
paradigm provides compositional rules whose proof
obligationsensuressoundnessofthecomposition. The
validityof theproofobligations orveriﬁcationcondi-
tionscanbecheckedatthedesignstageforstaticanal-
ysisofthecomposedsystem,andcanalsobechecked
atruntime using atheorem prover withactualparam-
eters. The Assumption-Commitment paradigm thus
providesapowerfultechniqueforreasoningaboutser-
vices that can be composed and once they are com-
posed, it helps in validating the integrity of the com-
positionatruntime.

The assertions required for formulating A - C in this scenario are
quite general. Conventionally, assumptions are predicates required
to be true by the environment of a service. For a service execut-
ing as part of a network, the environment is composed of all other
services executing in the network. In the original formalism, as-
sumptions are predicates over the channel variables. We relax this
notion and require assumption to be an ongoing temporal property
including constraints on the input parameters that a service provider
demands to be true as long as his service is in execution. The as-
sertions for the commitment can be any temporal property of the
service which the provider wishes to expose as a guarantee to the
assumption.

4.2 An ITL formalization of Assumption-

Commitment

A Service, S in ITL is expressed as a quadruple (ω, As, Co, ω

′

)

where,

ω
As

Co

′

ω

: state formula about initial state
: a temporal formula specifying properties
about the environment
: a temporal formula specifying properties
about the service
: state formula about ﬁnal state

Validity of an A-C formula,

|= (As, Co) : {ω}S{ω

′

}

inductively deﬁned in ITL, has the following intuitive meaning:

• if ω holds in the initial state, in which S starts its execution

then Co holds initially in S.

• if ω holds initially in S and, As holds upto the σkth state in

S, then Co holds upto the σk+1th state for all k ≥ 0.

• if ω holds initially in S and, As holds at all previous states,

before S terminates then ω

′ holds on termination.

k+1

k

               

w

′

w

 

 


 

 


 

 


 

 


As ∧ Co

skip

Figure 3: ITL representation of Assumption-Commitment

Co

Formally in ITL, the validity of the A - C representation (ref. Fig.
3) has the following form :

(As, Co) : {ω}S{ω

}

′

def
= S ⊃

ω ∧ 2i ((As ∧ Co) ; skip ⊃ Co) ∧ ﬁn ω

′

5465. OWL-S AND SWRL

OWL-S is an OWL ontology for the speciﬁcation of services. It
is structured to provide three types of information about a service.
The service proﬁle provides a representation of properties and ca-
pabilities that can be used by a service requester to specify their
needs and service providers to advertise their services for “what” it
does. The process model describes “how” the service “serves”. It
provides concepts for specifying the functional attributes of a ser-
vice in the form of Inputs, (Conditional)Outputs, Preconditions and
(Conditional)Effects. It also provides constructs for service com-
position. The Grounding maps process parameters to correspond-
ing WSDL representation of inter-service communication aspects
of the service, in terms of the message formats, protocols and com-
munication ports.

Our interest lies in augmenting the Process model with A - C
properties. Since assumptions and commitments are temporal for-
mulae, we need an extension to the core ontology that allows us to
express them. SWRL [9] is a preliminary proposal for a rule lan-
guage designed to express rules and constraints in the framework
of the OWL language. Related work for specifying rules within
the domain of Semantic web are initiatives like RuleML [3] and
DRS [8]. However SWRL gives us the ﬂexibility to remain within
the domain of OWL. A Concrete XML and RDF syntax are part of
the current speciﬁcation of the language. In this paper we present
our example using the RDF/XML encoding. It must be noted that
SWRL is evolving and signiﬁcant changes can be expected in the
near future.

SWRL is based on a combination of the OWL DL and OWL
Lite sublanguages of the OWL Web Ontology Language with the
Unary/Binary Datalog RuleML sublanguages of the Rule Markup
Language.
It proposes the speciﬁcation of rules in the form of
an implication. The Atoms within the body and the head of the
implication can be Class Predicates C(x) or Property Predicates
P (x, y). Within the body or head, multiple atoms are treated as a
conjunction. Here is a primitive way of how one could express a
rule or a condition for a book buying service, “BBS”. Semantically,
the rule can be deﬁned as,

if a buyer has a valid Account and a valid Credit Card, he can

buy a book from BBS.

We have the following variables as inputs to the book buying

service,
• Account ID
• Password
• Creditcard number
• Expiry date
• ISBN number

The variables can be deﬁned in SWRL as:

<V a r i a b l e
<V a r i a b l e
<V a r i a b l e
<V a r i a b l e
<V a r i a b l e

r d f : I D =” a c c t I D ” />
r d f : I D =” p a s s w o r d ” />
r d f : I D =” c r e d i t C a r d N u m b e r ” />
r d f : I D =” expDate ” />
r d f : I D =” ISBNNumber” />

The rule can now be stated as:

<Imp>

<body r d f : p a r s e T y p e =” C o l l e c t i o n ”>

<i n d i v i d u a l P r o p e r t y A t o m>

<p r o p e r t y P r e d i c a t e

r d f : r e s o u r c e =” # a c c o u n t E x i s t s ” />

<argument1 r d f : r e s o u r c e =” # a c c t I D ” />
<argument2 r d f : r e s o u r c e =” # p a s s w o r d ” />

<i n d i v i d u a l P r o p e r t y A t o m>
<i n d i v i d u a l P r o p e r t y A t o m>

<p r o p e r t y P r e d i c a t e

r d f : r e s o u r c e =” # c r e d i t E x i s t s ” />

<argument1 r d f : r e s o u r c e =” # c r e d i t C a r d N u m b e r ” />

<argument2 r d f : r e s o u r c e =” # e x p d a t e ” />

<i n d i v i d u a l P r o p e r t y A t o m>

<body>
<head r d f : p a r s e T y p e =” C o l l e c t i o n ”>

<i n d i v i d u a l P r o p e r t y A t o m>

<p r o p e r t y P r e d i c a t e

r d f : r e s o u r c e =” # allowedToBuy ” />

<argument1 r d f : r e s o u r c e =” # a c c t I D ” />
<argument2 r d f : r e s o u r c e =” #ISBNNumber” />

<i n d i v i d u a l P r o p e r t y A t o m>

<head>

<Imp>

Many times it may be the case that we do not want to express an
implication, but simply a predicate or a conjunction of predicates
[15]. This is the case for expressing “Condition”- which is used
in many places within the Process model. Within the framework
of OWL-S, Conditions are required to be logical formulae. They
are part of the deﬁnition for “Precondition” - a kind of Condition
and also for Conditional outputs and effects. Currently SWRL does
not specify any such constructs. Several proposals have been dis-
cussed for expressing Conditions in this format [15]. The common
factor in all these proposals is having a top-level concept called
“Formula” and deﬁning “Condition” to be of rdf:type
Formula. Eventually, “Formula” is expected to be deﬁned as
a part of SWRL. However for practical purposes it can be deﬁned
within the Process model or DRS representation of the same can
be used. In this paper we abstract the top -level representation of
“Formula”, as we believe that this is a matter of namespace rep-
resentation and express temporal properties as Property Predicates
using SWRL.

6. A SWRL REPRESENTATION OF A - C

PROPERTIES

A - C properties are Temporal formulae2.

<o w l : C l a s s

r d f : I D =” T emporalFormula ”>

<r d f : s u b C l a s s O f

r d f : r e s o u r c e =” # Formula ”>

</ o w l : C l a s s>

<o w l : C l a s s
<r d f : t y p e

r d f : I D =” Assumption ”>

r d f : r e s o u r c e =” # T emporalFormula ”>

</ o w l : C l a s s>

<o w l : C l a s s
<r d f : t y p e

r d f : I D =” Commitment ”>

r d f : r e s o u r c e =” # T emporalFormula ”>

</ o w l : C l a s s>

From the aspect of ontological representation, A - C can be re-
garded as ﬁrst-order logical formulae analogous to Conditions and
augmented with temporal operators. We have modelled a basic on-
tology for expressing various temporal operators in ITL [1]. When
the representation of Conditions is standardized, assumption and
commitments can be easily expressed by using the two ontologies.
As an example consider the following temporal formula:

2validISBN N umber(BookT itle, ISBN)

Informally it means that always the name of the book should cor-
respond to the given ISBN number. The ontological representation
of the above is,

<i n d i v i d u a l P r o p e r t y A t o m>

<p r e f i x O p e r a t o r

r d f : r e s o u r c e =”& i t l ; Always ” />

<p r o p e r t y P r e d i c a t e

r d f : r e s o u r c e =

<argument1 r d f : r e s o u r c e =” # b o o k T i t l e ” />

” # validISBNNumber ” />

2We
TemporalFormula at this stage.

specify

not

do

namespaces

of

Formula and

547<argument2 r d f : r e s o u r c e =” #ISBN” />

</ i n d i v i d u a l P r o p e r t y A t o m>

where, prefixOperator is a Class, representing temporal op-
erators like 2, 2i , 2a , 3 and ¬. The (cid:13) operator can be applied to
both formulae and variables.

7. COMPOSITIONAL RULES FOR SERVICE

COMPOSITION

In this section, we explain how A - C can be used to composi-
tionally reason about integrated services. Web services composi-
tions can be realised using several programming language control
constructs. Predominantly there are two forms of compositions:
sequential and parallel. Other forms of compositions can be de-
rived from these two forms using constructs like if-then-else, iter-
ate, repeat-until, while-do and choice [14].

We deﬁne compositional rules using A - C for the most intuitive
form of composition i.e sequential and parallel composition. We
provide the ontological representation for pre/post conditions and
A - C predicates using SWRL. In following subsections:

1. ω, ω

′ represent pre/post conditions respectively.

2. As1, As2 represent assumption for service S1 and S2.

3. Co1, Co2 represent commitment for service S1 and S2.

4. As, Co represent assumption and commitment of the com-

position.

7.1 Sequential Composition

S1 ; S2

S1

S2

ω1

ω

′

1

⊃ ω2

ω

′

2

Figure 4: Sequential Composition

We consider the sequential composition (ref. Fig. 4) of two ser-
vices. Services S1 and S2. In case of sequential composition we

(As, Co)
(As, Co)

:
:

{ω1}S1{ω
{ω2}S2{ω

As ≡ 2a As
Co ≡ Co∗
ω

1 ⊃ ω2

′

′

1}
2}

′

(As, Co)

:

{ω1}S1; S2{ω

(1)
(2)
(3)
(4)
(5)
(6)

′

2}

require that As and Co are respective ﬁxpoints3of the ITL opera-
tors 2a and chopstar. For the commitment to hold over the interval
deﬁned by S1; S2, we ﬁrst require the assumption to hold over that
interval. Hence, if the assumption holds and if it is a ﬁxpoint of 2a ,
it guarantees to holds over the individual subintervals i.e intervals
deﬁned by S1 and S2 as well (semantics of 2a ). Now in response to
this assumption, if the services guarantee some commitments, they
hold on the individual subintervals for S1 and S2. If we choose
these commitments such that they are ﬁxpoints of chopstar(i.e a
3The ﬁxed point of a function, f is any value, x for which f x = x.
A function may have any number of ﬁxed points from none (e.g. f
x = x+1) to inﬁnitely many (e.g. f x = x).

singular commitment), we can easily collapse the commitment to
hold for the interval deﬁned by S1; S2. The advantage of these
restrictions are ease in implementation and reduced complexity in
validating the composition.

We take an example of a global book searching service com-
posed in sequence with a book buying and shipping service. The
composition engine requires all necessary user inputs, i.e ISBN
number of the book, credit card details and shipping details to be
supplied to the composite service before engaging into the compo-
sition. Pre/post conditions can be deﬁned as:

ω b= valid(ISBN ) ∧ validCreditCard(cardN umber)

′

ω

b= cardBilled(cardN umber) ∧

bookShipped(shippingAddress)

When expressed as a property predicate in SWRL, the Precondi-
tion: can be deﬁned as:

<c o n j u n c t s

r d f : p a r s e T y p e =” C o l l e c t i o n ”>

<i n d i v i d u a l P r o p e r t y A t o m>

<p r o p e r t y P r e d i c a t e

r d f : r e s o u r c e =” # validISBNNumber ” />

<argument1 r d f : r e s o u r c e =” # b o o k T i t l e ” />
<argument2 r d f : r e s o u r c e =” #ISBN” />

</ i n d i v i d u a l P r o p e r t y A t o m>
<i n d i v i d u a l P r o p e r t y A t o m>

<p r o p e r t y P r e d i c a t e

r d f : r e s o u r c e =” # v a l i d C r e d i t C a r d ” />

<argument1 r d f : r e s o u r c e =” # cardNumber ” />
<argument2 r d f : r e s o u r c e =” # expDate ” />

</ i n d i v i d u a l P r o p e r t y A t o m>

</ c o n j u n c t s>

The post-condition can be expressed accordingly.

However, it can be observed that these assertions do not make

any statements about the credit card validity by the requester through-
out the composition and the assurance that the card will not be
billed till the transaction is complete by the service provider.
A - C assertions are required to increase trustworthiness of the ser-
vice and to take corrective measures in case of any unexpected be-
haviour. For e.g., it is likely that the requester’s credit card ceases
to be valid during an ongoing transaction. Therefore the following
temporal assertions are required to be made part of the speciﬁca-
tion.

As

Co

b= 2a validCreditCard(cardN umber)
b= (¬cardBilled(amount, cardN umber))∗

The commitment can be expressed as:

<i n d i v i d u a l P r o p e r t y A t o m>

<s u f f i x O p e r a t o r
<p r e f i x O p e r a t o r

r d f : r e s o u r c e =”& i t l ; C h o p s t a r ” />
r d f : r e s o u r c e =”& i t l ; Negate ” />

<p r o p e r t y P r e d i c a t e
<argument1 r d f : r e s o u r c e =” # amonut ” />
<argument2 r d f : r e s o u r c e =” # cardNumber ” />

r d f : r e s o u r c e =” # c a r d B i l l e d ” />

</ i n d i v i d u a l P r o p e r t y A t o m>

The assumption can be expressed accordingly.
7.2 Parallel Composition

A network of services executing concurrently consists of a set
of services and a set of shared objects such as channels, through
which the services communicate via message passing. The speci-
ﬁcation, proof obligations and the compositional rule for services
executing in parallel are as deﬁned below: For services executing
concurrently, the environment of each service is governed by the
environment of every other service in the network and by the over-
all environment of the composition. Hence the proof obligation

548(As1, Co1)
(As2, Co2)

:
:

{ω1}S1{ω
{ω2}S2{ω

As ∧ Co1 ⊃ As2
As ∧ Co2 ⊃ As1

′

1}
2}

′

(As, Co1 ∧ Co2)

:

(ω1 ∧ ω2)S1 k S2(ω

′

1 ∧ ω

′

2)

(1)
(2)
(3)
(4)
(5)

for parallel composition, relates the environment (As1) of a ser-
vice ((S1) with commitment (Co2) of the other service, (part of the
environment of (S1)) as the observable inﬂuence and with the as-
sumption (As) of the overall composition. An example of parallel
composition is presented in the following section.

8. CASE STUDY: AN AUCTION SERVICE
An Auction service (ref. Fig. 5) is presented as an example of a
composite service. The Auction service is a composition between
several buying services, a selling service and the auction house, ex-
ecuting in parallel with each other. Buyers and seller are classiﬁed

• Beat-the-Quote: At any time, the buyer cannot lower the cur-

rent highest amount.

• Unique Bid: At any time, a buyer has only one active bid.

• Winning Bid: At any time, only the winning bid is sent back

to the buyer.

• Dominant Bid: At any time, the latest bid submitted by a

buyer has to be higher than the last bid submitted by him.

• Unique Winner: The auction house guarantees a unique win-

ner once the auction is over.

Registration for the auction is a precondition for every buying/selling
service. The postcondition is that the auction declares a unique
winner. The remaining rules are constraints on bids and are re-
quired to hold while the auction is in progress. They can be consid-
ered as the “assumption” of the auction house or “commitments”
by the buying service. As long as these assumptions are satisﬁed,
the auction house guarantees to admit the bidder for the next round
and consider the bid as a valid bid.
8.1 Formalization of the Auction Service

The auction spans over an interval (ref. Fig. 6) deﬁned by a se-
quence of n states. The ask price is submitted at state 0 and the
winning bid is declared at state n. Bids are submitted and the auc-
tion is cleared at all intermediate states i.e between states 1. . . n−1.
The number of buyers registered for auction is k. Communication
between the buying services and the auction house takes place via
channels.

ask

0

winBid = max(bid1 , bid2 , bid5 )

1

2

winBid

n

bid1

bid5

bid2

Figure 6: Observable States of the Auction House

Figure 5: Composition of an Auction Service

We deﬁne observable variables for the auction service in Table 2

below.

as bidders in the auction process. Seller submits an ask price to
the auction house, buyers submit bids as per the rules of the auc-
tion, the auction house validates the incoming bids and clears the
auction, declaring the winning bid for each clearance. Finally the
winner is announced and the auction is closed.

The auction process spans over an interval with intermediate
states being deﬁned at the instants where communication between
the partners take place. The execution of the composed service
takes place concurrently as buyers can submit bids while other bids
are being processed by the auction house. The Seller can also
change his ask price while the auction progresses, depending on
the market situation. However for simplicity we do not consider
that case here and model the composition only between the Auc-
tion house and the buying services.

In our design we assume the selling and buying services to be
thin clients of the auction house. The auction house itself is a thick
computational server. It validates rules of the auction and proper-
ties of the incoming bids. Some of these properties can be deﬁned
informally as below:

• Registration: To trade via the Auction house bidders (sell-
er/buyers) have to register with the Auction house as mem-
bers.

Table 2: Observable variables

Ask price
Bidder, i’s bid
list of bids at any state

b= ask
b= bidi : 0 < i ≤ k
b= bidList
b= {bidi|0 < i ≤ k}

Winning Bid at any state b= max(bidList)

Bid received by a buyer b= bidrec

b= winBid

8.2 Specifying the Auction House

The initial-ﬁnal state properties required to be validated by the

auction house can now be deﬁned as,

ω b= winBid = ask ∧

∀i : 0 < i ≤ k : isRegistered(i)

′

ω

b= ∃i : 0 < i ≤ k : isW inner(i)

where, isRegistered(i) and isW inner(i) are pre/postcondition
predicates, respectively. The assumption (Asah) for any bid sub-
mitted to the auction house by a bidder and the corresponding com-
mitment by the auction house Coah can be formally expressed as,

549∀i : 0 < i ≤ k

Asah

Coah

b= 2(((cid:13)bidi ≥ bidi) ∧ ((cid:13)bidi ≥ winBid))
b= 2(bidrec = winBid)

We express the Assumption predicate in SWRL as below:

<V a r i a b l e
<V a r i a b l e
<V a r i a b l e

r d f : I D =” b i d ” />
r d f : I D =” winBid ” />
r d f : I D =” b i d r e c ” />

<c o n j u n c t s

r d f : p a r s e T y p e =” C o l l e c t i o n ”>

<i n d i v i d u a l P r o p e r t y A t o m>

<p r e f i x O p e r a t o r
<p r o p e r t y P r e d i c a t e

r d f : r e s o u r c e =”& i t l ; Always ” />

r d f : r e s o u r c e =” # isGEQNext ” />

<argument1 r d f : r e s o u r c e =” # b i d ” >

<p r e f i x O p e r a t o r

r d f : r e s o u r c e =”& i t l ; Next ” />

</ argument1>
<argument2 r d f : r e s o u r c e =” # b i d ” />

</ i n d i v i d u a l P r o p e r t y A t o m>
<i n d i v i d u a l P r o p e r t y A t o m>

<p r e f i x O p e r a t o r
<p r o p e r t y P r e d i c a t e

r d f : r e s o u r c e =”& i t l ; Always ” />

r d f : r e s o u r c e =” # isGEQWinBid ” />

<argument1 r d f : r e s o u r c e =” # b i d ” />

<p r e f i x O p e r a t o r

r d f : r e s o u r c e =”& i t l ; Next ” />

<argument2 r d f : r e s o u r c e =” # winBid ” />

</ i n d i v i d u a l P r o p e r t y A t o m>

</ c o n j u n c t s >

Applying the A-C formalism for these compositional properties,

2i ((Asah ∧ Coah) ; skip ⊃ Coah)

to the auction house service speciﬁcation, we have the following
compositional ITL formula that is required to be validated while
the auction is in progress.

2i (2(((cid:13)bidi ≥ bidi) ∧ ((cid:13)bidi ≥ winBid)∧

(bidrec = winBid)) ; skip ⊃ 2(bidrec = winBid))

8.3 Specifying the Buying Service

We focus on the A-C properties of the buying service. These
are informally described below. The compositional property of
assumption for any bid received by the buying service, from the
auction house, and the corresponding commitment by the buying
service, can be formally expressed as, ∀i : 0 < i ≤ k

Asi

Coi

b= 2(bidrec = winBid)
b= 2(((cid:13)bidi ≥ bidi) ∧ ((cid:13)bidi ≥ bidrec))

We express the Assumption predicate in SWRL as below:

<V a r i a b l e
<V a r i a b l e
<V a r i a b l e

r d f : I D =” b i d ” />
r d f : I D =” winBid ” />
r d f : I D =” b i d r e c ” />

<i n d i v i d u a l P r o p e r t y A t o m>

<p r e f i x O p e r a t o r
<p r o p e r t y P r e d i c a t e

r d f : r e s o u r c e =”& i t l ; Always ” />

r d f : r e s o u r c e =” # isEQ ” />

<argument1 r d f : r e s o u r c e =” # b i d r e c ” />
<argument2 r d f : r e s o u r c e =” # winBid ” />

</ i n d i v i d u a l P r o p e r t y A t o m>

Analogous to the auction house service we apply the A-C formal-
ism,

2i (2((bidrec = winBid) ∧ ((cid:13)bidi ≥ bidi)∧

((cid:13)bidi ≥ bidrec)) ; skip ⊃ 2(((cid:13)bidi ≥ bidi)∧

((cid:13)bidi ≥ bidrec)))

8.4 Composing the Auction Service

The auction house, buying service and selling service execute
concurrently. We simplify the scenario by considering composition
only between the buying service and the auction house. The en-
vironment of the overall composition, i.e As does not impose any
constraints on the composition and defaults to true. The proof obli-
gations for services composed in parallel are recalled from
Section 7.2.

Co2 ⊃ As1, Co1 ⊃ As2

The proof obligations for the auction service can now be speciﬁed
as, ∀i : 0 < i ≤ k,

Coah ⊃ Asi

Coi ⊃ Asah

The validity of above proof obligations can be proved from
Section 8.2 and 8.3.

9. RUNTIME VERIFICATION USING

ANATEMPURA

An important area where compositional speciﬁcations could pro-
vide valuable assistance is veriﬁcation of service composition. Tra-
ditional methods of verifying a composed system are noncomposi-
tional and require a global examination of the entire system. Ap-
proaches such as model checking also fail to scale up well since
the global state space that has to be explored grows exponentially
as components are added to the system. However, application of
these methods to verify the composition of web services is prob-
lematic because the actual binding between various components is
dynamic and therefore there is no global system available a priori
for applying these veriﬁcation techniques. Compositional veriﬁca-
tion, however, shifts the burden of veriﬁcation from the global level
to the local component level. Hence global properties of the com-
position can be established by composing together independently
veriﬁed component properties.

The assumption-commitment paradigm, a deductive (proof - the-
oretic) technique can be effectively applied as a compositional ver-
iﬁcation technique for Web services composition. The idea is to
prove the validity of the proof obligation for the composition using
the assertional speciﬁcation of each service in the network. The
veriﬁcation can be undertaken at two stages during service com-
position: (a) At the design stage where decisions regarding which
services can be composed are to be made. Here the veriﬁcation can
be automated using a theorem prover;(b) At runtime, when services
are actually wired with each other at the ports.

We are more interested in veriﬁcations of the second kind. The
motivation for that stems from the fact that at runtime service com-
position can be inﬂuenced by several factors like network condi-
tions, synchronization and availability of individual services in the
network. Dynamic coordination can thus give rise to an emergent
behaviour which may not be desired. The purpose of veriﬁca-
tion at runtime is therefore to gauge such unwanted behaviour, that
may lead to a “chaotic” composition. Since the assertions we pro-
pose are temporal properties of services and their environment, the
proof obligations for the speciﬁcation of the composition have to
be validated by an engine capable of handling temporal properties
AnaTempura [2] (ref. Fig 7) is a tool for the runtime veriﬁcation of
systems. It is an interpreter for executable Interval Temporal Logic
speciﬁcations written in Tempura: a subset of ITL. AnaTempura
generates a state-by-state analysis of the system behaviour as the
computation progresses. At any state during the computation if the

550ANATempura

System to analyse

Server

Result

Properties &

Check

Tempura
Interpreter

Figure 7: Runtime veriﬁcation using Anatempura

variable values cease to satisfy the Tempura formula, AnaTempura
throws up an exception for that state.

For veriﬁcation, the proof obligations that encode the temporal
assertions are speciﬁed in Tempura. At runtime, the assertions are
validated, by passing the actual parameter values to the Tempura
Program (ref. Fig. 8) at the initial state and at each critical state
deﬁned by the service provider. AnaTempura validates the proof
obligations at these states. If the proof obligations cease to hold, it
implies that some form of unwanted or chaotic behaviour has oc-
curred. This kind of veriﬁcation serves two purposes: (a) It assists
in identifying the errors in service description as the speciﬁcation
emerges from there. Conventional ways of verifying compositions
work at the implementation level using techniques like exception
handling;(b) Third party arbitration services can use the mechanism
for monitoring quality-of-service parameters. This is because the
veriﬁcation mechanism still works at the interface level and there-
fore no implementation details are required. We have developed a
preliminary implementation of the auction example using this tech-
nique which is currently in the testing phase.

10. CONCLUSION AND FUTURE WORK

In this paper we provide the much needed theoretical background
for applying compositionality to the domain of Semantic Web ser-
vices. We believe that both speciﬁcation and veriﬁcation should
be highly compositional allowing modular validation and veriﬁca-
tion to be performed. We have shown how Semantic Web service
speciﬁcations written as OWL ontologies, can be reinforced with
temporal properties - Assumption and Commitment. We have cho-
sen OWL-S as it has an inbuilt provision for accommodating logi-
cal formulae, which is missing in other languages. We have argued
that apart from state predicates ongoing assertions are also required
to fully capture the behaviour of a service, speciﬁed as a black box.
We have shown how assumption and commitment can be speciﬁed
for compositional reasoning about semantic Web service compo-
sition, using OWL-S and SWRL. We also show how the theory
can be applied in practice to the composition of an auction service.
We have done a preliminary implementation of the auction service
which will be presented in a future paper.

Little work has been done in the area of compositional speciﬁ-
cation and veriﬁcation of services as revealed from the literature
review done so far in the domain of semantic web services, both in
academia and industry. Semantics for the process model has been
deﬁned by Narayan and McIlraith [20] using axioms in situation
calculus, which are then mapped to Petri-net representation. An
alternative Concurrent Execution semantics for the same has also
been proposed by Ankolekar et al [4]. However, these do not dis-
cuss compositionality and veriﬁcation techniques that are impera-

Figure 8: Framework for service composition using Anatempura

tive while composing services on-the-ﬂy. Several industrial efforts
to create service composition standards like BPEL4WS [24] and
WSCI [10] provide syntactical means of describing and compos-
ing services. They however, lack the formal framework needed for
veriﬁcation of services composed using such speciﬁcations.

As part of our future goal, we aim to build a pre-processor (ref.
Fig. 8) that converts assumption - commitment speciﬁcation within
an OWL-S ontology into executable Tempura speciﬁcation. The
tool would be part of a larger framework for service composition.
We have already designed the framework for the implementation
of such a tool. We also plan to extend our work on veriﬁcation of
services using AnaTempura.

11. REFERENCES
[1] An Ontology for ITL.

http://www.cse.dmu.ac.uk/˜monika/Pages/Ontologies/ITLOnto.owl.

[2] ITL and (Ana)Tempura Home page on the web.

http://www.cse.dmu.ac.uk/˜cau/itlhomepage/itlhomepage.html.

[3] The Rule Markup Initiative.

http://www.dfki.uni-kl.de/ruleml/.

[4] Anupriya Ankolekar, Frank Huch, Katia Sycara. Concurrent
Execution Semantics for DAML-S with Subtypes. The First
International Semantic Web Conference (ISWC), Sardinia
(Italy), June 2002.

[5] D. Fensel, C. Bussler. Web Services Modelling Framework,

2002. http://www.swsi.org/resources/wsmf-paper.pdf.

[6] W.-P. de Roever et al. Concurrency Veriﬁcation: Introduction

to Compositional and Noncompositional Methods.
Cambridge University Press, Cambridge, England, 2001.

[7] E. W. Dijkstra. Solution of a problem in concurrent
programming control. Number 8(9). CACM, 1965.

[8] Drew McDermott and Dejing Dou . Representing

Disjunction and Quantiﬁers in RDF Embedding Logic in
DAML/RDF. International Semantic Web Conference, 2002.

[9] Ian Horrocks, Peter F. Patel-Schneider, Harold Boley, Said
Tabet, Benjamin Grosof, Mike Dean. SWRL: A Semantic
Web Rule Language Combining OWL and RuleML .
Technical report, Version 0.5 of 19 November 2003.

[10] Intalio, Sun Microsystems, BEA Systems, SAP. Web Service

Choreography Interface (WSCI) 1.0 Speciﬁcation, 2002.

[11] Jones C.B. Speciﬁcation and design of (parallel) programs.

pages 321–332, Amsterdam, 1983. Proceedings of
information processing’83, North Holland Publishing Co.

[12] M. Dean, D. Connolly, F. van Harmelen, J. Hendler, I.

Horrocks, D. Guinness, P. F. Patel-Schneider, L. A. Stein.

551Web Ontology Language (OWL) W3C Reference version
1.0, 18 August 2003.
http://www.w3.org/TR/2002/WD-owl-ref-20021112.

[13] J. Misra and K. Chandy. Proofs of networks of processes.

volume 7(7):417-426. IEEE Transactions on Software
Engineering, 1981.

[14] Monika Solanki, Antonio Cau, Hussein Zedan. Introducing
compositionality in webservice descriptions. Paris, France,
2003. 3rd International Anwire Workshop on Adaptable
Service Provision, Springer-Verlag.

[15] Monika Solanki, Drew McDermott and David Martin.

Discussions on the Semantic Web service Interest Group
mailing list.
http://www.w3.org/2002/ws/swsig/.

[16] B. Moszkowski. Executing temporal Logic Programs.

[19] Motta, E., Domingue, J., Cabral, L. and Gaspari, M. IRS-II:
A Framework and Infrastructure for Semantic Web Services.
In Proceedings of the 2nd International Semantic Web
Conference, 2003.

[20] S. Narayan and S. A.Mcllraith. Simulation, Veriﬁcation and

Automated Composition of Web Services. Hawaii, USA,
2002. Eleventh International World Wide Web Conference.

[21] Roberto Chinnic, Martin Gudgin,Jean-Jacques Moreau,

Sanjiva Weerawarana. Web Services Description Language
(WSDL) Version 1.2, 2003.
http://www.w3.org/TR/2003/WD-wsdl12-20030124/#intro.

[22] M. Sheshagiri, M. desJardins, and T. Finin. A Planner for

Composing Services Described in DAML-S. In Proceedings
of the AAMAS Workshop on Web Services and Agent-based
Engineering, 2003.

Cambridge University Press, Cambridge, England, 1986.

[23] The OWL-S Coalition. OWL-S 1.0 (Beta) Draft Release.,

[17] B. Moszkowski. Programming Concepts, Methods and
Calculi, IFIP Transactions, A-56., chapter Some Very
Compositional Temporal Properties, pages 307–326. Elsevier
Science B. V., North-Holland, 1994.

2003. http://www.daml.org/services/owl-s/1.0/ .

[24] Tony Andrews et al. Business Process Execution Language

for Web Services, Version 1.1, 2003.
http://www-106.ibm.com/developerworks/library/ws-bpel/.

[18] B. Moszkowski. Compositionality: The Signiﬁcant

[25] D. Wu, B. Parsia, E. Sirin, J. Hendler, and D. Nau.

Difference, volume 1536 of LNCS, chapter Compositional
reasoning using Interval Temporal Logic and Tempura, pages
439–464. Springer Verlag, Berlin, 1996.

Automating DAML-S Services Composition Using SHOP2.
In Proceedings of the 2nd International Semantic Web
Conference, 2003.

552