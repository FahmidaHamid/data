A Possible Simpliﬁcation of the Semantic Web Architecture

Bernardo Cuenca Grau

Maryland Information and Network Dynamics Lab.

∗

8400 Baltimore Avenue

College Park, Maryland, USA

bernardo@mindlab.umd.edu

ABSTRACT
In the semantic Web architecture, Web ontology languages are built
on top of RDF(S). However, serious difﬁculties have arisen when
trying to layer expressive ontology languages, like OWL, on top of
RDF-Schema. Although these problems can be avoided, OWL (and
the whole semantic Web architecture) becomes much more com-
plex than it should be. In this paper, a possible simpliﬁcation of the
semantic Web architecture is suggested, which has several impor-
tant advantages with respect to the layering currently accepted by
the W3C Ontology Working Group.

Categories and Subject Descriptors
I.2.4 [Knowledge Representation Formalisms and Methods]: Rep-
resentation Languages; F.4.1 [Mathematical Logic]: Model The-
ory

General Terms
Languages, Knowledge Representation, Web Technologies

Keywords
Semantic Web, Resource Description Framework (RDF), Resource
Description Framework Schema (RDF-Schema), Ontology Web Lan-
guage (OWL), Description Logics

1.

INTRODUCTION

The semantic Web [3] is an extension of the World Wide Web
in which both data and its semantic deﬁnition can be processed
by computer programs. The next generation of the Web will com-
bine existing Web technologies with knowledge representation for-
malisms in order to provide an infrastructure allowing data to be
processed, discovered and ﬁltered more effectively on the Web. A
set of new languages organized in a layered architecture will allow
users and applications to write and share information in a machine-
readable way, and will enable the development of a new generation
of technologies and toolkits.

In the semantic Web architecture, Web ontology languages are
built on top of RDF(S). However, serious difﬁculties have arisen
when trying to layer expressive ontology languages, like OWL,
on top of RDF-Schema [10][17]. Although these problems can
∗The author also works at the Institute of Robotics, Department of
Computer Science, University of Valencia (Spain)

Copyright is held by the author/owner(s).
WWW2004, May 17–22, 2004, New York, New York, USA.
ACM 1-58113-844-X/04/0005..

be avoided, OWL (and the whole semantic Web architecture) be-
comes much more complex than it should be. In this paper, a pos-
sible simpliﬁcation of the semantic Web architecture is suggested.
The paper is organized as follows: Section 2 reviews the main fea-
tures of RDF(S) model theory and of standard description logics
formalisms. In Section 3 the main design principles followed in
the design of the semantic Web languages are enumerated. Section
4 reviews the layering of OWL on top of RDF(S), while Section 5
summarizes other proposals for layering the semantic Web. Finally,
in Section 6, a possible simpliﬁcation of the semantic Web layering
is suggested and its main features and advantages are discussed.

2. RDF AND RDF-SCHEMA (RDF(S))

SYNTAX AND SEMANTICS

RDF [6] and RDF-Schema [4][6] are at the base of the semantic
Web. All the languages in the upper layers are built on top of them.
RDF(S) deﬁnes both the syntax and semantics of the subsequent
layers. However, RDF(S) is built upon a non-standard thesis of
representation [9]. The syntactic and semantic characterization un-
derlying RDF(S) differ signiﬁcantly from the syntax and semantics
of most ﬁrst-order logical languages [10].

The syntax of RDF is based on triples, atomic chunks of infor-
mation composed of three different elements < S, P, O >. Each
RDF triple:

• Is composed of a subject, a property and an object
• Represents a single fact, with a well-deﬁned meaning
• Is the minimum piece of knowledge that can be represented

in RDF

Every RDF(S) document is equivalent to an (unordered) set of
triples. However, although all these triples appear together in the
document, each one is given a meaning, which is independent of
the meaning of other triples.

RDF has a very limited set of syntactic constructs. No other
syntactic construct except for triples is allowed, neither in RDF(S),
nor in the remaining languages of the semantic Web architecture.
Moreover, the meaning of the triple syntax must be retained in
higher layers, i.e. all the triples in RDF are assigned the same basic
meaning. Richer languages are not allowed to modify this basic
meaning and can only reﬁne it.

RDF has been given a model-theoretic semantics, which pro-
vides formal meaning to its abstract syntax [6]. All the interpreta-
tions in RDF(S) model theory are relative to a set of names (URIrefs),
called the vocabulary of the interpretation. An RDF(S) interpre-
tation is deﬁned as a tuple I = {IR, IP, IEXT, IS, IL, LV },
composed of three sets and three mappings:

704• Sets

– IR is a non-empty set, called the domain of the inter-

pretation

– IP ⊆ IR is the set of properties.
– LV ⊆ IR is the set of literal values

• Mappings

– IEXT is a mapping IEXT : IP → IR × IR from

IP into the set of pairs < x, y >, with x, y ∈ IR

– IS is a mapping IS : U RIref s in V → IR
– IL is a mapping from typed literals in V into IR

In RDF model theory all resources (individuals, classes, proper-
ties, and even the language primitives) are elements of the domain
of the interpretation. The function IS maps every name (URI) of
the vocabulary to an element of the domain. All the names of a
RDF vocabulary, even the names contained in the reserved vocab-
ulary (language primitives) can appear at any position of a triple.
This means that triples like:

rdf : type rdf : type rdf : P roperty.

rdf s : range rdf s : domain rdf : P roperty.

rdf s : Class rdf : type rdf s : Class.

are allowed in RDF(S). These triples, composed of language
primitives, deﬁne the metamodeling architecture of RDF(S), and
can lead to unwanted consequences, especially when layering more
expressive languages like OWL on top of RDF(S) [15].

In RDF(S) all the names are mapped to a resource using IS. Thus,
a resource is deﬁned in RDF(S) as everything that has an identity,
i.e, everything that can be referred to by a URI.

Names that occur in a RDF document in a property position of
any triple are mapped by IS to a special subset of IR, called IP.
The elements of IP are then mapped to a set of ordered pairs of
elements of the domain by the function IEXT. The set of ordered
pairs corresponding to a property resource form the extension of the
property. RDF(S) semantics distinguishes objects from their exten-
sions. Objects representing individuals are deﬁned to have empty
extensions. Property objects are “special” in RDF because they
have non-empty extensions. Class primitives are not fundamental
primitives in RDF(S). The extension of a resource representing a
class is deﬁned through the property extension of IS(rdf:type)

The distinction between objects and their extensions allows for a

certain “syntactic freedom” in RDF(S):

• The extension of a resource can contain the resource itself
without violating the axioms of set theory. The extensions of
a resource is a set that, although it contains the resource, it
does not contain itself.

• Two properties or two classes can have the same instances
and still be different entities. In the case of ordinary sets,
equality is deﬁned through the principle of extensionality:
two sets are equal in axiomatic set theory iff they contain the
same elements.

However, there are three main non-standard features in the “free”

syntax of RDF:

• The resources representing the language primitives can ap-

pear at any position inside a triple

• There is no separation of vocabularies. Classes, properties
and individuals do not form disjoint collections in RDF(S).
Therefore, the same element of a vocabulary can be used
to denote, for example, a class and an individual, or even
a class, a property and an individual at the same time

• Self-referential syntactic constructs are allowed
RDF and RDF-Schema are at the basis of the semantic Web. All
the languages in the upper layers have been designed to use the
triple syntax in all their constructs, and to extend the meaning as-
signed to triples by RDF model theory adding new semantic condi-
tions to interpretations.

3. DESCRIPTION LOGICS SEMANTICS

Description logics (DL) [2][12] are a set of knowledge repre-
sentation formalisms, whose semantic characterization is based on
standard ﬁrst-order logics. Meaning is provided by interpretations,
which deﬁne the formal semantics of the logic.
An interpretation in DL is a mathematical structure I = {∆I , .I}

consisting of:

• A nonempty set ∆I, called the domain of the interpretation.

The domain is divided into two disjoint sets:

– The abstract domain is the set of all the individuals
– The concrete domain is composed of data values and is

used to integrate datatypes in description logics

• An interpretation function .I that maps:

– Every concept (class) name to a subset of ∆I
– Every role (property) name to a subset of ∆I × ∆I
– Every individual to an element of ∆I

The interpretation function can be extended to complex con-
cepts and roles and can be used to provide meaning to axioms
in the knowledge base.

OWL semantics is based on DL, so that an OWL ontology cor-
responds to a DL knowledge base. However, standard DL seman-
tics differs signiﬁcantly from the semantics of RDF(S). The main
differences between both formalisms, which make RDF(S) model
theory non-standard, are the following: [9]

• The interpretation function maps individual names to ele-
ments of the domain. Names used in other ways do not de-
note an element of the domain. Class and property names are
not mapped to resources: they are directly mapped to sets of
resources and sets of ordered pairs of resources respectively.
In DL, a resource is no longer “everything that can be re-
ferred to by a URI”: Only objects are considered as part of
the domain. Consequently, elements of the domain in DL do
not have extensions, as in RDF(S)

• In DL, class primitives are as fundamental as property prim-
itives. Classes are not deﬁned in terms of properties, as
in RDF(S). In RDF(S) all the semantic relationships are re-
ducible to properties.

• In RDF(S), the type membership and the subclass relation-
ships are not distinguished from other predicates, and can oc-
cur at any position in RDF triples (i.e., they can be arguments
for other predicates). As a consequence, the special meaning
of these predicates must be expressed explicitly through ax-
ioms. For example, in order to make rdfs:subClassOf transi-
tive, the axiom:

705∀x, y, z rdf s : subClassOf (x, y) ∧ rdf s :

subClassOf (y, z) → rdf s : subClassOf (x, z)

must be added to the RDF(S) model theory [9]. This axiom-
atization works well for RDFS, but has serious consequences
when trying to extend it to OWL. In OWL, new axioms are
required to specify the meaning of new constructs, like value
or cardinality restrictions, which makes the axiomatization
very complex to handle and understand.
In DL, however,
the meaning of these relationships is embedded in the for-
malism: the “type” relationship is unambiguously deﬁned as
“instance of”, while the “subclass” predicate is interpreted as
“subset of”. Hence, no axiomatization is required.

• In DL, the vocabulary to which the interpretation refers is di-
vided into disjoint sets. This means, for example, that classes
cannot be properties or objects at the same time. In RDF(S),
however, a resource can be both an individual and a class or
even an individual, a class and a property

4. DESIGN PRINCIPLES OF THE

SEMANTIC WEB

The semantic Web has been designed according to the following

principles [6] [16]:

• A resource is considered to be everything that has an identity,

i.e., everything that can be referred to with a URI

• RDF and RDF-Schema semantics is largely based on SKIF
semantics, a non-standard logical representation formalism
• RDF(S) syntax is based on triples, and the way names of

different kinds are introduced in those triples is rather free

• Every piece of knowledge representable in a semantic Web

document should be written (or translated) to triples

• All the triples share a common basic meaning. A document
is an unordered set of triples and the meaning of each triple
is independent from the others. Triples containing “special”
URIrefs are given an extra meaning by adding semantic con-
straints to the interpretations whose vocabulary contains that
particular URI

• All semantic Web languages are forced to use RDF syntax
only, and the meaning of RDF triples in all semantic Web lan-
guages must be compatible with the meaning given to them
in RDFS Model Theory

• The semantics of the languages of the ontology layer is based
on very expressive description logics (standard FOL formal-
ism)

5. LAYERING OWL ON TOP OF

RDF-SCHEMA

Serious difﬁculties have arisen when trying to layer expressive
ontology languages, like OWL on top of RDF(S) using these design
premises. Languages based on very expressive DLs include power-
ful modeling primitives like concept constructors, restrictions and
complex axioms. OWL richer theory of classes clashes with the un-
derlying principles of RDF(S) in the same syntax and extended se-
mantics layering [17][10][15]. Semantic integration problems arise
when trying to make compatible the semantics derived from very

expressive DLs with the triple syntax and the semantics already as-
sociated to those triples by RDF(S) model theory.

Although these semantic problems and paradoxes can be avoided,
OWL becomes consequently much more complex than it should
be. Non-standard techniques (like the deﬁnition of comprehension
principles [16]) must be used in order to make the DL semantics
compatible with the RDF(S) semantics resulting from the transla-
tion of OWL to triples [16].
5.1 The solution adopted by the W3C Web

Ontology Working Group

OWL combines features from different representation languages:
• Its semantics is largely based on very expressive description

logics

• Its modeling syntax and surface structure have been inﬂu-

enced by frame-based systems

• OWL has been designed to keep the maximum upward com-
patibility with RDF and RDF-Schema in both syntax and se-
mantics

The multiple inﬂuences underlying OWL speciﬁcation led to many

difﬁcult trade-offs. It has been especially conﬂictive to bring to-
gether satisfactorily the ﬁrst and the third features. The W3C Web
Ontology working group decided to:

• Provide OWL with a RDF-based syntax. This means that
any OWL ontology can be written as a RDF graph, made of
triples

• Ensure that the semantics of OWL ontologies is consistent
with the semantics of RDF. This particular requirement im-
plies two conditions:

– On one hand, any OWL ontology written in abstract
syntax notation is given a direct DL-like model-theoretic
semantics; on the other hand, the same ontology can be
written in terms of RDF triples and is assigned a RDF-
compatible model-theoretic semantics. Both encodings
of the same ontology must be semantically equivalent.
As RDF triples have RDF meaning, this meaning to-
gether with the special conditions added to OWL inter-
pretations in the OWL RDF-compatible semantics must
be equivalent to the meaning assigned to the ontology
by the direct model-theoretic semantics

– If OWL is designed as a semantic extension of RDF(S),
then any RDF(S) document must be a valid OWL ontol-
ogy. In other words, the free syntax of RDF(S) and its
corresponding semantics is “exported” to OWL. This
means, for example, that it would be possible to add
number restrictions to the “subClassOf” relationship,
because this relationship is considered syntactically as
an “ordinary” property and can be used as the subject
of RDF triples. These kinds of assertions provide the
language with an expressive power that goes beyond
standard description logics semantics

It was proved to be insurmountably difﬁcult to deﬁne OWL as
a true “same syntax, semantic extension” of RDF(S), while keep-
ing the reasoning services (OWL entailment) decidable. The Web
Ontology working group deﬁned three sublanguages of OWL [16],
each of which satisﬁes most (but not all) the requirements:

706• OWL Full is a true “same syntax, semantic extension” of
RDF(S) so that all RDF graphs are allowed. As a conse-
quence, its semantics is beyond the standard DL framework
and the language happens to be undecidable. Moreover, it
has yet to be proved that the RDF MT compatible semantics
for OWL Full gives a coherent meaning to OWL Full.

• In OWL-DL and OWL-Lite, however, some constraints are
applied in order to keep the language in a standard DL frame-
work, and to keep the decidability of the reasoning services
[16][10]:

– Only certain RDF triples and certain combinations of

those triples are allowed.

– The vocabulary of the interpretations is divided into
disjoint sets, so that the same URI cannot be used, for
example, as an individual and a property name at the
same time.

– An abstract syntax is deﬁned for the language, so that
OWL-Lite and OWL-DL can be deﬁned as the subset
of RDF graphs generated by the translation of their re-
spective abstract syntaxes to triples.

With these restrictions, the direct model-theoretic and the
RDF-complatible semantics for OWL-DL and OWL-Lite are
equivalent (OWL-full has neither a direct model-theoretic se-
mantics, nor an abstract syntax).

5.2 Discussion

In the author’s opinion this layering of OWL on top of RDF(S)

is not truly satisfactory, for several reasons:

1. The future semantic Web languages built on top of the ontol-
ogy layer (e.g. rules languages) will probably not be layered
on top of OWL Full. OWL Full is too expressive (namely
undecidable), and its semantic formalization is rather com-
plex, cumbersome and non-standard. As a result, OWL Full
happens to be both difﬁcult to implement and to understand
and it is foreseeable that it won’t be integrated in many ap-
plications. Consequently, OWL-full is not the best language
to stay at the basis of future and probably more expressive
semantic Web languages.

2. OWL-DL has been designed to be equivalent to the SHOIN(D)
[16][10] description logic. Although OWL-DL is decidable,
the entailment problem is computationally intractable in the
worst-case. Currently there exists no “practical” (easy to
implement and with a good computational behavior in av-
erage) reasoning algorithm to solve the satisﬁability prob-
lem for the (whole) SHOIN(D) logic. The design of efﬁ-
cient tableau-based reasoning algorithms, combining nomi-
nals, inverse roles, number restrictions, transitive roles and
role hierarchies remains an open problem in description log-
ics. Therefore, the only OWL sublanguage that could be eas-
ily implemented and optimized happens to be OWL-Lite.

3. The division of OWL in dialects is not clear. While in OIL
(Ontology Inference Layer) the different sublanguages were
layered according exclusively to their expressive power, in
OWL there are two different kinds of layering criteria:

• The relationship between OWL-Lite and OWL-DL is
similar to the relationship between OIL dialects: OWL-
DL is more expressive than OWL-Lite and they both
share the same underlying semantic formalism

• The relationship between OWL-DL and OWL-Full is

far more complex and unclear

4. The “same syntax, extended semantics” requirement for the
semantic Web forces OWL speciﬁcations to be far more com-
plex than they would be otherwise (e.g. comprehension prin-
ciples)

5. Two different logical formalisms have been used to deﬁne
the semantics of the semantic Web languages. RDF and
RDF-Schema are largely (but not completely) based on the
SKIF semantics [7][9], while OWL has been given a standard
description logics (direct) model-theoretic semantics. The
compatibility requirements between both formalisms force
the semantic Web to be complex and difﬁcult to understand

6. OTHER PROPOSALS FOR LAYERING

THE SEMANTIC WEB

The current layering of OWL on top of RDF(S) has been con-
sidered by several authors [17][9][15] to be rather unclear and non-
satisfactory. Other approaches for layering the semantic Web have
been recently suggested. There are mainly two ways to improve the
layering of the semantic Web:

1. To change some aspects in the design principles of OWL and
to leave the RDF(S) speciﬁcations unaltered. This approach
is based on the idea that some decisions made during the
early development of OWL and, in general, of the seman-
tic Web layer cake, have proved to be bad design decisions
up to a certain extent. Particularly, in the semantic Web ar-
chitecture, all the languages are forced to use RDF syntax so
that they are not allowed, either to extend it, or to change the
basic meaning assigned to triples by RDF(S) model theory.

2. To modify the speciﬁcations of RDF(S) in order to make
them more compatible with the underlying description log-
ics formalism of OWL-DL. In the semantic Web two differ-
ent formalisms have been used to deﬁne the semantics of the
languages; RDF(S) is based on an unusual model-theoretic
semantics, while OWL (direct) model-theoretic semantics is
based on standard description logics. The layering of the se-
mantic Web could be made clearer and simpler if the whole
semantic Web architecture was based on a standard ﬁrst order
logic formalism.

6.1

Syntax and semantic extension

In this approach, both the syntax and semantics of OWL are de-
ﬁned to be an extension of RDF(S) syntax and semantics respec-
tively [17]. This solution is based on the idea that most of the
problems and semantic paradoxes that occur when trying to layer
OWL on top of RDF(S) in the “same-syntax, semantic extension”
approach could be easily avoided if some of the OWL syntactic
constructs (e.g. restrictions) could be written using non RDF/XML
syntax.

If some “conﬂictive” constructs of OWL are not translated to
triples, then these constructs wouldn’t be given a RDF meaning and
their semantics would be completely deﬁned by the OWL model
theory.

In this proposed layering, each new language would share a com-
mon syntactic and semantic core with RDF, but would be allowed
to include new syntactic constructs and to deﬁne their meaning.

7076.2 Stratifying RDF-Schema:RDFS(FA)

RDFS(FA) (RDF-Schema Fixed Layer Metamodeling Architec-
ture) [13][15][14] is a sublanguage of RDF-Schema, which has
been assigned a (quite) standard description logics semantics. The
main design goal of RDFS(FA) has been to deﬁne a language for
the schema layer with both a standard ﬁrst-order logic semantics
and a clear metamodeling architecture. Moreover, the designers of
RDFS(FA) have tried to minimize the changes made to RDFS in
order to achieve a maximum reuse of existing RDFS documents
and tools.

6.2.1 RDFS(FA) overview
An interpretation in RDFS(FA) is a pair I = {IR, IE} where
IR is the domain and IE the interpretation function. In RDFS(FA)
interpretations, the universe of discourse is divided into four several
strata or layers, so that each individual, user-deﬁned class or prop-
erty, and each language primitive are mapped into a certain stratum
of the interpretation domain.

1. The instance stratum is composed of objects. Every individ-
ual name in the vocabulary is mapped to an element of the
domain corresponding to this layer

2. The ontology stratum is composed of both sets of objects
(user-deﬁned classes) and sets of ordered pairs of objects
(user-deﬁned properties).

3. The language stratum deﬁnes a language for specifying on-

tologies

4. The metalanguage stratum is used to deﬁne the language

layer

The ontology and the instance strata deﬁne the modeling capabil-
ities of the language, while the two upper layers deﬁne its meta-
modeling architecture.

It is not the purpose of this paper to analyze in detail the spec-
iﬁcation of RDFS(FA). A full discussion of the language can be
found in [13][15][14]. Nevertheless, as the simpliﬁcation of the
semantic Web architecture suggested in this paper is largely based
on the RDFS(FA) approach, it is particularly interesting to discuss
the main similarities and differences between RDFS(FA) and both
RDF(S) model theory and standard description logics formalism.

6.2.2 RDF(S) and RDFS(FA)

Although RDFS(FA) has been designed with the purpose of in-
troducing as few changes as possible in the speciﬁcation of RDF-
Schema, the semantic characterization of RDFS(FA) alters signif-
icantly some of the basic assumptions of RDF(S) model theory.
RDFS(FA) not only simpliﬁes the metamodeling architecture of
RDF(S), but also changes the very basics of RDF(S) data model
and formal semantics.

In this section, we will consider separately the new features in-
troduced in RDFS(FA). First of all, we will consider the changes
introduced in the basics of RDF(S) model theory and then the con-
sequent simpliﬁcation of the metamodeling architecture of the lan-
guage will be analyzed.

With respect to the basics of the data model and formal seman-
tics, there are several important differences between RDF(S) and
RDFS(FA):

1. The vocabulary (set of URIrefs) of the RDFS(FA) interpre-
tations is partitioned into disjoint sets, as in OWL-DL. As
a consequence of this particular design decision, the free
syntax of RDF(S) is explicitly constrained in the RDFS(FA)

speciﬁcation. The set of RDFS(FA) graphs can be mapped to
a subset of RDF(S) graphs; however, not every valid RDF(S)
graph can be mapped to a syntactically correct RDFS(FA)
graph. The constraints introduced by RDFS(FA) do alter sig-
niﬁcantly the syntax and data model of RDF(S) in several
important ways:

• If a URI is used in a property position inside a triple, it
cannot be used in the subject position of another triple.
The same URI cannot be used at the same time as a
class, property or individual

• Self-referential constructs are suppressed in RDFS(FA)
2. The names of the vocabulary are mapped directly from prop-
erty or class symbols to sets of pairs of elements and sets
of elements respectively. In RDFS(FA) class and property
primitives are fundamental primitives. Classes and proper-
ties are not objects of the domain: they are mapped directly
to sets of resources and to sets of pairs of resources respec-
tively in the adjacent lower stratum. In RDF model theory,
classes and properties are ﬁrst mapped via IS to objects in
the domain and then mapped by either ICEXT or IEXT to
their extensions. Thus, in RDFS(FA) a class or property is
not different from its extension. Consequently, the principle
of extensionality in set theory applies in a standard way, i.e.,
two classes are equal if and only if they contain exactly the
same instances (in RDF(S) two classes and properties with
identical extensions could be mapped vis IS to different ob-
jects in the domain)

3. Type properties are just instance-of relationships and can only
be used to link resources belonging to different layers. Specif-
ically, a “property” can only be used in RDFS(FA) to state
that an element or a set belonging to a certain layer is a mem-
ber of a set in the adjacent upper layer

4. Triples are not treated in a uniform way in the semantic spec-
iﬁcation of RDFS(FA). In RDF(S) all the triples share a com-
mon basic meaning. Triples containing certain language prim-
itives are assigned an extended meaning through the addi-
tion of semantic constraints to interpretations. However, in
RDFS(FA), as in DL, each triple is given a particular mean-
ing depending on the kind of URIs included in it. There is no
basic shared meaning between all the valid triples of the data
model.

With respect to the language primitives and their relationships,

RDFS(FA) simpliﬁes the metamodeling of RDF(S) suppressing some
of its most confusing aspects. Note that some of the features of
RDFS(FA) metamodeling architecture arise as a direct consequence
of the general design decisions of the language, discussed above.
• RDFS(FA) disallows the arbitrary use of built-in language
primitives, i.e. some of the (metamodeling) triples contain-
ing two or more language primitives that were valid in RDF(S)
have been suppressed in RDFS(FA). The metamodeling ar-
chitecture in RDF(S) is thus much richer than in RDFS(FA)
• A language primitive in RDF(S) might correspond to sev-
eral language primitives in RDFS(FA) (contained in different
strata).

• Language primitives are not instances of themselves
• As in RDF-Schema, the language primitives are interpreted

either as classes or as properties, but:

708– Language primitives in stratum “i” interpreted as classes
are mapped directly into sets of resources in stratum “i-
1”

– Language primitives interpreted as properties are also
mapped directly into sets of resources in the adjacent
lower stratum

The relationships among different language primitives are
deﬁned in such a way that that language primitives can only
be linked with other primitives layered in a different stratum
using an “instance of” (type) relationship.

6.2.3 RDFS(FA) and Standard Description Logics

RDFS(FA) semantics is largely embedded in a standard descrip-
tion logics framework. RDFS(FA) semantics has been conceived to
be compatible with OWL-DL and OWL-Lite direct model-theoretic
semantics. However, there are two important features in which
RDFS(FA) and OWL differ:

1. The domain of the interpretation in RDFS(FA) is different
from standard description logics. In RDFS(FA) interpreta-
tions not only sets of objects and pairs of objects are consid-
ered, but also sets of sets of objects and sets of sets of pairs
of objects, etc.

2. Standard DL semantics modeling primitives are not related to
each other as in RDFS(FA). OWL does not have a metamod-
eling architecture where the language primitives are treated
as meta-classes and meta-properties respectively.

The use of RDFS(FA) instead of RDF(S) implies several impor-
tant advantages. First, OWL can be much more easily layered on
top of RDFS(FA) than on top of RDF(S). If RDFS were replaced
by RDFS(FA) the semantics of OWL could be greatly simpliﬁed.
Second, the organization of the semantic Web architecture would
become clearer as a whole; all the languages of the semantic Web
would be based on a single, clear standard formalism. The price to
pay when replacing RDF(S) by RDFS(FA) is a loss of expressive
power. RDFS(FA) is less expressive than RDF-Schema.

7. A POSSIBLE REORGANIZATION
OF THE SEMANTIC WEB TOWER
ARCHITECTURE

7.1 Motivation

The layering suggested in this paper is largely based on the RDFS
(FA) approach, but represents a further simpliﬁcation of RDFS(FA),
in the same way as RDFS(FA) can be seen as a restricted sublan-
guage of RDF-Schema. The solution discussed here is motivated
by the following ideas:

1. In order to replace RDF-Schema by RDFS(FA) in the schema
layer of the semantic Web, the RDF syntactic and semantic
speciﬁcations should also be modiﬁed. RDFS(FA) cannot be
easily layered on top of RDF, given the way both RDFS(FA)
and RDF have been designed.
In order to properly layer
RDFS(FA) on top of the metadata layer, a sublanguage of
RDF must be deﬁned

2. It is unclear whether or not the metamodeling architecture
provides additional expressive power to RDFS(FA). In the
way RDFS(FA) has been speciﬁed, there is no plausible rea-
son, apart from the (apparent) compatibility with RDFS, to

deﬁne a metamodeling architecture for the language. Meta-
modeling doesn’t seem to enhance the inference capabilities
of the language. As far as we know no “interesting” entail-
ments have been suggested as a proof of the utility of the
metamodeling structure of RDFS(FA). Moreover it is also
unclear:

• What kind of reasoning algorithms could be deﬁned for

RDFS(FA).

• If standard DL reasoning algorithms are used, how meta-
modeling could be integrated in the algorithms to pro-
vide new interesting inference capabilities

3. The ontology and the schema layers share most of their aims
and scope. The main difference between both layers is the
semantic formalism they are based on. In the current seman-
tic Web, RDF-Schema can be considered, both as a simple
ontology language, and as a bridge between RDF and the
ontology layer. However, in the layering suggested in this
paper, there is no plausible reason for the schema layer to
exist.

7.2 Methodology

The methodology followed in this paper is composed of the fol-

lowing steps:

1. A sublanguage of RDFS(FA), called RDFS(DL) is deﬁned
and its correspondence to a simple description logic is estab-
lished

2. It is argued that RDFS(FA) can be replaced by RDFS(DL)

without a signiﬁcant loss of expressivity

3. The schema layer is suppressed from the semantic Web tower
architecture and the language RDFS(DL) is promoted to the
ontology layer as the simplest ontology language for the se-
mantic Web

4. The Organization of the OWL dialects is altered in two im-

portant ways:

• OWL-Full is suppressed
• OWL-Lite is layered on top of RDFS(DL)

5. RDF(DL), a sublanguage of RDF, is deﬁned. RDFS(DL) is

then layered on top of it

7.3 RDF-Schema(DL)

RDF-Schema(DL) is a sublanguage of RDFS(FA) where:
• The relationships between language primitives have been sup-

pressed

• Its semantics covers the strata 0 and 1 and the language itself

exists in stratum 2

• The language primitives are not stratiﬁed into different strata
of the language. This implies that there are no different “ver-
sions” of the same modeling primitive in different strata.

RDF-Schema(DL) is the result of suppressing the metamodel-
ing architecture of RDFS(FA). This design decision is motivated
by the fact that metamodeling in RDFS(FA) doesn’t seem to in-
crease the expressivity and the inference capabilities of the lan-
guage. Metamodeling in RDFS(FA) can be thought as a way to

709make the language as similar as possible to RDF-Schema. How-
ever, the fundamental assumptions of RDFS(FA), like the explicit
division of vocabularies and the constraints applied to the free syn-
tax of RDF(S) do change the language completely.
In this new
framework, metamodeling reveals itself as a rather “artiﬁcial” fea-
ture of the language. In this particular sense, RDFS(DL) is clearer
than RDFS(FA).

7.3.1

RDFS(DL) Syntax and Semantics

A RDFS(DL) vocabulary V is a set of URIrefs (a vocabulary)

composed of the following disjoint sets:

• VC is the set of concept (class) names
• VD is the set of datatype names
• VRA is the set of (object) property names
• VRD is the set of datatype property names
• VI is the set of individual names

As in RDF, a datatype “d” is deﬁned by two sets and one map-
ping: L(d) (lexical space), V(d) (value space) and L2V(d) the map-
ping from the lexical space to the value space. In this context a
datatype theory T is a partial mapping from URIrefs to datatypes.
A RDF-Schema(DL) interpretation with respect to T with vocab-
ulary VC , VD, VRA, VRD, VI is a tuple I = {R, EC, ER, L, S, LV }
where:

• R is a non-empty set representing the (abstract) domain of I
• LV ⊆ R is the distinguished subset representing the literal

values of I

• EC: VC → P (O), and VD → P (LV ) is a mapping from
class names in the vocabulary to subsets of the abstract do-
main and from datatype names in the vocabulary to subsets
of the datatype domain LV.

• ER maps object property names to a set of ordered pairs of
elements in the abstract domain VRA → P (O × O) and
datatype property names to ordered pairs, whose ﬁrst ele-
ment is a member of the abstract domain, and whose second
component is a datatype value VRD → P (O × LV )

• L maps typed literals to elements of the datatype domain L :
T L → LV . Let T be a datatype theory, d a datatype and d’
a datatype name (a URIref), then:

– If T (d0) = d then EC(d0) = V (d) ⊆ LV
– If T (d0) = d then L(0v0, d0) ∈ V (d), where ’v’ is a

string

– If T (d0) = d and v ∈ L(d) then L(v, d0) = L2V (d)(v),

where v is a string

– If T (d0) = d and v ∈ L(d) then L(v, d0) ∈ R − V (d)
• S maps individual names to objects in the abstract domain of

the interpretation. S : VI → O

The abstract syntax and semantics of RDFS(DL) are summarized

in Tables 1 and 2.

ABSTRACT SYN.
CLASS AXIOMS
SubClassOf (A1 A2)

PROP.AXIOMS
ObjectProperty(R)

dom(A1) ... dom (Am)

range(A1) ... range(An)

subP ropertyOf (R1R2)

DatatypeProperty(U)

dom(D1) ... dom (Dm)

range(D1) ... rangle(Dn)

subP ropertyOf (U1U2)

FACTS
Individual(o
type(C1)...type(Cn)
value(R1o1)...value(Rnon)

value(U1v1)...value(Unvn)

DL SYN.
A1 v A2

SEMANTICS
EC(A1) ⊆
EC(A2)
R ∈ VRA
ER(R) ⊆
R × R
≥ 1R v Ai, ER(R) ⊆
EC(Ai) × R
∀i ∈ [1, n]
> v ∀R.Ai ER(R) ⊆
R × EC(Ai)
ER(R1) ⊆
R1 v R2
ER(R2)
R ∈ VRD
ER(U ) ⊆
R × LV
≥ 1R v Di, ER(U ) ⊆
EC(Di) × R
∀i ∈ [1, n]
> v ∀U.Di ER(U ) ⊆
R × EC(Di)
U1 v U2
ER(U1) ⊆
ER(U2)
S(o) ∈
EC(Ci)
[S(o), S(oi)] ∈
ER(Ri)
[S(o), S(vi)] ∈
ER(Ui)

o ∈ Ci
[o, oi] ∈
ER(R)
[o, vi] ∈
EC(Ui)

Table 1: RDFS(DL) Axioms

ABSTRACT SYN. DL SYN.

CLASSES
A (URIref)
owl:Thing

A
>

d’

R

U

o

d

CONSTRUCTORS

(None)

RESTRICTIONS

(None)

DATATYPES
d’ (URIref)

ABSTRACT PROP.

R (URIref)

DATATYPE PROP.

U (URIref)
OBJECTS
o (URIref)

DATA VALUES (d)

d (Literal)

SEMANTICS
A ∈ ∆I
EC(owl : T hing)
= R

EC(d0) = V (d)
⊆ LV
ER(R) ⊆ R × R
ER(U ) ⊆ R × LV
oI ∈ R
S(d) ∈ LV

Table 2: RDFS(DL) semantics

7107.3.2 Reasoning in RDFS(DL)

The core reasoning service in the semantic Web languages is en-
tailment. We say that a RDFS(DL) (or an OWL) ontology O1 en-
tails O2 if and only if all the interpretations that satisfy O1 also
satisfy O2. However, entailment is not a standard DL reasoning
service. The standard DL tableaux-based and structural reasoning
algorithms have been conceived to solve the subsumption and the
satisﬁability problems. DL inference algorithms do not directly
deal with ontology entailment. Therefore, in order to use these al-
gorithms for reasoning in the semantic Web languages, entailment
has to be reduced to DL knowledge base satisﬁability [8].

In [8], it was shown that both ontology entailment in OWL-DL
and OWL-Lite can be reduced to the knowledge base satisﬁability
problem in the SHOIN(D) and SHIF(D) logics respectively.

Unfortunately, a similar reduction cannot be accomplished for
RDFS(DL) entailment. A RDFS(DL) ontology is composed of a
set of concept inclusion axioms A v B, a set of role inclusion
axioms R v S, a set of datatype role inclusion axioms U v V and
a set of facts, where A,B are atomic concepts, R and S atomic roles,
U and V datatype properties and where cycles might occur in the
terminology.

Let O1 and O2 be two RDFS(DL) ontologies and assume we
want to check if O1 entails O2. It can be shown that O1 entails O2
if and only if O1 entails every axiom Aj in O2. Then [8]:

• If Aj is of the form A v B, entailment checking is equiv-
alent to checking the unsatisﬁability of O1 ∪ {(A u ¬B)}.
Therefore, in order to reduce entailment to satisﬁability for
this kind of axioms, RDFS(DL) should include atomic nega-
tion

• If Aj is of the form R v S, then entailment checking is

equivalent to verify the unsatisﬁability of:

O1 ∪ {(B u ∃R(∀S−.¬B)}

where B is a new atomic concept and S− is the inverse role
of S. Thus, in order to reduce entailment to satisﬁability for
these axioms RDFS(DL) should include full existential re-
strictions, value restrictions, concept negation and role inver-
sion

• If Aj is a fact, then RDFS(DL) would need to include nega-

tion and value restrictions

• If Aj is a datatype role inclusion axiom, then nominals would
be required in order to reduce entailment to satisﬁability. It is
worth pointing out here that this speciﬁc aspect, which would
also affect the reduction of OWL-Lite entailment, is not con-
sidered in [8] when dealing with OWL-Lite.
In that case,
OWL-Lite entailment would be reduced to SHOIF(D) KB
satisﬁability (not to SHIF(D)). Therefore, if datatype role in-
clusions are considered, the logics corresponding to OWL-
Lite does not differ signiﬁcantly from SHOIN(D). In that
case, there would be, for example, no reason to avoid nomi-
nals (“one-of” constructor) in OWL-Lite and, most importat,
there would be no plausible reason for OWL-Lite to exist
separately from OWL-DL .

Hence, the following aspects should be considered for RDFS(DL)

(and also for RDFS(FA)!):

• If entailment is taken as the core reasoning service then, in
order to use standard DL reasoning algorithms for RDFS(DL),
the language would need to be extended up to the ALCHOI
logic, which is computationally intractable in the worst case.

• If entailment is taken as the main reasoning service, then
new DL algorithms could be designed for solving directly
the entailment problem. These algorithms might have poly-
nomial complexity (RDFS(DL) does not contain restrictions
and concept union, which are considered as the main sources
of complexity)

• If satisﬁability or subsumption of concepts with respect to
a knowledge base are considered as the core inference ser-
vices, then standard DL algorithms could be used to reason
in RDFS(DL)

• The main source of complexity in RDFS(DL) is the role hi-
erarchy. The possibility of replacing the role hierarchy by
other constructors could be reconsidered.
If, for example,
RDFS(DL) is made equivalent to the ALC description log-
ics and if the concept inclusion axioms are constrained to
be acyclic, then entailment could be reduced to knowledge
base satisﬁability, which is in PSPACE under these speciﬁc
conditions. This would make possible to have a polynomial
logic in the bottom of the ontology layer and to use standard
tableaux-based reasoning algorithms.

Instead of using tableaux-based algorithms, an interesting ap-
proach for reasoning in RDFS(DL) would be to use logic program-
ming (LP) inference engines. RDFS(DL) can be mapped to equality-
free Datalog Horn Logic [5] (the logical language composed of
Horn rules not including, either functions with arity greater than
zero, nor the equality predicate) . In [5] the equality-free Datalog
LP (def-LP) is also deﬁned. The difference between this logic and
the equality-free Datalog Horn Logic (def-Horn) is subtle, but im-
portant. The entailments in def-LP are limited to facts, while in
def-Horn also rules can be entailed. Therefore, def-LP is a subset
of def-Horn. In return to this loss of expressivity, the inference hap-
pens to be polynomial in the worst case. However, RDFS(DL) must
be mapped to def-Horn and not to def-LP, because the entailments
deﬁned in RDFS(DL) are not restricted to simple facts.
7.4 Building the new ontology layer

RDFS(DL) is deﬁned as a subset of both OWL-Lite and OWL-
DL, and is equivalent to a simple (though non-conventional) DL.
Instead of replacing RDF-Schema by RDFS(DL) in the schema
layer, it is suggested in this paper to promote RDFS(DL) to the on-
tology layer and then suppress the schema layer from the semantic
Web tower.

In this context, the layering of OWL becomes similar to the lay-
ering of OIL. In this new framework, all the OWL dialects corre-
spond to a particular description logic. OWL-Lite is deﬁned as a
subset of OWL-DL and RDFS(DL) as a subset of OWL-Lite. The
semantic Web developer could choose one of these languages for
creating an ontology depending on the expressive power required
by his/her application.

In this layering framework, RDFS(DL) would be layered directly
on top of the metadata layer and both the remaining layers (like the
rule level) and other OWL extensions would be based on OWL-DL.
7.5 RDF(DL)

RDFS(DL) cannot be deﬁned as an extension of RDF, in the way
RDF has been speciﬁed. RDF allows the programmer to use a free
syntax, so that:

• A resource can appear both in a subject/object or in a prop-

erty position.

• A URI belonging to RDF reserved vocabulary can appear as

the subject of a RDF triple

711• Self references are allowed

We suggest a sublanguage of RDF, called RDF(DL), based on a
standard model-theoretic semantics. In order to carry out this task
vocabularies in RDF are divided into three different parts, namely
classes, properties and individuals. The domain of RDF(DL) inter-
pretations is the set of all individuals, like in DL.

A RDF vocabulary V consists of ﬁve disjoint sets of URI refer-

ences, VC, VD, VI, VRA and VRD, where:
• VC is the set of concept (class) names
• VD is the set of datatype names
• VRA is the set of (object) property names
• VRD is the set of datatype property names
• VI is the set of individual names
The syntax of RDF(DL) is also based on triples, but some con-
straints are introduced so that the way triples can be written is no
longer completely free. In RDF(DL) close attention must be paid
to which names belong to which part of the RDF vocabulary.

• Class URI references can only appear in the object position
of the triples where rdf:type appears in the property position
• URIrefs belonging either to VRA or to VRD can only appear

in property positions

• Individuals (names in VI) can appear both in subject and ob-

ject positions, but never in property positions.

• Literal values can only appear at the object position of triples

where an element of VRD appears in the property position

In RDF(DL) four different kinds of assertions can be used:
• An assertion of the form C(a), where C is a class name and
“a” an object name, states that “a” is an instance of C and is
mapped to the triple [a rdf:type C]

• An assertion of the form R(a,b), where R is an object prop-
erty name and a,b are object names states that the objects
denoted by a,b are linked by the role denoted by R and is
mapped to the triples [a R b] and [R rdf:type rdf:ObjectProperty]

• An assertion of the form U(v), where U is a datatype name
and “v” a literal state that the value v belongs to the datatype
U and is mapped to [v rdf:type D]

• An assertion of the form U(a,v), where U is an datatype prop-
erty name, a is an object name and v is a literal state that the
object denoted by a is linked by the role denoted by U to the
data value denoted by v. The assertion would be mapped to
[a U v] and [U rdf:type rdf:DatatypeProperty]

Only the triples resulting of this mapping are given a model-

theoretic semantics in RDF(DL).
{IR, LV, .I} where,

A RDF(DL) interpretation of a vocabulary V is a tuple I =

• IR is a non-empty set called the domain of the interpretation
• LV ⊆ IR is a distinguished subset of IR
• .I is a function that:

– It maps every individual name “o” to an element of IR

oI ∈ IR

– It maps every object property name R to RI ⊆ IR×IR
– It maps every datatype property name U to U I ⊆ IR×

LV

– It maps every class name C to C I ⊆ IR

A rdf interpretation satisﬁes:
• The assertion C(a) if aI ∈ C I
• The assertion R(a,b) if < aI , bI >∈ RI
• The assertion D(v) if vI ∈ DI
• The assertion U(a,v) if < aI , vI >∈ U I

An RDF(DL) interpretation satisﬁes a RDF(DL) graph if and

only if it satisﬁes all the assertions in the graph.
7.6 A new vision of the Semantic Web

What have we achieved? First, and most important the layering
of the semantic Web has become clearer, easier to understand and
formalize. The layering of OWL dialects is now analogous to the
organization of OIL dialects. In this approach the ontology layer is
composed of three different languages:

1. RDFS(DL)

2. OWL-Lite

3. OWL-DL

These languages are organized according to their expressivity: OWL-
DL, the most expressive language, is equivalent to the SHOIN(D)
description logic. Satisﬁability checking for this logic is known
to be NEXP-TIME complete. No “practical” tableau-based rea-
soning algorithm for this logic has been developed yet. OWL-Lite
provides enough expressive power for most applications and its ab-
stract syntax can be mapped to the SHIF(D) description logic.

Reasoning services, though intractable in the worst-case, can
be implemented efﬁciently using highly-optimized algorithms that
work fairly well in average for most applications and use cases.
Finally, RDFS(DL) stays at the bottom of the ontology layer. Al-
though its expressive power is rather limited it can still be useful for
many applications. In this framework, the semantics of OWL-DL
and OWL-Lite would be greatly simpliﬁed: only a direct model-
theoretic semantics would be required. On the other hand, the
schema layer is suggested to be suppressed from the semantic Web
layer cake. Two main reasons support this suggestion:

• The schema layer has always been difﬁcult to understand and

formalize.

• The semantic speciﬁcation of RDF(S) requires non-standard
model-theoretic semantics and has non-standard metamod-
eling architecture, which make the language difﬁcult to un-
derstand, implement and formalize. Its aims and scope have
never been clearly distinguished from those of the ontology
layer

RDF-Schema can be conceived both as a simple ontology language
and as a “bridge” between the metadata and the ontology layers.
However, its motivation has not been properly justiﬁed and sup-
ported. There is no clear difference between the motivations and

712goals of the schema and the ontology layers; RDF-Schema has al-
ways been considered in practice as a simple ontology language
which shares many features with OWL. The only important dif-
ference between RDF-Schema and OWL happens to be the under-
lying semantic characterization. While OWL-Lite and OWL-DL
are based on very expressive description logics, RDF-Schema has
non-standard model-theoretic semantics.

In this approach, the metadata and the ontology layers share a
standard description logics semantics, with RDF(DL) correspond-
ing to an assertional (ABox) formalism, while OWL and RDFS(DL)
would correspond to a terminological (TBox) language. In this new
framework the semantic Web documents directly correspond to sets
of TBox axioms (OWL documents) and ABox facts (RDF(DL)) in
a DL knowledge base. With this approach, the layers at the bottom
of the semantic Web could be nicely integrated in a common and
coherent formalism.

8. CONCLUSION

In this paper an alternative layering for the semantic Web is de-
ﬁned. This approach has several advantages with respect to the
layering accepted by the Web Ontology Working Group:

• The semantic Web tower has become clearer, easier to under-

stand and formalise

• The remaining layers of the semantic Web and the extensions

of OWL can be more easily deﬁned using this approach.

• The semantic Web could beneﬁt from 15 years of description
logics research in both the metadata and the ontology layer
• In the new layering paradigm RDF(DL) would correspond to
a Abox formalism in DL, while RDFS(DL) and OWL would
be used to deﬁne the TBox.

• Some expressive power is lost in the lower layers of the se-

mantic Web when using this approach. However:

– The languages on top of the ontology layer will be as
expressive as they would be following the standard ap-
proach. New languages and extensions would hardly be
layered on top of OWL-full, which means that the ad-
ditional expressive power provided by RDF(S) model
theory will probably not be used in the languages built
on top of the ontology layer

– The additional capabilities of RDF and RDF-Schema
have not been widely used so far by modelers. For ex-
ample, the only modeling capability of RDF not pro-
vided by RDF(DL) is the ability to use properties in
subject position of triples. Nevertheless it is hard to
ﬁnd any examples of RDF graphs that use this speciﬁc
feature of the language.

• The semantic speciﬁcation of OWL would be greatly simpli-
ﬁed. Thus, for example, no RDF-compatible model theoretic
semantics would be required. All the languages in this solu-
tion would be given a direct model-theoretic semantics. This
makes OWL tools easier to implement

• Users can choose to use RDF(DL) and RDFS(DL) on one

hand or full RDF(S) on the other.

9. ACKNOWLEDGMENTS

The author would like to thank Bijan Parsia for insightful com-

ments and discussions.

10. REFERENCES
[1] F. Baader, I. Horrocks, and U. Sattler. Description logics as
ontology languages for the semantic Web. In D. Hutter and
W. Stephan, editors, Festschrift in honor of J¨org Siekmann,
Lecture Notes in Artiﬁcial Intelligence. Springer-Verlag,
2003.

[2] F. Baader and W. Nutt. Basic description logics. In F. Baader,

D. Calvanese, D. McGuinness, D. Nardi, and P. F.
Patel-Schneider, editors, The Description Logic Handbook:
Theory, Implementation, and Applications, pages 43–95.
Cambridge University Press, 2003.

[3] T. Berners-Lee, J. Hendler, and O. Lassila. The semantic

web. Scientiﬁc American, 2001.

[4] D. Brickley and R. V. Guha. Resource description framework

(rdf) schema speciﬁcation 1.0: Rdf schema. W3C Working
Draft, 2003.

[5] B. Grosof, I. Horrocks, R. Volz, and S. Decker. Description
logics programs, combining logic programs with description
logics. In Proc. of the 2003 International World Wide Web
Conference (WWW2003), Budapest, 2003.

[6] P. Hayes. Resource description framework (rdf) semantics.

W3C Working Draft, 2003.

[7] P. Hayes and C. Menzel. A semantics for the knowledge

interchange format. In Proc. of IJCAI 2001 Workshop on the
IEEE Upper Ontology, 2001.

[8] I. Horrocks and P. F. Patel-Schneider. Reducing OWL

entailment to description logic satisﬁability. In Proc. of the
2003 Description Logic Workshop (DL 2003), 2003.
[9] I. Horrocks and P. F. Patel-Schneider. Three theses of

representation in the semantic web. In Proc. of the Twelfth
International World Wide Web Conference (WWW 2003),
2003.

[10] I. Horrocks, P. F. Patel-Schneider, and F. V. Harmelen. From

SHIQ and RDF to OWL: The making of a web ontology
language. Journal of Web Semantics, 2003.

[11] G. Klyne and J. J. Carroll. Resource description framework

(rdf) concepts and abstract syntax. W3C Working Draft,
2003.

[12] D. Nardi and R. Brachman. An introduction to description

logics. In F. Baader, D. Calvanese, D. McGuinness, D. Nardi,
and P. F. Patel-Schneider, editors, The Description Logic
Handbook: Theory, Implementation, and Applications, pages
43–95. Cambridge University Press, 2003.

[13] J. Z. Pan and I. Horrocks. Metamodelling architecture of web

ontology languages. In Proc. of the 2001 Semantic Web
Working Symposium (SWWS), 2001.

[14] J. Z. Pan and I. Horrocks. RDFS(FA): A DL-ised

sub-language of RDFS. In Proc. of the 2003 Description
Logic Workshop (DL 2003), 2003.

[15] J. Z. Pan and I. Horrocks. RDFS(FA) and RDF MT: Two

semantics for RDFS. In Proc. of the 2003 International
Semantic Web Conference (ISWC 2003), 2003.

[16] P. F. Patel-Schneider, P. Hayes, and I. Horrocks. (editors).

Owl web ontology language semantics and abstract syntax.
W3C Candidate Recommendation, 2003. Work in progress.

[17] P. F. Patel-Schneider, P. Hayes, and I. Horrocks. Layering the
semantic web, problems and directions. In Proc. of the 2002
International Semantic Web Conference (ISWC 2002), 2002.

713