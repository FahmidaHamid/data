A Framework for the Server-Side Management of

Conversations with Web Services

Liliana Ardissono, Davide Cardinio, Giovanna Petrone and Marino Segnan

Dipartimento di Informatica, Universit`a di Torino

fliliana, giovanna, marinog@di.unito.it

Corso Svizzera 185
10149 Torino, Italy

ABSTRACT
The emerging standards for the publication of Web Services are fo-
cused on the speciﬁcation of the static interfaces of the operations
to be invoked, or on the service composition. Few efforts have been
made to specify the interaction between a Web Service and the indi-
vidual consumer, although this aspect is essential to the successful
service execution.
In fact, while “one-shot” services may be in-
voked in a straightforward way, the invocation of services requiring
complex interactions, where multiple messages are needed to com-
plete the service, depends on the fact that the consumer respects the
business logic of the Web Service.

In this paper, we propose a framework for the server-side man-
agement of the interaction between a Web Service and its con-
sumers. In our approach, the Web Service is in charge of assist-
ing the consumer during the service invocation, by managing the
interaction context and instructing the consumer about the oper-
ations that can be invoked and their actual parameters, at each
step of the conversation. Our framework is based on the exchange
of SOAP messages specifying the invocation of Java-based opera-
tions. Moreover, in order to support the interoperability with other
software environments, the conversation ﬂow speciﬁcation is ex-
ported to a WSDL format that enables heterogeneous consumers to
invoke the Web Service in a seamless way.

Categories and Subject Descriptors
D.2.11 [Software Engineering]: Software Architectures; D.2.12
[Software Engineering]: Interoperability

General Terms
Languages, Standardization

Keywords
Service Oriented Architectures, Tools and Technologies for Web
Services Development

1.

INTRODUCTION

Web Services are subject to several limitations that reduce their
applicability to realistic domains. For instance, the emerging ser-
vice publication standards, such as WSDL [32], support the spec-
iﬁcation of the static interfaces of elementary services. However,
these standards do not enable the service provider to specify the
ﬂow of the operations to be invoked by the consumer during the
Copyright is held by the author/owner(s).
WWW2004, May 17–22, 2004, New York, New York, USA.
ACM 1-58113-912-8/04/0005.

service execution. Therefore, the management of the interaction
between the consumer and the service provider is difﬁcult, unless
very simple tasks are requested. Moreover, these standards support
the invocation of operations characterized by very speciﬁc signa-
tures that fail to enable the peers to dynamically specify the actual
parameters of the operations to be performed. Although this is not
a problem when the requirements for the service can be speciﬁed
by the consumer in a pre-determined way, it challenges the pro-
vision of highly interactive services, such as those supporting the
customization of complex services and products.
In fact, in that
case, the Web Service has to identify the product features to be
conﬁgured at run time, depending on the product structure and on
the consumers’ requirements.

The current work on workﬂow management is focused on the
service composition in the Web but most of the proposed approaches
assume a rather simple type of interaction with the suppliers whose
services have to be invoked. For instance, BPEL4WS [13] sup-
ports the speciﬁcation of complex service compositions and offers
advanced solutions to the management of transactions [10] and fail-
ure recovery during the service execution [14]. However, the ser-
vice compositions are deﬁned as aggregations of standard WSDL
operations with ﬁxed parameters. Therefore, the service choreog-
raphy has to be speciﬁed at the same level of detail. Different from
BPEL4WS, Maamar etal [22] specify a service composition frame-
work that also handles conversation aspects, but they are concerned
with the establishment of the interaction with the service provider,
more than with the management of the interaction during the ser-
vice execution.

In order to make the service execution possible even when the in-
volved suppliers require complex interactions, the invocation has to
be modeled as a conversation where the peers may exchange sev-
eral messages before the service is completed; e.g., requirements
acquisition, negotiation and so forth. For instance, during the inter-
action with a Web Service supporting the conﬁguration of medium
complexity products, the speciﬁcation of the item features can re-
quire more than one step; moreover, failures may occur and have
to be repaired before the solution for the consumer is generated.
Finally, in some cases, the Web Service may require to suspend the
interaction, e.g., waiting for a sub-supplier or a human operator to
contribute to the generation of the solution.

In this paper, we present a framework for the management of
the communication between Web Service consumers and providers.
The conversation model we propose supports complex interactions
where several messages have to be exchanged before the service is
completed, and the conversation may evolve in different ways, de-
pending on the state and the needs of the two participants. We have
deﬁned our model by taking the speech-act theoretical model of

124dialog management as a starting point [26, 12], but we have simpli-
ﬁed it in order to meet the scalability and applicability requirements
of Web Services. Our proposal has the following peculiarities:

(cid:15) The conversation model clearly separates communicative be-
(cid:15) In the conversation ﬂow speciﬁcation, the signatures of the
(cid:15) Our conversation model introduces explicit methods that en-

havior from the domain-level actions that the conversation
participants perform during the service execution.

operations admit generic arguments that can be instantiated
with the actual parameters during the service execution.

able the Web Service provider to guide the consumer during
the service invocation, e.g., by informing it about the objects
to which the generic parameters of the operations have to be
bound.

Our contribution concerns the service execution, leaving the service
discovery apart, as this represents a separate, complex activity, to
be carried out by exploiting UDDI registries [30] and mediation
agents [21].

The remainder of this paper is organized as follows: Section
2 provides some background about the dialog models based on
Speech Act Theory and discusses some issues that limit their ap-
plicability to Web Services. Section 3 describes the approach to
conversation ﬂow speciﬁcation we propose and Section 4 presents
our conversation management framework at the conceptual level.
Section 5 sketches the infrastructure for the development of con-
versational Web Service providers and consumers we are develop-
ing. Section 6 addresses the exploitation of our framework from
the viewpoint of the Web Service consumer. Section 7 compares
our proposal to the related work and Section 8 concludes the paper.

2. BACKGROUND

Starting from the approach proposed in the Speech Act Theory
[7, 26], the communication between agents has often been modeled
by exploiting communicative actions, called speech acts, that deﬁne
the roles (speaker, hearer) played by the participants and separate
the illocutionary force of the agents’ messages from the object-level
actions underlying the execution of the conversation turns.

As the speech acts represent individual communicative actions,
various approaches have been proposed to model inter-agent com-
munication at the conceptual level. For instance, in [28] Finite
State Automata have been applied to specify the possible sequences
of conversation turns to be performed. Moreover, plan-based ap-
proaches have been introduced to model goal-oriented behavior and
to separate the management of the conversational behavior from the
domain-dependent activities carried out by the agents [12, 11, 25].
Two of the most important contributions provided by the Speech
Act Theory and the related dialog management models are the in-
troduction of explicit conversation roles played by the interacting
agents and the clear separation of communicative and domain-level
behavior. Speciﬁcally, the dialog management models assume that
the agents interact with each other to coordinate the domain-level
activity they are cooperating at. These contributions have been rec-
ognized as basic elements for the management of the communica-
tion between distributed processes and, especially in the research
about Multi-Agent systems, speech acts have been widely applied
to manage the inter-agent communication. For instance, see the
KQML [16] and the FIPA ACL [17] agent communication lan-
guages.

Although the speech-act based languages have been successfully
applied to support the communication between large, but closed

communities of interacting agents, we believe that they are hardly
applicable to Web Services, given the scalability and applicability
requirements of the open Internet environment. The point is that,
in order to exploit Web Services in an effective way, the consumers
should be able to start several e-business interactions with hetero-
geneous providers, also outside well established B2B relationships.
This means that the management of the communication between
Web Service consumers and providers should be loosely coupled
and that the conversation management should be lightweight, at
least at the consumer side. Unfortunately, the traditional speech-act
based approaches fail to meet these requirements in several aspects.
In particular:

(cid:15) From a pragmatic point of view, the imposition of complex
(cid:15) At the conceptual level, these approaches propose a mixed-

speech acts on Web Services is not realistic because current
services are published by means of very simple languages
such as RPC invocations or WSDL operations.

initiative model of dialog management, opposed to the client-
server interaction adopted in the interaction with Web Ser-
vices. In order to correctly interact with each other, the agents
have to agree on a shared interaction protocol, to separately
handle the interaction context and to autonomously regulate
the turn management activity. Each agent is expected to
maintain an internal representation of the information ex-
changed during the conversation and to exploit this informa-
tion to track the evolution of the conversation with respect
to the agreed protocol. In the world of Web Services, this
requirement raises serious interoperability issues. In fact, in
order to track the evolution of the conversation and to select
at each step the next speech act to be performed, the con-
sumer has to locally execute a copy of the possibly complex
conversation management tool (e.g., a ﬁnite state automaton)
employed by the provider.

In the rest of this paper, we describe a conversation model that ad-
dresses these requirements while preserving most of the concepts
introduced in the speech-act based dialog management models. We
deﬁne a ﬂexible, but simple representation formalism supporting
the speciﬁcation of the correct sequence of turns to be exchanged
between Web Service provider and consumer without the overhead
of the pure speech-act model. Moreover, being based on the emerg-
ing standards for the publication of Web Services, our model can
be applied to current Web Service providers and consumers in a
reasonably straightforward way.

3. CONVERSATION FLOW

SPECIFICATION

One way to satisfy the scalability and interoperability require-
ments described in the previous section is to place the overhead
of the communication management on the service provider, which
should assist the consumers during the service invocation, e.g., by
controlling and guiding the invocation of the operations at each
conversation step. Given the public speciﬁcation of the operations
offered by the service provider, the provider should maintain a lo-
cal interaction context for each active conversation. Moreover, at
each conversation step, the provider should enrich the outbound
messages for the consumer with contextual and turn management
information, in order to make the consumer aware about the eligi-
ble turns it may perform. In this way, the consumer can participate
to the conversation by interpreting the instructions it receives and
selecting the operation to invoke next.

1251

InitInteraction
SendM(C,S,
 InitConversation())

2

Refusal1
SendM(S,C,KO(res))

3

Agreement
SendM(S,C,OK,
 nextOps,ctx)

Refusal2
SendM(C,S,KO(res)))

Error
SendM(S,C,Fault(res,
   comment),nextOps,ctx)

4

SetData
SendM(C,S,SetData(args))

Confirmation

SendM(S,C,OK(res),
   nextOps,ctx)

5

ProposeProduct

SendM(S,C,ReceiveResult(prod),
                 nextOps,ctx)

8

10

Accept

SendM(C,S,OK(res))

SuspendInteraction2

ResumeInteraction1
SendM(S,C,Resume,
  nextOps,ctx)

UnrecoverableError

SendM(S,C,
  Fault(res, comment))

7

Figure 1: Conversation ﬂow speciﬁcation of a product customization Web Service.

6

SuspendInteraction1
Request(S,C,Suspend)

(cid:15) At each conversation step, the consumer is guaranteed to in-
(cid:15) In the dynamic speciﬁcation of the operations that can be

voke an operation that is eligible in the provider’s business
logic, without managing the interaction context. This aspect
reduces the probability of a failure in the overall service.

This approach explicitly puts the service provider in control of
the interaction, with the following advantages in the management
of the overall service:

invoked, a highly interactive provider may also specify the
actual parameters of these operations. For instance, a conﬁg-
uration Web Service may guide the consumer in the choice
of a large number of features by specifying, at each step, the
features to be considered and the admissible values that the
consumer may select.

With respect to the original representation of Speech Acts, we
propose to simplify the speciﬁcation of the interaction ﬂow by mod-
eling the interaction turns as generic conversational activities where
the performed speech act (e.g., Request, Inform, etc.) is not speci-
ﬁed. Moreover, in order to assist the consumer in the invocation of
the operations offered by the service provider, the interaction turns
have to be enriched with the necessary turn-management informa-
tion. Each conversational action is thus represented as a simpliﬁed
speech act (SendM message) where the sender asks the recipient to
perform the operation speciﬁed as an argument. The conversational
actions have the following structure:

(cid:15) Sender: message sender, which may be either the consumer
(cid:15) Recipient: receiver of the message (similar).

where the last two arguments are optional. The arguments of the
actions have the meaning reported below.

SendM(sender, recipient, operation, nextOps, ctx)

C, or the service provider S.

9

ResumeInteraction2

Request(C,S,Suspend)

SendM(C,S,Resume,
  nextOps,ctx)

(cid:15) Operation: operation that the sender invokes on the recipi-
(cid:15) NextOps: list of the possible continuations of the conversa-
(cid:15) Ctx: context argument, storing information about the state of

tion. As the service provider has the control of the inter-
action, this argument is only present in the messages to be
received by the consumer. The argument includes the set of
alternative operations offered by the provider which the con-
sumer may invoke in the next conversation step. For each
operation, the actual arguments are reported, together with
their domains, i.e., the sets of values that the arguments can
take.1

ent. It should be noted that the actor of the requested oper-
ation may be omitted because it coincides with the recipient
of the message. In other words, each message is aimed at
requesting that the recipient performs the operation reported
as the argument of the message.

the interaction. Similar to the nextOps argument, the ctx one
is only present in the messages directed to the consumer. The
structure of the context argument depends on the application
domain. For instance, the context object can be empty in
simple and deterministic interactions, where the consumer
has at most one conversation turn to choose from, i.e., the
next operation argument of the SendM message includes at
most one element. We will not consider the context argument
in the rest of this presentation.

The conversation ﬂow of a Web Service can be speciﬁed by deﬁn-

1The domain of a variable may change during the interaction with
the Web Service and thus has to be speciﬁed each time the variable
occurs as an argument of an operation. For instance, during the
conﬁguration of a product, the set of admissible feature values is
progressively narrowed by constraint propagation (domain reduc-
tion).

126ing the sequence of (simpliﬁed) speech acts that each conversation
partner has to perform. At the conceptual level, this can be done
by applying Finite State Automata (FSA), which ar a simple, well-
known and easily understandable formalism, and have been applied
in several proposals for the management of Web Service choreog-
raphy; e.g., see [8, 9].

We have selected the customization of bicycles as a sample appli-
cation domain to present our conversation model. Figure 1 shows
the FSA representing the conversation ﬂow speciﬁcation of the ser-
vice. The states of the automaton represent the dialog states: the
plain circles denote the conversation states and the thick one (state
1) is the initial state. The thick dotted states (3, 7, 10) are ﬁnal
states of the dialog. The conversation turns are represented as send
message (SendM) activities specifying the related arguments: mes-
sage sender, recipient, invoked operation, and so forth. The turns
to be performed by each of the peers are speciﬁed as labels of the
arcs. The states having more than one output arc represent situa-
tions where alternative turns may be performed by the peer. Notice
that we have also labeled the arcs with a boldface identiﬁer to sim-
plify the identiﬁcation of the conversation turns in the rest of this
presentation.

The interaction starts with the consumer C (e.g., the personal as-
sistant of an end-customer) asking the service provider S to start the
interaction (InitInteraction: SendM(C, S, InitConversation)). The
provider may accept to perform the request (Agreement: SendM(S,
C, OK, nextOps, ctx)), or reject it (Refusal1: SendM(S, C, KO(res))).
If the provider accepts the interaction, a data acquisition phase
starts during which the consumer speciﬁes (SetData arc) the end-
customer’s data and her/his requirements on the product to be cus-
tomized. The consumer informs the provider about these types of
information by invoking the SetData(args) operation on the list of
data/features to be set. For instance, the consumer might set the
number of gears of the bicycle equal to 4. Notice that the consumer
may retrieve this list from the nextOps argument of the last message
it received. SetData is an example of the generic kind of operation
we have introduced in our conversation model. Speciﬁcally, the
args parameter does not refer to any particular end-customer data
or product feature. When the consumer invokes the operation, it
binds the parameter to the actual list of features to be set.2

(cid:15) Conﬁrm the successful data acquisition (Conﬁrmation arc)
(cid:15) Notify the consumer that there was a failure in the product
(cid:15) Notify the consumer

When the consumer speciﬁes a set of data, e.g., some features
of the bicycle, the service provider may react in different ways.
Speciﬁcally, it may:

customization process (Failure) and enable the consumer to
select other values for the conﬂicting features.

and enable another invocation of the SetData operation.

the interaction is suspended
(SuspendInteraction1)
on
(ResumeInteraction1). The possibility to suspend and restart
the interaction enables the service provider to synchronize
with its own sub-suppliers, if necessary.

resume

later

that

and

it

Finally, the data acquisition phase can end negatively or positively.
The ﬁrst case happens when an unrecoverable error occurs; for
instance, the end-customers’ requirements are incompatible with

2The selection of the feature values would not be possible without
a suitable binding phase, where the consumer analyzes the product
structure speciﬁed in the Web Service ontology. Sharing the prod-
uct ontology is thus necessary to let the consumer understand the
individual product features to be set. See Section 6.

SendM message:

operation = Fault(nrGear,

"invalid parameter value");

nextOps = {SetFeatures(nrGear);
PostponeSet(nrGear);
Suspend(id)};

ctx = null;

Figure 2: Sample SendM message.

one another and thus they cannot be concurrently satisﬁed.
If,
however, the customization process succeeds, the provider con-
tinues the interaction by proposing the product (ProposeProduct).
The consumer may react in three different ways. If it accepts the
proposal (Accept), the conversation terminates; note that a pay-
ment phase should start, but we omit it for simplicity. If the con-
sumer rejects the proposal (Refusal2), the conversation goes back
to the data acquisition phase to start the conﬁguration of another
product. Otherwise, the consumer might suspend the interaction
(SuspendInteraction2)
on
(ResumeInteraction2). This alternative behavior enables the con-
sumer to submit the proposal to the end-customer and get the au-
thorization to accept/reject it.
Looking at the FSA, we can see that two kinds of object-level op-
erations may be the arguments of a conversation turn:

(cid:15) Domain-dependent operations, such as SetData, offered by
(cid:15) Domain-independent operations, such as InitConversation,

the service provider to execute its service.

resume

later

and

it

OK, Fault, Suspend, Resume and ReceiveResult, focused on
the coordination of the conversation between the partners.

Except for special cases, such as InitConversation, the domain-
independent operations have to be offered by the provider as well
as by the consumer. For instance, the consumer must offer the
ReceiveResult operation, which corresponds to the WSDL output
messages sent by the service provider to acknowledge the service
execution and communicate results.

the

sends

provider

Figure 2 shows a sample SendM message sent by the service
provider to the consumer during the conﬁguration of a bicycle. In
the message,
failure message:
Fault(nrGear, “invalid parameter value”). This message notiﬁes
the unsuccessful execution of a previously invoked operation: the
consumer previously set the nrGear parameter to an invalid value.
The provider also speciﬁes that the consumer may invoke SetData
to set the number of gears again, PostponeSet to postpone the set-
ting to a later stage of the interaction, or it may suspend the conver-
sation.

a

4.

INTERACTION MANAGEMENT

In order to manage the conversation at both sides, the two peers
should run, respectively, a Conversation Manager and a Conversa-
tion Client modules. The former is employed by the provider to
manage the interaction with the consumers, which would only rely
on the lightweight Conversation Client to parse the incoming mes-
sages and return the responses. The situation is shown in Figure 3,
that sketches the architecture of the proposed framework.

Notice that each turn (SendM message) is an asynchronous mes-
sage that one of the participants should send to continue the conver-
sation. If the message does not reach the recipient. the interaction
has to be suspended, by the conversation module, with a time out.

127Conversation
Client

consumer

SOAP
Request

SOAP
Response

Web
Service
Servlet

Web server

WSDL service
description

service provider

Conversation
Manager

Component
    A

Interaction
 Context-i

Interaction
 Context-j

Supplier

Figure 3: Interaction with a web service provider.

4.1 Conversation Manager

The Conversation Manager should exploit a conversation au-
tomaton, such as the one depicted in Figure 1, to control the ser-
vice provider’s behavior. For each interaction session with a con-
sumer, the Conversation Manager of the provider should maintain
the active state of the interaction as a description of the contextual
information concerning the speciﬁc conversation, moving the state
from the initial state of the automaton to the other ones, depending
on the messages it sends or receives. The Conversation Manager
would also be in charge of computing the next operations avail-
able to the consumer and to include them in the outbound SendM
messages.

The operations that the consumer may perform in the next con-
versation turn can be identiﬁed by performing a look-ahead in the
conversation automaton, starting from the active state. In fact, the
arcs of the automaton are associated to the signatures of the oper-
ations to be invoked. However, if the next operations have generic
parameters, such as the SetData operation of the product conﬁgura-
tion service, their signature is underspeciﬁed and the Conversation
Manager has to retrieve the actual parameters to include in the next
operations speciﬁcation. A highly interactive service provider has
thus the responsibility of exposing the list of data that may be spec-
iﬁed, at each step of the interaction.

We are not concerned about how the service provider addresses
this issue because it strictly depends on the provider’s implemen-
tation and has thus to be solved case by case. We want however
to point out that the inference engines typically exploited to carry
out problem solving activities are designed to stop and question the
calling modules when they need to set some variables in order to
carry the problem solving activity out. For instance, the conﬁgu-
ration systems based on constraint satisfaction, such as the ILOG
JConﬁgurator [20], explores the solution space by generating par-
tial solutions, which can be further speciﬁed, until all the variables
of the problem are instantiated, in an interactive way. Similarly,
BDI agent development tools, such as JACK [2], support the devel-
opment of agents that can interleave planning activities with sens-
ing actions, aimed at acquiring the values of their unbound vari-
ables.

4.2 Conversation Client

The Conversation Client is a lightweight conversation compo-
nent and has to be downloaded by the consumer before invoking
the Web Service. This component enriches the consumer’s conver-
sation capabilities with the following functionalities:

1. Establishing an endpoint to catch the incoming messages.
The Conversation Client provides the domain-independent

operations, such as Suspend, Resume, ReceiveResult, etc.,
that have to be offered by the consumer in order to manage
the interaction with the service provider.

2. Interpreting the inbound messages that the consumer receives
from the service provider. The Conversation Client extracts
the eligible continuations of the interaction by parsing the
nextOps argument of the inbound messages. For each oper-
ation, this list reports the parameters and their domains. In
[24, 5], we provide an XML schema specifying the format
adopted in the deﬁnition of the operations. Notice that, given
the list of alternatives, the consumer is responsible for choos-
ing the most convenient option and deciding the details of the
invocation, depending on its own business logic.

3. Guiding the consumer in the instantiation of the selected op-
eration. When the consumer sets the values of the parameters
of the invoked operation, the Conversation Client performs
type checks to ensure that the selected values belong to the
associated domains. The Client does not ﬁnalize the instan-
tiation of the operation until all the parameters are correctly
set by the consumer.

4. Generating the outbound SendM messages and sending them

to the service provider.

Item 3 deserves further discussion because it plays a critical role
in the enforcement of the correct invocation of the provider, there-
fore reducing the occurrences of failures in the service execution.
In fact, the consumer might make a mistake when binding the ar-
guments of the object-level operation to be invoked. For instance,
the SetData operation could be invoked by specifying values that
violate the parameter domains, with a consequent failure in the ex-
ecution of the operation at the provider side and the need to com-
pensate the failure. Of course, although the local checks support the
repair to several problems within the consumer, they do not prevent
the failure of the overall product customization. Problems might
occur, for instance, if the overall set of features speciﬁed during
the customization of the product is inconsistent. This general type
of failure is detected at the service provider side and is handled
as speciﬁed in the UnrecoverableError transition of the automaton
depicted in Figure 1.

1285. A FRAMEWORK FOR THE

SERVER-SIDE MANAGEMENT OF
COMPLEX INTERACTIONS

We are developing a set of Java libraries aimed at facilitating
the development of a Conversation Manager and a Conversation
Client modules supporting the communication between Web Ser-
vice providers and consumers. For the implementation, we are ex-
ploiting the Sun Microsystem Web Service Developer Pack [29]
and in particular the JAXP-RPC package of the Pack.

We have developed a Java-based Conversation Manager module
that enables the Web Service provider to control the communica-
tion with the interacting consumer applications. The proposed ar-
chitecture of the Web Service Provider is shown in Figure 3. A
Servlet supports the (SOAP) HTTP-based communication with the
consumer, by catching the incoming requests and forwarding them
to the Conversation Manager for their management.

The Conversation Manager is the core of the Servlet listening
to the incoming requests, invoking the appropriate components to
execute the services and sending the SOAP response messages to
the consumer applications. Depending on the binding to the Web
Service provider’s business logic, this module can invoke different
types of components to provide the service. For instance, a ser-
vice could rely on an internal component, such as Component A in
Figure 3, or by an external Supplier.

The Conversation Manager may execute a conversation ﬂow au-
tomaton for the management of the interaction sessions with the
consumers in order to compute the possible continuations of each
interaction. Although a general infrastructure, supporting the def-
inition of general purpose conversation automata, is not yet avail-
able, we have developed a prototype Conversation Manager that
implements the FSA shown in Figure 1 and that can be easily cus-
tomized to satisfy the interaction requirements of different applica-
tion domains.

As previously mentioned, for interoperability purposes we rely
on an XML representation of the signatures of the operations and
of the parameter domains. In our infrastructure, the generation of
Java classes and objects starting from the XML representation is
carried out by exploiting the JAXB tool offered by the Pack.

We have also developed a Java-based Conversation Client that
may be downloaded by the consumer and run in order to handle the
interaction with a Web Service.

The Conversation Client catches the messages that the Web Ser-
vice sends to the consumer and extracts the operations that may be
invoked on the Web Service next (nextOps). Moreover, the Client
supports the generation of the SendM messages to be sent in re-
sponse to the Web Service; for the generation of messages, a subset
of the libraries available to the Conversation Manager is exploited.
Similar to the Conversation Manager, the execution of the Client
has the prerequisite that the consumer binds the invocation of the
operations to its own business logic. This issue is discussed in de-
tail in Section 6. Here, we only mention the fact that the Con-
versation Client offers suitable APIs for the invocation of its func-
tionalities; e.g., extraction of next operations with parameters and
domains, instantiation of operations and message generation.
In
particular, the instantiation of the operations enables the consumer
to set the values of the parameters. During the execution of the in-
stantiation procedure, the Conversation Client checks whether the
selected values belong to the domains of the parameters, returning
a failure in case of type violation.

It should be noted that the XML representation of the SendM
messages supports the interoperability between service consumers
and providers, but the Conversation Client we implemented can

only be run in a Java-based environment. The idea is therefore
that other versions of the Client should be implemented to provide
advanced conversation capabilities in different environments such
as, for instance, .Net.
5.1 WSDL Speciﬁcation of Operations

It should be noticed that JWSDP allows the development of Java
code that is automatically translated to SOAP messages following
the WSDL speciﬁcation. In our work, we have exploited this fea-
ture to support the interoperability of a Java-based Web Service
with consumers developed in heterogeneous environments.

More speciﬁcally, we enable the service provider running our
Conversation Manager to handle inbound and outbound messages
by applying the SOAP communication protocol to exchange Java-
based messages. However, we also provide a declarative represen-
tation of the format of the SendM messages, including the WSDL
speciﬁcation of the object-level operations requested by means of
the SendM messages. Following the WSDL speciﬁcation, the
schema deﬁning datatypes and object-level operations, such as Set-
Data, are generated, as well as the ports and bindings needed to
interpret WSDL messages.3 Thus, a generic consumer, which does
not exploit our Conversation Client, may invoke the Conversation
Manager by conforming to the WSDL speciﬁcation of its services.
Moreover, the consumer may be guided by the provider in the cor-
rect invocation of services if it correctly parses the SendM messages
it receives, by suitably extracting the nextOperations information
stored in the messages.

From our perspective, the SendM operation is a service offered
by both conversation participants. In fact, the consumer needs to of-
fer the SendM operation in order to receive messages from the ser-
vice provider. Therefore this operation must be added to the WSDL
speciﬁcation of both types of peers. However, the publication of
the SendM operation does not impose any development overhead
because it is automatically generated by our framework. Figure
4 shows a portion of the WSDL declarations generated to support
the management of SendM messages and includes the speciﬁcation
of the SetData object-level operation speciﬁc for the customization
of products. For readability purposes we have removed some in-
formation from the WSDL speciﬁcation. See [3] for the complete
representation of this portion of the product customization service.

6. DISCUSSION

In this section, we discuss the binding requirements imposed by
our approach on the administrator of the service consumer. This
aspect is very important, as binding the consumer’s business logic
to the invocation of operations on the Web Service is a prerequisite
to the service execution.

The ﬁrst proposals for the management of Web Services assumed
a synchronous type of interaction between service provider and
consumer. Although this requirement imposed that the consumer
waits for the result message each time it invokes an operation on
the provider, the synchronization facilitated the set up of the com-
munication. The consumer could in fact associate the invocation of
operations to its own business logic by inspecting the WSDL ports
published by the provider and by connecting the invocation of op-
erations to its own internal processes. The results of the invoked
operations could then be collected by the consumer by exploiting
an implicit return channel.

In order to overcome the limitations of synchronous communi-

3The infrastructure enforces the WS-I standards on complex object
type to ensure interoperability between Web Services providers and
consumers developed in heterogeneous environments.

129<?xml version="1.0" encoding="UTF-8"?>
<definitions name="MyConversationService" targetNamespace="urn:Foo"

xmlns:tns="urn:Foo" xmlns="http://schemas.xmlsoap.org/wsdl/"
xmlns:xsd="http://www.w3.org/2001/XMLSchema"
xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/">

<types>

<schema targetNamespace="http://java.sun.com/jax-rpc-ri/internal"
xmlns:tns="http://java.sun.com/jax-rpc-ri/internal" ..... ">

<restriction base="soap11-enc:Array">

<attribute ref="soap11-enc:arrayType" wsdl:arrayType="anyType[]"/>

<import namespace=..."/>
<complexType name="vector"> ...
<complexType name="collection">

<complexContent>

</restriction>

</complexContent>

</complexType>

...

<complexType name="SendMArgs">

<sequence>

<element name="context" type="anyType"/>
<element name="convId" type="string"/>
<element name="currentOperation" type="string"/>
<element name="nextOperations" type="ns2:vector"/>

</sequence>

</complexType>

</schema>

</types>

<message name="Conversation_sendM">

<part name="SendMArgs_1" type="tns:SendMArgs"/>

</message> ... DEFINITION OF OBJECT-LEVEL OPERATIONS, i.e., SetData, FOLLOWS ...

<portType name="Conversation">

<operation name="sendM" parameterOrder="SendMArgs_1">

<input message="tns:Conversation_sendM"/>
<output message="tns:Conversation_sendMResponse"/>

</operation>

</portType>

<binding name="ConversationBinding" type="tns:Conversation">

<operation name="sendM">

<soap:body encodingStyle="http://schemas.xmlsoap.org/soap/encoding/" ... />

<input>

</input>
<output>

<soap:body encodingStyle="http://schemas.xmlsoap.org/soap/encoding/" ... />

</output>
<soap:operation soapAction=""/>

</operation>
<soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="rpc"/>

</binding>

<service name="MyConversationService">

<port name="ConversationPort" binding="tns:ConversationBinding">

<soap:address location="REPLACE_WITH_ACTUAL_URL"/>

</port>

</service>

</definitions>

Figure 4: Portion of the WSDL speciﬁcation of a product customization service.

130cation, the emerging Web Services standards have recently evolved
to support asynchronous communication based on call back mes-
sages; see [1]. This change has made the binding phase more com-
plex because now the Web Service has to publish different port
types, one for each conversation participant, and the consumer be-
comes itself a Web Service that offers the ports required by the role
it wants to play in the interaction. For instance, in our conﬁguration
example, the consumer would play a purchaser role that speciﬁes
all the operations to be offered in order to participate to a purchase
business interaction. Roughly speaking, the role-based port types
represent the participants’ viewpoints on the shared interaction pro-
tocol.

In our approach, binding the consumer’s business logic is not

dramatically different from the previous case. Similar to BPEL4WS1.1,
our conversation model relies on the deﬁnition of conversational
roles for the speciﬁcation of the services that have to be offered by
each participant; e.g., consider the domain-dependent and domain-
independent operations offered by service providers and consumers.
Moreover, our model assumes that the service provider publishes
the conversation ﬂow speciﬁcation, so that the consumer can in-
spect the speciﬁcation and bind the invocation of services to its
own internal processes. At the same time, the conversation man-
agement features offered by our framework are partially handled
by the Conversation Client libraries we offer. Speciﬁcally:

(cid:15) The public conversation ﬂow speciﬁcation published by the
(cid:15) The presence of operations having generic arguments adds

service provider describes all the possible sequences of turns
between the interactants and the next operations represent a
subset of those sequences. Therefore, the next operations are
not discovered by the consumer starting from zero knowl-
edge. The consumer can analyze the conversation ﬂow at
business logic binding time; it then acquires at run time the
subset of operations that can be invoked in the context of the
individual interaction session.

complexity to the speciﬁcation formalism, hiding the indi-
vidual parameters of the operations from the conversation
ﬂow speciﬁcation. However, the type of information needed
to enable the consumer to bind the invocation of operations
(with instantiated parameters) to its own business logic is
the same as that of the standard ﬁxed parameters approach.
The only difference is that, instead of directly analyzing the
parameters speciﬁed in the signatures of the operations, the
consumer has to analyze a separate representation structure,
published by the service provider, where the possible param-
eters are described. For instance, in our sample domain, the
Service must publish the speciﬁcation of the list of product
features that can be arguments of the SetData operation. The
publication of this information enables the consumer to bind
the possible invocations of the operations to its own busi-
ness logic. For example, the operation could have as actual
parameters the product features deﬁned in the public spec-
iﬁcation of the product structure; e.g., gears, frame, and so
forth.

(cid:15) Our Conversation Client implements and publishes the do-

main independent operations that the consumer has to offer
in order to receive the provider’s messages, interpret them
and send the responses to the provider. Therefore, no over-
head is imposed on the consumer to set up the conversation
framework; it only has to download the Client and associate
internal processes to object-level actions. Moreover, at run
time, the Conversation Client supports the consumer by ex-

tracting from the next operations information the actual pa-
rameters to be applied to the invoked operations.

As already mentioned, our conversation model handles operations
having generic arguments in order to overcome the limitations of
the emerging Web Service publication standards. Indeed, the ex-
ploitation of operations characterized by ﬁxed parameters would
not support a concise and efﬁcient speciﬁcation of the conversation
ﬂow of highly interactive service providers. Moreover, it would not
take priorities in the assignment of parameters into account. The
sample domain that we selected provides an example of this prob-
lem. For instance, in the conﬁguration of complex products, the
operations to be performed can be clearly deﬁned, e.g., specifying
the needed components and their features. However, the features
whose values have to be set depend on the optionals required by the
consumer and the expressed requirements may change the strategy
adopted by the conﬁguration Web Server in the speciﬁcation of the
other product features. Therefore, assuming that the consumer has
bound the setting of all the possible features to its own business
logic, the Web Service has to dynamically determine the correct in-
vocation of operations during the exploration of the search space,
by taking contextual information about the interaction into account.

7. RELATED WORK

The Semantic Web community [27] is deﬁning standards for the
publication of Web Services that support the speciﬁcation of the
domain ontology underlying the service, the meaning of the op-
erations to be invoked and the service choreography. The main
advantage with respect to the pure XML approach is that the ser-
vice offered by a provider can be unambiguously understood by the
(UDDI) registries, therefore enhancing their capability to redirect
consumers to the most suitable providers. In order to facilitate the
interoperability between service consumers and providers, some re-
cent work also proposes prototype infrastructures for the run-time
conversation management. These infrastructures rely on the se-
mantic representation of the services to guide the interaction, e.g.,
by instructing the consumer during the service invocation [23].

Although the semantic Web approach is the most promising so-
lution to the interoperability in the internet, the current proposals
are still too complex to be applied in real-world examples. For in-
stance, these approaches rely on sophisticated representations of
the services to be invoked; although translation tools assist the
binding to the consumers’ business logics, this remains a rather
complex process. Moreover, the selection of the operations to be
invoked, depending on the service choreography, is based on the
exploitation of inference engines, such as rule-based ones, impos-
ing relevant overhead on the management of the interaction. In our
work we are deeply concerned with the scalability and applicability
constraints imposed by the Web. For this reason, we try to reduce
the complexity added by semantic information as much as possi-
ble, and to handle the interaction between service consumer and
provider in a lightweight fashion, at least at the consumer side.

Other XML-based standards for the speciﬁcation of the conver-
sation ﬂow in e-business interactions with Web Services have been
recently proposed and are currently submitted as W3C standards.
For instance, WSCL (Web Services Conversation Language [31])
and WSCI (Web Services Choreography Interface [6]) introduce
an explicit representation of Web Services interaction processes,
aimed at deﬁning the admissible sequences of messages to be ex-
changed by the peers. To this purpose, WSCL exploits a sequence
diagram model that the peers should interpret to handle the conver-
sation, while WSCI introduces the notion of interaction process,
with the speciﬁcation of timing constraints on the service invoca-

131tion. Moreover, cpXML (IBM’s Conversation Support [18]) in-
troduces an explicit notion of Conversational Policy as a machine
readable speciﬁcation of a pattern of message exchange in a con-
versation, which can be used to make the interaction with complex
Web Services easier from the consumer application viewpoint.

Our interaction model differs from the previously mentioned
ones because they assume that the participants share the interaction
protocol and autonomously plan the conversational behavior, ac-
cording to that protocol. In those approaches each participant sep-
arately maintains its own internal record of the conversation state,
which is necessary to understand how to continue the interaction.
In contrast, we propose that only the service provider maintains the
state of the conversation and that the consumer application is as-
sisted in the service invocation. Another difference with respect to
WSCL and WSCI is the fact they conform to WSDL in the spec-
iﬁcation of request-response and solicit-response operations; thus,
they cannot support a ﬁne-grained speciﬁcation of the conversation
turns.

Among the mentioned approaches, cpXML deserves a more thor-
ough comparison with our work, because it aims at developing an
implementation framework supporting the communication, while
the other approaches only contribute with a speciﬁcation of a com-
munication protocol. In cpXML the consumer and provider roles
require the same effort from the conversational point of view. In
contrast, we try to simplify the implementation of the consumer;
moreover, the consumer is supplied with the minimum amount of
information needed to interact with the provider. This is positive,
because it supports the implementation of lightweight consumers.
At the same time, our approach does not impose extra overhead
on the service provider, for two reasons. First, the provider has
to maintain the context for each interaction session, otherwise, it
would not be able to correctly execute the service requests. Sec-
ond, the provider knows the details of the execution of its own ser-
vices. Therefore, it may suitably guide the consumers during the
management of complex interactions.

Both cpXML and our work aim at decoupling the peers’ busi-
ness logics by mediating their interaction by means of the conver-
sational activity. However, our model has the potential to separate
the consumer from the provider in a clearer way because it does not
impose the execution of a speciﬁc conversation policy.

8. CONCLUSIONS

We have presented a conversational model aimed at ﬁlling the
conversational gap between consumers and service providers in the
internet. Our approach is based on the idea that the accessibility of
Web Services and the establishment of short-term interactions with
consumers are facilitated by the following factors:

(cid:15) A ﬂexible but simple conversation model supporting the ex-
(cid:15) The provider-side control of the interaction, aimed at enforc-
(cid:15) The possibility to perform local type and consistency checks

ing the correct invocation of services and at minimizing the
communication overhead posed on the consumer. Our con-
versation model supports the participation of the consumer
in the interaction with the service provider by dynamically
specifying the eligible operations that can be invoked at each
step.

change of asynchronous messages during the interaction.

at the consumer side, before invoking the operations on the
provider.

As discussed in [15], the invocation of Web Services should be as
seamless as possible for the consumers that should not be forced to

implement speciﬁc procedures for the service invocation. Although
the current Web Service speciﬁcation frameworks address this con-
straint by providing stubs that can be invoked by consumers, we
aim at providing interactivity between the peers and we take into
account the fact that the consumer has to be additionally guided
by the provider whenever the sequence of operations to be invoked
and their actual parameters have to be speciﬁed during the service
fruition. To this extent, we propose a framework that enables the
consumer to correctly invoke the service provider and to locally
perform simple type checks aimed at enforcing the correct invo-
cation of operations and at minimizing the occurrence of failures,
with the consequent need to exchange repair messages.

Our framework supports the consumer by offering a Conversa-
tion Client that may be downloaded and run to handle the inter-
action with a Web Service after having bound the invocation of
operations to the consumer’s business logic. Moreover, the frame-
work offers the libraries needed by the service provider to generate
the messages guiding the consumer in the correct invocation of ser-
vices and the libraries for the speciﬁcation and implementation of
the conversational ﬂow automaton held by the Web Service.

At the current stage, the automaton specifying the service provider’s

conversation ﬂow is represented in an XML language that we de-
ﬁned by taking inspiration from the WSFL ﬂow speciﬁcation lan-
guage; see [24, 4, 5]. Moreover, our infrastructure offers the Con-
versation Manager module that can be exploited by the service
provider to control the interaction with the customer, according to
the conversation automaton. As discussed in Section 5.1, the rep-
resentation of the conversation turns is compatible with the WSDL
format: the only difference is that the arguments of the SendM op-
erations may be object-level operations, or turn-management infor-
mation. The conversation ﬂow could therefore be represented in a
standard process language, such as, for instance, BPEL4WS1.1. In
our future work, we want to investigate this issue and see whether
a different version of our Conversation Manager can be developed
and plugged into a suitable ﬂow engine, e.g., BPWS4J [19], in or-
der to integrate workﬂow management and conversation manage-
ment into a single process.

9. REFERENCES
[1] T. Andrews, F. Curbera, H. Dholakia, Y. Goland, J. Klein,
F. Leymann, K. Liu, D. Roller, D. Smith, S. T. I. Trickovic,
and S. Weerawarana. Business Process Execution Language
for Web Services version 1.1j. http://www-
106.ibm.com/developerworks/webservices/library/ws-bpel/,
2003.

[2] AOS. JACK Intelligent Agents [tm].

http://www.agent-software.com/shared/products/index.html,
2002.

[3] Appendix. Automatic generation of a WSDL interface for

the invocation of a service provider.
http://www.di.unito.it/˜liliana/appendix.txt, 2003.
[4] L. Ardissono, A. Goy, and G. Petrone. Enabling

conversations with Web Services. In Proc. 2nd Int. Joint.
Conf. on Autonomous Agents and MultiAgent Systems, pages
819–826, Melbourne, Australia, 2003.

[5] L. Ardissono, G. Petrone, and M. Segnan. Enabling ﬂexible

interaction with web services. Forthcoming.

[6] A. Arkin, S. Askary, S. Fordin, W. Jekeli, K. Kawaguchi,

D. Orchard, S. Pogliani, K. Riemer, S. Struble,
P. Takacsi-Nagy, I. Trickovic, and S. Zimek. Web Service
Choreography Interface 1.0.
http://ifr.sap.com/wsci/speciﬁcation/wsci-specp10.html,
2002.

132[7] J. Austin. How to Do Things with Words. Harvard University

[19] IBM AlphaWorks. BPWS4J.

Press, Cambridge, Mass, 1962.

http://www.alphaworks.ibm.com/tech/bpws4j, 2003.

[8] B. Benatallah, F. Casati, F. Toumani, and R. Hamadi.

[20] ILOG. ILOG JConﬁgurator.

Conceptual modeling of Web Service conversations. In Proc.
Advanced Information Systems Engineering, 15th Int. Conf.,
CAiSE 2003, Klagenfurt, Austria, 2003.

[9] D. Berardi, F. D. Rosa, L. D. Santis, and M. Mecella. Finite
state automata as a conceptual model of e-services. In Proc.
Integrated Design and Process Technology (IDPT 2003),
Austin, Texas, 2003.

http://www.ilog.com/products/jconﬁgurator/, 2002.

[21] M. Klusch and K. Sycara. Brokering and matchmaking for

coordination of agent societies: A survey. In A. Omicini,
F. Zambonelli, M. Klusch, and R. Tolksdorf, editors,
Coordination of Internet Agents: Models, Technologies, and
Applications, chapter 8, pages 197–224. Springer-Verlag,
2001.

[10] F. Cabrera, G. Copeland, T. Freund, J. Klein, D. Langworthy,

[22] Z. Maamar, B. Benatallah, and W. Mansoor. Service chart

D. Orchard, J. Shewchuk, and T. Storey. Web Services
Coordination (WS-Coordination).
http://www-106.ibm.com/developerworks/library/ws-coor/,
2002.

[11] J. Chu-Carroll and S. Carberry. Collaborative response

generation in planning dialogues. Computational Linguistics,
24(3):355–400, 1998.

[12] P. Cohen and H. Levesque. Rational interaction as the basis
for communication. In P. Cohen, J. Morgan, and M. Pollack,
editors, Intentions in communication, pages 221–255. MIT
Press, 1990.

[13] F. Curbera, Y. Goland, J. Klein, F. Leymann, D. Roller,

S. Thatte, and S. Weerawarana. Business Process Execution
Language for Web Services, version 1.0. http://www-
106.ibm.com/developerworks/webservices/library/ws-bpel/,
2002.

[14] F. Curbera, R. Khalaf, N. Mukhi, S. Tai, and S. Weerawarana.
The next step in Web Services. Communications of the ACM,
Special Issue on Service-Oriented Computing, 46(10), 2003.

[15] H. Deo. The need for a dynamic invocation framework.

WebServices.org,
http://www.webservices.org/index.php/article/articleview/
469/1/24, 2002.

[16] T. Finin, Y. Labrou, and J. Mayﬁeld. KQML as an agent

communication language. In J. Bradshaw, editor, Software
Agents. MIT Press, Cambridge, 1995.

[17] FIPA. Foundation for Physical Intelligent Agents.

http://www.ﬁpa.org/, 2000.

[18] J. Hanson, P. Nandi, and D. Levine. Conversation-enabled

Web Services for agents and e-Business. In Proc. of the Int.
Conf. on Internet Computing (IC-02), pages 791–796, Las
Vegas, Nevada, 2002.

diagrams - description & application. In Proc. of
WWW’2003, Budapest, 2003.

[23] M. Paolucci, K. Sycara, T. Nishimura, and N. Srinivasan.
Toward a semantic web e-commerce. In Proc. of 6th Int.
Conf. on Business Information Systems (BIS’2003), Colorado
Springs, Colorado, 2003.

[24] G. Petrone. Managing ﬂexible interaction with Web Services.

In AAMAS-03 workshop on Web-services and agent-based
engineering, pages 41–48, Melbourne, Australia, 2003.

[25] C. Rich, D. McDonald, N. Lesh, and C. Sidner.

COLLAGEN: Java middleware for collaborative agents
services with multiple suppliers.
http://www.merl.com/projects/collagen, 2002.

[26] J. Searle. Indirect speech acts. In P. Cole and J. Morgan,

editors, Syntax and Semantics: Speech Acts, volume 3, pages
59–82. Academic Press, New York, 1975.

[27] Web Services Coalition. DAML-S: Web Service description

for the Semantic Web. In Proc. Int. Semantic Web
Conference, pages 348–363, Chia Laguna, Italy, 2002.

[28] A. Stein and E. Maier. Structuring collaborative

information-seeking dialogues. Knowledge-Based Systems,
8(2-3):82–93, 1994.

[29] Sun Microsystems, Inc. Java Web Services Development

Pack 1.3.
http://java.sun.com/webservices/webservicespack.html/,
2003.

[30] UDDI Org. Universal Description, Discovery and Integration

of Business for the Web. http://www.uddi.org/.

[31] W3C. Web Services Conversation Language (WSCL).

http://www.w3.org/TR/wscl10, 2002.

[32] W3C. Web Services Deﬁnition Language.

http://www.w3.org/TR/wsdl, 2002.

133