CTR-S: A Logic for Specifying Contracts

in Semantic Web Services∗

Hasan Davulcu
Department of CSE

Arizona State University

Box 875406,

Tempe, AZ 85287-5406
hdavulcu@asu.edu

Michael Kifer

Department of Computer

Science

Stony Brook University
Stony Brook, NY 11794

I.V. Ramakrishnan
Department of Computer

Science

Stony Brook University
Stony Brook, NY 11794

kifer@cs.stonybrook.edu

ram@cs.stonybrook.edu

ABSTRACT
A requirements analysis in the emerging ﬁeld of Semantic Web Ser-
vices (SWS) (see http://daml.org/services/swsl/requirements/) has
identiﬁed four major areas of research: intelligent service discov-
ery, automated contracting of services, process modeling, and ser-
vice enactment. This paper deals with the intersection of two of
these areas: process modeling as it pertains to automated contract-
ing. Speciﬁcally, we propose a logic, called CT R-S, which cap-
tures the dynamic aspects of contracting for services. Since CT R-S
is an extension of the classical ﬁrst-order logic, it is well-suited to
model the static aspects of contracting as well. A distinctive feature
of contracting is that it involves two or more parties in a potentially
adversarial situation. CT R-S is designed to model this adversarial
situation through its novel model theory, which incorporates cer-
tain game-theoretic concepts. In addition to the model theory, we
develop a proof theory for CT R-S and demonstrate the use of the
logic for modeling and reasoning about Web service contracts.

Categories and Subject Descriptors
H.4.m [Information Systems]: Miscellaneous; I.1.3 [Computing
Methodologies ]: Symbolic and algebraic manipulation—Lan-
guages and Systems
General Terms
Algorithms, Languages, Veriﬁcation
Keywords
Web Services, Services Composition, Contracts

1.

INTRODUCTION

A Web service is a process that interacts with the client and other
services to achieve a certain goal. A requirements analysis in the
emerging ﬁeld of Semantic Web Services (SWS)1 has identiﬁed four
major areas of research: intelligent service discovery, automated
contracting of services, process modeling, and service enactment.
It is generally agreed that Semantic Web Services should be based
on a formalism with a well-deﬁned model-theoretic semantics, i.e.,
on some sort of a logic. In this paper we propose a logic, called
CT R-S, which captures the dynamics of contracting for services
∗
M. Kifer and I.V. Ramakrishnan were supported in part by the
NSF grants CCR-0311512 and IIS-0072927.
1See http://daml.org/services/swsl/requirements/
Copyright is held by the author/owner(s).
WWW2004, May 17–22, 2004, New York, New York, USA.
ACM 1-58113-912-8/04/0005.

and thus is in the intersection of the areas of contracting and pro-
cess modeling. Since CT R-S is an extension of the classical ﬁrst-
order logic, it is well-suited for modeling of the static aspects of
contracting as well. If object-oriented representation is desired, F-
logic [14] (and an adaptation of CT R-S) can be used instead.

The idea of using a logic to model processes is not new [12, 2,
23, 8, 21]. These methodologies are commonly based on the clas-
sical ﬁrst-order logic, temporal logic [9], and Concurrent Transac-
tion Logic [5]. A distinctive aspect of contracting in Web services,
which is not captured by these formalisms, is that contracting in-
volves multi-party processes, which can be adversarial in nature.
One approach to deal with this situation could be to try and ex-
tend a multi-modal logic of knowledge [10]. However, we found
it more expedient to extend Concurrent Transaction Logic [5] (or
CT R), which has been proven a valuable tool for modeling and rea-
soning about processes [8, 4, 17]. The extension is called CT R-S
and is designed to model the adversarial situation that arises in ser-
vice contracting. This is achieved by extending the model theory of
CT R with certain concepts borrowed from the Game Theory [18,
13, 19]. In this paper we also develop a proof theory for CT R-S
and illustrate the use of this logic for modeling and reasoning about
Web service contracts.

A typical situation in contracting where different parties may
sometimes have conﬂicting goals is when a buyer interacts with a
seller and a delivery service. The buyer needs to be assured that the
goods will either be delivered (using a delivery service) or money
will be returned. The seller might need assurance that if the buyer
breaks the contract then part of the down-payment can be kept as
compensation. We thus see that services can be adversarial to an
extent. Reasoning about such services is an unexplored research
area and is the topic of this paper.

Overview and summary of results. We introduce game-theoretic
aspects into CT R using a new connective, the opponent’s conjunc-
tion. This connective represents the choice of action that can be
made by a party other than the reasoner. The reasoner here can
be the client of a Web service who needs to verify that her goals are
met or a service that needs to make sure that its business rules are
satisﬁed no matter what the other parties (the clients and other ser-
vices) do. Actors other than the reasoner are collectively referred
to as the opponent. We then develop a model theory for CT R-S
and show how this new logic can be used to specify executions of
services that may be non-cooperating and have potentially conﬂict-
ing goals. We also discuss reasoning about a fairly large class of
temporal and causality constraints.
In CT R-S, a contract is modeled as a workﬂow that represents
the various possibilities for the service and the outside actors (or the

144client and other services). The CT R-S model theory characterizes
all possible outcomes of a formula W that represents such a work-
ﬂow. A constraint, Φ, represents executions of the contract with
certain desirable properties. For instance, from the client’s point of
view, a desirable property might be that either the good is delivered
or the payment is refunded. The formula W∧Φ characterizes those
executions of the contract that satisfy the constraint Φ. If W ∧ Φ is
satisﬁable, i.e., there is at least one execution in its model, then we
say that the constraint Φ is enforcible in the workﬂow formula W.
We describe a synthesis algorithm that converts declarative spec-
iﬁcations, such as W ∧ Φ, into equivalent CT R-S formulas that
can be executed more efﬁciently and without backtracking. The
transformation also detects unsatisﬁable speciﬁcations, which are
contracts that the reasoner cannot force to execute with desirable
outcomes. In game-theoretic terms, the result of such a transfor-
mation can be thought of as a concise representation of all winning
strategies, i.e., all the ways for the reasoner to achieve the desired
outcome, regardless of what the rest of the system does, if all the
parties obey the terms of the contract.
Finally, since CT R-S is a natural generalization of CT R, a
pleasing aspect of this work is that our earlier results in [8] become
special cases of the new results.
The rest of the paper is organized as follows. In Section 2, we
introduce CT R-S and discuss its use for modeling workﬂows and
contracts. In Section 3, we introduce the model theory of CT R-S.
Section 4 discusses the proof theory. Section 5 introduces causal
and temporal workﬂow constraints that can be used to specify goals
of the participants in a contract. In Section 6, we present an algo-
rithm for solving these constraints and discuss its complexity. Sec-
tion 7 concludes with a discussion of related formalisms.

VICE CONTRACTS

2. CT R-S AND THE DYNAMICS OF SER-
Familiarity with CT R [5] can help understanding of CT R-S and
its relationship to workﬂows and contracts. However, this paper is
self-contained and includes all the necessary deﬁnitions. We ﬁrst
describe the syntax of CT R-S and then supply intuition to help the
reader make sense out of the formal deﬁnitions that follow.
2.1 Syntax

The atomic f ormulas of CT R-S are expressions of the
form p(t1, ..., tn), where p is a predicate symbol and ti are terms,
i.e., they are the same as in classical logic. Complex formulas are
built with the help of connectives and quantiﬁers: if φ and ψ are
CT R-S formulas, then so are φ ∧ ψ, φ ∨ ψ, φ ⊗ ψ, φ | ψ, ¬φ,
φ (cid:4) ψ, (∃X)φ, and (∀X)φ, where X is a variable. Intuitively, the
formula φ ⊗ ψ means: execute φ and then execute ψ. The con-
nective ⊗ is called serial conjunction. The formula φ | ψ
denotes an interleaved execution of two games φ and ψ. The con-
nective | is called concurrent conjunction. The formula
φ (cid:4) ψ means that the opponent chooses whether to execute φ or
ψ, and therefore (cid:4) is called opponent
(cid:1)
s conjunction. The
meaning of φ ∨ ψ is similar, except the reasoner makes the deci-
sion. In CT R this connective is called classical disjunction
but because of its interpretation as reasoner’s choice we will also
s disjunction. Finally, the formula
refer to it as reasoner
φ ∧ ψ denotes execution of φ constrained by ψ (or ψ constraint by
φ). It is called classical conjunction.2
As in classical logic, we introduce φ←ψ as an abbreviation for
2The meaning of ∧ is all but classical. However, its semantic def-
inition looks very much like that of a conjunction in predicate cal-
culus. This similarity is the main reason for the name.

(cid:1)

φ∨¬ψ. The usual dualities φ∨ψ ≡ ¬(¬φ∧¬ψ) and ∃ φ ≡ ¬∀¬φ
also hold. The opponent’s conjunction has a dual connective, (cid:9), but
we will not discuss it in this paper.

As mentioned in the introduction, we model the dynamics of
service contracts using the abstraction of a 2-party workﬂow, where
the ﬁrst party is the reasoner and the other represents the rest of
the players involved in the contract. In general, if several parties
need to be able to reason about the same contract, the contract can
be represented as several 2-party workﬂows, each representing the
contract from the point of view of a different reasoner.

Deﬁnition 1. (Workﬂows) A CT R-S goal is recursively de-
ﬁned as either an atomic formula or an expression of the form φ⊗ψ,
φ | ψ, φ ∨ ψ, or φ (cid:4) ψ, where φ and ψ are CT R-S goals. A rule
is of the form head←body, where head is an atomic formula and
body a CT R-S goal. A workf low control specif ication
consists of a CT R-S goal and a (possibly empty) set of rules.
Note that the connective ∧ is not allowed in workﬂow control spec-
iﬁcations, but is used to specify constraints.
2.2 Modeling Contract Dynamics in CT R-S

Example 1. (Procurement Contract) Consider a procurement
application that consists of a buyer interacting with three services,
sell, f inance, and deliver. We assume that the buyer is the rea-
soner in this example.

Services are modeled in terms of their signif icant events.
For instance, the buy service begins when the signiﬁcant event
pay escrow occurs. When pay escrow is ﬁnished, a concurrent
execution of the sell and f inance services begins.

Thus, at a high level, the buy service can be represented as:

pay escrow ⊗ (f inance | sell)

The connective ⊗ represents succession of events or actions: when
the above expression “executes,” the underlying database state is
ﬁrst changed by the execution of the formula pay escrow and then
by the execution of f inance | sell. The connective | represents
concurrent, interleaved execution of the two sequences of actions.
Intuitively, this means that a legal execution of (f inance | sell)
is a sequence of database states where the initial subsequence cor-
responds, say, to a partial execution of the subformula f inance;
the next subsequence of states corresponds to an execution of
sell; the following subsequence is a continuation of the execu-
tion of f inance; and so on. The overall execution sequence of
(f inance | sell) is a merge of an execution sequence for the left
subformula and an execution sequence for the right subformula.
Execution has precise meaning in the model and proof theories
of CT R. Truth of CT R formulas is established not over database
states, as in classical logic, but over sequences of states; it is inter-
preted as an execution of that formula in which the initial database
state of the sequence is successively changed to the second, third,
etc., state. The database ends up in the ﬁnal state of the sequence
when the execution terminates.3
Workﬂow formulas can be modularized with the help of rules.
The intuitive meaning of a rule, head←body, where head is an
atomic formula and body is a CT R-S goal, is that head is an in-
vocation interface to body, where body is viewed as a subroutine.
This is because according to the semantics described in Section 3,
3Space limitation does not permit us to compare CT R to other
logics that on the surface might appear to address the same issues
(e.g., temporal logics, process and dynamic logics, the situation
calculus, etc.). We refer the reader to the extensive comparisons
provided in [5, 6].

145such a rule is true if every legal execution of body must also be a
legal execution of head. Combined with the minimal model seman-
tics this gives the desired effect [6]. With this in mind, we can now
express the above procurement workﬂow as follows:

buy ← pay escrow ⊗ (sell | f inance)

Next, we search for matching services for the sell service using

a service directory to discover the following rules.

sell ← reserve item ⊗ (deliver ∨ keep escrow)
deliver ← insured ∨ uninsured

The ∨ connective in the deﬁnition of sell represents alternative ex-
ecutions. For instance, a legal execution of insured ∨ uninsured
is either a legal execution of insured or of uninsured. Similarly,
a legal execution of sell involves the execution of reserve item
and then, an execution of either deliver or recv escrow.

The above deﬁnition of sell also requires compliance with the
following contract requirements between the buyer and the seller:

− if buyer cancels, then seller keeps the escrow
− if buyer pays, then seller must deliver

Thus, the connective ∨ represents a choice. The question is
whose choice is it: the reasoner’s or that of the opponent? In an
environment where workﬂow activities might not always cooper-
ate, we need a way to distinguish these two kinds of choices. For
instance, the contract may say that the outcomes of the actions of
the delivery agent are that the goods might be delivered or lost.
This alternative is clearly not under the control of the buyer, who
is the reasoner here. On the other hand, the choice of whether to
use insured or uninsured delivery is made by the buyer, i.e., the
reasoner. With this understanding, the insured and uninsured
services can be deﬁned as follows:

insured ← (delivered ⊗ satisf ied) (cid:4) (lost ⊗ satisf ied)
uninsured ← (delivered ⊗ satisf ied) (cid:4) lost
The connective (cid:4) here represents the choice made by the actors
other than the reasoner (the buyer). If the buyer uses insured deliv-
ery then she is guaranteed satisfaction if the item is delivered or
lost (in the latter case the buyer presumably gets the money back).
If the buyer uses uninsured delivery then she can get satisfaction
only if the item is delivered. Whether the item is delivered or
lost is outside of the control of the buyer.

Next, we identify the following matching service for f inance:

f inance ← (approve ⊗ (make payment ∨ cancel))

(cid:4) (reject ⊗ cancel)

Note that approval or rejection of the ﬁnancing request is an op-
ponent’s (the servicing agent’s) choice. However, if ﬁnancing is
approved the choice of whether to proceed and make payment
or to cancel depends on the reasoner (the buyer). In addition, the
ﬁnancing agent might require the following clause in the contract:

− if ﬁnancing is approved and buyer does not cancel

then delivery should satisfy

Details of how to express the above contract requirement in CT R-S
will be given in Section 5.

The buyer and the services involved might have speciﬁc goals
with respect to the above contract. For instance, the buyer wants
that if ﬁnancing is approved then she has a strategy to ensure that
she is satisﬁed (either by receiving the goods or by getting the
money back). The seller might want to have the peace of mind
knowing that if the buyer cancels the contract after receiving ﬁ-
nancing then the seller can keep the escrow. In Section 6 we will

show how such goals can be represented and that they can be en-
forced under this contract even in adversarial situations.

We shall see that a large class of temporal and causality con-
straints can be represented as CT R-S formulas.
If Φ represents
such a formula for the above example, then ﬁnding a strategy to
enforce the constraints under the rules of the contract is tantamount
to checking whether buy ∧ Φ is satisﬁable in CT R-S.

Before going on, we should clear up one possible doubt: why
is there only one opponent? The answer is that this is sufﬁcient
for a vast majority of practical cases, especially those that arise in
Web services. Indeed, even when multiple independent actors are
involved, we can view each one of them (or any group that decides
to cooperate) as the reasoner and all the rest as the opponent. Any
such actor or a group can then use CT R-S to verify that its goals
(speciﬁed as a condition Φ) are indeed enforcible.

3. MODEL THEORY

In this section we deﬁne a model theory for our logic. The im-
portance of a model theory is that it provides the exact semantics
for the behavioral aspects of service contracts and thus serves as a
yardstick of correctness for the algorithms in Section 6.
3.1 Sets of Multipaths

A path is a sequence of database states, d1...dn. Informally, a
database state can be a collection of facts or even more com-
plex formulas, but for this paper we can think of them as simply
symbolic identiﬁers for various collections of facts.
In CT R [5], which allows concurrent, interleaved execution, the
semantics is based on sequences of paths, π = (cid:10)p1, ..., pm(cid:11), where
each pi is a path. Such a sequence is called a multipath, or
an m-path [5]. For example, (cid:10)d1d2, d3d4d5(cid:11) is an m-path that
consists of two paths: one having two database states and the other
three (note that a comma separates paths, not states in a path). As
explained in Example 1, multipaths capture the idea of an execu-
tion of a transaction that interleaves with executions of other trans-
actions. Thus, an m-path can be viewed as an execution that is
broken into segments, such that other transactions could execute
in-between the segments.
CT R-S further extends this idea by recognizing that in the pres-
ence of other parties, the reasoner cannot be certain which execu-
tion (or “play”) will actually take place, due to the lack of informa-
tion about the actual moves that the opponent will make. However,
the reasoner can have a strategy to ensure that regardless of what
the opponent does the resulting execution will be contained within
a certain set of plays. If every play in the set satisﬁes the prop-
erties that the reasoner wants, then the strategy will achieve the
reasoner’s objectives. Such a set of plays is called an outcome
of the game. Thus, while truth values of formulas in CT R are
determined on m-paths, CT R-S formulas get their truth values on
sets of m-paths. Each such set, S, is interpreted as an outcome
of the game in the above sense, and saying that a CT R-S formula,
φ, is true on S is tantamount to saying that S is an outcome of φ.
In particular, two games are considered to be equivalent if and only
if they have the same sets of outcomes.
3.2 Satisfaction on Sets of Multipaths
The following deﬁnitions make the above discussion precise.

Deﬁnition 2. (m-Path

An m-path
structure is a triple of the form (cid:10)U, IF , Ipath(cid:11), where U
is the domain, IF is an interpretation function for constants and
function symbols (exactly like in classical logic), and Ipath is a

Structure

[5])

146mapping such that if π is an m-path, then Ipath(π) is a ﬁrst-order
semantic structure (as commonly used in classical predicate logic).
For a CT R formula, φ, and an m-path, π, the truth of φ on π
with respect to an m-path structure is determined by the truth val-
ues of the components of φ on the appropriate sub-m-paths of π.
In a well-deﬁned sense, establishing the truth of a formula, φ, over
an m-path, π = (cid:10)p1, ..., pn(cid:11), corresponds to the possibility of exe-
cuting φ along π where the gaps between p1, ..., pn are ﬁlled with
executions of other formulas [5].
The present paper extends this notion to CT R-S by deﬁning truth
of a formula φ over sets of m-paths, where each such set represents
a possible outcome of the game corresponding to φ. The new deﬁ-
nition reduces to CT R’s for formulas that have no (cid:4)’s.

Deﬁnition 3. (Satisfaction) Let I = (cid:10)U, IF , Ipath(cid:11) be an m-
path structure, π be an arbitrary m-path. Let S, T , S1, S2, etc.,
denote non-empty sets of m-path, and let ν be a variable assign-
ment, which assigns an element of U to each variable. We deﬁne
the notion of satisf action of a formula, φ, in I on S by struc-
tural induction on φ:

1. Base Case:

ν

|=ν

p(t1, . . . , tn)

I, {π}
iff
p(t1, . . . , tn). Here {π} is a set of m-
Ipath(π) |=classic
paths that contains only one m-path, π, and p(t1, . . . , tn)
is an atomic formula. Recall that Ipath(π) is a usual ﬁrst-
order semantic structure, so |=classic here denotes the usual,
classical ﬁrst-order entailment.
Typically, p(t1, ..., tn) is either deﬁned via rules (as in Ex-
ample 1) or is a “built-in,” such as insert(q(a, b)), with a
ﬁxed meaning. For instance, in case of insert(q(a, b)) the
meaning would be that I,{π} |=ν insert(q(a, b)) iff π is
an m-path of the form (cid:10)d1 d2(cid:11), which consists of a single
path, and d2 = d1 ∪ {q(a, b)}.4 These built-ins are called
elementary updates and constitute the basic building
blocks from which more complex actions, such as those at
the end of Example 1, are constructed.

2. Negation: I, S |=ν ¬φ iff it is not the case that I, S |=ν φ.
3. Reasoner’s Disjunction: I, S |=ν φ∨ ψ iff I, S |=ν φ or
I, S |=ν ψ. We deﬁne φ∧ ψ as a shorthand for ¬(¬φ∨¬ψ).
I, S |=ν φ (cid:4) ψ iff S =
S1 ∪ S2, for some pair of m-path sets, such that I, S1 |=ν φ ,
and I, S2 |=ν ψ. The dual connective, (cid:9), also exists, but is
not used in this paper.

4. Opponent’s Conjunction:

5. Serial Conjunction:

S

I, S |=ν φ ⊗ ψ iff there is a set R
π∈R π ◦ Tπ,
of m-paths, such that S can be represented as
where each Tπ is a set of m-paths, I, R |=ν φ , and for each
Tπ, I, Tπ |=ν ψ.
Here π◦T = {π ◦ δ | δ ∈ T}, where π ◦ δ is an m-path ob-
tained by appending the m-path δ to the end of the m-path π.
(For instance, if π = (cid:10)d1d2, d3d4(cid:11) and δ = (cid:10)d5d6, d7d8d9(cid:11)
then π ◦ δ = (cid:10)d1d2, d3d4, d5d6, d7d8d9(cid:11).) In other words,
R is a set of preﬁxes of the m-paths in S.

6. Concurrent Conjunction:

I, S |=ν φ | ψ iff there
is a set R of m-paths, such that S can be represented
as

S
π∈R π(cid:15)Tπ, where each Tπ is a set of m-paths, and
• either I, R |=ν φ and for all Tπ, I, Tπ |=ν ψ;

4Formally, the semantics of such built-ins is deﬁned using the no-
tion of the transition oracle [6].

• or I, R |=ν ψ and for all Tπ, I, Tπ |=ν φ

Here π(cid:15)Tπ denotes the set of all m-paths that are ob-
tained by interleaving π with some m-path in Tπ. For in-
stance, if π = (cid:10)d1d2, d3d4(cid:11) and (cid:10)d5d6, d7d8d9(cid:11) ∈ Tπ then
one interleaving is (cid:10)d1d2, d5d6, d3d4, d7d8d9(cid:11), another is
(cid:10)d1d2, d5d6, d7d8d9, d3d4(cid:11), etc.

7. Universal Quantiﬁcation:

I, π |=ν ∀X.φ if and only
if I, π |=µ φ for every variable assignment µ that assigns
the same value as ν to all variables except X. Existential
quantiﬁcation, ∃X.φ, is a shorthand for ¬∀X¬φ.

Example 2. (Database Transactions) Consider the following
formula, where st means “start,” ab means “abort,” cm is “commit,”
cp means “compensate,” and no stands for a noop. Further assume
that each elementary update em in the following formula denotes
an insert(em) operation which satisﬁes {(cid:10)d d ∪ {em}(cid:11)} |=
insert(em) where d is a set of ground atomic formulas.

φ = st ⊗ (ab (cid:4) cm) ⊗ (cp ∨ no)

Then the possible outcomes for φ can be computed from the out-
comes of its components as follows:

1. By (3) in Deﬁnition 3: {(cid:10)∅ {cp}(cid:11)} |= (cp ∨ no),

and {(cid:10)∅ {no}(cid:11)} |= (cp ∨ no)

2. By (5) in Deﬁnition 3: {(cid:10)∅ {ab}(cid:11), (cid:10)∅ {cm}(cid:11)} |= (ab (cid:4) cm)
3. By (6) in Deﬁnition 3:

{(cid:10)∅ {st} {st, ab}(cid:11), (cid:10)∅ {st} {st, cm}(cid:11)} |= st ⊗ (ab (cid:4) cm)
4. By (6) in Deﬁnition 3: Hence there are four possible
outcomes for φ;
{(cid:10)∅{st}{st, ab}{st, ab, cp}(cid:11), (cid:10)∅{st}{st, cm}{st, cm, cp}(cid:11)}
{(cid:10)∅{st}{st, ab}{st, ab, cp}(cid:11), (cid:10)∅{st}{st, cm}{st, cm, no}(cid:11)}
{(cid:10)∅{st}{st, ab}{st, ab, no}(cid:11), (cid:10)∅{st}{st, cm}{st, cm, cp}(cid:11)}
{(cid:10)∅{st}{st, ab}{st, ab, no}(cid:11), (cid:10)∅{st}{st, cm}{st, cm, no}(cid:11)}

Deﬁnition 4. (Playset) As in classical logic, φ ∨ ¬φ is a tautol-
ogy for any φ, i.e., it is true on every set of m-paths. We denote this
tautology with a special proposition Playset, an analogue of true
in classical logic.

By deﬁnition, I, S |= Playset for any m-path structure and any
set of m-paths. Therefore, ¬Playset is unsatisﬁable. Intuitively,
Playset is the game in which all outcomes are possible, while
¬Playset is a game with no outcomes.

4. PROOF THEORY
4.1 Execution as Entailment

We now deﬁne executional entailment, a concept that connects
model theory with the execution of a certain strategy of the rea-
soner.

Deﬁnition 5. (Executional Entailment) Let φ be a CT R-S
goal and W a set of rules that deﬁne services (see Deﬁnition 1).
Let D0, ..., Dn be a sequence of database states. A path tree
with a shared pref ix D0, ..., Dn is a set of paths where each
begins with this sequence of states. We deﬁne
D0, ..., Dn --- |= (∃)φ

(4.1)
to mean that for every model M of φ there is a path tree T such
that M, T |= (∃)φ and (cid:10)D0, ..., Dn(cid:11) is a shared preﬁx of T . Here
(∃) indicates that all variables in φ are quantiﬁed existentially.

147Intuitively, (4.1) means that the reasoner playing the game φ can
ensure that the execution will begin with the database state D0 and
continue with D1, ..., Dn.

Observe that executional entailment is deﬁned over path trees,
not over arbitrary outcomes. Hence, when we talk about execution
of a game we are only interested in enforcible outcomes that can
reduce to a path tree. We call these executable outcomes.
We are interested in these outcomes because ultimately we want
to obtain strategires that contain complete plays—plays that repre-
sent movements of all the players involved. Such a play must be
represented by a path, not m-path, because m-paths are incomplete
plays—they contain gaps, which must be ﬁlled by external players.
The plays in an outcome that represents a strategy must form a
path tree because all the plays in an outcome of a real game start
with the same initial state D0. Thus, ﬁnding out if a winning strat-
egy exists in state D0 is tantamount to proving W, D0 --- |= (∃)φ.
4.2 Inference Rules
We now develop an inference system for proving statements of
the form W, D0 --- |= (∃)φ, where W is a set of rules and φ is
a CT R-S goal. The system manipulates expressions of the form
W, D0 --- (cid:17) φ, called sequents.

First we need the notion of the hot component of a formula;
it is a generalization of a similar notion from [5]: hot(φ) is a set
of subformulas of φ, deﬁned by induction on the structure of φ as
follows:

1. hot(φ) = {φ}, if φ is an atomic formula
2. hot(φ ⊗ ψ) = hot(φ)
3. hot(φ | ψ) = hot(φ) ∪ hot(ψ)
4. hot(φ ∨ ψ) = {φ ∨ ψ}
5. hot(φ (cid:4) ψ) = {φ (cid:4) ψ}.

Note that in cases of ∨ and (cid:4), the hot component is a singleton set
that contains the very formula that is used as an argument to hot.
Here are some examples of hot components:
a ⊗ b ⊗ c
(a ⊗ b) | (c ⊗ d)
(a (cid:4) b) ⊗ c
(a (cid:4) b) | (c ∨ d)
((a (cid:4) b) ⊗ c) ∨ ((f | g) ⊗ h)

{a}
{a, c}
{a (cid:4) b}
{a (cid:4) b, c ∨ d}
{((a (cid:4) b) ⊗ c) ∨ ((f | g) ⊗ h)}

Note that a hot component represents a particular occurrence of
a subformula in a bigger formula. For instance, hot(a ⊗ b ⊗ a)
is {a}, where a corresponds to the ﬁrst occurrence of this subfor-
mula in a ⊗ b ⊗ a and not the second one. This point is important
because in the inference rules, below, we will sometime say that
(cid:3)
is obtained from ψ by deleting a hot occurrence of a (or some
ψ
other subformula). Thus, in the above, deleting the hot component
a leaves us with b ⊗ a, not a ⊗ b.

The inference rules are as follows:

Axiom: P, D --- (cid:17) ( ),

for any D.

Here ( ) is the empty CT R-S goal; it represents a game that
starts and stops in the same state without making any moves.
The axiom says that such a game can be played in any state.

Inference Rules: In Rules 1–4 below, σ is a substitution, ψ and
are concurrent serial conjunctions, and a is a formula in

(cid:3)

ψ
hot(ψ).

(cid:3)

(cid:3)

(cid:3)

(cid:3)

(cid:3)

σ

where ψ

is obtained from ψ

1. Applying transaction deﬁnitions: Let b←β be a rule in
P, and assume that its variables have been renamed so
that none are shared with ψ. If a and b unify with mgu
(most general uniﬁer) σ then
P, D --- (cid:17) (∃) ψ
P, D --- (cid:17) (∃) ψ
currence of a is replaced by β.
For instance, if ψ = (c (cid:4) e) | (a ⊗ f ) | (d ∨ h) and
the hot component in question is a in the middle sub-
formula, then ψ
2. Querying the database: If Od(D) |=c (∃)aσ; aσ and

(cid:3) = (c (cid:4) e) | (β ⊗ f ) | (d ∨ h).

is ψ where a hot oc-

where ψ

σ

σ share no variables, then

3. Executing elementary updates:

(cid:3)
σ share no variables; then
ψ
P, D --- (cid:17) (∃) ψ
P, D --- (cid:17) (∃) ψ
by deleting a hot occurrence of a.
For instance, if ψ = (c (cid:4) e) | (a ⊗ f ) | (d ∨ h) and
the hot component is a in the middle subformula, then
(cid:3) = (c (cid:4) e) | f | (d ∨ h).
ψ
If Ot(D1, D2) |=c
(∃)aσ; aσ and ψ
P, D2 --- (cid:17) (∃) ψ
P, D1 --- (cid:17) (∃) ψ
ψ by deleting a hot occurrence of a.
For instance, if ψ = (c (cid:4) e) | (a ⊗ f ) | (d ∨ h) and
the hot component is a in the middle subformula, then
(cid:3) = (c (cid:4) e) | f | (d ∨ h).
ψ
Note that in this rule the current state changes from D2
to D1.
4. Reasoner’s move: Let ψ be a formula with a hot com-
ponent η of the form α∨β. Then we have the following
pair of inference rules, which can lead to two indepen-
dent possible derivations.
P, D --- (cid:17) (∃) ψ
P, D --- (cid:17) (∃) ψ
is obtained from ψ by replacing the hot compo-
Here ψ
is obtained from ψ by replacing
nent η with α and ψ
η with β.
For instance, if ψ = (c(cid:4) e) | (a⊗ f ) | (d∨ h) and the
(cid:3) = (c(cid:4)e) | (a⊗f ) | d
hot component η is d∨h, then ψ
(cid:3)(cid:3) = (c (cid:4) e) | (a ⊗ f ) | h.
and ψ
5. Opponent’s move: Let ψ be a formula with the hot
component, τ , of the form γ (cid:4) δ. Then we have the
following inference rule:
P, D --- (cid:17) (∃) ψ

P, D --- (cid:17) (∃) ψ
P, D --- (cid:17) (∃) ψ

and P, D --- (cid:17) (∃) ψ

where ψ

is obtained from

(cid:3)

σ

(cid:3)

(cid:3)

(cid:3)(cid:3)

(cid:3)(cid:3)

(cid:3)(cid:3)

P, D --- (cid:17) (∃) ψ

(cid:3)

(cid:3)(cid:3)

is obtained from ψ by replacing the hot com-
where ψ
ponent τ with γ and ψ
is obtained from ψ by replacing
τ with δ.
For instance, if ψ = (c(cid:4) e) | (a⊗ f ) | (d∨ h) and the
(cid:3) = c | (a⊗f ) | (d∨h)
hot component τ is c(cid:4)e, then ψ
(cid:3)(cid:3) = e | (a ⊗ f ) | (d ∨ h).
and ψ
Note that unlike in the reasoner’s case when we have
two inference rules,
the opponent’s case is a sin-
gle inference rule.
It says that in order to prove
P, D --- (cid:17) (∃) ψ (i.e., to execute ψ on a set S of

(cid:3)

(cid:3)

148(cid:3)

(cid:3)(cid:3)
on a set S1 of paths emanating from D and ψ

paths emanating from D) we need to be able to execute
on
ψ
another (possibly the same) set S2 of paths emanating
from D such that S = S1 ∪ S2.

THEOREM 1

(SOUNDNESS OF INFERENCE SYSTEM). Un-
|= (∃) φ holds
der the Horn conditions, the entailment P, D ---
if there is a deduction of the sequent P, D --- (cid:17) φ in the above
inference system.

We conjecture that the above proof theory is also complete for
workﬂow control speciﬁcations. The importance of the proof the-
ory in CT R-S is that it can be used to execute workﬂow speciﬁ-
cations. When these speciﬁcations represent a service contract, the
inference system will be able to execute the contract.

5. CONSTRAINTS ON CONTRACT

EXECUTION

In [8], we have shown how a large class of constraints on work-
ﬂow execution can be expressed in CT R. In CT R-S we are in-
terested in ﬁnding a similar class of constraints, which could be
used to denote the desirable properties of a contract, as explained
at the end of Sections 1 and 2.2.
In this context, veriﬁcation of
a constraint against a contract means that the reasoner has a way
of executing the contract so that the constraint will hold no matter
what the other parties do (for instance, that the goods are delivered
or the payment is refunded regardless). Our veriﬁcation algorithm
requires that behavioral speciﬁcations of contracts have no loops
in them and that they have the unique event property deﬁned be-
low.5 The no-loops requirement is captured by the restriction that
the workﬂow rules are non-recursive (so having rules is just a mat-
ter of convenience, which does not increase the expressive power).
We assume that there is a subset of propositions, E VENT , which
represents the “interesting” events that occur in the course of work-
ﬂow execution. These events are the building blocks of both work-
ﬂows and constraints. In terms of Deﬁnition 3, these propositions
would be deﬁned as built-in elementary updates.

Deﬁnition 6. (Unique-event property) A CT R-S workﬂow W
has the unique event property if and only if every proposi-
tion in E VENT can execute at most once in any execution of W.
Formally, this can be deﬁned both model-theoretically and syn-
tactically. The syntactic deﬁnition is that for every proposition
e ∈ E VENT :

If W is W1 ⊗ W2 or W1 | W2 and e occurs in W1
then it cannot occur in W2, and vice versa.

For workﬂows with no loops, we can always rename different oc-
currences of the same type of event to satisfy the above property.
We shall call such workﬂows unique event workf lows.

Deﬁnition 7. (Constraints) Let φ be a (cid:4)-free formula. Then
∗φ denotes a formula that is true on a set of m-paths, S, if and only
if φ is true on every m-path in S. The operator ∗ can be expressed
using the basic machinery of CT R-S.
Our constraints on workﬂow execution, deﬁned below, will all
be of the form ∗φ because, intuitively, the most common thing that
a reasoner wants is to make sure that every execution in the out-
come has certain desirable properties. Items 1–3 deﬁne primitive
5This assumption is made by virtually all formal approaches to
workﬂow modeling (e.g., [2, 22]) and even such speciﬁcation lan-
guages as WSFL — IBM’s proposal for a Web service speciﬁcation
language that was one of the inputs to BPEL4WS [15].

constraints, denoted PRIMIT IVE. Item 4 deﬁnes the set CONST R
of all constraints.

1. Elementary primitive constraints: If e ∈ E VENT is an
event, then ∗e and ∗(¬e) are primitive constraints.
Infor-
mally, the constraint ∗e is true on a set S of m-paths in an
m-path structure I = (U, IF , Ipath) iff e occurs on every m-
path in S. Similarly, ∗(¬e) is true on S iff e does not occur
on any m-path in S.
Formally, ∗e says that every execution of the contract, i.e.,
every m-path (cid:10)p1, ..., pi, ..., pn(cid:11) ∈ S, includes a path, pi, of
the form d1...dkdk+1...dm, such that for some pair of adja-
cent states, dk and dk+1, the event e occurs at dk and causes
a state transition to dk+1, i.e., Ipath((cid:10)dkdk+1(cid:11)) |=classic e
(see Deﬁnition 3). The constraint ∗(¬e) means that e does
not occur on any m-path in S.

2. Disjunctive and Conjunctive Primitive constraints: Any
∨, ∧, or ¬ combination of propositions from E VENT is al-
lowed under the scope of ∗. For instance, ∗(e1 ∨ e2) and
∗(e1 ∨ ¬e2) are allowed. The former is true on a set of m-
paths, S, if either e1 or e2 occurs on every m-path in S. The
latter is true if, for every m-path in S, the occurrence of e1 on
the m-path implies that e2 occurs on the same m-path. For
∗(e1 ∨ ¬e2), we will use the abbreviation ∗(e2 → e1).

3. Serial primitive constraints: If e1, ..., en ∈ E VENT then
∗(e1 ⊗ ... ⊗ en) is a primitive constraint. It is true on a set
of m-paths S iff e1 occurs before e2 before ... before en on
every path in S.

4. Complex constraints: The set of all constraints, CONST R,
consists of all Boolean combinations of primitive constraints
(i.e., constraints deﬁned by Items 1–3) using the connectives
∨ and ∧: φ ∧ ψ (resp. φ ∨ ψ) is satisﬁed by a set of m-paths
S iff S satisﬁes φ and (resp. or) ψ.

It can be shown that under the unique event assumption any serial
primitive constraint can be decomposed into a conjunction of bi-
nary serial constraints. For instance, ∗(e1 ⊗ e2 ⊗ e3) is equivalent
to ∗(e1 ⊗ e2) ∧ ∗(e2 ⊗ e3). Here are some typical constraints in
CONST R and their real-world meaning:
∗e − event e should always eventually happen;
∗e ∧ ∗f − events e and f must always both occur (in some order);
∗(e ∨ f ) − always either event e or event f or both must occur;
∗e ∨ ∗f − either always event e occurs or always event f occurs;
∗(¬e ∨ ¬f ) − it is not possible for e and f to happen together;
∗(e → f ) − if event e occurs, then f must also occur.
Example 3. (Contract Goals) The actors in the procurement
workﬂow of Example 1 may want to ensure that they have a way to
reach their goals within the scope of the contract. We express these
goals using the following set of constraints:
∗(approve ∧ ¬cancel → satisf ied)

if ﬁnancing is approved and buyer does not cancel
then she wants to be satisﬁed

∗(cancel → keep escrow)
∗(make payment → deliver)

if buyer cancels, then seller keeps the escrow

if buyer pays, then seller must deliver

1496. ENFORCEMENT OF EXECUTION

CONSTRAINTS

Given a contract represented as a CT R-S workﬂow, W, and a
reasoner’s goal speciﬁed as a constraint, Φ ∈ CONST R, we would
like to construct another workﬂow, WΦ, that represents a class of
strategies that enforce Φ within the rules of the contract. “Enforce-
ment” here means that as long as the opponent plays by the rules of
the contract (i.e., chooses only the alternatives speciﬁed by the (cid:4)-
connective), the reasoner can still ensure that all the plays belong to
an outcome that satisﬁes the constraints. In CT R-S this amounts to
computing W ∧ Φ — the formula that represents the collection of
all reasoner’s strategies for ﬁnding the outcomes of W that satisfy
the constraint Φ.
We must clarify what we mean by “computing” W ∧ Φ. After
all, W ∧ Φ already is a representation of all the winning strategies
for the reasoner and all outcomes of W ∧ Φ satisfy Φ. However,
this formula is not an explicit set of instructions to the workﬂow
scheduler.
In fact, it is not even a workﬂow speciﬁcation in the
sense of Deﬁnition 1. In contrast, the formula WΦ that we are after
is a workﬂow speciﬁcation. It does not contain the ∧-connective,
and it can be directly executed by the CT R-S proof theory. This
means that the proof theory can be used to execute the contract W
in such a way that the reasoner’s objectives Φ will be satisﬁed. The
precise relationship between W ∧ Φ and WΦ will be established in
Deﬁnition 8. Informally speaking, the two formulas are equivalent
in the sense that they have exactly the same executions modulo
certain synchronization acts.
We now develop an algorithm for computing WΦ through a se-

ries of transformations.
Enforcing complex constraints. Let ∗C1,∗C2 ∈ CONST R, W
be a CT R-S workﬂow, then

(∗C1 ∨ ∗C2) ∧ W ≡ (∗C1 ∧ W) ∨ (∗C2 ∧ W)
(∗C1 ∧ ∗C2) ∧ W ≡ (∗C1 ∧ (∗C2 ∧ W))

Thus, we can compute W(∗C1∨∗C2) as W∗C1 ∨ W∗C2 and
W(∗C1∧∗C2) as W∗C1 ∧ W∗C2 .
Enforcing elementary constraints. The following transformation
takes an elementary primitive constraint Φ of the form ∗α or ∗¬α
and a CT R-S unique-event workﬂow W, and returns a CT R-S
workﬂow that is equivalent to W ∧ Φ. Let α, β ∈ E VENT and
W1,W2 be CT R-S workﬂows. Then:
∗α ∧ α ≡ α
∗α ∧ β ≡ ¬Playset
∗α ∧ (W1 ⊗ W2) ≡ (∗α ∧ W1) ⊗ W2 ∨ W1 ⊗ (∗α ∧ W2)
∗¬α ∧ (W1 ⊗ W2) ≡ (∗¬α ∧ W1) ⊗ (∗¬α ∧ W2)
∗α ∧ (W1 | W2) ≡ (∗α ∧ W1) | W2 ∨ W1 | (∗α ∧ W2)
∗¬α ∧ (W1 | W2) ≡ (∗¬α ∧ W1) | (∗¬α ∧ W2)
(Recall that Playset was introduced in Deﬁnition 4.) These log-
ical equivalences are identical to those used for workﬂows of co-
operating tasks in [8]. The ﬁrst equivalence below is speciﬁc to
CT R-S. Here we use Φ to denote ∗α or ∗¬α:

∗¬α ∧ α ≡ ¬Playset
∗¬α ∧ β ≡ β if α (cid:20)= β

Φ ∧ (W1 (cid:4) W2) ≡ (Φ ∧ W1) (cid:4) (Φ ∧ W2)
Φ ∧ (W1 ∨ W2) ≡ (Φ ∧ W1) ∨ (Φ ∧ W2)

For example, if W is abort(cid:4) prepare⊗ (abort∨ commit), then:

∗abort ∧ W ≡ abort (cid:4) (prepare ⊗ abort)
∗¬abort ∧ W ≡ ¬Playset

The above equivalences enable us to decompose the prob-
lem of computing WΦ into simpler problems.
For instance,

(α)∗α = α, and to compute (W1 (cid:4) W2)Φ it sufﬁces to compute
(W1)Φ (cid:4) (W2)Φ.
Enforcing serial constraints. Next we deal with constraints of
the form ∗(α ⊗ β). Let α, β ∈ E VENT and let W be a CT R-S
workﬂow. We deﬁne W∗(α⊗β) as

sync(α < β, (∗α ∧ (∗β ∧ W)))

where sync is a transformation that synchronizes events in the
It uses elementary updates send(ξ) and receive(ξ)
right order.
and is deﬁned as follows: sync(α < β,W) = W(cid:3)
, where W(cid:3)
is like W, except that every occurrence of event α is replaced with
α⊗send(ξ) and every occurrence of β with receive(ξ)⊗β, where
ξ is a new constant.
The primitives
can be deﬁned as
insert(channel(ξ)) and channel(ξ) ⊗ delete(channel(ξ)),
respectively, where ξ is a new proposition symbol. The point here
is that these two primitives can be used to provide synchronization:
receive(ξ) can become true if and only if send(ξ) has been
executed previously. In this way, β cannot start before α is done.
The following examples illustrate the deﬁnition of W∗(α⊗β):

and receive

send

(β ⊗ α)∗(α⊗β) = receive(ξ) ⊗ β ⊗ α ⊗ send(ξ)
(α | β | ρ1 | ... | ρn)∗(α⊗β) =

(α ⊗ send(ξ)) | (receive(ξ) ⊗ β) | ρ1 | ... | ρn)

Note that W∗(α⊗β) is not logically equivalent to W ∧ ∗(α ⊗ β),
but these two formulas are behaviorally equivalent as deﬁned next.
Deﬁnition 8. (Behavioral Equivalence) A CT R-S formula φ
behaviorally entails ψ iff for every m-path structure I =
(U, IF , Ipath) and a set on m-paths S, if I, S |= φ then there is
another set S
and S are congruent
modulo synchronization; namely, these sets of m-paths reduce to
the same set of m-paths under the following operations:

(cid:3) |= ψ, where S

such that I, S

(cid:3)

(cid:3)

• Remove all synchronization messages inserted by the
send and receive primitives (i.e., the atoms of the form
channel(ξ)) from all database states in S

and S.

(cid:3)

• Eliminate adjacent duplicate states from all m-paths (i.e., if
π is an m-path of the form (cid:10)..., d1...dkdk+1..., ...(cid:11) and dk
is the same state as dk+1 then delete dk+1 from π. (After the
previous step, such adjacent duplicate states normally corre-
spond to state transitions that occur due to the execution of
send and receive.)

φ and ψ are behaviorally equivalent if each behaviorally
entails the other.

Proposition 1. (Enforcing Elementary and Serial Con-
straints) The above transformations compute a CT R-S workﬂow
that is behaviorally equivalent to W ∧ Φ, where Φ is an elementary
or serial constraint and W is a unique event workﬂow.

Enforcing conjunctive primitive constraints. To enforce a prim-
itive constraint of the form ∗(Φ1 ∧ ... ∧ Φm), where all Φi are ele-
mentary, we utilize the logical equivalence ∗(Φ1 ∧ ... ∧ Φm) ≡ ∗
Φ1 ∧ ...∧∗Φm (and the earlier equivalences for enforcing complex
constraints).
Enforcing disjunctive primitive constraints. These constraints
have the form ∗(Φ1 ∨ ... ∨ Φn), where all Φi are elementary con-
straints. Enforcement of such constraints relies on the following
lemma.

150Lemma 1. (Disjunctive Primitive Constraints) Let Φi be ele-
mentary constraints. Then
∗(Φ1 ∨ ... ∨ Φn) ≡ (∗¬Φ2 ∧ ... ∧ ∗¬Φn → ∗Φ1) (cid:4) ...
(cid:4) (∗¬Φ1 ∧ ... ∧ ∗¬Φi−1 ∧ ∗¬Φi+1 ∧ ... ∧ ∗¬Φn → ∗Φi) (cid:4) ...
(cid:4) (∗¬Φ1 ∧ ... ∧ ∗¬Φn−1 → ∗Φn)
This equivalence allows us to decompose the set of all plays in an
outcome into subsets that satisfy the different implications shown
in the lemma. Unfortunately, enforcing such implications is still not
easy. Unlike the other constraints in this section, enforcement of the
implicational constraints cannot be described by a series of simple
equivalences. Instead, we have to resort to equivalence transforma-
tions deﬁned with the help of parse trees of CT R-S formulas that
represent unique event workﬂows.

Deﬁnition 9. (Maximal guarantee for an event) Let ∗Φ be an
elementary constraint (i.e., Φ is e or ¬e), W be a formula for a
unique event workﬂow, and ϕ be a subformula of W. Then ϕ is
said to be a maximal guarantee for ∗Φ iff

1. (W ∧ (ϕ | Playset)) |= ∗ Φ
2. ϕ is a maximal subformula of W that satisﬁes (1)

Intuitively, a maximal guarantee for ∗e is any maximal subformula,
φ, of W such that e occurs in every execution of φ. A maximal
guarantee for ∗¬e is such a maximal subformula, φ, of W that
e does not occur in any execution of φ. The set of all maximal
guarantees for an elementary event ∗Φ is denoted by GS∗Φ(W).
Deﬁnition 10. (Co-executing sub-formulas) Let W be a for-
mula for a unique event workﬂow and ψ, ϕ be a pair of subfor-
mulas of W. We say that ψ coexecutes with ϕ in W, denoted
ψ ∈ coExec(W, ϕ), iff

1. (W ∧ (ϕ | Playset)) |= (ψ | Playset),
2. φ and ψ are disjoint subformulas in W, and
3. ψ is a maximal subformula in W satisfying (1) and (2)

following

Intuitively members of coExec(W, ϕ) correspond to maximal
sub-formulas of W that must be executed whenever ϕ executes as
part of the workﬂow W.

procedures

compute GS∗Φ(W)

Proposition 2. (Computing GS∗Φ(W) and coExec(W, ϕ))
and
The
coExec(W, ϕ). They operate on the parse tree of W, which
is deﬁned as usual:
the inner nodes correspond to composite
subformulas and the leaves to atomic subformulas. Thus, the
leaves are labeled with their corresponding atomic subformulas,
while the inner nodes are labeled with the main connective of the
corresponding composite subformula.
GS∗e(W): The set of subformulas that correspond to the nodes in
the parse tree of W that are closest to the root of the tree and
can be reached by the following marking procedure: (i) mark
all the leaves labeled with e; (ii) mark any node correspond-
ing to a subformula of W of the form (ϕ ⊗ ψ) or (ϕ | ψ) if
either the node for ϕ or for ψ is marked; (iii) mark any node
corresponding to a subformula of the form (ϕ∨ψ) or (ϕ(cid:4)ψ)
if both the node for ϕ and the node for ψ are marked.

coExec(W, ϕ): Consider a subformula of W of the form ψ1 | ψ2,
ψ2 | ψ1, ψ1 ⊗ ψ2, or ψ2 ⊗ ψ1, where φ is a subformula of
ψ1. Suppose that ψ2 is a maximal subformula with such a
1 | ψ
property, i.e., W has no subformula of the form ψ
(cid:3)
(cid:3)
2,
2 ⊗ ψ
1 ⊗ ψ
2 | ψ
(cid:3)
(cid:3)
(cid:3)
(cid:3)
(cid:3)
2, or ψ
1, respectively, such that φ is a
ψ
2 (cid:20)= ψ2).
(cid:3)
(cid:3)
1 and ψ2 is a subformula of ψ
subformula of ψ
Then, ψ2 ∈ coExec(W, ϕ).

(cid:3)
2 (ψ

(cid:3)
1, ψ

buy

n3

pay_escrow

 finance

n1

n2

sell
n4

n6

approve

n5

make_payment

reserve

reject

cancel

n8
keep_escrow

deliver

n7

n10
cancel

n11

insured

delivered

lost

satisfied

satisfied

uninsured
n9

lost

delivered

satisfied

Figure 1: Workﬂow parse tree and workﬂow graph for Exam-
ple 3

GS∗¬e(W): Let T be the set of nodes in the parse tree of W that
belong to any of the subformulas ϕ ∈ GS∗e(W) or ψ ∈
coExec(W, ϕ). Then, η ∈ GS∗¬e(W) iff it is a subformula
of W such that its subtree contains no nodes in T and η is a
maximal subformula with such a property.

Example 4. (Computation of maximal guarantees and co-
execution) The workﬂow parse tree for Example 3 is shown in
Figure 1. For the event approve, the highest node that can be
reached by the aforesaid marking procedure is n1 and there are
no other such nodes. Therefore, GS∗approve(W) is {approve ⊗
(make payment∨cancel)}. The set of co-executing subformulas
for n1, coExec(W, n1), consists of two formulas that correspond
to the nodes n3 and n4 in the ﬁgure. The only maximal guarantee
for ¬approve is the subformula reject ⊗ cancel, which corre-
sponds to node n2.

if W |= ∗Φ1 ∧ ... ∧ ∗Φn then Compute W∗Φ

for each i such that W (cid:20)|= ∗ Φi do
for each f ∈ GS∗¬Φi (W) do

procedure Compute W(∗Φ1∧...∧∗Φn→∗Φ)
1.
2. else Guard(g) := ∅ for all g ∈ subf ormulas(W)
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.

for each g ∈ subf ormulas(W) do

if Guard(g) (cid:20)= ∅ then

for every g ∈ GS∗¬Φ(h) set
Guard(g) := Guard(g) ∪ {receive(ξ)}

if ∃h ∈ coExec(W, f ) and (h ∧ ∗Φ) is satisﬁable

then Rewrite f to send(ξ) ⊗ f and

receive(ξ)∈Guard(g) receive(ξ)) ⊗ g

else Compute sibling(f )(∗Φ1∧...∧∗Φn→∗Φ)

rewrite g to (

W

Figure 2: Computation of W(∗Φ1∧...∧∗Φn→∗Φ)

Recall that, according to Lemma 1, in order to enforce a disjunc-
tive constraint we need to learn how to enforce implicational con-
straints of the form ∗Φ1 ∧ ... ∧ ∗Φn → ∗Φ, where Φ and the Φis
are elementary. This is done using the algorithm in Figure 2, which
computes a workﬂow that is equivalent to (∗Φ1 ∧ ... ∧ ∗Φn →

151∗Φ) ∧ W. If the antecedent of the constraint is true during an
execution, then (in line 1) ∗Φ must be enforced on W. Otherwise,
for every ∗Φi that is not true everywhere, we identify the subfor-
mulas f ∈ GS∗¬Φi (lines 2-3). Note that, whenever subformulas
in GS∗¬Φi are executed the constraint ∗Φ1 ∧ ... ∧ ∗Φn → ∗Φ is
vacuously true. In lines 4-6, we identify the subformulas h of W
that co-execute with the formulas f ∈ GS∗¬Φi. If ∗Φ is enforcible
in any of these subformulas h, i.e., h ∧ ∗Φ is satisﬁed (there can
be at most one such subformula h per f, due to the unique event
property, Deﬁnition 6), then we enforce the above constraint by de-
laying executions of those subformulas in h that violate ∗Φ (these
are exactly the g’s in line 7) until it is guaranteed that the execution
moves into f ∈ GS∗¬Φi, because once f is executed our constraint
becomes satisﬁed. This delay is achieved by synchronizing the ex-
ecutions of f to occur before the executions of g by rewriting f into
send(ξ) ⊗ f (in line 6) and by adding receive(ξ) to the guard for
g (in line 8). Otherwise, if no such h exists, in line 9, we explicitly
enforce the constraint on the sibling nodes (in the parse tree of W)
of the formulas f ∈ GS∗¬Φi (because an outcome that satisﬁes
∗Φi might exist in a sibling). Finally, in lines 10-12, we make sure
that the execution of every g that has a non-empty guard is condi-
tioned on receiving of a message from at least one f with which g
is synchronized.

Example 5. (Procurement Workﬂow, contd.) The algorithm in
Figure 2 creates the following workﬂow by applying the constraints
in Example 3 to the procurement workﬂow in Example 1. Refer to
the parse tree for that workﬂow in Figure 1.

• To enforce (∗cancel → ∗keep escrow) we ﬁrst com-
pute GS∗¬cancel(buy) = {n5}, and coExec(buy, n5) =
{n3, n4, n6}. Of these, n4 (substituted for h) satisﬁes the
conditions on line 5 of the algorithm in Figure 2. Since
GS∗¬keep escrow(n4) = {n7}, we insert a synchronization
from node n5 to n7 shown in Figure 1 as a dotted line. This
ensures that if the buyer cancels the procurement workﬂow,
the seller collects the escrow.

• To enforce (∗approve ∧ ∗ ¬cancel → ∗satisf ied),
we compute GS∗¬approve(buy) = {n2} and notice that
n4 ∈ coExec(buy, n2)} satisﬁes the conditions in line 5
of the algorithm in Figure 2. Since GS∗¬satisf ied(n4) =
{n8, n9}, we insert a synchronization from node n2 to n8
and n9 which yields the dotted edges in Figure 1. We
also compute GS∗cancel(buy) = {n10, n2} and notice
that n4 ∈ coExec(buy, n2)}, n4 ∈ coExec(buy, n10)},
and n4 satisﬁes the conditions in line 5 of the algorithm.
Since GS∗¬satisf ied(n4) = {n8, n9}, we insert a syn-
chronization from the nodes n10 and n2 to n8 and n9,
which yields the dotted edges in Figure 1. This synchro-
nization ensures that if buyer’s ﬁnancing is approved and he
chooses to make the payment and buy the item then deliv-
ery must use the insured method. Also, once the constraint
(∗make payment → ∗deliver) is enforced too, the seller
can no longer pocket the escrow. The resulting strategy is:

((send(ξ3) ⊗ cancel))) (cid:4) (send(ξ2) ⊗ (reject ⊗ cancel))

buy ← pay escrow ⊗ (f inance | sell)
f inance ← (approve ⊗ ((send(ξ1) ⊗ make payment) ∨
sell ← reserve item ⊗ ((receive(ξ1) ⊗ deliver)
deliver ← insured ∨ ((receive(ξ2) ∨ receive(ξ3)) ⊗ uninsured)
insured ← (delivered ⊗ satisf ied) (cid:4) (lost ⊗ satisf ied)
uninsured ← (delivered ⊗ satisf ied) (cid:4) lost

∨ ((receive(ξ2) ∨ receive(ξ3)) ⊗ keep escrow))

Proposition 3. (Enforcing disjunctive primitive constraints)
The above algorithm for enforcing disjunctive primitive constraints
computes a CT R-S workﬂow WΦ that is behaviorally equivalent
to W ∧ ∗(Φ1 ∨ ... ∨ Φn) where Φi are elementary constraints.

V

THEOREM 2

(DISJUNCTIVE CONSTRAINTS). Let W be a
control ﬂow graph and ∗Φ ∈ PRIMIT IVE be a disjunctive prim-
itive constraint. Let |W| denote the size of W, and d be the
number of elementary disjuncts in ∗Φ. Then the worst-case size
of WΦ is O(d × |W|), and the time complexity is O(d × |W|2).
(∨jP rim)
Enforcement of arbitrary constraints. If Φ =
where P rim ∈ PRIMIT IVE, we compute WΦ by applying the
above transformations for complex and elementary constraints.
Each transformation is either a logical equivalence or a behavioral
equivalence. Therefore, WΦ is behaviorally equivalent to W ∧ Φ.
(ARBITRARY CONSTRAINTS). Let W be a
control ﬂow graph W and Φ ⊂ CONST R be a set of global
(∨jP rim) where
constraints in the conjunctive normal form
P rim ∈ PRIMIT IVE. Let |W| denote the size of W, N be
the number of constraints in Φ, and d be the largest number of
disjuncts in a primitive constraint in Φ. Then the worst-case size
of WΦ is O(dN×|W|), and the time complexity is O(dN×|W|2).

THEOREM 3

N

V

N

Cycle detection and removal. We can still improve the above
transformation by eliminating certain “useless” parts of WΦ—the
parts that will never be executed. The problem is that even though
WΦ is an executable workﬂow speciﬁcation, WΦ may have sub-
formulas where the send/receive primitives cause a cyclic wait.
This means that those parts of WΦ can never be involved in an
execution. Fortunately, we can show that all cyclic waits can be
removed from W in time O(|W|3).

Example 6. (Cyclic Wait Removal) Let W be (a∨ b)⊗ (c(cid:4) d)
and Φ be (∗c → ∗a). Our algorithm transforms W ∧ Φ into (a ∨
receive(ξ)⊗b)⊗(c(cid:4)(send(ξ)⊗d)). Now, if the reasoner chooses
b, a deadlock occurs. However, we can rewrite this formula into a
behaviorally equivalent formula a⊗ (c(cid:4) d) and avoid the problem.

7. CONCLUSION AND RELATED WORK
We presented a novel formalism, CT R-S, for modeling the dy-
namics of service contracts. CT R-S is a logic in which service con-
tracts are represented as formulas that specify the various choices
that are allowed for the parties to the contracts. The logic permits
the reasoner to state the desired outcomes of the contract execution
and verify that a desired outcome can be achived no matter what
the other parties do as long as they obey the rules of the contract.

There is a body of preliminary work trying to formalize the rep-
resentation of Web service contracts [20, 11], but none deals with
the dynamics of such contracts, which is the main subject of this
paper. Technically, the works closest to ours come from the ﬁelds
of model checking and game logics.

Process algebras and alternating temporal logic [7, 1] have been
used for modeling open systems with game semantics. Model
checking is a standard mechanism for verifying temporal proper-
ties of such systems and deriving automata for scheduling. In [16],
the complexity and size of computing the winning strategies for
inﬁnite games played on ﬁnite graphs are explored. A result anal-
ogous to ours is obtained for inﬁnite games: assuming the size of
the graph is Q and the size of the winning condition is W , the com-
plexity of computing winning strategies is exponential in the size
of W and polynomial in the size of the set Q.

152The use of CT R-S has enabled us to ﬁnd a more efﬁcient veri-
ﬁcation algorithm than what one would get using model checking.
Indeed, standard model checking techniques [7, 1] are worst-case
exponential in the size of the entire formula and the corresponding
scheduling automata are also exponential. This is often referred to
as the state-explosion problem. In contrast, the size of our solver
is linear in the size of the original workﬂow speciﬁcation and ex-
ponential only in the size of the constraint set (Theorem 3), which
is a much smaller object. In a sense, our solver can be viewed as
a specialized and more efﬁcient model checker for the problem at
hand. It accepts high level speciﬁcations of workﬂows and yields
strategies and schedulers in the same high level language.
Logic games have been proposed before in other contexts [13,
19]. As in CT R-S, validity of a statement in such a logic means
that the reasoner has a winning strategy against the opponent. In
CT R-S however, games, winning conditions, and strategies are
themselves logical formulas (rather than modal operators). Log-
ical equivalence in CT R-S is a basis for constructive algorithms
for solving games and synthesizing strategies, which are in turn
executable by the proof theory of CT R-S. Related game logic for-
malisms, such as [13, 19], only deal with assertions about games
and their winning strategies. In these logics, games are modalities
rather than executable speciﬁcations, so they can only be used for
reasoning about Web service contracts, but not for modeling and
executing them.

Related work in planning, where goals are expressed as temporal
formulas, includes [3]. In [3], plans are generated using a forward
chaining engine that generates ﬁnite linear sequences of actions. As
these linear sequences are generated, the paths are incrementally
checked against the temporal goals. This approach is sound and
complete. However, in the worst case it performs an exhaustive
search of the model similar to the model checking approaches.

For the future work, we are planning to extend our results to al-
low contracts that include iterative behaviour. Such contracts can
already be speciﬁed in CT R-S. However, iteration requires new
veriﬁcation algorithms to enable reasoning about the desired out-
comes of such contracts.

8. REFERENCES
[1] R. Alur, T.A. Henzinger, and O. Kupferman.

Alternating-time temporal logic. In Intl. Conference on
Foundations of Computer Science, pages 100–109, 1997.

[2] P.C. Attie, M.P. Singh, E.A. Emerson, A.P. Sheth, and
M. Rusinkiewicz. Scheduling workﬂows by enforcing
intertask dependencies. Distributed Systems Engineering
Journal, 3(4):222–238, December 1996.

[3] F. Bacchus and F. Kabanza. Planning for temporally

extended goals. In Proceedings of the Thirteenth National
Conference on Artiﬁcial Intelligence (AAAI-96), pages
1215–1222, Portland, Oregon, USA, 1996. AAAI Press / The
MIT Press.

[4] A.J. Bonner. Workﬂow, transactions, and datalog. In ACM

Symposium on Principles of Database Systems, Philadelphia,
PA, May/June 1999.

[5] A.J. Bonner and M. Kifer. Concurrency and communication
in transaction logic. In Joint Intl. Conference and Symposium
on Logic Programming, pages 142–156, Bonn, Germany,
September 1996. MIT Press.

[6] A.J. Bonner and M. Kifer. A logic for programming database
transactions. In J. Chomicki and G. Saake, editors, Logics for
Databases and Information Systems, chapter 5, pages
117–166. Kluwer Academic Publishers, March 1998.

[7] E.M. Clarke, E.A. Emerson, and A.P. Sistla. Automatic

veriﬁcation of ﬁnite-state concurrent systems using temporal
logic speciﬁcations. In ACM Transactions on Programming
Languages and Systems (TOPLAS), pages 244–263, 1986.

[8] H. Davulcu, M. Kifer, C.R. Ramakrishnan, and I.V.

Ramakrishnan. Logic based modeling and analysis of
workﬂows. In ACM Symposium on Principles of Database
Systems, pages 25–33, Seattle, Washington, June 1998.

[9] E.A. Emerson. Temporal and modal logic. In Handbook of
Theoretical Computer Science, pages 997–1072. Elsevier
and MIT Press, 1990.

[10] R. Fagin, J. Y. Halpern, Y. Moses, and Moshe Y. Vardi.

Reasoning About Knowledge. MIT Press, 1994.

[11] B.N. Grosof and T.C. Poon. Sweetdeal: representing agent
contracts with exceptions using XML rules, ontologies, and
process descriptions. In Proceedings of the twelfth
international conference on World Wide Web, pages
340–349, May 2003.

[12] R. Gunthor. Extended transaction processing based on

dependency rules. In Proceedings of the RIDE-IMS
Workshop, 1993.

[13] J. Hintikka. Logic, Language Games, and Information.

Oxford Univ. Press, Clarendon, Oxford, 1973.

[14] M. Kifer, G. Lausen, and J. Wu. Logical foundations of

object-oriented and frame-based languages. Journal of ACM,
pages 741–843, July 1995.

[15] F. Leymann. Web services ﬂow language (wsﬂ 1.0).

Technical report, IBM, 2001. http://www-
4.ibm.com/software/solutions/webservices/pdf/WSFL.pdf.

[16] R. McNaughton. Inﬁnite games played on ﬁnite graphs.

Annals of Pure and Applied Logic, 65:149–184, 1993.

[17] S. Mukherjee, H. Davulcu, M. Kifer, G. Yang, and P. Senkul.
Survey of logic based approaches to workﬂow modeling. In
J. Chomicki, R. van der Meyden, and G. Saake Springer,
editors, Logics for Emerging Applications of Databases,
LNCS. Springer-Verlag, October 2003.

[18] M. Osborne and A. Rubinstein. A Course in Game Theory.

The MIT Press, 1998.

[19] Rohit Parikh. Logic of games and its applications. In Annals

of Discrete Mathematics, volume 24, pages 111–140.
Elsevier Science Publishers, March 1985.

[20] D.M. Reeves, M.P. Wellman, and B.N. Grosof. Automated

negotiation from declarative contract descriptions. In J.P.
M¨uller, E. Andre, S. Sen, and C. Frasson, editors,
Proceedings of the Fifth International Conference on
Autonomous Agents, pages 51–58, Montreal, Canada, 2001.
ACM Press.

[21] C. Schlenoff, M. Gruninger, M. Ciocoiu, and J. Lee. The

essence of the process speciﬁcation language. Transactions
of the Society for Computer Simulation International,
16(4):204–216, 2000.

[22] M.P. Singh. Semantical considerations on workﬂows: An
algebra for intertask dependencies. In Proceedings of the
International Workshop on Database Programming
Languages, Gubbio, Umbria, Italy, September 6–8 1995.

[23] M.P. Singh. Synthesizing distributed constrained events from

transactional workﬂow speciﬁcations. In Proceedings of
12-th IEEE Intl. Conference on Data Engineering, pages
616–623, New Orleans, LA, February 1996.

153