A Query Algebra for XML P2P Databases

Carlo Sartiani

Dipartimento di Informatica - Universit`a di Pisa

Via F. Buonarroti 2 - 56127 - Pisa - Italy

sartiani@di.unipi.it

ABSTRACT
This paper describes a query algebra for queries over XML
p2p databases that provides explicit mechanisms for model-
ing data dissemination, replication constraints, and for cap-
turing the transient nature of data and replicas.

Categories and Subject Descriptors: H.3.5[Information
Storage and Retrieval]: Online Information Service - Data
sharing; H.2.5[Database Management]: Heterogeneous Data-
bases; H.2.3[Database Management]: Languages - Data de-
scription languages (DDL)

General Terms: Algorithms, Management, Languages

Keywords: Query algebras, peer data management sys-
tems, XML

1.

INTRODUCTION

In the peer-to-peer (p2p) model, systems are composed of
an open-ended and dynamic network of peers, which share
data, computational resources, etc; peers are usually au-
tonomous or semi-autonomous, and may cooperate together
in the execution of tasks or in the hosting and querying of
data. In the ﬁeld of database research, p2p systems aﬃrmed
as an interesting evolution of past distributed and integra-
tion systems. Several ongoing projects focus on the design
of p2p database systems, mostly for XML data. One miss-
ing point in the current research about p2p XML databases
is the deﬁnition of a proper query algebra. Existing query
algebras, most notably the oﬃcial algebra by W3C [2], have
been deﬁned in the context of static and centralized database
systems, and cover issues ranging from query result analy-
sis and query type-checking to the rigorous deﬁnition of the
statical and dynamic semantics of XML query languages.
As a consequence, they lack support for key issues in p2p
database systems, such as: the dissemination of data over
multiple peers, which may appear and disappear unpre-
dictably; the replication of data in multiple copies, which
have a limited time validity; and the dynamic nature of data
distribution and replication.

This paper shortly describes a query algebra for XML
p2p databases. The proposed algebra supports the FLWR
core of XQuery, and, unlike existing query algebras for XML
data, provides explicit mechanisms for modeling data dis-
semination and replication constraints: in particular, the al-
gebra data model incorporates the notion of locations, which
model peer content, as well as the notion of data freshness;
moreover, the algebra provides operators for manipulating
locations, and for expressing replication constraints.

Copyright is held by the author/owner(s).
WWW2004, May 17–22, 2004, New York, New York, USA.
ACM 1-58113-912-8/04/0005.

2. DATA MODEL AND TERM LANGUAGE
Data in the system are represented as unordered forests of
node-labeled trees. According to the term grammar shown
below, each node (n) has a unique object identiﬁer (oid) that
can be accessed by the special-purpose function oid, and is
augmented with the indication of the hosting peer (location
in the following) as well as with a freshness parameter f r,
which indicates when the last update on the node was per-
formed (⊥ indicates that the freshness is undeﬁned).

| n

t ::= t1, . . . , tn | n[t]
n ::= (oid, loc, f r)label
loc : (dbname → t, (dbname, loc) → t)
where label ∈ Σ∗, f r ∈ N ∪ {⊥}, and
loc1 and loc2 are partial functions.

trees
nodes
locations

Locations model the content of peers, hence they are rep-
resented as a pair of partial functions: the ﬁrst function
(loc1) returns, for each database identiﬁer, the trees con-
tributed to the database by the given peer, if any; the second
function (loc2), instead, describes the replication services of-
fered by a given peer, i.e., it returns, for each database iden-
tiﬁer and location, the replicated trees for such database
and location, if any. Replicas are further described by a
(distributed) set replicas, which contains dynamic repli-
cation constraints. A replication constraint has the form
(loc1, loc2, db, δ1, δ2), and it states that loc2 replicates the
content of loc1 for the database db from time δ1 to time δ2
(δ2 may assume the special value ∞, which indicates that
the replica is always kept up to date); given the dynamic
nature of the system, we expect replication constraints to
evolve over time.

The set of locations containing data relevant for a given
database db is returned by the function Locs. We expect
Locs to be computed during the generation of the query
plan; as usual in p2p systems, the computed set Locs will
be a subset of the set of all relevant locations, or, even worst,
a partially overlapping set.

3. ALGEBRA OPERATORS

The algebra exploits relational-like intermediate structures,
called Env, to accumulate variable bindings collected dur-
ing query evaluation. Env structures, represented as node-
labeled trees conforming to the algebra data model, are ma-
nipulated by quite traditional operators, such as Selection,
P rojection, T upJoin, DJoin, M ap, and GroupBy. In ad-
dition to these operators, the algebra features location oper-
ators, used for manipulating locations, and border operators,
used for performing conversions from data model instances
to Env structures, and vice versa.

258To support dynamic replication constraints, we assume
that each query has two time parameters: the query issuing
time τ0, and the maximum replica time δτ0 , which indicates
that replication constraints of the form (loc1, loc2, db, δ1, δ2)
with δ2 > τ0 − δτ0 can be considered during query plan
generation.
3.1

path and return

The main task of the path operator is to extract infor-
mation from the database, and to build variable bindings.
The way information is extracted is described by an input
ﬁlter ; a ﬁlter is a tree, describing the paths to follow into
the database (and the way to traverse these paths), the vari-
ables to bind and the binding style, as well as the way to
combine results coming from diﬀerent paths.

While the path operator extracts information from exist-
ing XML documents, the return operator uses the variable
bindings of an Env to produce new XML documents. return
takes as input an Env structure and an output ﬁlter, i.e., a
skeleton of the XML document being produced, and returns
a data model instance (i.e., a well-formed XML document)
conforming to the ﬁlter. This instance is built up by ﬁll-
ing the XML skeleton with variable values taken from the
Env structure: this substitution is performed once per each
tuple contained in the Env, hence producing one skeleton
instance per tuple.
3.2 Operators on Locations

Operators on locations are crucial for retrieving data com-
ing from multiple peers, and for exploiting,
if necessary,
replicas of the content of some location. The query alge-
bra oﬀers two location operators: LocU nion, and Choice.
LocU nion (•) takes as input two locations loc1 and loc2,
and it returns a new location obtained by uniting the content
and the replica functions of the arguments. LocU nion is
primarily used for expressing queries retrieving data from
multiple peers, as shown by the following Example.

Example 1. Consider a real-estate market database, and
assume that locations loc1, loc11, loc13, and loc17 share data
about buildings. Suppose that you want to retrieve the price
and the description of each building in the database, as shown
below:

for $b in input()//building,

$d in $b/desc,
$p in $b/price

return <entry> {$d, $p} </entry>

This query can be expressed by the following algebraic ex-

pression:

returnentry[ν$d,ν$p](
path(//,$b,in)building[(/,$d,in)desc[∅]]((•i=1,11,13,17loci)1(db1)))
The Choice (|δ

sulate replication constraints into query plans. loc1 |δ
indicates that loc2 replicates loc1
permitted, it can serve requests for data in loc1
consequence, loc1 |δ
tions concerning db) as loc1 or as loc2
example shows the use of Choice.

db) operator is a convenient way to encap-
db loc2
1(db) until time δ, so, if
1(db). As a
db loc2 can be rewritten (in path opera-
2(loc1). The following

Example 2. Consider the query of the previous example,
and assume that loc11(db1) is replicated at loc17 till time δ;
furthermore, assume that the query was submitted at time

τ0 so that τ0 < δ. Then, the query can be expressed by the
following algebraic expression:

returnentry[ν$d,ν$p](
path(//,$b,in)building[(/,$d,in)desc[∅],(/,$p,in)price[∅]](
(loc1 • (loc11 |δ
db1 loc17) • loc13 • loc17)1(db1)))

4. OPTIMIZATION PROPERTIES

Four main classes of algebraic rewriting rules can be ap-
plied to the XPeer query algebra: classical equivalences in-
herited from relational and OO algebras; path decomposi-
tion rules, which allows the query optimizer to break com-
plex input ﬁlters into simpler ones; equivalences for query
unnesting; and, ﬁnally, rewriting rules for location opera-
tors. For the sake of brevity, only the rules for location
operators will be shown in this paper.

Three main rewriting rules can be applied to location op-
erators: extrusion of LocU nion operations from path oper-
ations; simpliﬁcation of Choice operators; and introduction
of Choice operations.

and loc2, it holds that:

Proposition 1. Given a database db disseminated on loc1
pathf ((loc1•loc2)1(db)) = pathf ((loc1)1(db))∪pathf ((loc2)1(db))
This property states that LocU nion operations inside path
operations can be split and distributed across the query;
this, in turn, allows the system to more easily decompose a
query in single-location subqueries.

Proposition 2. Given a database db hosted at loc1 and

replicated at loc2, it holds that:

db loc2)1(db)) = pathf (loc1
db loc2)1(db)) = pathf (loc2

pathf ((loc1 |δ
pathf ((loc1 |δ
This property shows how a Choice operation inside a path
operation can be rewritten; we expect that this rewriting will
be guided by additional information about network condi-
tions, peer computing power, etc.

1(db))
2(loc1)(db))

Proposition 3. Given a database db, if (loc1, loc2, db, δ1, δ2)

∈ replicas, and δ2 > τ0 − δτ0 , then loc1
loc2)1(db)

1(db) → (loc1 |δ2

db

∈ replicas, and δ2 > τ0 − δτ0 , then

Corollary 1. Given a database db, if (loci, locj, db, δ1, δ2)
pathf ((loc1•loci)1(db)) → pathf ((loc1•(loci |δ2
db locj))1(db))
These properties back the introduction of Choice opera-

tions in query plans.

5. CONCLUSIONS

This paper presented a query algebra for XML p2p data-
bases. The query algebra features mechanisms for modeling
data dissemination and replication, and for incorporating
replication constraints into query plans. The proposed al-
gebra can be used for expressing query plans, as well as for
formally reasoning about query semantics in a p2p environ-
ment, and, in particular, for investigating correctness and
completeness properties of query results.

6. REFERENCES
[1] Sophie Cluet and Guido Moerkotte. Classiﬁcation and

optimization of nested queries in object bases. Technical
report, University of Karlsruhe, 1994.

[2] Denise Draper, Peter Fankhauser, Mary Fernandez, Ashok

Malhotra, Kristoﬀer Rose, Michael Rys, J´erˆome Sim´eon, and
Philip Wadler. XQuery 1.0 and XPath 2.0 Formal Semantics.
Technical report, World Wide Web Consortium, August 2003.
W3C Working Draft.

259