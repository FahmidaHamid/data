P-Tree: A P2P Index for Resource Discovery Applications

Adina Crainiceanu Prakash Linga Johannes Gehrke Jayavel Shanmugasundaram

Department of Computer Science, Cornell University

{adina,linga,johannes,jai}@cs.cornell.edu

ABSTRACT
We propose a new distributed, fault-tolerant Peer-to-Peer
index structure for resource discovery applications called the
P-tree. P-trees eﬃciently support range queries in addition
to equality queries.
Categories and Subject Descriptors
H.3.4 [Information Storage and retrieval]: Systems and
Software—distributed systems
General Terms
Algorithms
Keywords
peer-to-peer, indexing, range queries, resource discovery
1.

INTRODUCTION

Peer-to-peer (P2P) systems are emerging as a new paradigm

for structuring large-scale distributed systems. The key ad-
vantages of P2P systems are their scalability, due to resource-
sharing among peers, their fault-tolerance, due to the sym-
metrical nature of peers, and their robustness, due to self-
organization in the face of peer and network failures. Due to
the above advantages, P2P systems have made inroads for
content distribution and service discovery applications [10,
8, 9, 1]. However, most existing systems only support loca-
tion of services based on their name (equality lookups).

Here, we argue for a richer query semantics for P2P sys-
tems. We envision a future where users will use their local
servers to oﬀer services described by semantically-rich XML
documents. Users can then query this “P2P service direc-
tory” as if all the services were registered in one centralized
database. As a ﬁrst step towards this goal we propose the
P-tree, a new distributed fault-tolerant index that can eﬃ-
ciently support range queries in addition to equality queries.
As an example, consider a large-scale computing grid dis-
tributed all over the world. Each grid node (peer) has an
associated XML document that describes the node and its
available resources. Each XML document has an IPAddress
attribute that speciﬁes the IP address of the grid node, an
OSType attribute indicating the operating system, and a
MainMemory attribute indicating how much main memory
is available at the node. Given this setup, a user may wish to
issue a query to ﬁnd suitable grid nodes for a main-memory
intensive application - grid nodes with a “Linux” operating
system with at least 4GB of main memory:

Copyright is held by the author/owner(s).
WWW2004, May 17–22, 2004, New York, New York, USA.
ACM 1-58113-912-8/04/0005.

for $node in //node
where $node/@OSType = ’Linux’ and

$node/@MainMemory >= 4096

return $node/@IPAddress

A naive way to evaluate the above query is to contact ev-
ery peer in the system, and select only the relevant peers.
However, this approach has obvious scalability problems be-
cause all peers have to be contacted for every query, even
though only a few of them may satisfy the query predicates.
P2P index structures that support only equality queries will
also be ineﬃcient here: they will have to contact all the grid
nodes having “Linux” as the OSType, even though a large
fraction of these may have main memory less than 4GB.

In contrast, the P-tree supports the above query eﬃciently
because it supports both equality and range queries. In a
stable system (no insertions or deletions), a P-tree of order
d provides O(m + logdN ) cost for range queries, where N is
the number of peers in the system, m is the number of peers
in the selected range and the cost is the number of mes-
sages. The P-tree requires O(d · logdN ) space at each peer
and is resilient to failures of even large parts of the net-
work. Our experimental results show that P-trees handle
frequent item/peer insertions and deletions with low main-
tenance overhead and small impact on search performance.
In this paper, we target applications that oﬀer a single ser-
vice per peer, such as resource discovery applications for web
services or the grid. We call the XML document describing
each service a data item. Our techniques can be applied to
systems with multiple data items per peer by ﬁrst using a
scheme such as [5] to assign ranges of data items to peers,
and then considering each range as being one data item.
We call the attributes of the data items on which the index
is built the search key (in our example, the search key is a
composite key of the OSType and MainMemory attributes).
2. THE P-TREE INDEX

The P-tree index supports equality and range queries in a
dynamic environment. P-trees are highly distributed, fault-
tolerant and scale to a large number of peers.
2.1 P-tree: Overview

Centralized databases use the B+-tree index [3] to eﬃ-
ciently evaluate equality and range queries. The key idea
behind the P-tree is to maintain parts of semi-independent
B+-trees at each peer. This allows for fully distributed in-
dex maintenance.

Conceptually, each peer views the search key values as
being organized in a ring, with the highest value wrapping
around the lowest value (see Figure 1). When constructing

390its semi-independent B+-tree, each peer views its search key
value as being the smallest value in the ring (note that on
a ring, any value can be viewed as the smallest value). In
a P-tree, each peer stores and maintains only the left-most
root-to-leaf path of its corresponding B+-tree. Each peer
relies on a selected sub-set of other peers to complete the
remaining (non root-to-leaf) parts of its tree.

As an illustration, consider Figure 1. The peer p1, which
stores the item with value 5, only stores the root-to-leaf path
of its independent B+-tree. To complete the remaining parts
of its tree - i.e., the sub-trees corresponding to the index
values 29 and 31 at the root node - p1 simply points to the
corresponding nodes in the peers p5 and p7 (which store
the data items corresponding to 29 and 31, respectively).
Note that p5 and p7 also store the root-to-leaf paths of their
independent B+-trees. Consequently, p1 just points to the
appropriate nodes in p5 and p7 to complete its own B+-tree.
To illustrate an important diﬀerence between P-trees and
B+-trees, consider the semi-independent B+-tree at peer p1.
The root node of this tree has three sub-trees stored at the
peers with values 5, 29, and 31, respectively. The ﬁrst sub-
tree covers values in the range 5-23, the second sub-tree cov-
ers values in the range 29-31, and the third sub-tree covers
values in the range 31-5. These sub-trees have overlapping
ranges, and the same data values (31 and 5) are indexed
by multiple sub-trees. Such overlap is permitted because it
allows peers to independently grow or shrink their tree; this
in turn eliminates the need for excessive coordination and
communication between peers. A full formalization of the
P-tree properties, such as the extent of the allowed overlap
among sub-trees, can be found in [4].

The above structure of P-trees has the following advan-
tages. First, since the P-tree maintains the B+-tree-like
hierarchical structure, it can provide O(logdN ) search per-
formance for equality queries in a consistent state. Second,
since the order of the ring corresponds to the order of the
search key space, range queries can be answered eﬃciently
by ﬁrst ﬁnding the smallest value in the range (using equality
lookup), and then scanning the relevant portions of the ring.
Third, since each peer is solely responsible for maintaining
the consistency of its leftmost root-to-leaf path nodes, it
does not require global coordination and does not need to
be notiﬁed for every insertion/deletion. Finally, since each
peer only stores tree nodes on the leftmost root-to-leaf path,
and each node has at most 2d entries, the total storage re-
quirement per peer is O(d · logdN ).
2.2 P-tree: Algorithms

This section presents a high-level description of the P-tree
algorithms, which are fully decentralized. For full details
and experimental results, we refer the reader to [4].

The main idea is to allows the P-tree to be in a state of
local inconsistency, where some of the consistency require-
ments for semi-independent B+-trees are not satisﬁed (such
as the extent of overlap between successive tree branches).
Local inconsistency allows searches to proceed correctly, with
perhaps a slight degradation in performance, even if peers
are continually being inserted and deleted from the system.
The local inconsistency of the P-tree is repaired by two
co-operating periodic processes, the Ping Process and the
Stabilization Process that run at each peer. These processes
transform an inconsistent P-tree to a consistent one without
any need for global coordination. The Ping Process detects
changes due to insertions, deletions and peer failures, and

Figure 1: Full P-tree

marks the appropriate index entries as inconsistent. The
Stabilization Process repairs these inconsistent entries so the
P-tree properties are again satisﬁed. We can formally prove
that the (implicit and loose) cooperation between peers as
expressed in the Ping and Stabilization Process leads even-
tually to a globally consistent P-tree.
3. RELATED WORK

Existing systems [10, 6] that use hash functions and im-
plement distributed schemes for eﬃcient lookup cannot eﬃ-
ciently process range queries to provide exact answers due to
order scrambling in the value space. Distributed database
index structures (e.g.
[7]) are inadequate in a P2P frame-
work as they do not allow peers to leave the system at will.
Skip graphs [2] and Peper [5] support range queries but one
[2] provides only probabilistic guarantees while the other [5]
provides no search guarantees, even with a consistent index.
4. CONCLUSION

We have proposed the P-tree index, which is well suited
for applications such as resource discovery for web services
and the grid, by supporting range queries in addition to
equality queries. Results from our simulation study and real
implementation show that P-trees eﬃciently support search,
insertion and deletion, with average cost per operation being
approximately logarithmic in the number of peers.
5. REFERENCES
[1] K. Aberer. P-grid: A self-organizing access structure for

p2p information systems. In CoopIS, 2001.

[2] J. Aspnes and G. Shah. Skip graphs. In SODA, 2003.
[3] D. Comer. The ubiquitous b-tree. In Computing Surveys,

11(2), 1979.

[4] A. Crainiceanu et al. Querying peer-to-peer networks using

p-trees. In Cornell University TR 2004-1926, 2004.

[5] A. Daskos et al. Peper: A distributed range addressing

space for p2p systems. In DBISP2P, 2003.

[6] A. Gupta et al. Approximate range selection queries in

peer-to-peer systems. In CIDR, 2003.

[7] D. B. Lomet. Replicated indexes for distributed data. In

PDIS, 1996.

[8] S. Ratnasamy and et al. A scalable content-addressable

network. In SIGCOMM, 2001.

[9] A. Rowstron and P. Druschel. Pastry: Scalable,

decentralized object location, and routing for large-scale
peer-to-peer systems. In Middleware, 2001.

[10] I. Stoica et al. Chord: A scalable peer-to-peer lookup
service for internet applications. In SIGCOMM, 2001.

51330p3p2p1p4p6p7p8723293142 5| 7|13|23p2p3 5|29|31p5p7 7|13|23|29 p2p3p4 7|29|31|5p5p7p542| 5 p8p142| 7|23|30p2p431|42| 5p7p831| 7|29p2p513|23|29|30p3p413|29|42| 7p5p8p523|29|30p4p5p7p1p623|31| 5p529|30|31p5p629|42| 7p8p2p730|31p6p7p8p230|42| 7p4p1p1p6p61111111122222222p1p2391