A Service Creation Environment Based on End to End

Composition of Web Services

Vikas Agarwal, Koustuv Dasgupta, Neeran Karnik, Arun Kumar

Ashish Kundu, Sumit Mittal and Biplav Srivastava

favikas,kdasgupta,kneeran,kkarun,kashish,sumittal,sbiplavg@in.ibm.com

IBM India Research Laboratory
Block 1, IIT campus, Hauz Khas

New Delhi 110016, India

ABSTRACT
The demand for quickly delivering new applications is
increasingly becoming a business imperative today. Applica-
tion development is often done in an ad hoc manner, without
standard frameworks or libraries, thus resulting in poor
reuse of software assets. Web services have received much
interest in industry due to their potential
in facilitating
seamless business-to-business or enterprise application inte-
gration. A web services composition tool can help automate
the process, from creating business process functionality,
to developing executable work(cid:13)ows, to deploying them
on an execution environment. However, we (cid:12)nd that
the main approaches taken thus far to standardize and
compose web services are piecemeal and insu(cid:14)cient. The
business world has adopted a (distributed) programming
approach in which web service instances are described
using WSDL, composed into (cid:13)ows with a language like
BPEL and invoked with the SOAP protocol. Academia
has propounded the AI approach of formally representing
web service capabilities in ontologies, and reasoning about
their composition using goal-oriented inferencing techniques
from planning. We present the (cid:12)rst integrated work in
composing web services end to end from speci(cid:12)cation to
deployment by synergistically combining the strengths of
the above approaches. We describe a prototype service
creation environment along with a use-case scenario, and
demonstrate how it can signi(cid:12)cantly speed up the time-to-
market for new services.

Categories and Subject Descriptors
H.3.5 [Information Systems]: Information Storage and
Retrieval|Web-based services;
I.2.8 [Arti(cid:12)cial Intelli-
gence]: Problem Solving, Control Methods, and Search|
Plan execution, formation, and generation; D.2.m [Software
Engineering]: Miscellaneous

General Terms
Design, Languages

is held by the International World Wide Web Conference
Copyright
Committee (IW3C2). Distribution of these papers is limited to classroom
use, and personal use by others.
WWW 2005, May 10-14, 2005, Chiba, Japan.
ACM 1-59593-046-9/05/0005.

Keywords
Semantic Web, Planning, Web Services Composition

1.

INTRODUCTION

The demand for quickly delivering new applications is
increasingly becoming a business imperative today. For
example, given the intense competition in the telecom
sector, mobile telephony service providers need to con-
tinually develop compelling applications to attract and
retain end-users, with quick time-to-market. Often,
if a
competitor introduces a new service, the service provider
must o(cid:11)er a similar or better service within days/weeks,
to avoid losing customers. Also, a service provider can
attract enterprise customers by o(cid:11)ering custom-developed
value-added services that leverage its telecom and IT in-
frastructure. Enterprise customers typically o(cid:11)er signi(cid:12)-
cantly higher margins than consumers, and are thus more
attractive.
Service providers therefore need tools and
standards-based runtime platforms to quickly develop and
deploy interesting applications for their clients. This would
assist in their transition towards \on demand", responsive
businesses.

Much of this service/application development is currently
done in an ad hoc manner, without standard frameworks
or libraries, thus resulting in poor reuse of software assets.
When a new service is needed, the desired capability is
informally speci(cid:12)ed. An application developer must then
create this capability using component services available in-
house or from known vendors. This process is essentially
manual. For example, if a mobile service provider wishes
to o(cid:11)er a taxi-request service to its users, the developer
must pick a third-party taxi service (with an advertised
network interface) apart from in-house services like location-
tracking, accounting, etc.
and design a work(cid:13)ow that
delivers the required functionality. The dynamic nature
of the environment impacts the development process as
well. For example, new taxi services may become available,
o(cid:11)ering better and/or cheaper services; physical changes in
the network or environment may necessitate a redesign of
the (cid:13)ow, etc.

Web services have received much interest in industry
due to their potential
in facilitating seamless business-
to-business or enterprise application integration [22, 27].

Web services o(cid:11)er standardized interface description, dis-
covery and messaging mechanisms. Also, the programming
tools and runtime environments for web services have now
matured. A component-oriented software development
approach where each software is wrapped as a web ser-
vice would o(cid:11)er substantial bene(cid:12)ts in the mobile service
provider’s scenario. Mobile user applications often rely on
several, relatively simple building blocks { user pro(cid:12)le look-
ups, address books, location-tracking services, accounting
and billing services, etc. Many of these building blocks
are already in place, but they are not easy to reuse and
integrate into new applications because they are not built
using standardized frameworks or component models. This
leads to high development costs, and substantial time-to-
market for new services. This could be alleviated by building
applications using the service-oriented architecture (SOA)
paradigm, using web services as the underlying abstraction.
We (cid:12)nd that two di(cid:11)erent approaches have been taken
to standardize and compose web services. The business
world has adopted a distributed systems approach in which
web service instances are described using WSDL, composed
into (cid:13)ows with a language like BPEL1, and invoked with
the SOAP protocol. Academia has propounded the AI
approach of formally representing web service capabilities in
ontologies, and reasoning about their functional composition
using goal-oriented inferencing techniques from planning
[16]. These approaches by themselves are piecemeal, and
insu(cid:14)cient. The former has focused on the execution aspects
of composite web services, without much consideration for
requirements capture and the development process. The
latter approach has stressed on the feasibility of service
composition based on semantic descriptions of service ca-
pabilities, but its output cannot be directly handed o(cid:11) to a
runtime environment for deployment.

In this paper, we demonstrate how web services compo-
sition can be leveraged for business process integration, by
synergistically combining the strengths of both the above
approaches. The main contributions are:

(cid:15) To the best of our knowledge, we present the (cid:12)rst
end to end web services composition methodology
that, given a formally speci(cid:12)ed requirement for a new
service, stitches together semantically-annotated web
service components in a BPEL (cid:13)ow that delivers the
required function.

(cid:15) We propose a principled two-stage web services compo-
sition approach leveraging the di(cid:11)erentiation between
web service types and instances. This helps in handling
di(cid:11)erent goals, di(cid:11)erent data, di(cid:11)erent rates of change
of data at each stage, and di(cid:11)erent means to optimize
them. It allows us to achieve scalability.

(cid:15) We describe an end to end working prototype:

(a)
Ontology matching, composition at type level with
service matchmaking (b) Composition at physical
level with instance selection (c) Deployment onto a
decentralized work(cid:13)ow orchestration infrastructure.

The rest of this paper is organized as follows. In the next
section, we describe a business process integration scenario
and motivate the role of web services composition. We then

1http://www.ibm.com/developerworks/webservices/library/
ws-bpel/

describe our approach (Sec. 3) followed by details on its
main aspects { logical composition (Sec. 4) and physical
composition (Sec. 5). Section 6 illustrates our solution for
the use-case scenario. In Sec. 7, we provide a summary of
related work. Finally we conclude with some directions for
future work.

2. A MOTIVATING EXAMPLE

Service providers, like telcos, are increasingly targeting
businesses as customers because of the higher margins
and longer-term relationships.
Suppose a telco wants
to enable an enterprise customer to use its telecom and
IT infrastructure by creating and deploying services that
automate the customer’s business processes. As an example
the telco is attempting to automate a typical Helpline (or
call center) for a washing machine manufacturer.

A customer calls in to report a problem with her washing
machine. This problem needs to be assigned to an agent
for resolution.
If the problem is such that it could be
solved over the phone, a desk-based agent at the call center
will be assigned. Otherwise, we need to (cid:12)nd an agent in
the (cid:12)eld who can visit the customer and (cid:12)x the washing
machine. The service provider would like to create a set of
web services that automate parts of this process to whatever
extent possible, and keep aggregating these components to
create higher-level composite services. Once such a software
infrastructure is developed, the telco could o(cid:11)er it as a
service to various enterprise customers (appliance manufac-
turers, software vendors, etc), with minor customization.
Figure 1 summarizes the work(cid:13)ow in this Helpline scenario.

User Input

Problem
Reporting

Problem Ticket

Problem

Classification

Expertise Level,
Expert Location

Expert
Lookup

Problem Ticket,
List of Field Agents

Location−based
Agent Selector

Problem Ticket,
Desk Agent

Problem Ticket,

Field Agent

Message
Delivery

Call Set Up

On Site

Help Desk

Problem Ticket,
Problem Resolution Status

Problem Ticket,
Problem Resolution Status

Figure 1: Helpline Service.

Here is a sampling of the component services that may be
available in the service provider’s infrastructure: Location
tracking, SMS, Call Setup, Agent Expertise data, Problem
Classi(cid:12)cation, Agent Selection. Some of these provide telco-
speci(cid:12)c functions such as delivering SMS text messages,
location tracking of mobile phones, etc. Others are speci(cid:12)c
to the application domain, e.g. problem classi(cid:12)cation.

A developer needs to create a set of higher-level services
using these components. Consider for example a location-
based agent selector service (Fig. 2). Given a customer’s
location and a list of agents out in the (cid:12)eld, this service
needs to select one of the agents, based on proximity to the
customer’s residence. This selected agent will then be asked

Problem Ticket,
List of Field Agents

Location−based
Agent Selector

Problem Ticket,
Field Agent

Problem Ticket (Customer Location)

List of Agent Mobile Nos

List of Agent Locations,
List of Agent IDs

Expert DB

Location
Tracker

Distance
Calculator

Optimal Agent

Selector

Nearest Agent

List of Agent IDs

List of Agent Locations

Figure 2: Location-based Agent Selector Service.

to visit the customer and (cid:12)x her washing machine. The
bottom half of Fig. 2 shows how this can be done by creating
a (cid:13)ow linking together several component services, feeding
them the right inputs, etc. Doing this manually takes
time (and the developer has to know which components
exist, and how to connect them up).
Instead, we provide
a tool that discovers the relevant services from amongst the
available ones, and creates the control (cid:13)ow between them.
The available services are semantically annotated, providing
meta-information about their functionality in the context of
a domain model. The developer only needs to (formally)
specify the requirements of the service to be created. The
tool can then generate a (cid:13)ow, and with some developer
inputs, deploy the (cid:13)ow on to a runtime infrastructure. This
should lead to quicker service creation, and thus faster time-
to-market for new services.

Further, the newly created Location-based Agent Selector
(LAS) service itself becomes available as a component. It
can now be reused in creating other (cid:13)ows, such as the one in
Fig. 1. Each new service thus enriches the infrastructure and
makes the developer’s task easier in future. We will use the
LAS service as a running example to explain the phases in
the composition process. Our service creation environment
however includes a domain model and ontology for the
entire Helpline Automation scenario, and we demonstrate
the automated composition of the complete (cid:13)ow of Fig. 1 in
Sec. 6.

3. SYSTEM OVERVIEW

Our service creation methodology, based on web service

composition techniques, consists of the following steps:

1. Service Representation: Representing the available

services and their capabilities.

2. Requirements Speci(cid:12)cation:

Specifying the desired

functionality of a new service.

3. Composition: Constructing a composition of available

services that provides the desired functionality.

4. Composite Service Representation: Representing the
new composite service and its capabilities so that
it can be programmatically deployed, discovered and
invoked.

In previous work a similar process has been applied at
di(cid:11)erent levels of abstraction, none of which individually
yields a practical solution. Our system takes an end to
end view that synergistically combines the AI approach and
the distributed programming approach currently adopted
by academia and the industry respectively.
It drives the

Service
Service

Specification
Specification

Service Creation
Service Creation

Environment
Environment

Logical 
Logical 
Composer
Composer

Abstract 
Abstract 

Workflow (Plan)
Workflow (Plan)

Domain 
Domain 
Ontology
Ontology

Physical 
Physical 
Composer
Composer

Service 
Service 
Registry
Registry

Deployable
Deployable
Workflow
Workflow

Execution Environment
Execution Environment

Figure 3: System Overview.

composition process right from speci(cid:12)cation of the business
process, through creation of desired functionality using
planning techniques, through generation of a deployable
work(cid:13)ow by selection and binding of appropriate service
instances, to (cid:12)nally deploying and running the composite
service.
This integrated solution achieves the best of
both worlds and provides scalability to the composition
process. We have built a service creation environment that
realizes this approach in terms of the following phases of
composition:

1. Logical Composition: This phase provides func-
tional composition of service types to create new
functionality that is currently not available.

2. Physical Composition: This phase enables the
selection of component service instances based on non-
functional (e.g. quality of service) requirements, that
would then be bound together for deploying the newly
created composite service.

This basic approach to automating the process of service
creation is illustrated in Fig. 3. A Service Registry con-
tains information about services available in-house as well
as with participating 3rd-party providers. The capabilities
of each available service type are described formally, using
domain-speci(cid:12)c terminology that is de(cid:12)ned in a Domain
Ontology. When a new service needs to be created, the
developer provides a Service Speci(cid:12)cation to the Logical
Composer module. Driven by the speci(cid:12)ed requirements,
the Logical Composer uses generative planning-based auto-
mated reasoning techniques to create a composition of the
Its goal is to explore qualitatively
available service types.
di(cid:11)erent choices and produce an abstract work(cid:13)ow,
i.e.
a plan (assuming a feasible plan exists) that meets the
speci(cid:12)ed requirements.

In order to turn the plan into a concrete work(cid:13)ow that can
be deployed and executed, speci(cid:12)c instances must be chosen
for the component services in the plan. The Physical
Composer uses scheduling and compilation techniques in
selecting the best web service instances to produce an
executable work(cid:13)ow. The focus is now on quantitatively
exploring the available web service instances for work(cid:13)ow
execution. It queries the registry for deployed web service
instances, to accomplish this task.

The work(cid:13)ow generated by the service creation environ-
ment must then be deployed onto a runtime infrastructure,
and executed in an e(cid:14)cient and scalable manner. This
is especially important in environments like that of a
mobile service provider, where the number of end-users
is likely to be very high. The state of the art is to
execute the work(cid:13)ow using a work(cid:13)ow engine such as
WebSphere Process Choreographer2, with data (cid:13)owing back
and forth from this engine to the component web services.
Our Execution Environment instead orchestrates the
work(cid:13)ow in a decentralized fashion, with partitions of the
(cid:13)ow executing concurrently, in network-proximity with the
component services they invoke. These (cid:13)ow partitions are
generated automatically by a Decentralizer tool, using static
analysis of the input BPEL (cid:13)ow. The communication
amongst these partitions is designed to minimize network
usage, while retaining the original (cid:13)ow semantics. This, in
conjunction with the added concurrency, results in better
scalability and performance.
For more details on our
Execution Environment please refer to [5, 18]. In this paper,
we will focus on the Logical and Physical composition stages.

4. LOGICAL COMPOSITION

Figure 4 depicts our system for implementing the four
steps of composition during Logical Composition. Available
service types and their capabilities are represented in a
Service Capabilities Registry. An Ontology captures the do-
main model. We use IBM’s SNOBASE3 as the management
system for our ontology and the service capabilities registry.
Speci(cid:12)cation of the desired service is supplied to a Logical
Composer module that (cid:12)rst gets it veri(cid:12)ed for syntactic
correctness using a Validator module. The Matchmaker
module allows querying the service registry for available ser-
vices. Based upon the validated speci(cid:12)cation, Planner4J
retrieves the set of candidate services using the matchmaker.
The Filter module helps in pruning the set of candidate
services before Planner4J uses planning techniques to create
the composite service. We next discuss the issues that arise
in each step of logical composition.

Service
Specs

Logical 
Composer

Abstract 
Workflow

Domain

Information

SNOBASE

Validator

Validated

Specs

Ontology

Service

Capabilities

Registry

Domain

Information

Available 
Service
Types
Matchmaker

Planner4J

Filter

Candidate
Component

Services

Candidate
Component

Services

Figure 4: Logical Composition.

4.1 Representation of Service Types

To enable automatic discovery and composition of desired
functionality, we need a language to describe the available
web services. This can take place at two levels { web service
types and web service instances. At the logical composition

stage, the composition process typically involves reasoning
procedures. To enable those, services need to be described
in a high-level and abstract manner [12]. Therefore at this
stage it su(cid:14)ces to describe the capabilities of the types
of web services, using semantic annotations. The second
level of description becomes important in the physical
composition stage where individual running services need to
be identi(cid:12)ed for deploying the work(cid:13)ow. Once the language
is known, the basic terms used in the language have to be
drawn from a formal domain model. This is required to
allow machine based interpretation while at the same time
preventing ambiguities and interoperability problems.

The DARPA Agent Markup Language (DAML, now
called OWL)4 is the result of an ongoing e(cid:11)ort to de(cid:12)ne
a language that allows creation of domain models or con-
cept ontologies. We use it to create the domain model
using which services are described. The OWL-S markup
language [19] (previously known as DAML-S) is also being
de(cid:12)ned as a part of the same e(cid:11)ort, for facilitating the
creation of web service ontologies.
It speci(cid:12)es an upper
ontology of services that de(cid:12)nes the structure of a service
description. It de(cid:12)nes that a service presents a ServicePro(cid:12)le
(i.e. what the service does), is describedBy a ServiceModel
(i.e. how it works) and supports a ServiceGrounding (i.e.
how to access it).

Currently, OWL-S is designed to describe a single web
service instance [19]. This is easily observed since the
ServiceModel and ServiceGrounding aspects are speci(cid:12)c to
an instance of a web service. However, we believe that the
type of a web service needs to be described independent
of individual web service instances. This helps in working
with large collections of web services { categorizing them,
supporting multiple views, etc. [12]. In our present solution
prototype, we use the ServicePro(cid:12)le model of OWL-S to
represent web service type de(cid:12)nitions. The task of providing
descriptions for speci(cid:12)c web service instances is deferred to
the physical composition phase.

We have also developed a proposal to separate the
representation of web service type de(cid:12)nitions from instance
de(cid:12)nitions by enhancing the OWL-S upper ontology to have
a ServiceType class hierarchy in addition to the Service
hierarchy, as described in detail in [11]. Similar approach
of separating type de(cid:12)nitions from instance de(cid:12)nitions has
been used successfully in data models for distributed systems
management [17, 1]. In future, we plan to incorporate the
proposal and thereby use the same modeling language for
representing both the service types and instances.

4.2 Requirements Speciﬁcation

In order to create a new service, the developer should
describe the required functionality as well as non-functional
constraints such as throughput, response time, cost etc. We
again use OWL-S for representing the requirements in IOPE
terms, because the result of the composition is also a service.
The developer is presented with a graphical user interface
using which she can specify these requirements. The tool
maps these to OWL-S for internal processing.

In keeping with our philosophy of qualitatively composing
the plan before focusing on the quantitative optimization is-
sues, the tool processes the requirements incrementally. The
preconditions and e(cid:11)ects are logical terms and sentences,

2http://www.software.ibm.com/wsdd/zones/was/wpc.html
3http://www.alphaworks.ibm.com/tech/snobase

4http://www.daml.org

the initial state (e.g. whether Agent needs to be desk-
based or in the (cid:12)eld) but they can be found at runtime
using sensing actions. Plans of contingent planning
problems have branches corresponding to di(cid:11)erent
outcomes that sensing actions may (cid:12)nd. However, the
user may not be interested in all branches { which
are exponential in the number of unknown terms {
but only in speci(cid:12)c branches. For the rest (usually
unimportant or unlikely cases), the user may manually
insert a default branch. We have implemented such a
contingent planner in the Planner4J framework [25].

(cid:15) Filtering is needed to remove irrelevant web services.
Since the number of web service instances in a registry
could be very large, the number of web service types
can also be large. Given a goal speci(cid:12)cation, the
Filter (cid:12)nds services of potential relevance to the goal
without actually searching for the solution. Relevant
services are those that can either contribute to the
goals (at least one e(cid:11)ect uni(cid:12)es with a goal) or to
the preconditions of any service which can potentially
contribute to the goal.

(cid:15) Our Matchmaker [7] matches the preconditions of
a web service with the e(cid:11)ects of another up front.
Another approach may be to perform matchmaking
as needed during planning [23]. This can support
more expressive matching (e.g.
involving expressions
of initially unknown terms) but at the cost of slower
performance due to frequent reference to the ontology
uni(cid:12)er.

(cid:15) We provide incomplete plans on request. If no com-
plete sequence of actions is possible from the available
services for a given requirement, planning can still help
the user scope down the composition request or point
to missing capabilities in the ontology. The planner
sorts the search space of non-solutions based on a
heuristic distance to goal. The plan with the lowest
such distance gives us a candidate plan for further
development. This is especially valuable when the
ontology development has not stabilized.

With these features planning is scalable, e(cid:14)cient and user
friendly. We illustrate with some empirical results. On
a contingent problem having a 7-step plan, with the (cid:12)lter
enabled, the planner can return a solution in 4 seconds when
100,000 irrelevant service types/actions are present, whereas
it takes an hour without the (cid:12)lter. If the user chooses speci(cid:12)c
branches, the planner can leverage it for better performance
{ in an experiment where 3 branches were speci(cid:12)ed on a
contingent problem with 100 sensing actions (2100 possible
branches), the planner takes 90% less time by leveraging this
information rather than exploring the whole search space.

In Fig. 5, the planner was invoked for the LAS service.
Recall that the initial state asserts that CustomerLocation
is known and the goal is to (cid:12)nd the agent (AgentID) nearest
to the customer location. The output of the tool is a 4-step
plan that can accomplish the goal. The created service is
added to the service capabilities registry by the user.
4.4 The Abstract Workﬂow

The generated plan is a sequence of time steps, where each
time step may have concurrent actions. Since plans can have

Figure 5: Logical Plan for the LAS service.

and are used during planning in logical composition5. The
inputs and outputs are expressions involving general data
types (e.g.
integers, strings, algebraic expressions) which
are used during instance selection and (cid:13)ow concretization in
the physical composition phase. It is possible to incorporate
numeric inputs and outputs during planning as well { this
approach to planning is called metric planning [6]. Exploring
the feasibility of metric planning for end to end web service
composition would be an interesting area for future work.

For the LAS composite service, the precondition (or
the initial state of the composition problem) asserts that
CustomerLocation is known and the e(cid:11)ect (or the goal
state) is to (cid:12)nd the agent (AgentID) nearest to the customer
location.
4.3 Composition through Planning

AI Planning deals with (cid:12)nding a course of actions that
can take an agent from the initial state to a goal state,
given a set of actions (legal state transformation functions)
in the domain. Formally, a planning problem [30] P is a
3-tuple (cid:30) I; G; A (cid:31) where I is the complete description
of the initial state, G is the partial description of the goal
state, and A is the set of executable (primitive) actions.
An action sequence S (a plan) is a solution to P if S can
be executed from I and the resulting state of the world
contains G. A planner (cid:12)nds plans by evaluating actions and
searching in the space of possible world states or the space
of partial plans. Logical composition of web services can be
cast as a planning problem by using the description of web
services as actions, and forming initial and goal states from
the speci(cid:12)cation of the service to be built along with the
domain model [16].

For our service creation tool, planning for web services

has some unique characteristics (refer to Fig. 4):

(cid:15) The nature of planning is limited contingency planning.
The value of all logical terms may not be known in

5Services can be matched using arbitrary sentences as
de(cid:12)ned with OWL-S 1.1 but for planning, we use a state
representation consistent with the STRIPS assumptions[30].

branches which are contingent on speci(cid:12)c conditions (called
branch context) being met, actions are labeled with their
context. The default context for an unconditional action is
true, always valid.

The plan is translated to the work(cid:13)ow representation of
BPEL, a language for expressing interactions and message
exchanges between partner entities. It can be automatically
interpreted and executed by a work(cid:13)ow engine. A BPEL
speci(cid:12)cation can be abstract or executable depending on
whether binding information has been excluded or included.
We render the generated plan as an abstract BPEL
work(cid:13)ow since web service instance information is not
known at this stage of the composition process. The actions
in the plan are mapped to corresponding invoke activities in
BPEL and organized into branches by inserting appropriate
switch and case activities.

5. PHYSICAL COMPOSITION

Abstract
Workflow

Physical
Composer

Deployable
Workflow

Matching
Instances

Instance 
Selector

WSME

Matchmaker

Selected
Instances

BPEL 

Generator

Available 
Service
Instances

Service
Instances
Registry

WSDLs for the 

selected Instances

Matchmaking 
language/rules

Data 

Dictionary

Figure 6: Physical Composition.

In this phase, the abstract work(cid:13)ow for the composite
service is fed to the Physical Composer, which binds each
service in the work(cid:13)ow to a concrete service instance. The
process of matching each service type to a corresponding
instance, and then orchestrating between the set of instances
in the resulting work(cid:13)ow is a non-trivial matchmaking
problem. The problem has been addressed extensively for
web services and involves a number of issues related to
data (cid:13)ow orchestration, data type and invocation protocol
matching, QoS matching and SLA composition. While some
of these issues can be resolved in an automated manner,
others might require manual intervention from a developer
supervising the composition process. We next describe each
of the steps involved in the Physical Composition stage,
illustrated in Fig. 6.
5.1 Representation of Service Instances and

Requirements

As in Logical Composition, we require a representation for
service instances and composition requirements to facilitate
Composition. It has been established that directory services,
such as UDDI, are important but insu(cid:14)cient for this
purpose [9] and need to be complemented with matchmaking
facilities like symmetry of information exchange between
services and their consumers, the ability of each party
to describe requirements from the other party, a rich
language to describe services’ and consumer demands, and a
methodology to choose e(cid:14)ciently among competing service
instances.

To this end, we use the Web Services Matchmaking Engine
(WSME) [9] { an engine capable of matching complex

entities, and a Data Dictionary tool
for de(cid:12)ning the
language for the matching process. Matching is performed
between service instances and requirements speci(cid:12)ed by the
consumer.
In our case, the requirements come from the
abstract work(cid:13)ow and additional matching criteria speci(cid:12)ed
by the developer performing the service composition.

The engine is deployed as a Web service that receives
queries and advertisements from the two parties involved in
matchmaking. Each party essentially submits a description
of itself and the demands from the other party. The Adver-
tisement is submitted by the provider to WSME and is long
lived, remaining in WSME until it is explicitly withdrawn
by the provider or until the application server is stopped.
The advertisement contains the following information: (1)
MyType - this speci(cid:12)es the advertisement record-type. (2)
YourType - this speci(cid:12)es the record-type expected to be
submitted by the consumer query.
(3) Properties - a
list of the properties de(cid:12)ned as MyType. Some of those
properties may be de(cid:12)ned as dynamic properties by the
provider evaluated at runtime. (4) Rules (optional) - what
the provider requires from the consumer.

A Query submission is sent from the consumer to WSME
and is transient, terminating after initiating the match-
making process and bringing it to its conclusion. The
query contains the following information: (1) MyType - this
speci(cid:12)es the query record-type. (2) YourType - this speci(cid:12)es
the provider’s advertisement record-type that the query is
looking for. (3) Properties - a list of the properties de(cid:12)ned as
MyType. (4) Rules - what the consumer requires from the
provider. The descriptions and demands can be dynamically
created, deleted and modi(cid:12)ed in the form of properties and
rules respectively, using a Data Dictionary tool.

The WSME rules allow both sides to select the other party
they wish to deal with by specifying their eligibility. A
rule is a WSME script that is evaluated at matchmaking
time, resulting in a Boolean value. A rule can refer to the
properties of the two parties whose advertisement and query
are involved in the matchmaking process. Example of a pos-
sible consumer rule is the following: return(my:M axCost (cid:20)
your:cost). A problem arises if a rule refers to a property
that was not supplied. To avoid such a situation, the WSME
Type system de(cid:12)nes the mandatory list of properties that a
submission must provide; the data dictionary contains those
de(cid:12)nitions.

We illustrate the Data Dictionary de(cid:12)nitions used for
composing the Helpline Service discussed in Fig. 8. Each
service instance needs to advertise itself to the WSME
service instance registry using the advertisement de(cid:12)nition.
Each advertisement record contains basic information like
the service name, service type, method name and WSDL
information, along with QoS-speci(cid:12)c metrics like (expected)
response time, throughput and cost of invoking the particu-
lar instance. Each query record speci(cid:12)es the method name
and service type that needs to be bound to an instance along
with additional rules that are speci(cid:12)ed by the developer
supervising the composition process.

5.2 Matchmaking and Instance Selection

We employ a two-step approach where, in the (cid:12)rst step,
we use the WSME Matchmaker to select one or more can-
didate instances that match the requirement speci(cid:12)cations.
Since a speci(cid:12)c service type can be matched with more than
one instance, we next adopt a heuristic-based approach to

Data Dictionary Tool

Service Provider

Service Consumer

Service Name
Service Type
Method Name

Cost
Throughput
Response Time

WebService_URL

WSDL

String
String
String
String

Float
Float
Float

String
String

Service Type
Method Name
Max Cost

Max Response Time
Min Throughput

String
String
Float
Float
Float

Query Rules

Definition of advertisement

submission record type

Definition of query
submission record type

Figure 7: Advertisement and Query Formats for
Helpline Service.

select one among the con(cid:13)icting instances, to complete the
matchmaking process.

The WSME matchmaking process is a two-way or sym-
metric process - it brings together matching advertisements
and queries by applying the rules of each party to the
description of the other, thus allowing both parties to
‘select’ each other. A matching advertisement is called an
o(cid:11)er. If more than one o(cid:11)er is available, they are collected
together. Zero, one or more matching o(cid:11)ers are sent to the
consumer. For further details on the matchmaking process,
the interested reader is referred to [9].

Next, we deal with those service types that have more
than one matching o(cid:11)ers (instances) from WSME. While
there are many ways to perform the instance selection,
we chose to employ a greedy heuristic approach to solve
the problem.
In particular, the Instance Selector (cid:12)nds
instance binding assignments that optimize certain quality
of service metrics. For the current prototype, we focus
on commonly used QoS metrics like cost, response time
and throughput. We assume that values of these metrics
(as advertised in WSME) are statistically guaranteed. If a
service type has multiple matching instances, we choose an
instance based on the optimization criteria speci(cid:12)ed by the
developer supervising the composition process.

5.3 BPEL Generation for Composite Service
Now that each service type in the abstract (cid:13)ow is bound
to an instance, the BPEL generator produces a (concrete)
BPEL work(cid:13)ow that can be deployed onto a runtime
infrastructure, to realize the composite service.

We (cid:12)rst generate the WSDL description for the composite
service. It provides the name and interface of the composite
service and describes the port types for stitching together
the component services. Once the WSDL has been gener-
ated, partner link types are de(cid:12)ned, linking the component
services. The next step is the generation of the BPEL (cid:13)ow.
Components are invoked in the manner described by the
abstract work(cid:13)ow. The composite service accepts inputs
from the user that is fed to the (cid:12)rst component service and
sends an output from the last component service back to
the user. We introduce variables that capture the output
of one service and provide it as input to the next. Speci(cid:12)c

<invoke name= "invoke−GetAgentMobileNumbers"
               partnerLink="link2"
               portType="GetAgentMobileNumbers"
               operation="GetAgentMobileNumbers"
               inputVariable="variable1"
               outputVariable="variable2"  / >

<invoke name= "invoke−LocationTracker"
               partnerLink="link3"
               portType="LocationTracker"
               operation="LocationTracker"
               inputVariable="variable2"
               outputVariable="variable3"  / >

<invoke name= "invoke−DistanceCalculator"

               partnerLink="link4"
               portType="DistanceCalculator"
               operation="DistanceCalculator"
               inputVariable="variable3"
               outputVariable="variable4"  / >

<invoke name= "invoke−OptimalAgentSelector"

               partnerLink="link5"
               portType="OptimalAgentSelector"
               operation="OptimalAgentSelector"
               inputVariable="variable4"
               outputVariable="variable5"  / >

Figure 8: BPEL code for the LAS service.

details for each component service are obtained using the
WSDL description for the corresponding instance, present
in the WSME service instance registry.

Though BPEL and WSDL are XML-based standards, we
do not manipulate XML directly. We use an Eclipse Mod-
eling Framework (EMF) model of BPEL (WSDL) that is
automatically created from a BPEL (WSDL) schema6. The
model provides in-memory representation of constructs and
support for persistence to (cid:12)les (serialization) and loading
from (cid:12)les (de-serialization). BPEL and WSDL manipulation
become signi(cid:12)cantly simpli(cid:12)ed with the corresponding EMF
models.

Note that the BPEL generated might not be readily
deployable on a work(cid:13)ow engine. This is due to the fact that
the code for messaging between component services needs
to handle issues like (input/output) type matching and
transformation, mismatch in invocation protocols that are
used (synchronous vs asynchronous), ordering of parameters
etc. While the BPEL work(cid:13)ow acts as the template for the
composite service,
it needs to be examined and possibly
modi(cid:12)ed by the developer to ensure that the data (cid:13)ow
between component services is handled properly.
In the
current prototype, this is done by allowing the developer to
edit the BPEL work(cid:13)ow before it is actually deployed. We
also make the observation that the handling of some of these
matching problems could be delegated to the matchmaking
engine (WSME), and we plan to investigate this approach
in the future.

Figure 8 illustrates part of the BPEL code generated by
the Physical Composer for the LAS service. It is composed
of the four component services described in Sec. 2. Further,
once physical composition is done, the WSDL description of
this new service is added to the WSME instance registry, and
can be later used in the composition of some other service.

6http://www.eclipse.org/emf

(a)

(b)

Figure 9: (a) Specifying input in the Composition Tool. (b) Logical Plan for Helpline Service.

6. COMPOSING THE HELPLINE SERVICE
We now discuss how our service creation tool can be used
for composing the Helpline service described in Sec. 2. Re-
call that the Helpline service consists of multiple components
services like the LAS service, Message Delivery and Call
Setup services. By way of running example, we showed how
an executable work(cid:13)ow is created for the LAS service using
the tool. The user can add the composite service to the
service registry so that it is available for reuse.

For developing the Helpline service, the user may choose
to use the tool to explore basic services available, build ap-
propriate composite services, and (cid:12)nally build the Helpline
service. Alternatively, the user could ask the tool to build
the Helpline service at the outset using the available services,
and let the tool search through the set of possible plans.
We expect the user to prefer the former approach, when
the scenario is large and the user wants to control the
composition.

We have approximately 100 terms in the ontology and
25 service types. Assume that the previously created
composite LAS service has been added to the registry.
Now the tool
is invoked for the overall Helpline service
with a precondition of ProblemHTMLForm, and the e(cid:11)ect
of ProblemResolutionStatus as shown in Fig. 9(a). The
Logical Composer produces the plan shown in Fig. 9(b).
Note that the LAS service is reused. The plan containing
LAS service is selected over alternative plans without it,
because the plan’s heuristic cost is less7. Finally, the Physi-
cal Composer takes the abstract work(cid:13)ow and generates the
appropriate BPEL (similar to Fig. 9).

7. DISCUSSION AND RELATED WORK

The literature on web service composition is extensive,

7Designing heuristic functions
is
respected is an active area of research in Hierarchical Task
Network planning [8].

so that user

intent

consisting of promising results and many challenges [28,
27]. To put it in perspective of this paper, we organize
this section around design approaches for end to end
composition, logical composition and physical composition.

7.1 End to End Service Composition

In AI planning, the potential advantage of resource
abstraction whereby causal reasoning is decoupled from
resource reasoning is well-established [26]. Our work can be
seen as applying the same idea to web services composition.
Speci(cid:12)cally, we di(cid:11)erentiate web services at the twin levels
of web service types and instances. Our phased approach
is easier for the user to work with and limits the impact of
frequent deployment and runtime changes on the goal-driven
composition.

A planning-based phased approach has been used in
[2] where an end-to-end system is described to construct
work(cid:13)ows for manipulation of scienti(cid:12)c data, which are
executed on Grids. The domain involves composition at
three levels { application domain level where appropriate
applications are (cid:12)rst selected, then an abstract plan is built
with a planner, and (cid:12)nally it is detailed based on grid
execution details. Two main di(cid:11)erences with our work are
that (a) they do not use ontologies while they recognize the
need, and (b) the plan/work(cid:13)ow representation is simpler
during logical composition { sequential, while we can handle
branches as well. As our output is in BPEL which also
has support for loops, exceptions and other behavioral
constructs, the physical stage can be even more expressive.
In [29], executable BPELs are automatically composed
from goal speci(cid:12)cation by casting the planning problem as
a model checking problem on the message speci(cid:12)cation of
partners. The approach is promising but presently restricted
to logical goals and small number of partner services.
In
contrast to our top-down approach, Mandell and McIlraith
[13] extend a BPEL engine to support runtime service
selection using a semantic discovery server.

7.2 Logical Composition

The literature on composing services based on annotations
(semantically organized in ontologies or otherwise) has
taken two paths. One direction is disambiguating similar
annotations using domain meta-data, rules, etc.
The
other direction is on methods to combine services whose
annotations match based on some notion of similarity.

In [20], matching of web services from a directory is
formalized based on various inexactness measures.
In
[12], the authors have identi(cid:12)ed the information that a
Semantic Web Service must expose in order to ful(cid:12)ll the
objective of automated discovery, composition, invocation
and interoperation.

SWORD [21] was one of the initial attempts to use
planning to compose web services.
It does not model
service capabilities in an ontology but uses rule chaining
to composes web services.

Sirin et al.

[24] use contextual

information to (cid:12)nd
matching services at each step of service composition. They
further (cid:12)lter the set of matching services by using ontological
reasoning on the semantic description of the services as well
as by using user input. They attempt to overcome lack
of support for service types in OWL-S by creating a class
hierarchy of Service Pro(cid:12)les. A new sub-class is created for
each value of an IOPE parameter.

There are three problems with their approach. First, a
large set of values for an attribute of a service would result
in generation of that many classes. Second, to represent
a functionality with multiple attributes a huge number of
services, one each for a set of possible values of all attributes,
would have to be represented as derived classes. Third,
new classes need to be added to the ontology every time
a new type of service is introduced. A cleaner approach
that separates representation of the service de(cid:12)nitions from
service instances has already been described in Sec. 4.

Web Services Modeling Ontology8 (WSMO) is a recent
e(cid:11)ort for modeling semantic web services in a markup
language (WSML) and also de(cid:12)ning a web service execution
environment (WSMX) for it. Our logical composition
approach is not speci(cid:12)c to any particular modeling language
and can adapt to newer languages.

7.3 Physical Composition

Several standardization proposals aimed at providing
infrastructure support to Web service composition have re-
cently emerged including SOAP, WSDL, UDDI, and BPEL.
There has also been a lot of interest in the area of dynamic
Web service and QoS-based work(cid:13)ow management. Pre-
vious e(cid:11)orts in this area like eFlow [4] have investigated
dynamic service selection based on user requirements. Zeng
[31] propose that the choice of component services
et al.
in the plan be made at run time for optimality.
Instead
of making local choices at each step of the composition,
the focus is on optimization at a composite level based on
a generic QoS model (based on price, duration, reliability
etc.) and established linear programming techniques. Other
proposals such as METEOR [3] and CrossFlow [10] have
considered QoS models for work(cid:13)ows along four dimensions
namely time, cost, reliabilty and (cid:12)delity. Finally, there has
been a considerable e(cid:11)ort in the Web service community in
identifying the challenges in work(cid:13)ow orchestration between

8http://wsmo.org

component services.
In [14], the authors consider the
problem of service composition as a problem of software
synthesis where algorithms for matching and composition
are based on Structural Synthesis of Programs (SSP) [15].
The SSP language is used as an internal representation
language for automated service composition, while DAML-S
is used as an external language for describing Web service
properties.

8. CONCLUSION

We have described a two-step methodology for end to end
composition of web services by semantically annotating web
service components, as well as a prototype that demon-
strates this methodology in a domain-speci(cid:12)c scenario.
Service developers can maintain a registry of web services
that goes beyond the traditional UDDI by incorporating
semantic descriptions of the components. When a new
service requirement arises, it can be expressed in the context
of a domain ontology. Our service creation environment can
then be used to generate potential work(cid:13)ows for achieving
the desired functionality reusing existing web services. This
automation of the discovery process results in signi(cid:12)cant
reduction in the time-to-market for the new service.

There are two key innovations in our solution. First, we
decouple web service composition into logical and physical
composition stages that address complementary integration
issues. The (cid:12)rst stage focuses on the feasibility of functional
composition while the latter deals with e(cid:14)cient execution
of the resulting composition.
Second, we use scalable
and optimizing techniques in each stage that can adapt to
changes in the service creation environment.

In the future, we plan to integrate the service creation
tool with a larger service development and execution in-
frastructure.
In order to do so, we wish to enable more
interactions with the developer to stitch together message
(cid:13)ows between the component services and, if required, re(cid:12)ne
the abstract/BPEL work(cid:13)ow for the composite service. Fur-
ther, in the current solution, if the service composition fails
for any reason, the composition process simply fails and the
developer has to (cid:12)gure out the reasons for failure. E(cid:11)orts are
ongoing to enable a procedure to classify composition failure
at di(cid:11)erent stages under di(cid:11)erent conditions, and then give
a feedback of possible causes and suggests remedies to
overcome the failure. This would serve as a decision-support
tool that can be used along side a service composition
tool. We also plan to transition to OWL 1.1 (currently
in Beta stage) that provides support for rules. This would
enable us to express richer pre-conditions and e(cid:11)ects while
representing service capabilities. For physical composition,
we will continue investigating di(cid:11)erent instance selection
heuristics for QoS matching, not only at the service instance
level but also at the level of the composite service. Finally,
we want to explore a feedback{based approach where the
service creation tool
interacts with the service execution
infrastructure, to adapt and optimize based on changes in
the execution environment.

9. ACKNOWLEDGMENTS

The authors would like to thank Anupam Mediratta, Sug-
ata Ghosal, Yigal Ho(cid:11)ner, Christian Facciorusso, Richard

Goodwin and Rama Akkiraju for their contributions to the
development of the ideas presented in this paper.

10. REFERENCES
[1] V. Agarwal, N. Karnik, and A. Kumar. An

Information Model for Metering and Accounting. In
Proceedings of the IEEE/IFIP Network Operations
and Management Symposium, April 2004.

[2] J. Blythe et al. The Role of Planning in Grid

Computing. Proc. of Intl Conference on AI Planning
and Scheduling, 2003.

[3] J. Cardoso. Quality of Service and Semantic

Composition of Work(cid:13)ows. PhD thesis, University of
Georgia, 2002.

[4] F. Casati, S. Ilnicki, L. J. Jin, V. Krishnamoorthy,
and M. C. Shan. eFlow: A Platform for Developing
and Managing Composite e-Services. . Technical
Report HPL-2000-36, HP Laboratories, 2000.

[5] G. B. Cha(cid:13)e, S. Chandra, V. Mann, and M. G.

Nanda. Decentralized Orchestration of Composite
Web Services. In Proceedings of the 13th International
World Wide Web Conference, 2004.

[6] M. B. Do and S. Kambhampati. Sapa: A Scalable

Multi-objective Heuristic Metric Temporal Planner.
Journal of AI Research, 20:155{194, 2003.

[7] P. Doshi, R. Goodwin, R. Akkiraju, and S. Roeder.
Parameterized Semantic Matchmaking for Work(cid:13)ow
Composition. Technical Report RC23133. Available at
http://dali.ai.uic.edu/pdoshi/research/RC23133.html,
March 2004.

[8] K. Erol, J. Hendler, and D. S. Nau. HTN planning:

Complexity and expressivity. In Proceedings of the
Twelfth National Conference on Arti(cid:12)cial Intelligence,
Seattle, Washington, USA, 1994.

[9] C. Facciorusso, S. Field, R. Hauser, Y. Ho(cid:11)ner,

R. Humbel, R. Pawlitzek, W. Rjaibi, and C. Siminitz.
A Web Services Matchmaking Engine for Web
Services. In Proceedings of 4th Intl. Conf. on
e-Commerce and Web Technologies, September 2003.

[10] J. Klingemann. Controlled (cid:13)exibility in work(cid:13)ow

management. In Proc. of the 12th International
Conference on Advanced Information Systems
(CAiSE), June 2000.

[11] A. Kumar, B. Srivastava, and S. Mittal. Information
modeling for end to end composition of web services.
In IBM Research Report RI05001. Available from
http://domino.watson.ibm.com/library/CyberDig.nsf/Home.,
2005.

[12] R. Lara, H. Lausen, S. Arroyo, J. de Bruijn, and

D. Fensel. Semantic Web Services: Description
Requirements and Current Technologies. In
International Workshop on Electronic Commerce,
Agents, and Semantic Web Services, September 2003.

[13] D. J. Mandell and S. A. McIlraith. Adapting

BPEL4WS for the Semantic Web: The Bottom-Up
Approach to Web Service Interoperation. In
Proceedings of International Semantic Web
Conference, Oct 2003.

[14] M. Matskin and J. Rao. Value Added Web Services

Composition using Automatic Program Synthesis. In
Proceedings of International Workshop on Web
Services, E-business, and the Semantic Web, 2002.

[15] M. Matskin and E. Tyugu. Strategies of Structural

Synthesis of Programs and its Extensions. Computing
and Informatics, 20:1{25, 2001.

[16] S. McIlraith, T. C. Son, and H. Zeng. Semantic Web
Services. IEEE Intelligent Systems, Special Issue on
the Semantic Web., 16(2):46{53, March/April 2001.
[17] Common Information Model (CIM) Metrics Model,

Version 2.7. Distributed Management Task Force,
http://www.dmtf.org/standards/documents/CIM/
DSP0141.pdf, June 2003.

[18] M. G. Nanda and N. Karnik. Synchronization

Analysis for Decentralizing Composite Web Services.
In Proceedings of the ACM Symposium on Applied
Computing, March 2003.

[19] OWL Services Coalition. OWL-S: Semantic Markup

for Web Services. http://www.daml.org/services/
owl-s/1.0/owl-s.html, Nov. 2003.

[20] M. Paolucci, T. Kawmura, T. Payne, and K. Sycara.
Semantic Matching of Web Services Capabilities. In
First Int. Semantic Web Conf., 2002.

[21] S. Ponnekanti and A. Fox. SWORD: A Developer

Toolkit for Web Service Composition. In Proc. of the
11th International World Wide Web Conference, 2002.

[22] S. Staab et al. Web services: Been there, done that?

IEEE Intelligent Systems, pages 72{85, Jan-Feb 2003.

[23] E. Sirin and B. Parsia. Planning for Semantic Web

Services. In Semantic Web Services Workshop at 3rd
International Semantic Web Conference, 2004.

[24] E. Sirin, B. Parsia, and J. Hendler.

Composition-driven Filtering and Selection of
Semantic Web Services. In AAAI Spring Symposium
on Semantic Web Services, March 2004.

[25] B. Srivastava. A Software Framework for Building

Planners. In Proc. Knowledge Based Computer
Systems (KBCS 2004), 2004.

[26] B. Srivastava, S. Kambhampati, and M. B. Do.

Planning the project management way: E(cid:14)cient
planning by e(cid:11)ective integration of causal and
resource reasoning in RealPlan. Artif. Intell.,
131(1-2):73{134, 2001.

[27] B. Srivastava and J. Koehler. Web Service

Composition - Current Solutions and Open Problems.
ICAPS 2003 Workshop on Planning for Web Services,
2003.

[28] X. Su and J. Rao. A Survey of Automated Web

Service Composition Methods. In Proceedings of First
International Workshop on Semantic Web Services
and Web Process Composition, July 2004.

[29] P. Traverso and M. Pistore. Automated Composition
of Semantic Web Services into Executable Processes.
In 3rd Int. Semantic Web Conf., November 2004.
[30] D. S. Weld. Recent Advances in AI Planning. AI

Magazine, 20(2):93{123, 1999.

[31] L. Zeng, B. Benatallah, M. Dumas, J. Kalagnanam,

and Q. Z. Sheng. Quality Driven Web Services
Composition. In Proceedings of the 12th Intl. World
Wide Web Conf., May 2003.

