Ensuring Required Failure Atomicity of Composite Web

Services

Sami Bhiri
LORIA-INRIA

BP 239, F-54506

France

Olivier Perrin
LORIA-INRIA

BP 239, F-54506

France

Claude Godart

LORIA-INRIA

BP 239, F-54506

France

Vandoeuvre-les-Nancy Cedex,

Vandoeuvre-les-Nancy Cedex,

Vandoeuvre-les-Nancy Cedex,

bhiri@loria.fr

operrin@loria.fr

godart@loria.fr

ABSTRACT
The recent evolution of Internet, driven by the Web services
technology, is extending the role of the Web from a support
of information interaction to a middleware for B2B interac-
tions.

Indeed, the Web services technology allows enterprises to
outsource parts of their business processes using Web ser-
vices. And it also provides the opportunity to dynamically
o(cid:11)er new value-added services through the composition of
pre-existing Web services.

In spite of the growing interest in Web services, current
technologies are found lacking e(cid:14)cient transactional support
for composite Web services (CSs).

In this paper, we propose a transactional approach to en-
sure the failure atomicity, of a CS, required by partners. We
use the Accepted Termination States (ATS) property as a
mean to express the required failure atomicity.

Partners specify their CS, mainly its control (cid:13)ow, and the
required ATS. Then, we use a set of transactional rules to
assist designers to compose a valid CS with regards to the
speci(cid:12)ed ATS.

Categories and Subject Descriptors
H.3.5 [Information Storage and Retrieval]: Online In-
formation Services|Web-based services; H.2.4 [Database
Management]: Systems|Transaction Processing; K.4.4
[Computers and Society]: Electronic Commerce|Dis-
tributed commercial transactions

General Terms
Design, Reliability

Keywords
Reliable Web services compositions, Failure atomicity, Trans-
actional models

1.

INTRODUCTION

Web services are emerging as a promising technology for
automating B2B interactions. Nowadays, enterprises are

Copyright is held by the International World Wide Web Conference Com-
mittee (IW3C2). Distribution of these papers is limited to classroom use,
and personal use by others.
WWW2005, May 10–15, 2005, Chiba, Japan.
ACM 1-59593-046-9/05/0005.

able to outsource their internal business processes as ser-
vices and make them accessible via the Web. Then they
can dynamically combine individual services to provide new
value-added services.

A main problem that remains is how to ensure a correct
composition and a reliable execution of a composite service
(CS) with regards to partners transactional requirements.

Despite growing interest, Web services middleware is still
rather primitive in terms of functionality, far from what cur-
rent EAI middleware can provide for intra-enterprise appli-
cations [2].

The current Web services technologies ensure communi-
cation interoperability which is a part of the problem when
considering the building of reliable Web services composi-
tions [16]. Indeed, unlike activities in traditional work(cid:13)ows,
services are de(cid:12)ned independently of any computing context.
Thereafter, the task of building composite Web services re-
quires mechanisms to deal with the inherent autonomy, and
heterogeneity of Web services.

Although powerful, Advanced Transaction Models (ATMs)
[6] are found lacking functionality and performance when
used for applications that involve dynamic composition of
heterogenous services in a peer-to-peer context.

Their limitations come mainly from their in(cid:13)exibility to
incorporate di(cid:11)erent transactional semantics as well as dif-
ferent interactions patterns into the same structured trans-
action [8].

In this paper, we propose a transactional approach for
reliable Web services compositions by ensuring the failure
atomicity required by the designers.

From a transactional point of view, we consider a CS as
a structured transaction, Web services as sub transactions
and interactions as inter sub transactions dependencies. We
use the Accepted Termination States (ATS) property as a
correctness criteria to relax atomicity.

To the best of our knowledge, de(cid:12)ning a transaction with a
particular set of properties, in particulary ATS, and ensuring
that every execution will preserve these properties remains
a di(cid:14)cult and open problem [18].

The paper is organized as follows. Section 2 introduces
a motivating example and gives the main points which has
driven our approach. In section 3, we explain the notion of
transactional web service and show how we express its trans-
actional properties. Section 4 presents the notion of Trans-
actional Composite (Web) Service (TCS) and explains our
transactional point of view. Section 5 presents the notion

of Accepted Termination States (ATS) as a mean to express
the required failure atomicity. Section 6 illustrates how our
approach proceeds (using a set of transactional rules) to
assist designers to compose valid TCSs.
In section 7, we
discuss some related work. Section 8 concludes our paper.

2. MOTIVATING EXAMPLE AND

METHODOLOGY

Let us (cid:12)rst present a motivating example. We consider
an application dedicated to the online purchase of personal
computer. This application is carried out by a composite
service as illustrated in (cid:12)gure 1. Services involved in this
application are: the Customer Requirements Speci(cid:12)-
cation (CRS) service used to receive the customer order
and to review the customer requirements, the Order Items
(OI) service used to order the computer components if the
online store does not have all of it, the Payment by Credit
Card (PCC) service used to guarantee the payment by
credit card, the Computer Assembly (CA) service used
to ensure the computer assembly once the payment is done
and the required components are available, and the Deliver
Computer (DC) service used to deliver the computer to
the customer (provided either by Fedex (DCF ed) or TNT
(DCT N T )).

Figure 1: A composite service for online computer
purchase.

When a user designs a composite service, he expects the
service execution to be reliable. That means he particularly
pays attention to failure handling. In our example, the de-
signer may want to be sure: that one of the two delivery
services will succeed, that the service CA is sure to com-
plete, and that it is possible for the service OI to undo its
e(cid:11)ects (for instance when the payment fails). These proper-
ties de(cid:12)ne what we call the transactional behavior of the ser-
vice. This behavior is speci(cid:12)ed using a set of transactional
requirements. Since these requirements may vary from one
context to another, the transactional behavior will vary too.
For instance, a designer may accept the failure of the DCF ed
service in a context, while in another one he may not toler-
ate such a failure at such an advanced stage. So the mean
of a reliable execution is tightly related to transactional re-
quirements and it may vary according to designers.

In the same time, in order to ensure a reliable execution,
we have to be sure that a speci(cid:12)ed transactional behavior
is consistent with the set of selected services and the trans-
actional requirements. Back to our example, we can easily
notice that since the OI service is not sure to complete, the
payment service PCC have to be compensatable (and it must
be compensated when the OI service fails).

The following points introduce our approach and its con-

cepts for supporting this kind of scenarios.

scription for a better characterization of their transactional
behavior. This can be done by enhancing WSDL interface
with transactional properties.

Second, we have to model services composition and chore-
ography, in particular mechanisms for failure handling and
recovery.

Third, we have to provide designers with a mean to ex-
press their transactional requirements, in particular their
required failure atomicity level. Finally, we have to sup-
port composite service validation with regards to designers’
requirements.

In the rest of the paper we detail each of these issues
and especially our set of transactional management rules
for composite service validation.

3. TRANSACTIONAL WEB SERVICE

DESCRIPTION

A Web service is a self-contained modular program that
can be discovered and invoked across the Internet. Web
services are typically built with XML, SOAP, WSDL and
UDDI speci(cid:12)cations [4] [17]. A transactional Web service is
a Web service that emphasizes transactional properties for
its characterization and correct usage.

The main transactional properties of a Web service that
we are considering are retriable, compensatable and pivot
[14]. A service s is said to be retriable if it is sure to
complete after several (cid:12)nite activations.
s is said to be
compensatable if it o(cid:11)ers compensation policies to seman-
tically undo its e(cid:11)ects. Then, s is said to be pivot if once
it successfully completes,
its e(cid:11)ects remains for ever and
cannot be semantically undone. Naturally, a service can
combine properties, and the set of all possible combinations
is fr; cp; p; (r; cp); (r; p)g.

In order to model the internal behavior of a service, we
have adopted a states/transitions model. A service has a
minimal set of states (initial, active, aborted, cancelled, failed
and completed ), and it also includes a set of transitions (ac-
tivate(), abort(), cancel(), fail(), and complete()). The (cid:12)gure
2.a shows the internal states/transitions diagram of a pivot
service.

When a service is instantiated, the state of the instance is
initial. Then this instance can be either aborted or activated.
Once it is active, the instance can normally continues its
execution or it can be cancelled during its execution.
In
the (cid:12)rst case, it can achieve its objective and successfully
completes or it can fail.

The requested transactional properties can be expressed
by extending the service states and transitions. For instance,
for a compensatable service, a new state compensated and a
new transition compensate() are introduced (e.g., service in
(cid:12)gure 2.b). Figure 2 illustrates the states/transitions dia-
gram of a retriable service ((cid:12)gure 2.c) and states/transitions
diagrams of services combining di(cid:11)erent transactional prop-
erties ((cid:12)gures 2.d and 2.e).

Within a transactional service, we also distinguish be-

tween external and internal transitions.

External transitions are (cid:12)red by external entities. Typi-
cally they allow a service to interact with the outside and to
specify composite services choreographies (see next section).
The external transitions we are considering are activate(),
abort(), cancel(), and compensate().

First, we believe that we must enhance Web services de-

Internal transitions are (cid:12)red by the service itself (the ser-

Figure 2: Services states/transitions diagrams according to di(cid:11)erent transactional properties.

vice agent). Internal transitions we are considering are com-
plete(), fail(), and retry().

4. COMPOSITION OF TRANSACTIONAL

WEB SERVICES

A composite Web service is a conglomeration of existing
Web services working in tandem to o(cid:11)er a new value-added
service [13].
It coordinates a set of services as a cohesive
unit of work to achieve common goals.

A Transactional Composite (Web) Service (TCS) empha-
sizes transactional properties for composition and synchro-
nization of component Web services. It takes advantage of
services transactional properties to specify mechanisms for
failure handling and recovery.
4.1 Dependencies between services

A TCS de(cid:12)nes services orchestration by specifying depen-
dencies between services. They specify how services are cou-
pled and how the behavior of certain service(s) in(cid:13)uence the
behavior of other service(s).

Definition 4.1

(Dependency from s1 to s2). A

dependency from s1 to s2 exists if a transition of s1 can
(cid:12)re an external transition of s2.

A dependency de(cid:12)nes for each external transition of a
service a precondition to be enforced before this transition
can be (cid:12)red.

In our approach, we consider the following dependencies

between services:

Activation dependency from s1 to s2: There is an
activation dependency from s1 to s2 if the completion of s1
can (cid:12)re the activation of s2.

We can tailor activation dependencies between services by
specifying the activation condition, ActCond(s), of each ser-
vice s. ActCond(s) de(cid:12)nes the precondition to be enforced

before the service s can be activated (only after the comple-
tion of other service(s)). There is an activation dependency
from s1 to s2 if f s1:completed 2 ActCond(s2). Reciprocally
for each service s1 2 ActCond(s2), there is an activation de-
pendency from s1 to s2 according to ActCond(s2).

For example, the composite services de(cid:12)ned in (cid:12)gure 3
de(cid:12)ne an activation dependency from OI and P CC, to CA
such that CA will be activated after the completion of OI
and P CC. That means ActCond(CA) = OI:completed V
P CC:completed.

Alternative dependency from s1 to s2: There is an
alternative dependency from s1 to s2 if the failure of s1 can
(cid:12)re the activation of s2.

We can tailor alternative dependencies between services
by specifying the alternative condition, AltCond(s), of each
service s. AltCond(s) de(cid:12)nes the precondition to be en-
forced before the service s can be activated as an alterna-
tive of other service(s). There is an alternative dependency
from s1 to s2 if f s1:f ailed 2 AltCond(s). Reciprocally
for each service s1 2 AltCond(s2), there is an alternative
dependency from s1 to s2 according to AltCond(s2)

For instance the composite service cs1 in (cid:12)gure 3.b de(cid:12)nes
an alternative dependency from DCF ed to DCT N T such that
DCT N T will be activated when DCF ed fails. That means
AltCond(DCT N T ) = DCF ed:f ailed.

Abortion dependency from s1 to s2: There is an abor-
tion dependency from s1 to s2 if the failure, cancellation or
the abortion of s1 can (cid:12)re the abortion of s2.

We can tailor abortion dependencies between services by
specifying the abortion condition, AbtCond(s), of each ser-
vice s. AbtCond(s) de(cid:12)nes the precondition to be enforced
before the service s can be aborted. There is an abortion
dependency from s1 to s2 if f s1:aborted 2 AbtCond(s2)) W
s1:f ailed 2 AbtCond(s2) W s1:cancelled 2 AbtCond(s2).
Reciprocally for each service s1 2 AbtCond(s2), there is an
abortion dependency from s1 to s2 according to AbtCond(s2).
Compensation dependency from s1 to s2: There is

Figure 3: Two composite services de(cid:12)ned according to the same skeleton.

a compensation dependency from s1 to s2 if the the failure
or the compensation of s1 can (cid:12)re the compensation of s2.
We can tailor compensation dependencies between ser-
vices by specifying the compensation condition, CpsCond(s),
of each service s. CpsCond(s) de(cid:12)nes the precondition to
be enforced before the service s can be compensated. There
is a compensation dependency from s1 to s2 if f s1:f ailed 2
CpsCond(s2) W s1:compensated 2 CpsCond(s2). Recipro-
cally for each service s1 2 CpsCond(S2), there is a compen-
sation dependency from s1 to s2 according to CpsCond(s2).
Composite services in (cid:12)gure 3 de(cid:12)ne a compensation de-
pendency from P CC to OI such that OI will be comp-
ensated when P CC fails. That means CpsCond(OI) =
PCC.failed.

Cancellation dependency from s1 to s2: There is a
cancellation dependency from s1 to s2 if the failure of s1 can
(cid:12)re the cancellation of s2.

We can tailor cancellation dependencies between services
by specifying the cancellation condition, CnlCond(s), of
each service s. CnlCond(s) de(cid:12)nes the precondition to be
enforced before the service s can be cancelled. There is
a cancellation dependency from s1 to s2 if f s1:f ailed 2
CnlCond(s2).

Reciprocally for each service s1 2 CnlCond(s2), there

is
from s1 to s2 according to

a cancellation dependency
CnlCond(s2).

Composite services in (cid:12)gure 3 de(cid:12)ne a cancellation depen-
dency from P CC to OI such that OI will be cancelled when
P CC fails. That means CnlCond(OI) = P CC:f ailed.

For clarity reasons, we do not deal with abortion depen-
dencies. We call transactional dependencies the compensa-
tion, cancellation and alternative dependencies.
4.2 Relations between dependencies

Dependencies speci(cid:12)cation must respect some semantic
restrictions. Indeed, transactional dependencies depend on
activation dependencies according to the following relations:

R1 : An abortion dependency from s1 to s2 can exist only

if there is an activation dependency from s1 to s2.

R2 : A compensation dependency from s1 to s2 can exist
only if there is an activation dependency from s2 to s1,
or s1 and s2 execute in parallel and are synchronized.

R3 : A cancellation dependency from s1 to s2 can exist only
if s1 and s2 execute in parallel and are synchronized.

R4 : An alternative dependency from s1 to s2 can exist only

if s1 and s2 are exclusive.

Section 4.4 shows how these relations de(cid:12)ne potential de-

pendencies induced by given activation dependencies.
4.3 Control and transactional ﬂow of a TCS

Within a transactional composite service, we distinguish
between the TCS control (cid:13)ow and the TCS transactional
(cid:13)ow.

Control (cid:13)ow: The control (cid:13)ow (or skeleton) of a TCS
speci(cid:12)es the partial ordering of component services activa-
tions. Activation dependencies between component services
de(cid:12)ne the corresponding TCS control (cid:13)ow.

We use (work(cid:13)ow-like) patterns to de(cid:12)ne a composite ser-
vice skeleton. As de(cid:12)ned in [7], a pattern \is the abstrac-
tion from a concrete form which keeps recurring in speci(cid:12)c
non arbitrary contexts". A work(cid:13)ow pattern can be seen as
an abstract description of a recurrent class of interactions
based on (primitive) activation dependency. For example,
the AND-join pattern [21] (see (cid:12)gure 3.a) describes an ab-
stract services choreography by specifying services interac-
tions as following: a service is activated after the completion
of several other services.

Example: Figure 3.a illustrates a TCS skeleton de(cid:12)ned
using an AND-split, an AND-join and an XOR-split pat-
terns.

Transactional (cid:13)ow: The transactional (cid:13)ow of a TCS

speci(cid:12)es mechanisms for failures handling and recovery.

Transactional dependencies (like compensation, cancellation
and alternative) de(cid:12)ne the TCS transactional (cid:13)ow.
4.4 Pattern’s potential dependencies

Several TCSs can be de(cid:12)ned based on a skeleton. Each
TCS adopts the activation dependencies de(cid:12)ned by the skele-
ton’s patterns and may extend them by specifying additional
transactional dependencies.

Example: Figure 3 shows two TCSs, cs1 and cs2, de-
(cid:12)ned using the same skeleton. Each of these TCSs adopts
this skeleton ((cid:12)gure 3.a) and re(cid:12)nes it with an additional
transactional (cid:13)ow.

Additional transactional dependencies are a subset of po-
tential transactional dependencies de(cid:12)ned by the skeleton’s
patterns. Indeed, a pattern de(cid:12)nes in addition to the default
activation dependencies, a set of potential transactional de-
pendencies.

A potential dependency is a dependency that is not ini-
tially de(cid:12)ned by the pattern but that can be added by TCSs
using this pattern. Potential dependencies are directly re-
lated to the pattern’s activation dependencies according to
the relations we have introduced in section 4.2.

We have shown above that dependencies between services
can be tailored by specifying preconditions on services’ ex-
ternal transitions. And potential transactional dependencies
are not an exception to this fact. So a TCS skeleton de(cid:12)nes
for each service the potential conditions corresponding to the
potential dependencies. A pattern de(cid:12)nes for each service s
it is connected with:

(cid:15) ptCpsCond(s): its potential compensation condition,

(cid:15) ptAltCond(s): its potential alternative condition,

(cid:15) ptCnlCond(s): its potential cancellation condition.

We can write each of these conditions in exclusive dis-
junctive normal form. For instance, we can write the po-
tential compensation condition of a service s as follows:
ptCpsCond(s) = Li ptCpsCondi(s). Then ptCpsCondi(s)
is one potential compensation condition of s.

Example: The TCS skeleton illustrated in (cid:12)gure 3.a uses
an AND-join pattern to de(cid:12)ne activation dependencies be-
tween services OI, P CC and CA. According to the rela-
tion R2 given in section 4.2, a TCS based on this skele-
ton can eventually speci(cid:12)es the following compensation de-
pendencies:
from
CA to OI and from CA to P CC. Similarly, according
to the relation R3, this pattern de(cid:12)nes the following po-
tential cancellation dependencies:
from OI to P CC, and
from P CC to OI. That means, among other, that ptCp-
sCond(PCC)=OI.failed L CA.failed L CA.compensated
and ptCnlCond(OI)=PCC.failed.

from OI to P CC,

from P CC to OI,

In the same way, according to the relation R4, the XOR-
split pattern connecting CA, DCF ed and DCT N T de(cid:12)nes the
following potential alternative dependencies: from DCT N T
to DCF ed and from DCF ed to DCT N T .

That means that ptAltCond(DCT N T ) =DCF ed:f ailed and

that DCT N T :f ailed = ptAltCond(DCF ed).

Finally, note that both TCSs cs1 and cs2 de(cid:12)ne their
transactional (cid:13)ow as a subset of the potential transactional

(cid:13)ow presented above. Both de(cid:12)ne compensation and can-
cellation dependencies from P CC to OI.
cs1 de(cid:12)nes an
alternative dependency from DCF ed to DCT N T .

5. FAILURE ATOMICITY REQUIREMENTS

OF A TCS

Several executions can be instantiated according to the
same TCS. The state of an instance of a TCS composed of
n services is the tuple (x1, x2, ..., xn), where xi is the state
of service si at a given time. The set of termination states
of a TCS cs, ST S(cs), is the set of all possible termination
states of its instances.

Back to our motivating example limited to the three ser-
vices CRS, OI and P CC, we can have the following set of
termination states: (CRS.completed, OI.completed, PCC.co-
mpleted );
(CRS.completed, OI.failed, PCC.completed );
(CRS.completed, OI.completed, PCC.failed ); (CRS.compen-
sated, OI.failed, PCC.initial ); (CRS.compensated, OI.initial,
PCC.failed ); (CRS.compensated, OI.failed, PCC.failed ).

In order to express the designer’s requirements for failure
atomicity, we use the notion of Accepted Termination States
([18]).
In other word, the concept of ATS represents our
notion of correction.

Definition 5.1

(Accepted Termination States).
An accepted termination state, ats, of a composite service cs
is a state for which designers accept the termination of cs.
We de(cid:12)ne AT S the set of all Accepted Termination States
required by designers.

An execution is correct if f it leads the CS into an ac-
cepted termination state. A CS reaches an ats if (i) it
completes successfully or (ii) it fails and undoes all undesir-
able e(cid:11)ects of partial execution in accordance with designer
failure-atomicity requirements [18].

Back to our example, a designer may choose the following
ATS: ATS(CS)=f(CRS.completed, OI.completed, PCC.co-
mpleted); (CRS.compensated, OI.failed, PCC.failed)g that
means that an execution is correct when all of the services
complete, or when CRS is compensated (given the failure of
OI and P CC). Obviously, we note that a composite service
transactional behavior may vary according to the required
ATS.

6. TRANSACTIONAL RULES

To explain the rules and to illustrate how they are work-
ing, we go back to our motivating example of personal com-
puter online purchase. We suppose in addition that design-
ers specify the AT S illustrated in the (cid:12)gure 5 to express
their required failure atomicity.

Intuitively, the execution of a composite service can gen-
erate various termination states. A composite service is not
valid if it exists some termination states that do not belong
to the ATS speci(cid:12)ed by the designers.

Definition 6.1

(Validity according to an AT S).
A CS cs is said to be valid according to AT S i(cid:11) its set of
termination states is included in AT S, written ST S(cs) (cid:18)
AT S.

Example: The composite service cs1 (illustrated in (cid:12)gure
3.b) is valid because ST S(cs1) 2 AT S. However regard-
ing the composite service cs2 (illustrated in (cid:12)gure 3.c), we

Initial TCS
definition

Designers

Transactional
properties
computing

Computer

Valid TCS
composition

Pick up some

services

Compose them

using pattern

Extend pattern
with additional
dependencies

Specify the
required ATS

ATS = {A.completed,…}

We use(cid:201)

Transactional validity rules

to compute(cid:201)

Transactional properties

to ensure

The appropriate transactional behavior
for valid TCSs

No

Is the initial
TCS valid ?

Yes

Select new services

An engine
dynamically
ensures the
compliance

with the

generated

transactional

properties

Specify new additional

dependencies

Execution engine

Execution of the TCS
with the appropriate
transactional behavior

Figure 4: Objective and overview of our approach.

Figure 5: ATS used in our example of PC online purchase.

note that ST S(cs2) contains the following termination state,
(CRS:completed; OI:f ailed; P CC:completed; CA:aborted;
DCF ed:aborted; DCT N T :aborted), which is not an accepted
termination state. Thereafter cs2 is not valid.
6.1 Objective and overview

As illustrated in (cid:12)gure 4, our approach applies in a top-

down manner.

De(cid:12)nition of an initial TCS: First, designers dynam-
ically choose some available services and combine them to
o(cid:11)er a new value added service. They compose the new
service using a set of interactions patterns (sequence, AND-
split, AND-join,...).

They can augment this skeleton by new dependencies se-
lected from the potential dependencies. Then they express
their required failure atomicity by specifying the required
ATS.

Compute validity transactional properties: We use

a set of rules, independent from skeletons and designers’
ATS, to compute from the TCS skeleton and the required
ATS a set of transactional properties.

These transactional properties tailor the appropriate trans-
actional behavior for valid TCSs. A TCS must satisfy these
transactional properties to be valid.

De(cid:12)nition of a valid TCS: If the initial TCS is not
valid, designers can (i) select new services (with eventu-
ally new transactional properties) and (ii) augment the same
skeleton with new dependencies. During this phase an en-
gine assist designers to compose a valid TCS by respecting
the generated transactional properties.

Once a valid TCS is reached, it can be deployed and exe-

cuted.
6.2 Extracting services conditions

Tailoring the appropriate transactional behavior for valid
composite services is equivalent to identify the appropriate

is the only ats in which OI is cancelled. Furthermore, the
potential cancellation condition of OI, P CC:f ailed is sat-
is(cid:12)ed in ats5. Then we can deduce that atsCnlCond(s) =
P CC:f ailed. Finally, we can deduce in the same way, from
ats6 and ptAltCond(DCT N T ), that atsAltCond(DCT N T ) =
DCF ed:f ailed.

It is important to note that the ATS speci(cid:12)ed by the de-
signers must be consistent with the pattern semantics. An
ATS is consistent if it satis(cid:12)es the following two conditions.
First, each of its ats must be well-formed. An ats 2 AT S
is not well-formed if it exists a service s such that none of
its potential (or activation) conditions (corresponding to its
state in ats) is satis(cid:12)ed (in ats). We can easily modify the
previous algorithm to detect if it exists a not well-formed
ats 2 AT S.

Second, the set of all ats must be consistent. Such incon-
sistency can be detected after the generation of transactional
properties ensuring CSs validity.

For instance given the following termination state (limited
to the three services OI, P CC and CA) ts = (OI.completed,
PCC.compensated, CA.aborted), we note, among other, that
none of the service P CC potential conditions (OI:f ailed,
CA:f ailed and CA:compensated) is satis(cid:12)ed in ts. So we
can deduce that ts is not well-formed.

To illustrate an ATS inconsistency, let us consider the fol-
lowing ATS=fats1 = (OI.completed, PCC.completed, CA.co-
mpleted); ats2 = (OI.completed, PCC.failed, CA.aborted);
ats3 = (OI.compensated, PCC.failed, CA.aborted)g. Note
that ats1 and ats2 are contradictory because the service OI
once it is completed (in ats2) and once it is compensated (in
ats3) for the same condition (P CC:f ailed V CA:aborted).
Thereafter the given ATS is not consistent although each of
its ats is well-formed.
6.3 Transactional validity rules

An AT S also de(cid:12)nes the accepted termination states of
each component service. We denote AT S(s) the set of ac-
cepted termination states of a component service s. Regard-
ing our illustrative example, we can deduce, for instance,
that ATS(PCC) = fcompleted,
failed, compensatedg and
ATS(CA) = fcompleted, abortedg.

We can now introduce validity rules we are using to gener-
ate transactional properties that ensure validity (we suppose
that 3F means that F is eventually true):

8sj s is a component service in TCS

1. s:f ailed =2 AT S(s) =) generate the following trans-

actional property T P r

s : s must be retriable

2. s:compensated =2 AT S(s) =) generate the following
s : there is no need for s to

transactional property T P p
be compensatable

3. 8atsCpsCondi(s) 2 atsCpsCond(s); generate the fol-

lowing transactional property T P cpi
3(atsCpsCondi(s)) =)

s

:

(a) s must be compensatable and

(b) atsCpsCondi(s) 2 CpsCond(s).

4. 8atsCnlCondi(s) 2 atsCnlCond(s); generate the fol-

lowing transactional property T P cli
3(atsCnlCondi(s)) =)
atsCnlCondi(s) 2 CnlCond(s).

s

:

Figure 6: The algorithm for extracting ATS com-
pensation conditions of a service s from the speci(cid:12)ed
ATS and the TCS skeleton.

dependencies between services. We can deduce from the
speci(cid:12)ed AT S and the TCS skeleton the services’ conditions
corresponding to these dependencies.

For each service s we distinguish (i) atsCpsCond(s), the
AT S compensation condition deduced from AT S, (ii) the
AT S cancellation condition, atsCnlCond(s), deduced from
AT S, and (iii) atsAltCond(s), the AT S alternative condi-
tion deduced from AT S. Below, we explain how we can
deduce these conditions.

The algorithm given in (cid:12)gure 6 allows to extract the ATS
compensation condition for a given service s from the com-
posite service skeleton and the required ATS. The principle
is: a potential compensation condition of s becomes an AT S
compensation condition if it is satis(cid:12)ed in an ats 2 AT S
such that the state of s in ats is compensated. We pro-
ceed similarly to deduce AT S alternative and cancellation
conditions of each service.

For instance in our example, the potential compensation
condition of P CC, OI:f ailed, becomes an AT S compen-
sation condition because it is satis(cid:12)ed in ats4 (in which
the state of P CC is compensated). And since ats4 is the
only ats in which P CC is compensated then we can de-
duce that atsCpsCond(P CC) = OI:f ailed. Similarly we
can extract the AT S cancellation condition for OI. ats5

5. 8atsAltCondi(s) 2 atsAltCond(s); generate the fol-

lowing transactional property T P ati
3(atsAltCondi(s)) =) atsAltCondi(s) 2 AltCond(s).

:

s

The (cid:12)rst rule postulates that if the state failed does not
belong to the AT S of s, then it exists a transactional prop-
erty saying that s must be retriable.

The second rule postulates that if the state compensated
does not belong to the AT S of s, then it exists a trans-
actional property saying that there is no need for s to be
compensatable.

The third rule postulates that for each ATS compensa-
it exists a transac-
tion condition of s, atsCpsCondi(s),
tional property saying that:
if this condition is eventually
true then s must be compensatable and atsCpsCond(s) be-
comes a compensation condition of s. That means 8s0 2
atsCpsCondi(s) add a compensation dependency from s0 to
s according to atsCpsCondi(s).

The fourth rule postulates that for each ATS cancella-
tion condition of s, atsCnlCondi(s), it exists a transactional
property saying that: if this condition is eventually true then
atsCnlCond(s) becomes a cancellation condition of s. That
means 8s0 2 atsCnlCondi(s) add a cancellation dependency
from s0 to s according to atsCnlCondi(s).

The (cid:12)fth rule postulates that for each ATS alternative
condition of s, atsAltCondi(s), it exists a transactional prop-
erty saying that:
if this condition is eventually true then
atsAltCond(s) becomes an alternative condition of s. That
means 8s0 2 atsAltCondi(s) add an alternative dependency
from s0 to s according to atsAltCondi(s).

Example Back to our example, we can compute the fol-
lowing transactional properties: T P V (AT S; CSskeleton) =
fTPr
TP p

DCT N T ; TP p
OI ; TP cl1

CA; TP r
P CC ; TP cp1

CA; TP p
OI ; TP at1

CRS; TP p

CRS; TP r

; TP cp1

DCF ed

DCT N T ;

DCT N T g

(cid:15) By applying the (cid:12)rst rule and since the state failed
does not belong to AT S(CRS) we get the transac-
tional property TPr
CRS : CRS must be retriable. Simi-
larly, we can compute the following transactional prop-
erties: TPr
DCT N T :
DCT N T must be retriable.

CA : CA must be retriable and TPr

(cid:15) By applying the second rule and since the state com-
pensated does not belong to AT S(CA) we get the
transactional property TP p
CA : there is no need for CA
to be compensatable. Similarly we can compute the fol-
lowing transactional properties:TP p
DCT N T ,
and TP p
there is no need for CRS, DCT N T ,
DCF ed to be compensatable.

CRS, TP p

DCF ed

:

(cid:15) By applying the third rule and since atsCpsCond(PCC)
P CC :

= OI.failed we get the transactional property TP cp1
3(OI:f ailed) (means that OI is not retriable) =)

(a) P CC must be compensatable and

(b) P CC must be compensated when OI fails.

(cid:15) By applying the third rule and since atsCpsCond(OI)
= PCC.failed we get the transactional property TP cp1
OI :
3(P CC:f ailed) (means that P CC is not retriable)
=)

(a) OI must be compensatable and

(b) OI must be compensated when P CC fails.

(cid:15) By applying the fourth rule and since atsCnlCond(OI)
= PCC.failed we get the transactional property TP cl1
OI :
3(P CC:f ailed) (means that P CC is not retriable)
=) OI must be cancelled when P CC fails.

(cid:15) By applying the (cid:12)fth rule and since DCF ed.failed =
atsAltCond(DCT N T ) we get the transactional prop-
erty TP At1
P CC : 3(DCF ed:f ailed) (means that DCF ed
is not retriable) =) DCT N T must be activated when
DCF ED fails.

The composite service cs1 veri(cid:12)es all the validity rules
and thereafter it is valid. However the composite service
cs2 veri(cid:12)es all the validity rules except the Rcp1
P CC rule. This
rule postulates that if the compensation condition of P CC
(which is the failure of OI) is eventually true (which is the
case in cs2) then P CC must be compensatable and must be
compensated when OI fails (which is not the case in cs2).
The composite service cs1 respects this rule since OI is sure
to complete and thereafter never fails.
6.4 Validity rules proof

We use the following lemma (the proof is not shown due

to lack of space).
Lemma A TCS termination state ts is not an accepted
termination state if f 9 a service s such that

(cid:15) the termination state of s in ts =2 AT S(s) or

(cid:15) none of its ATS potential conditions (corresponding to

its state in ts) is satis(cid:12)ed (in ts).

Proving that: (cs satis(cid:12)es all validity rules () cs is valid)
is equivalent to proof that: (cs is not valid () 9 a rule such
thats cs does not satisfy this rule).
1) =): cs is not valid means that it has a not valid termina-
tion state. That means (using the lemma above) either (a)
it exists a service s which terminates in a not valid state or
(b) it exists a service s which terminates in a valid state but
without satisfying one of its ATS conditions corresponding
to this termination state. (a) means that cs does not verify
the validity rules 1 or 2. (b) means that cs does not verify
one of the validity rules 3, 4 or 5.
2) (=: (a) If cs does not verify one of the validity rules
1 or 2 then it exists a service s which will terminate in a
non valid termination state. (b) if cs does not verify one of
the validity rules 3, 4 or 5 then it exists a service s which
will terminate in a valid state without satisfying none of
its corresponding ATS conditions. (a) and (b) means that
(using the lemma above) cs is not valid.
6.5 Implementation

We are currently developing a prototype that supports

this work. Our prototype is written in Java.

The (cid:12)rst part of the prototype is the transactional engine.
It allows the user to select the services (with transactional
properties), to de(cid:12)ne the TCS skeleton using patterns, and
to specify the required ATS. The engine uses the transac-
tional rules to compute the appropriate transactional prop-
erties for valid TCSs. Then, it assists designers to compose
a valid TCS by respecting these transactional properties.

Window 1 of (cid:12)gure 7 shows how designers can choose ser-
vices from the \Web services" scroll panel. It typically shows
the transactional properties of the chosen service.

Figure 7: A screen shot illustrating the application of our transactional approach.

Window 2 of (cid:12)gure 7 illustrates how designers can specify
the TCS skeleton using patterns from the \operators" panel.
Finally, window 3 of (cid:12)gure 7 illustrates how the transac-
tional engine computes the appropriate transactional prop-
erties from the required ATS.

The second part of the prototype is a work(cid:13)ow engine
that is able to execute the composite service. Our work-
(cid:13)ow engine is Bonita, a work(cid:13)ow engine supported by the
Object Web consortium ([20]). Bonita is a cooperative work-
(cid:13)ow system supporting the speci(cid:12)cation, the execution, the
monitoring, and the coordination of the processes. The main
features of Bonita are: a third-generation work(cid:13)ow engine
that can be parameterized by an activity model, a web
interface to control work(cid:13)ow processes (accessing work(cid:13)ow
methods as J2EE-based web services), an implementation
using J2EE Enterprise Java Beans, the possibility to exe-
cute code in the server side for di(cid:11)erent events (e.g., start
and cancel activities) by means of hooks (hooks can be for
instance Java programs, and may be assigned to process and
node events), and the availability of a graphical user inter-
face to design and control work(cid:13)ow processes, based on Java
JFC/Swing. Of course, for our concern, the most interesting
feature is related to the ability to de(cid:12)ne a speci(cid:12)c model of
services, including transactional states.

7. RELATED WORK

Advanced Transaction Models (ATMs) have been pro-
posed to support new database applications by relaxing trans-
action isolation and atomicity to better match the new re-
quirements. As work(cid:13)ows in the past, services composition
requirements either exceed or signi(cid:12)cantly di(cid:11)er from those
of ATMs [6] in terms of modelling, coordination [22] and
transactional requirements. Their limitations come mainly
from their in(cid:13)exibility to incorporate di(cid:11)erent transactional
semantics as well as di(cid:11)erent behavioral patterns into the
same structured transaction [8]. To overcome these limita-

tions, [18] proposed a transactional Work(cid:13)ows system sup-
porting multitask, multisystem activities where: (a) di(cid:11)er-
ent tasks may have di(cid:11)erent execution behaviors or prop-
erties, (b) application or user de(cid:12)ned coordination of the
di(cid:11)erent tasks, and (c) application or user de(cid:12)ned failure
and execution atomicity are supported.
In this approach,
failure atomicity requirement is de(cid:12)ned by specifying a set
of ATS. Unfortunately, no transaction management support
is provided to ensure this correctness criteria. Accepted ter-
mination states as a mean to relax atomicity has been dis-
cussed in many previous works [1, 5, 18]. In fact, ATS prop-
erty has been always implicitly included in most of transac-
tional models. For example, atomicity property implicitly
de(cid:12)nes ATS for traditional transactions; all (success state)
and nothing (correct failure state). Also, when an advanced
transaction model speci(cid:12)es global transaction structure, sub
transactions properties, inter sub transaction dependencies,
mechanisms of handing-over, success and failure criteria,
and so on, it implicitly de(cid:12)nes its ATS. In the same way,
when [19, 23] de(cid:12)ne rules to form a well de(cid:12)ned (cid:13)exible
transaction, they implicitly de(cid:12)ne the appropriate ATS for
(cid:13)exible transaction model.

Emerging standards such as BTP [15], WS-transaction
(WS-AtomicTransaction and WS-BusinessActivity [11, 12]),
and WS-TXM (Acid, BP, LRA)[3] de(cid:12)ne models to support
a two-phase coordination of web services. These proposals
are based on a set of extended transactional models to spec-
ify coordinations between services. Participants agree to a
speci(cid:12)c model before starting interactions. Then the cor-
responding coordination layer technologies support the ap-
propriate messages exchange according to the chosen trans-
actional model. These propositions inherit the extended
transactional models rigidity. Besides, there is a potentiel
problem of transactional interoperability between services
implemented with di(cid:11)erent approaches. Our approach can
complement these e(cid:11)orts and overcome these two gaps. In-
deed, our approach allows for reliable, more complex, and

more (cid:13)exible compositions. In addition, it can coordinate
services implemented with di(cid:11)erent technologies since we use
only services transactional features (and not interested in
how they are implemented). So, we can use our approach to
specify (cid:13)exible and reliable composite services, while com-
ponent services can be implemented by one of the above
technologies. Once a valid TCS is reached, it can be consid-
ered as a coordination protocol and can be plugged in one
of the existing coordination technology to be executed.

8. CONCLUSION

In this paper, we have proposed a transactional approach
for reliable Web services compositions by ensuring the failure
atomicity required by the designers.

Contrary to ATMs, our approach follows the opposite di-
rection by starting from designers requirements to provide
correctness rules. Like in [9, 18] (for transactions), designers
de(cid:12)ne the global composite service structure, using patterns,
and speci(cid:12)es required ATS as a correctness criteria. Then,
we use a set of transactional rules to assist designers to com-
pose a valid CS with regards to the speci(cid:12)ed ATS.

The main contribution of our approach is that is able to in-
corporate di(cid:11)erent interactions patterns into the same struc-
tured transaction, and besides it can validate CSs according
to designers transactional requirements.

Acknowledgment: We would like to thank Laura Lozano
for her implementation e(cid:11)orts.

9. REFERENCES
[1] M. Ansari, L. Ness, M. Rusinkiewicz, A. Sheth. Using

Flexible Transactions to Support Multi-System
Telecommunication Applications. In Proc. of the 18th
VLDB Conference, 65-76, August 1992.

[2] B. Benatallah, F. Casasti, F. Toumani. Web Service

Conversation Modeling: A Cornerstone for E-Business
Automation. In IEEE Internet Computing, 8(1), 46-54,
January/February 2004.

[9] N. Krishnakumar, A. Sheth. Managing Heterogenous

Multi-system Tasks to Support Enterprise-wide
Operations. Distributed and Parallel Databases, 3(2),
155-186. Kluwer Academic Publishers, 1995.

[10] D. Langworthy et al. Web Services Coordination
(WS-Coordination). BEA, IBM, Microsoft, 2003.

[11] D. Langworthy et al. Web Services Atomic

Transaction (WS-AtomicTransaction). BEA, IBM,
Microsoft, 2003.

[12] D. Langworthy et al. Web Services Business Activity

Framework (WS-BusinessActivity). BEA, IBM,
Microsoft, 2004.

[13] B. Medjahed, B. Benatallah, A. Bouguettaya, A. H.

H. Ngu, A. K. Elmagarmid. Business-to-business
interactions: issues and enabling technologies. VLDB
Journal: The International Journal on Very Large Data
Bases, 12(4), 59-85, April 2003.

[14] S. Mehrotra, R. Rastogi, A. Silberschatz, H. Korth. A

transaction model for multidatabase systems. In
Proceedings of the 12th International Conference on
Distributed Computing Systems (ICDCS92)
(Yokohama, Japan), IEEE Computer Society Press,
56-63, June 1992.

[15] OASIS Committee Speci(cid:12)cation. Business Transaction

Protocol, Version 1.0 (June 2002).

[16] P. F. Pires. WebTransact: A Framework For

Specifying And Coordinating Reliable Web Services
Compositions. Technical report ES-578/02, Coppe
Federal University of Rio De Janeiro, Brazil, April
2002.

[17] P. F. Pires, M. R. Benevides, M. Mattoso. Building

Reliable Web Services Compositions. In Web,
Web-Services, and Database Systems, LNCS 2593,
59-72, Springer, 2003.

[18] M. Rusinkiewicz, A. Sheth. Speci(cid:12)cation and

Execution of Transactional Work(cid:13)ows. In Modern
Database Systems: The Object Model, Interoperability,
and Beyond., W. Kim Ed., ACM Press and
Addison-Wesley, 1995.

[3] D. Bunting et al. Web Services Transaction

[19] H. Schuldt, G. Alonso, C. Beeri, H. J. Schek.

Management (WS-TXM) Version 1.0. Arjuna, Fujitsu,
IONA, Oracle, and Sun, July 28, 2003.

[4] F. Curbera, M. Duftler, R. Khalaf, W. Nagy, N. Mukhi,

S. Weerawarana. Unraveling the Web services web: an
Introduction to SOAP, WSDL, and UDDI. IEEE
Internet Computing, 6(2), 86-93, March/April 2002.

[5] A. Elmagarmid, Y. Leu, W. Litwin, M. Rusinkiewicz. A
multidatabase transaction model for Interbase. In Proc.
of the 16th VLDB Conference, Brisbane, Australia
1990.

[6] A. Elmagarmid, (Ed.). Transaction Models for

Advanced Database Applications. Morgan-Kaufmann,
1992.

[7] E. Gamma, R. Helm, R. Johnson, J. Vlissides. Design

Patterns: Elements of Reusable Object Oriented
Software. Addison-Wesley, Reading, Massachusetts,
1995.

[8] N. Gioldasis, S. Christodoulakis. UTML: Uni(cid:12)ed

Transaction Modeling Language. In Third International
Conference on Web Information Systems Engineering
(WISE’02), 115-126, IEEE Computer Society,
December 2002.

Atomicity and isolation for transactional processes. In
ACM Transactions on Database Systems, 27(1), 63-116,
March 2002.

[20] M. Vald(cid:18)es, F. Charoy. Bonita: Work(cid:13)ow Cooperative

System. ObjectWeb consortium,
http://bonita.objectweb.org/, 2004.

[21] W. M. P. van der Aalst, A. H. M. ter Hofstede, B.

Kiepuszewski, A.P. Barros. Advanced Work(cid:13)ow
Patterns. In the 7th International Conference on
Cooperative Information Systems (CoopIS 2000), LNCS
1901, 18-29. Springer-Verlag, Berlin, 2000.

[22] D. Worah, A. Sheth. Transactions In Transactional

Work(cid:13)ows. In Advanced Transaction Models and
Architectures, S. Jajodia and L. Kerschberg, Eds.,
chapter 1, pages 3-45. Kluwer Academic Publishers,
1997.

[23] A. Zhang, M. Nodine, B. Bhargava, O. Bukhres.

Ensuring Relaxed Atomicity for Flexible Transactions
in Multidatabase Systems. In Proc. ACM SIGMOD
International Conference on Management of Data,
22(3), 67-78, 1994.

