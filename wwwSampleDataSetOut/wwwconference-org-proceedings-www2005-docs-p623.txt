OWL DL vs. OWL Flight: Conceptual Modeling and

Reasoning for the Semantic Web

Jos de Bruijn

Axel Polleres

Digital Enterprise Research Institute (DERI)

Digital Enterprise Research Institute (DERI)

University of Innsbruck, Austria

University of Innsbruck, Austria

jos.debruijn@deri.org

axel.polleres@deri.org

Tecnolog´ıa, Informaci´on y Finanzas

Rub´en Lara

Madrid, Spain
rlara@aﬁ.es

ABSTRACT
The Semantic Web languages RDFS and OWL have been
around for some time now. However, the presence of these
languages has not brought the breakthrough of the Semantic
Web the creators of the languages had hoped for. OWL has
a number of problems in the area of interoperability and us-
ability in the context of many practical application scenarios
which impede the connection to the Software Engineering
and Database communities. In this paper we present OWL
Flight, which is loosely based on OWL, but the semantics
is grounded in Logic Programming rather than Description
Logics, and it borrows the constraint-based modeling style
common in databases. This results in diﬀerent types of mod-
eling primitives and enforces a diﬀerent style of ontology
modeling. We analyze the modeling paradigms of OWL DL
and OWL Flight, as well as reasoning tasks supported by
both languages. We argue that diﬀerent applications on the
Semantic Web require diﬀerent styles of modeling and thus
both types of languages are required for the Semantic Web.

Categories and Subject Descriptors
I.2.4 [Knowledge Representation Formalisms and
Methods]: Representation languages; H.3.4 [World Wide
Web]

General Terms
Languages, Standardization

Keywords
Semantic Web, Ontologies, Description Logics, Logic Pro-
gramming

1.

INTRODUCTION

The vision of the Semantic Web [2] is to enable automatic
interoperation between entities on the Web. Such interoper-
ation can be achieved through annotation of the content on
Copyright is held by the International World Wide Web Conference Com-
mittee (IW3C2). Distribution of these papers is limited to classroom use,
and personal use by others.
WWW 2005, May 10-14, 2005, Chiba, Japan.
ACM 1-59593-046-9/05/0005.

Dieter Fensel

Digital Enterprise Research Institute (DERI)

University of Innsbruck, Austria

National University of Ireland, Galway, Ireland

dieter.fensel@deri.org

the Web with machine-processable data. When such anno-
tations are linked to ontologies, machines can achieve a cer-
tain degree of understanding of the data. Ontologies [11] are
formal and explicit speciﬁcations of certain domains and are
shared between large groups of stakeholders. These proper-
ties make ontologies ideal for machine processing and en-
abling interoperation. In fact, ontologies form the backbone
of the Semantic Web and are the key to enable automated
interoperation and collaboration. An ontology typically con-
sists of a number of classes, a number of relations (some-
times called properties) between these classes, a number of
instances and a number of axioms. These elements are all
expressed using some logical language.

In order to allow sharing and reuse of ontologies on the Se-
mantic Web, a common ontology language is required. The
W3C has developed two ontology languages for use on the
Semantic Web. The ﬁrst is RDFS [3], which was developed
as a lightweight ontology language. The second language
is OWL [7], which is a more expressive ontology language
based on Description Logics [1].

OWL consists of three species, namely OWL Lite, OWL
DL and OWL Full, which are intended to be layered accord-
ing to increasing expressiveness. OWL Lite is a notational
variant of the Description Logic SHIF (D); OWL DL is a
notational variant of the Description logic SHOIN (D) [17].
It turns out that OWL DL adds very little in expressiveness
to OWL Lite [19]. OWL Lite and OWL DL pose several
restrictions on the use of RDF and redeﬁne the semantics
of the RDFS primitives; thus, OWL Lite and OWL DL are
not properly layered on top of RDFS. The most expressive
species of OWL, OWL Full, layers on top of both RDFS and
OWL DL, and because these languages are so diﬀerent, the
semantics of OWL Full are not straightforward and are not
a proper extension of the OWL DL semantics (see also Sec-
tion 4.1). The lack of proper layering between RDFS and the
less expressive species of OWL and the lack of proper lay-
ering between OWL DL and OWL Lite on the one side and
OWL Full on the other, raises doubts about interoperability
between ontologies written in these diﬀerent languages.

For computing professionals from the areas of Software
Engineering and Database Systems, there are some modeling
pitfalls in OWL (see also [5]):

• Behavior of cardinality restrictions (the allowed num-
ber of values for a property): equality between individ-
uals or existence of individuals outside the knowledge
base can be inferred. The cardinality of properties is
not checked, but inferred.

• Behavior of range restrictions: the type of property
values can be inferred. The type of property values is
not checked, but inferred.

Some of these potential pitfalls can be eliminated by intro-
ducing the unique name assumption and asserting complete
knowledge about certain descriptions. The unique name as-
sumption can be introduced in a Description Logic knowl-
edge base by asserting inequality between each distinct pair
of individual names. OWL DL oﬀers the allDiﬀerent oper-
ator for this purpose. For modeling complete knowledge,
the Description Logic community oﬀers the epistemic oper-
ator K [9]. When using the K operator as a preﬁx to a
description, the description represents complete knowledge
about the description, i.e., the knowledge base is assumed
to contain all instances of this description.

In this paper we are not concerned with possible exten-
sions of OWL or with the use of explicit assertions in order
to enforce certain behavior of the modeling primitives. We
are concerned with OWL DL as it is and with the modeling
constructs provided by the language. In order to assert the
unique name assumption in an OWL DL knowledge base,
it is necessary to include all individuals in the knowledge
base in the allDiﬀerent statement. This is not feasible in
practice. Clearly, OWL could be extended with a construct
with the implicit meaning that all individuals are diﬀerent
and OWL could also be extended with a construct which
asserts complete knowledge for a certain description. How-
ever, we examine in this paper the OWL language as it is
and the properties of the OWL modeling constructs as they
are being used today.

In order to investigate these modeling pitfalls of OWL
and the usability of OWL for modeling and reasoning on
the Semantic Web, we describe in this paper OWL Flight
[6], an ontology language based on the Logic Programming
subset of OWL [5] which is inspired by the intersection of
Logic Programming and Description Logic [12] with certain
extensions in the area of datatypes [26], database-style con-
straints and meta-modeling. Our two main motivations for
creating OWL Flight were: (1) eliminate some of the pitfalls
in conceptual modeling with OWL and (2) enable eﬃcient
query answering using common oﬀ-the-shelf reasoning en-
gines which beneﬁt from many years of research on optimiz-
ing query answering for deductive databases (e.g. [28]).

This paper is further structured as follows. We ﬁrst dis-
cuss the formal and conceptual diﬀerences between restric-
tions and constraints in Section 2. Then, we brieﬂy describe
OWL DL and pitfalls in the use of this language for the
Semantic Web in Sections 3 and 4, followed by the intro-
duction of OWL Flight in Section 5. We analyze the con-
ceptual modeling features of OWL DL and OWL Flight in
the light of potential modeling tasks on the Semantic Web
in Section 6. We contrast the reasoning tasks supported by
the languages and the use cases for these reasoning tasks in
Section 7. Finally, we provide some conclusions and mention
future work in Section 8.

2. RESTRICTIONS AND CONSTRAINTS

In order to provide a better understanding of modeling
and reasoning with diﬀerent types of languages, we describe
the diﬀerence between restrictions and constraints. The
terms restriction and constraint both refer to some aspects
of a property, such as the cardinality or the range of the
property. We describe the diﬀerences ﬁrst from a formal
logical point of view and then from a conceptual modeling
point of view.

For the purposes of our formal treatment of restrictions
and constraints, we see an ontology as a logical theory where
class deﬁnitions, property deﬁnitions, etc., are formulae in
the theory. From a logical point of view, a restriction applied
to a class deﬁnition can be seen as a ﬁrst-order formula.
Thus, a restriction restricts the number of models of a logical
theory. Restrictions are thus an integral part of the logical
theory. For an ontology Ω and a restriction r, let M Ω be the
set of models of Ω and M Ω∪r be the set of models of Ω ∪ r,
then M Ω ⊇ M Ω∪r. Let cons(Ω) be the set of consequences
of Ω and cons(Ω ∪ r) be the set of consequences of Ω ∪ r,
then cons(Ω) ⊆ cons(Ω∪r). Thus, restrictions allow to infer
additional information, because they increase the number of
consequences.

Constraints1 specify conditions which may not be violated
by an interpretation of the logical theory. Constraints are
not part of the logical theory and thus they do not increase
the number of consequences of the theory. For ontology Ω
and constraint c, if Ω (cid:54)|= c we say that the constraint is vi-
olated. However, since we don’t see c as part of the theory,
it does not aﬀect the set of consequences. In summary, con-
straints do not allow to infer additional information, instead,
they can be used to check the knowledge base with respect
to certain conditions.

From a modeling point of view, restrictions and constraints
are both used to specify certain aspects of a property, namely
cardinality and range.

The cardinality of a property is the number of values a
particular property may have for a particular individual.
It is possible to specify a minimal bound and a maximal
bound on the cardinality which we will refer to as minimal
and maximal cardinality, respectively. Both minimal and
maximal cardinality can be an arbitrary positive integer.
Say we have a property P and an individual a. In case P
has a minimal cardinality restriction of n, and the number
of values of P for a in the knowledge base is smaller than n,
a number of unknown individuals is inferred to exist outside
of the knowledge base. In case P has a maximal cardinality
restriction of n, and there are more than n values of P for a
in the knowledge base, equality between property values is
inferred in order to make the knowledge ﬁt the restriction.
As for a minimal (or maximal, respectively) cardinality
constraint of n on P , whenever the number of diﬀerent val-
ues of P for a derivable from the knowledge base is smaller
(or greater, respectively) than n, the constraint is violated
and thus the knowledge base is erroneous.

The range of a property is the type a property value may
have. Say we have a property P with a range restriction C
and a tuple (cid:104)a, b(cid:105) ∈ P . In case it is not known that b is of
type C, it is inferred that b is of type C. In contrast, if P
would have a range constraint C, then from the fact that it

1Our notion of constraints is similar to the notion of in-
tegrity constraints in logic programming and databases.

is not known that b is of type C, the constraint is violated
and the knowledge base is inconsistent.

3. OWL DL

In this paper we are mainly concerned with the most well-
known and most investigated species of OWL, namely OWL
DL, which can be seen as an alternate notation for the De-
scription Logic language SHOIN (D) [17].

OWL DL has diﬀerent syntaxes, the most prominent be-
ing the RDF/XML syntax, which is actually used in the lan-
guage reference. However, the normative syntax for OWL
DL is the abstract syntax, described in [27], which we will
use for the examples in the remainder of this paper for rea-
sons of legibility. In the remainder of this section we will
explain OWL DL using Description Logic syntax. See Ta-
bles 1 and 2 for a mapping between the OWL DL abstract
syntax and the syntax of the Description Logic SHOIN (D).

OWL Abstract Syntax

Class axioms

Class(A partial C1 ... Cn)
Class(A complete C1 ... Cn)
EnumeratedClass(A o1 ... on)
SubClassOf(C1 C2)
EquivalentClasses(C1 ... Cn)
DisjointClasses(C1 ... Cn)

Property axioms

DL syntax
A (cid:118) Ci
A ≡ C1(cid:117). . .(cid:117)Cn
A ≡ {o1, . . . on}
C1 (cid:118) C2
C1 ≡ . . . ≡ Cn
Ci (cid:117) Cj (cid:118) ⊥

R (cid:118) Ri
(cid:62) (cid:118) ∀R−.Ci
(cid:62) (cid:118) ∀R.Ci
R ≡ R
−
R ≡ R−
0
(cid:62) (cid:118)(cid:54) 1R
(cid:62) (cid:118)(cid:54) 1R−
Trans(R)

ObjectProperty(R
super(R1)...super(Rn)
domain(C1) ... domain(Cn)
range(C1) ... range(Cn)
[inverseOf(R0)]
[Symmetric]
[Functional]
[InverseFunctional]
[Transitive])
Datatype(T )
DatatypeProperty(U
super(U1)...super(Un)
domain(C1) ... domain(Cn)
range(T1) ... range(Tn)
[Functional])
SubPropertyOf(Q1 Q2)
EquivalentProperties(Q1 ... Qn) Q1 ≡ . . . ≡ Qn

U (cid:118) Ui
(cid:62) (cid:118) ∀U−.Ci
(cid:62) (cid:118) ∀U.Ti
(cid:62) (cid:118)(cid:54) 1U
Q1 (cid:118) Q2

Individual assertions

Individual(o
type(C1) ... type(Cn)
value(R1 o1) ... value(Rm om)
value(U1 t1) ... value(Un tn))
SameIndividual(o1 ... on)
DifferentIndividuals(o1 ... on)

o ∈ Ci
(cid:104)o, oi(cid:105) ∈ Qi
(cid:104)o, ti(cid:105) ∈ Ui
o1 = . . . = on
oi (cid:54)= oj, i (cid:54)= j

Table 1: Axioms in OWL DL and SHOIN (D)

A Description Logic knowledge base consists of two parts,
namely the TBox and the ABox. The TBox consists of a
number of class and property axioms; the ABox consists
of a number of individual assertions (see Table 1). Here,
C refers to a description, T refers to a concrete datatype;
D refers to either a description or a datatype. R refers to
an object property name, U refers to datatype property; Q
refers to an object or datatype property where several ap-
pearances of Qi, Qj in one statement always refer to either
both object or both datatype properties; o and t refer to

object and concrete values, respectively. A class axiom in
the TBox consists of two class descriptions, separated with
the GCI (General Class Inclusion, or subsumption; (cid:118)) sym-
bol or the equivalence symbol (≡), which is equivalent to
GCI in both direction (i.e. (cid:118) and (cid:119)). Similarly, a prop-
erty axiom consists of two property names, separated with
the subsumption ((cid:118)) or the equivalence (≡) symbol. A de-
scription in the TBox is either a named class (A), an enu-
meration ({o1, . . . on}), a property restriction (∃R.D, ∀R.D,
∃R.o, (cid:62) nR, (cid:54) nR, analogously for datatype property re-
strictions), or an intersection (C (cid:117) D), union (C (cid:116) D) or
complement (¬C) of such descriptions (Table 2). Individual
assertions in the ABox are either class membership (o ∈ Ci),
property value ((cid:104)o1, o2(cid:105) ∈ Ri, (cid:104)o1, t1(cid:105) ∈ Ui), or individual
(in)equality (o1 = o2, o1 (cid:54)= o2) assertions (Table 1).

OWL Abstract Syntax
DL syntax
A (URI Reference)
A
(cid:62)
owl:Thing
⊥
owl:Nothing
C1 (cid:117) . . . (cid:117) Cn
intersectionOf(C1 ... Cn)
C1 (cid:116) . . . (cid:116) Cn
unionOf(C1 ... Cn)
¬C
complementOf(C)
{o1, . . . on}
oneOf(o1 ... on)
∃R.D
restriction(R someValuesFrom(C))
∀R.D
restriction(R allValuesFrom(C))
∃R.o
restriction(R value(o))
restriction(R minCardinality(n)) (cid:62) nR
restriction(R maxCardinality(n)) (cid:54) nR
∃U.T
restriction(U someValuesFrom(T ))
∀U.T
restriction(U allValuesFrom(T ))
∃U.t
restriction(U value(t))
restriction(U minCardinality(n)) (cid:62) nU
restriction(U maxCardinality(n)) (cid:54) nU
Table 2: Descriptions in OWL DL and SHOIN

Description Logics have a set-based model-theoretic se-
mantics. In an interpretation I, a description C (Table 2)
is mapped to a subset of the domain ∆I and an individual
o is mapped to an object of ∆I using the mapping func-
tion ·I. Similarly, a datatype T is mapped to a subset of
the concrete domain ∆I
D and a literal is mapped to a value
in ∆I
D. An abstract role R is mapped to a binary relation
over the abstract domain domain: ∆I × ∆I. Similarly, a
concrete role R is mapped to a binary relation between the
abstract and the concrete domain: ∆I × ∆I
D. Equivalence
of descriptions is interpreted as set equivalence (C ≡ D is
interpreted as CI = DI), subsumption is interpreted as set
inclusion (C (cid:118) D is interpreted as CI ⊆ DI), and so on.
We refer the interested reader to [1, Chapter 2] for a more
exhaustive treatment of Description Logic semantics.

There exist several implementations for reasoning with
Description Logics (e.g. FaCT++ [30], RACER [13]) which
implement diﬀerent reasoning tasks in Description Logic lan-
guages. Two important reasoning tasks in Description Log-
ics are subsumption checking and checking class membership
[1]. Subsumption checking amounts to checking whether one
class is a subclass of another concept, i.e., checking whether
one concept is more speciﬁc than another concept. The class
membership inference is used to check whether an individual
is a member of a speciﬁc class.

4. PITFALLS OF OWL

In this section we describe a number of (potential) pitfalls
of OWL with respect to interoperability on the Semantic
Web and scalability of reasoning with the language. Further-
more, we discuss the suitability of its modeling constructs
and modeling style for certain domains and extensibility of
the language in the direction of rules.
4.1 Interoperability

Problems of interoperability might occur between RDFS
and OWL and between the species of OWL because of prob-
lems in the layering of the languages.

The OWL language is layered on top of RDFS. However,
only the most expressive species of OWL, namely OWL Full,
is completely syntactically and semantically layered on top
of RDFS. The less expressive species of OWL, namely OWL
Lite and OWL DL, pose syntactical restrictions on the use
of RDF and redeﬁne the semantics of the RDFS modeling
primitives.

The species of OWL are layered according to increasing
expressiveness, where OWL Lite is the least expressive and
OWL Full the most expressive. On the one hand, OWL
Lite poses many syntactical restrictions on the constructs
which can be used in ontology modeling. On the other hand,
the only feature really added by OWL DL compared with
OWL Lite is the use of nominals (individuals in class de-
scriptions) [19]; all other features of OWL DL can be writ-
ten down using OWL Lite through complicated syntactical
constructions. The third, and most expressive, species of
OWL, namely OWL Full, is unfortunately not properly se-
mantically layered on top of OWL DL; entailment under
OWL DL semantics is not equivalent to entailment under
OWL Full semantics for the same ontology: OWL Full al-
lows additional inferences. This discrepancy is caused by
the incompatibility between the model-theoretic semantics
of OWL DL and the axiomatic semantics of and syntacti-
cal freedom of RDFS. This raises doubts about the level of
interoperability between the diﬀerent species of OWL.

Both the layering of OWL on top of RDFS and the layer-
ing of the OWL species (especially the layering of OWL Full
on top of OWL DL) is, in our opinion, inappropriate. The
two less expressive species of OWL, OWL Lite and OWL
DL, are only layered on top of a restricted subset of RDFS,
whereas the most expressive species of OWL, OWL Full, is
completely syntactically and semantically layering on top of
RDFS, but not on top of OWL Lite and OWL DL. This
improper layering might hamper interoperability between
agents using RDFS or OWL Full on the one side and agents
using OWL Lite or OWL DL on the other.
4.2 Scalability

There are doubts with respect to the scalability of certain
reasoning tasks in OWL, mostly query answering. Descrip-
tion Logic reasoning and optimization has so far mostly fo-
cused on the optimization of the subsumption inference; few
optimizations exist for query answering. Optimizing query
answering for Description Logics is currently still very much
a research issue [12, 22, 14, 16].
The satisﬁability problem in SHOIN , the Description
Logic underlying OWL DL, has NExpTime (non-deterministic
exponential time) worst-case complexity. Most current De-
scription Logic implementations use complex Tableaux sat-
isﬁability checks for query answering [21]. The major prob-

lem with using Tableaux for query answering for knowledge
bases with more than a few individuals is that a Tableaux
check is required for each individual in the knowledge base
to check whether it is in the answer to the query. Although
there exist several optimizations [14, 16], the fundamental
problems are not solved. In our opinion it is a mistake to
require such complex reasoning for even the least expres-
sive of the OWL species, since eﬃcient ABox reasoning will
most likely play a major role on the Semantic Web. There
are currently over four billion web pages indexed by Google,
thus, in order for the Semantic Web to work outside of the
research lab, it must be possible to reason with large collec-
tions of instances.
4.3 Conceptual Modeling

Some of the modeling constructs of OWL DL have a se-
mantics which might seem odd to people not familiar with
Description Logics. These constructs concern the treatment
of abstract vs. concrete values, cardinality restrictions, and
value restrictions. Furthermore, we identify limitations in
the support for datatypes in OWL.

Difference in the treatment of abstract and concrete
values. The interpretation of literals (concrete values) in
OWL is ﬁxed and thus unknown equality between literals
can not be derived. Consequently, cardinality and range re-
strictions exhibit diﬀerent behavior depending on whether
they are concerned with object or datatype properties. Re-
strictions over object properties exhibit the usual behavior
of restriction as we have described in Section 2. Restrictions
over datatype properties, however, exhibit the behavior of
constraints as described in Section 2.
It has been argued
that the diﬀerence in treatment of individuals and literals
makes sense, because the domain of a data type is known.
We argue that from the point of view of the user of the lan-
guage, this conceptual distinction is not intuitive. Whereas
restrictions involving the abstract domain are used to infer
new knowledge, restrictions involving the concrete domain
are used to check whether the knowledge satisﬁes certain
constraints.

Deriving Equality through Cardinality Restrictions. In
OWL, it is possible to specify a maximal cardinality restric-
tion for a property. When there are more instances of this
property with the same domain value than the maximal car-
dinality restriction prescribes, equality between individuals
is inferred. We illustrate this with an example.

Example 1. Assume the following OWL DL knowledge

base:
ObjectProperty(hasPassenger domain(FlightSeat)

range(Passenger))

Class(FlightSeat partial

restriction(hasPassenger maxCardinality(1)))

Individual(seat1 type(FlightSeat)

value(hasPassenger mary)
value(hasPassenger john))

FlightSeat represents the seats in a particular ﬂight. The
property hasPassenger associates a seat in a ﬂight with a
passenger. A seat may only have one passenger, which is
guaranteed by the restriction maxCardinality(1). The indi-
vidual seat1 an instance of FlightSeat; seat1 has two val-
ues for the property hasPassenger, namely mary and john.

From the OWL knowledge base in Example 1 the reasoner
will draw the conclusion that mary and john both refer to the
same passenger. The possibility that there was a mistake in
the system (either at the ontology or at the instance level)
is not taken into account. This could lead to the booking of
several passengers on a single seat, unless the unique name
assumption is enforced.

Deriving Class Membership through Value Restrictions.
In OWL it is possible to restrict the range of a property P
to a class description C either through a range restriction
in the property deﬁnition or through a local universal range
restriction in a class deﬁnition. From this restriction it is
inferred that every value of this property is a member of
class C.

Example 2. We take the OWL knowledge base from Ex-

ample 1 and add the following assertions:

Individual(seat3 type(FlightSeat))
Individual(seat2 type(FlightSeat)
value(hasPassenger seat3))

The above assertions introduce two new instances of the
class FlightSeat by the names of seat2 and seat3 plus
a value for the property hasPassenger at seat3, namely
seat3.

From Example 2 we can infer that seat3 is a Passenger.
Clearly, there is some mistake in the individual assertions,
because a seat cannot occupy another seat; only a passenger
can. However, this mistake is not detected; instead the mod-
eling mistake allows for additional (incorrect) inferences. Al-
though it is possible in OWL DL to express disjointness of
classes, in which case an inconsistency would be derived,
we argue that in many application domains it is natural to
assume disjointness of classes beforehand and only deviate
from this assumption when classes are known not to be dis-
joint.

Limited Support for Datatypes. OWL allows for a lim-
ited treatment of datatypes. Only unary datatypes are sup-
ported by OWL. The three major limitations of datatype
support in OWL are [26]: (1) lack of negated datatypes,
which is required for most Description Logic reasoners, (2)
lack of support for datatype predicates; it is only possible to
refer to a single value in a datatype domain and not, e.g., to
express the greater-than (≥) relation for the xsd:integer
domain, and (3) lack of support for user-deﬁned datatypes.
OWL-E [26] is an extension of OWL with so-called data-
type groups. Datatype groups overcome the aforementioned
limitations of datatype support in OWL and bridge the gap
between datatypes in OWL and concrete domains as they
have been investigated in the Description Logic community
(see e.g. [20]).
4.4 Extensibility

It has been suggested that besides an ontology language,
the Semantic Web needs a rule language. Such a rule lan-
guage would provide additional expressiveness on top of the
ontology language. It was identiﬁed as a requirement that
the rule language is an extension of the ontology language.
There have been several proposals for rule extensions of
Description Logic languages (e.g., CARIN [24] and SWRL
[18]).

SWRL (Semantic Web Rule Language) has been proposed
as a rule language for the Semantic Web, layered on top of
OWL DL. Satisﬁability of an OWL DL knowledge base aug-
mented with SWRL rules is undecidable, as was pointed out
by the authors of the proposal [18]. Straightforward exten-
sion of Description Logics with rules leads to undecidability
[24] and does not allow the use of existing rule systems to
reason with the language. Instead, complex new calculi need
to be developed, or ﬁrst-order theorem proving is required.

5. OWL FLIGHT

As opposed to OWL DL, in this section we will deﬁne a
novel variant of OWL, called OWL Flight, which addresses
some of the above-mentioned problems. On the one hand,
OWL Flight restricts the OWL syntax such that it falls in
the Datalog fragment and thus query answering can be done
using a Logic Programming implementation (cf. [12]). On
the other hand, we take this restricted subset of OWL DL as
a basis which we further extend in order to overcome some
of the limitations of OWL DL. These extensions include in-
tegrity constraints, a more elaborate treatment of datatypes
than OWL based on OWL-E [26], and meta-modeling fea-
tures where we make use of the meta-modeling features of
the Datalog compatible variant of F-Logic [23].
The formalism underlying OWL Flight is DatalogIC,(cid:54)=,not,
which is Datalog extended with integrity constraints, in-
equality and default negation. OWL Flight is an extension
of the so-called DLP fragment of OWL which marks the in-
tersection of Description Logics and Datalog [12, 5]. Com-
pared to DLP, we further add limited support for nominals,
as well as a meta-modeling facility (e.g., treating classes as
instances) and constraints.

Features of OWL DL not included in OWL Flight are:
enumerated classes, individual (in)equality assertions, com-
plements, property restrictions in complete class deﬁnitions.
Furthermore, we restrict the use of property restrictions,
nominals, and union on the left- and right-hand-side of the
GCI.

OWL Flight adds the following distinct features to this re-
stricted subset of OWL DL: We adopt the unique name as-
sumption 2 and adding cardinality constraints, i.e., checking
cardinalities rather than the non-intuitive inference of equal-
ity. Property value constraints eliminate the non-intuitive
inferring of class membership. Constraints adopt the closed
world assumption, allowing to check the data in the knowl-
edge base, i.e. a single ontology (along with imported on-
tologies); as mentioned above, this feature is useful in many
contexts and missing in OWL DL (cf. [15, 9]). Meta-modeling
returns modeling support lost in the transition from RDFS
to OWL DL. More elaborate treatment of datatypes, follow-
ing OWL-E [26], which overcomes the limitations of the
treatment of datatypes in OWL.
5.1 OWL Flight Abstract Syntax and

Mapping to F-Logic

Syntactically, we base OWL Flight on a subset of the
abstract syntax of OWL DL, but add distinct constructs

2Notice that also the prominent Description Logic reasoner
RACER assumes unique names, not implementing equal-
ity reasoning, for eﬃciency reasons. As pointed out above,
we do not necessarily see the lack of equality reasoning as
a drawback but even as an advantage, due to unintuitive
eﬀects it might have with respect to reasoning in OWL DL.

for constraints and eliminate the separation of the vocabu-
lary. Table 3 shows a feature comparison of OWL DL and
OWL Flight based on an extended version of the OWL ab-
stract syntax. The meaning of the letters in the table cor-
responds with the description given in Section 3; further-
more, E stands for a datatype predicate and n stands for
the arity of the datatype predicate. The terms lhs (and rhs,
resp.) in the table express that certain descriptions in OWL
Flight are restricted to be used in the left-hand side (or
right-hand side, resp.). Descriptions allowed on the right-
hand side are allowed in partial class deﬁnitions and in
the second argument of SubClassOf. Descriptions allowed
on the left-hand side are allowed in the ﬁrst argument of
SubClassOf. Descriptions allowed on both sides are also
allowed in complete class deﬁnitions. On the one hand, un-
restricted usage of these features would lead us outside the
expressivity of DatalogIC,(cid:54)=,not. On the other hand, some
of the unintuitive features of OWL DL like inferring equal-
ity originate precisely from this unrestricted usage. In the
lower part of Table 3 we ﬁnd the features newly added in
OWL Flight, which are constraints in partial class deﬁn-
itions and Datatype expressions. As described in Section
2, constraints check all inferred instances of the respective
class on the lhs for the condition on the rhs. Datatype
expressions follow the idea of [26], which allows to deﬁne
n-ary datatype predicates which constrain the values of the
tuples given by datatype properties U1, . . . , Un of an object.
So, with this extension, one can express relations between
datatype properties, for instance that the number of book-
ings for a hotel room has to be smaller than its capacity,
etc.

Note that constraints are only allowed for object proper-
ties, because for datatype properties the restriction key-
word in OWL DL already has a constraining semantics as
discussed in Section 4. For the sake of brevity, we refer to [6]
for a complete description of the abstract syntax of OWL
Flight.

We deﬁne the semantics of OWL Flight through a map-
ping to the Datalog subset of F-Logic [23]. By doing so,
we gain the following beneﬁts: Staying within the Datalog
world, we can directly use implemented engines tailored for
eﬃcient query answering. F-Logic syntax with its origins in
Frame based modeling (as opposed to pure Datalog) directly
allows for meta-modeling features and provides constructs
for class membership, subclassing and attributes in the lan-
guage, rather than relying on predicates to axiomatize the
behavior of these constructs. The complete mapping is de-
ﬁned in [6] and we restrict ourselves to the rough idea in
this paper.

Let x, y, z be variables, : stands for class membership, ::
stands for the subclass relationship and a molecule of the
form A[B→→C] stands for “object A has an attribute B with
value C”. Such molecules can be combined, for instance r1 :
Room[hasBooked→→2], stating that r1 is an instance of the
concept Room, having the value 2 for attribute hasBooked.
Over such molecules we deﬁne clauses of the form

m ← m1, . . . , mn

with the usual meaning from logic programming, where the
body molecules of such rule may be preceded by the nega-
tion as failure symbol not. Furthermore we allow modules of
the form x (cid:54)= y, representing inequality, in the body of such
clauses. Variables in F-Logic might be used for any kind

Abstract Syntax

DL Fl.

Axioms and Individual Assertions

Class(A partial C1 ... Cn)
Class(A complete C1 ... Cn)
EnumeratedClass(A o1 ... on)
SubClassOf(C1 C2)
EquivalentClasses(C1 ... Cn)
DisjointClasses(C1 ... Cn)
ObjectProperty(R ...)
Datatype(T )
DatatypeProperty(U . . . )
SubPropertyOf(Q1 Q2)
EquivalentProperties(Q1 ... Qn)
Individual(o type(C1) ... type(Cn)
value(R1 o1) ... value(Rn on))
SameIndividual(o1 ... on)
DifferentIndividuals(o1 ... on)
Descriptions

A (URI Reference)
owl:Thing
owl:Nothing
intersectionOf(C1 ... Cn)
unionOf(C1 ... Cn)
complementOf(C)
oneOf(o1 ... on)
restriction(Q someValuesFrom(D) )
restriction(Q allValuesFrom(D))
restriction(Q value(o)
restriction(Q minCardinality(n))
restriction(Q maxCardinality(n))
constraint(R someValuesFrom(C))
constraint(R allValuesFrom(C))
constraint(R value(o))
constraint(R minCardinality(n))
constraint(R maxCardinality(n))

+
+
+
+
+
+
+
+
+
+
+
+
+
+
+

+
+
+
+
+
+
+
+
+
+
+
+
–
–
–
–
–

+
+
–
+
+
+
+
+
+
+
+
+
+
–
–∗

+
+
+
+
lhs
–
lhs
lhs
rhs
+
–
rhs
rhs
rhs
rhs
rhs
rhs

Datatype Expressions and n-ary Datatype constraints

DatatypeExpression (E/n
–
and/or/domain( E1/n ...Em/n) )
–
restriction(U1...Un someValuesFrom(E/n))
restriction(U1...Un allValuesFrom(E/n))
–
∗ would be superﬂuous because OWL Flight adopts UNA

+
lhs
rhs

Table 3: Features of OWL DL vs. OWL Flight

of objects, individuals, concepts or even attributes, allowing
meta-modeling with sets of such clauses (i.e., F-Logic Pro-
grams). There exist eﬃcient engines, such as Ontobroker [8]
and FLORA-2 [32], for evaluating these kinds of programs.
Both implementations use a translation to plain Datalog in
order to evaluate the program using a plain Datalog engine.
We will illustrate the mapping from OWL Flight to F-
Logic with some small examples. Simple subclass axioms or
partial class deﬁnitions for named classes, i.e., statements of
the form Class(A partial C1 ... Cn) are translated to

sets of statements of the form:(cid:94)

A :: Ci

Nested property restrictions in Ci can be handled by chain-
ing variables, e.g.
Class(A partial restriction(R allvaluesFrom

(restriction S allValuesFrom B)))

is translated to:

z : B ← x : A, x[R→→y], y[S→→z]

We translate constraints to integrity constraints, i.e., clauses
with an empty head, and involve negation as failure for
checking integrity on the knowledge base. So, e.g.

Class(A partial constraint(R allValuesFrom(C)))
will result in

← x : A[R→→y], not y : C

The complete translation [6] involves some particularities,
but it allows us to translate all of OWL Flight to function-
free F-Logic programs with integrity constraints and default
negation, i.e. the DatalogIC,(cid:54)=,not fragment of F-Logic. The
Datatype-Expression facilities of OWL-E ﬁt nicely in this
translation.

Summarizing, OWL Flight on the one hand uses a maxi-
mal subset of OWL DL which is compatible with the logic
programming world and on the other hand deﬁnes slight
extensions addressing some of the limitations identiﬁed in
Section 4. Although this new OWL “dialect” can not to be
viewed as a fully-ﬂedged ontology language to solve all the
above-mentioned problems, we conceive it as a solid starting
point for a uniﬁed framework of OWL based ontology lan-
guages combining the beneﬁts of the Description Logics and
Logic Programming paradigms. Furthermore, it serves as a
good starting point to investigate the limitations of OWL
and ways to overcome its limitations.

6. CONCEPTUAL MODELING ON THE

SEMANTIC WEB

In this section we compare the modeling constructs of
OWL Flight and OWL DL in the context of modeling tasks
on the Semantic Web.
6.1 Cardinality Restrictions and Constraints
OWL DL has the notion of cardinality restrictions, which
can be used in class deﬁnitions. Cardinality restrictions al-
low for inferring equality and/or the existence of individuals
not in the knowledge (see also Section 2). OWL Flight has
an explicit notion of cardinality constraints, which are used
to check the number of values for a certain property, rather
than to derive equality or assume existence of individuals
beyond the knowledge base.

Besides the possible non-intuitiveness of deriving equal-
ity (see also Section 4.3), we see the following pitfall for a
language which allows to infer equality: The possibility to
derive equality might be misleading, because not all equality
on the Semantic Web can be resolved in the logical language.
Equality reasoning in OWL DL is not powerful enough
to resolve all equalities between identiﬁers on the Semantic
Web. Only if the world would be perfectly and completely
modeled in an ontology and only if all individuals on the Se-
mantic Web are related to this ontology could all equalities
on the Semantic Web be resolved. We argue that very few
equalities can actually be resolved with reasoning and that
many derived equalities are actually faulty. Thus, it makes
more sense in our opinion to either resolve equalities beyond
the logical language or to make strong assumptions on the
available knowledge, i.e., assume that each identiﬁer in the
knowledge base uniquely identiﬁes an individual (the unique
name assumption).

6.2 Value Restrictions vs. Constraints

OWL allows for two kinds of value restrictions, namely,
existential and universal. However, an existential value re-
striction merely corresponds to a qualiﬁed minimal cardinal-
ity of 1. Therefore, and because we have already discussed
cardinality restrictions in the previous section, we only treat
universal value restrictions here.

When used in a class deﬁnitions, a value restriction over
an object property can be used to derive additional infor-
mation about property values with members of this class as
its domain (see also Section 4.3).

OWL Flight allows for the speciﬁcation of value constraints.
A constraint is used to check whether the knowledge in the
knowledge base conforms to the constraint. Take for exam-
ple the following deﬁnition:

Class(Parent partial

constraint(hasChild allValuesFrom Person)

This constraint does not allow any child which is not

known to be a person.

We argue that the constraining approach is more intu-
itive to many computing professionals with Software Engi-
neering and Database Systems backgrounds [5]. However,
constraints do not allow additional inferences. Therefore,
there is a tradeoﬀ between the ability to detect modeling
mistakes and the inferencing power of the language. OWL
DL focuses more on the inferencing power of the language,
whereas OWL Flight focuses more on catching modeling
mistakes.

We have pointed out in Section 4.3 that in OWL DL there
is an asymmetry between the treatment of datatype and
abstract individuals. From a modeling point of view, this
asymmetry is most apparent in the way property restrictions
and range restrictions of datatype properties are handled, as
we have argued in Section 4.3. Consider the following OWL
DL knowledge base:

Class(A partial restriction(Q allValuesFrom D))
Individual(a value(Q b))

Say, Q is an object property and D is an abstract class
description. By the universal value restriction, we can infer
that b is an instance of D.

Now suppose Q is a datatype property and D is a datatype.
From this knowledge base, we cannot conclude that b is a
data value of type D, and thus the knowledge base is incon-
sistent.

This asymmetry between the treatment of object and data-
type properties does not occur in OWL Flight, because it
allows to model constraints for object properties which are
treated in the same way as constraints for datatype proper-
ties.
6.3 Meta-modeling

Meta-modeling is based on the principle that the same
object can be seen as a class, an individual or a property,
depending on the point of view. An example taken from
[29] is the object ‘Boeing747’ which is an instance of the
class ‘AircraftType’ but is itself also a class whose instances
are the individual aircraft. Another example [25] is the de-
scription of the topics of individual books. Each topic is a
class and each book is an individual. This obviates the need
to use classes as property values. Because of the hetero-
geneity to be expected on the Semantic Web, a conceptual

modeling language for the Semantic Web should support
meta-modeling.

RDFS and OWL Full allow full meta-modeling. Each
identiﬁer can denote a class, instance and/or property. Un-
fortunately, RDFS is not expressive enough for many appli-
cations and OWL Full is undecidable in general. The de-
cidable species of OWL, namely OWL Lite and OWL DL,
unfortunately do not allow meta-modeling.
Instead, they
require a strict separation between identiﬁers of classes, in-
dividuals and properties.

In the case of a strict separation between classes and in-
stances, it is sometimes hard to ﬁnd an agreement as to
whether to model an object as a class or an instance. Since
an ontology is shared by its very nature, it is important
to ﬁnd this agreement. In case inter-operation is required
between diﬀerent ontologies, this requirement becomes even
more apparent, because the modelers of the diﬀerent ontolo-
gies might have diﬀerent notions of what is an instance and
what is a class.

OWL Flight allows meta-modeling while retaining decid-
ability, following the meta-modeling support of F-Logic [23],
which allows a limited form of meta-modeling by interpret-
ing an identiﬁer diﬀerently depending on the context in
which it occurs.
In this way, F-Logic stays inside the ex-
pressiveness of ﬁrst-order logic. OWL Flight allows meta-
modeling in the same way as F-Logic and by doing this, it
stays inside the (decidable) Datalog fragment.

6.4 Complete Class Deﬁnitions

OWL allows two types of class deﬁnitions: partial class
deﬁnitions and complete class deﬁnitions. A partial class
deﬁnition corresponds with a necessary deﬁnition, thus, it
speciﬁes all conditions (such as superclasses and property re-
strictions) which are necessarily fulﬁlled (and thus inferred )
for all members of the class. A complete class deﬁnition
speciﬁes necessary and suﬃcient conditions, which means
that not only are these conditions inferred from class mem-
bership, but class membership is also inferred if all condi-
tions are fulﬁlled, i.e., if an individual is a member of all
superclasses and all property restrictions are fulﬁlled.

Complete class deﬁnitions are allowed only to a limited
extent in OWL Flight: only named classes and individual
value restrictions are allowed in the deﬁnition (see also Table
3).
In contrast, OWL DL allows all descriptions in both
partial and complete class deﬁnitions.

To harvest the full power of Description Logic reasoning,
complete class deﬁnitions should be used, because they allow
for more powerful inference than partial deﬁnitions. How-
ever, it is hard to model complete deﬁnitions correctly, es-
pecially because it is easy to miss certain aspects of a class
when creating the deﬁnition, in which case the deﬁnition
is incorrectly labeled as ‘complete’. Thus, there is again a
tradeoﬀ between the ability to detect modeling mistakes and
the inferencing power of the language.

Correct and complete modeling cannot be guaranteed in
general in such an open and distributed environment as the
Web. However, in closed and controlled sections of the Se-
mantic Web where it is possible to guarantee a certain de-
gree of correctness of modeling, complete class deﬁnitions
can be very useful. Complete class deﬁnitions are related to
subsumption reasoning, to be discussed in Section 7.1.

7. REASONING TASKS ON THE

SEMANTIC WEB

In this section we describe the primary reasoning tasks on
the Semantic Web and how there are supported by OWL DL
and OWL Flight. The primary reasoning tasks we consider
are subsumption and query answering.
7.1 Subsumption

Subsumption corresponds with checking whether a class
description subsumes (is more general than) another class
description. By doing this for all classes in the knowledge
base, one can compute the subsumption hierarchy. By check-
ing the place in the subsumption hierarchy of a given class
description, this class description is classiﬁed with respect
to the knowledge base and hidden relationships with other
classes in the knowledge base become visible.

Subsumption can be reduced to checking (un)satisﬁability
and thus, for OWL DL, an eﬃcient Description Logic algo-
rithm [21] can be used to compute the subsumption for any
two OWL DL descriptions. There exist several implemen-
tations for the subset of OWL DL which excludes nominals,
such as RACER [13] and FaCT++ [30].

For OWL Flight, subsumption reasoning can be performed
using a Description Logic reasoner for that subset of OWL
Flight which falls inside OWL DL. There are also techniques
for subsumption reasoning using Logic Programming en-
gines, again using the same fragment of OWL Flight. These
techniques [12, 31] eﬀectively reduce subsumption reasoning
to query answering in a deductive database. However, De-
scription Logic reasoners are in general more eﬃcient for
subsumption reasoning (cf. [31]).

It is not entirely clear how constraints in OWL Flight in-
teract with subsumption reasoning. Presumably, they should
not be taken into account when doing subsumption reason-
ing, because constraints are not part of the logical theory
(see also Section 2). This is a matter which requires further
investigation.

Subsumption reasoning allows inferring relationships be-
tween terms which have not been explicitly stated. On the
one hand, this kind of reasoning might not be easily accepted
in some areas. We believe that businesses will want control
over their business vocabularies and do not want (possibly
incorrect) inferred relationships between terms.

On the other hand, some areas may greatly beneﬁt from
the additional knowledge derived in subsumption reasoning.
For example, search results in Knowledge Management ap-
plications might be improved because more relevant terms
are taken into account and also other applications where
100% precision is not required or where complete and correct
modeling can be assumed and where mistakes introduced
through inferences can be tolerated can beneﬁt greatly from
classiﬁcation reasoning.

There is a tradeoﬀ between the possibilities for automa-
tion on the one hand and the requirements on the complete-
ness and correctness of the modeling on the other hand. If
one wants to automate certain tasks on the Semantic Web,
such as Web Service execution, then correct and complete
modeling of goals and web services is required. If one cannot
assume correct and complete modeling of the functionality
of a web service, then it is impossible to automate execution.

Figure 1: OWL DL and OWL Flight: conceptual modeling and reasoning

7.2 Query Answering

There exist two diﬀerent types of queries, namely, ground
queries and open queries. A ground query consists of a
knowledge base and a ground fact. The inference task is
to check whether the ground fact is entailed by the knowl-
edge base. An open query is a formula with free variables.
The query answer consists of a number of substitutions for
the variables with values from the knowledge base. An open
query can be reduced to a number of ground queries, namely,
a ground query for each of the facts in the knowledge base.
This is clearly not eﬃcient and thus optimizations have been
(and are being) developed for answering such open queries.
As we can see from Section 7.1, the main power of Descrip-
tion Logics lies in subsumption reasoning. Query answering
reasoning is also possible, but is in general less investigated
and very few optimizations exist to do query answering eﬃ-
ciently in Description Logics, as we have argued in Section
4.2.

OWL Flight was developed with eﬃcient query answer-
ing using deductive databases in mind. Thus, common oﬀ-
the-shelf deductive database engines (e.g. OntoBroker [8],
FLORA-2 [32]) can be used for reasoning with OWL Flight.
These deductive databases incorporate optimizations which
have been developed in the database research area.

Summarizing, we can say that the expressive power, the
modeling constructs and the current state-of-the-art reason-
ers for Description Logics (and thus OWL DL) are tuned to
powerful subsumption reasoning. The expressive power of
OWL Flight takes into account current state-of-the-art de-
ductive databases and thus allows to take advantage of eﬃ-
cient query answering. OWL DL has signiﬁcantly more ex-
pressive power than OWL Flight, because of disjunction and
existential quantiﬁcation allowed in the language. There-
fore, even if optimizations for query answering with Descrip-
tion Logics are developed, these implementations cannot get
around the theoretical complexity of the reasoning task.

8. CONCLUSIONS

In this paper we have introduced OWL Flight, a variant of
OWL which is based on Logic Programming rather than De-
scription Logics. We took Description Logic Programs [12]
(the intersection of Description Logics and Logic Program-
ming) as a basis and extended it with cardinality and value
constraints, meta-modeling and powerful datatype support
(based on OWL-E [26]).

We have compared the modeling styles for OWL DL and
OWL Flight, as well as the reasoning tasks supported by
both languages. We summarize the modeling styles and rea-
soning tasks for both languages in Figure 1.

With respect to the modeling styles we can conclude that

OWL DL has an inferring modeling style. Restrictions on
property values and cardinalities are used by the reasoner to
infer new knowledge from the existing knowledge, such as
equality of individuals and class membership. OWL Flight
has a constraining modeling style; it allows expressing cardi-
nality and values constraints on properties. Such constraints
are used by the reasoner to check whether the knowledge
in the knowledge base corresponds with the conditions ex-
pressed in the constraints.

With respect to the supported reasoning tasks, we can
conclude that OWL DL is most suited for the subsumption
task and OWL Flight is most suited for the query answer-
ing task, because of the modeling styles of the languages
and because of the optimized algorithms and implementa-
tions which have been developed for the respective modeling
tasks. There exists a tradeoﬀ between the inferencing power
of a language and the ability to detect modeling mistakes.

We can conclude that diﬀerent tasks on the Semantic Web
need diﬀerent styles of modeling and diﬀerent types of rea-
soning. Therefore, we argue that it is not suﬃcient to re-
strict the Semantic Web to only one style of modeling for
ontologies, which is currently done by OWL, in the form
of Description Logics. Many applications on the Semantic
Web would beneﬁt from an ontology language which favors
a constraining modeling style, such as OWL Flight. Fur-
thermore, such a language might appeal more to software
engineers and database designers, so that they more easily
adopt the Semantic Web.

Interoperation between Description Logic-based and Logic

Programming-based languages can be achieved either through
their common subset [12], through an interface between the
languages [10] or through a common superset. Such a com-
mon superset is not easy to deﬁne, because the default nega-
tion common in logic programming does not ﬁt nicely in a
ﬁrst-order framework. Nonmonotonic extensions such as the
K operator [9] could help bridge the gap.

We argue that the Semantic Web requires a unifying frame-
work for the Logic Programming and the Description Logic
paradigm. Such a unifying framework would consist of a
core language, based on [12], which is the common subset of
both paradigm. The framework should have extensions in
both the Logic Programming and the Description Logic di-
rections to allow applications on the Semantic Web to take
advantage of existing algorithms and implementations. The
languages would then be uniﬁed in a language which cap-
tures both paradigms. This unifying language could be a
ﬁrst-order language with nonmonotonic extensions in order
to capture the nonmonotonicity of negation in Logic Pro-
gramming. We are currently in the process of developing
such a framework in the context of the WSML Working
Group [4].

Conceptual ModelingReasoning tasksOWL DLOWL FlightQuery Answering under-developedEfficient subsumption for a significant part (SHIQ)Query Answering well-developed; many well-knownoptimization techniques and implementationsLimited expressiveness for classification; not optimizedConstraints check existing knowledgeRestrictions allow inferring new knowledgeComplete class descriptionsLimited complete class descriptionsModeling style of Knowledge RepresentationModeling style of Databases andSoftware EngineeringAcknowledgement
This work has been supported by the European Commission
under the projects DIP, Knowledge Web, InfraWebs, SEKT,
SWWS, ASG and Esperonto; by the Science Foundation
Ireland under the DERI-Lion project.

9. REFERENCES
[1] F. Baader, D. Calvanese, D. L. McGuinness, D. Nardi,
and P. F. Patel-Schneider, eds. The Description Logic
Handbook. Cambridge University Press, 2003.

[2] T. Berners-Lee, J. Hendler, and O. Lassila. The

semantic web. Scientiﬁc American, 284(5):34–43, May
2001.

[3] D. Brickley and R. V. Guha. RDF vocabulary

description language 1.0: RDF schema.
Recommendation 10 February 2004, W3C, 2004.

[4] J. de Bruijn, H. Lausen, and D. Fensel. The WSML

Family of Representation Languages. Deliverable
D16.1v0.2, WSML, 2004.
http://www.wsmo.org/TR/d16/d16.1/v0.2/.
OWL−. Deliverable D20.1v0.2, WSML, 2004.
http://www.wsmo.org/TR/d20/d20.1/v0.2/.

[5] J. de Bruijn, A. Polleres, R. Lara, and D. Fensel.

[6] J. de Bruijn, A. Polleres, R. Lara, and D. Fensel.
OWL ﬂight. Deliverable D20.3v0.1, WSML, 2004.
http://www.wsmo.org/TR/d20/d20.3/v0.1/.

[7] M. Dean and G. Schreiber, eds. OWL Web Ontology
Language Reference. 2004. W3C Recommendation 10
February 2004.

[8] S. Decker, M. Erdmann, D. Fensel, and R. Studer.

Ontobroker: Ontology based Access to Distributed and
Semi-Structured Information. Kluwer Academic, 1999.
[9] F. M. Donini, M. Lenzerini, D. Nardi, W. Nutt, and A.

Schaerf. An epistemic operator for description logics.
Artiﬁcial Intelligence, 100(1–2):225–274, April 1998.

[10] T. Eiter, T. Lukasiewicz, R. Schindlauer, and H.

Tompits. Combining answer set programming with
description logics for the semantic web. In Proc. of the
Int. Conf. of Knowledge Representation and
Reasoning (KR2004), 2004.

[11] D. Fensel. Ontologies: Silver Bullet for Knowledge

Management and Electronic Commerce, 2nd edition.
Springer-Verlag, Berlin, 2003.

[12] B. N. Grosof, I. Horrocks, R. Volz, and S. Decker.

Description logic programs: Combining logic programs
with description logic. In Proc. Intl. Conf. on the
World Wide Web (WWW2003), Budapest, Hungary,
2003.

[13] V. Haarslev and R. M¨oller. Racer system description.

In Proc. of the 12th Int. World Wide Web Conf.
(WWW2003), pages 48–57. ACM, 2003.

[14] V. Haarslev and R. M¨oller. Optimization techniques

for retrieving resources described in OWL/RDF
documents: First results. In Proc. of the Int. Conf. of
Knowledge Representation and Reasoning (KR2004),
pages 163–173, 2004.

[15] J. Heﬂin and H. Mu˜noz-Avila. LCW-based agent

planning for the semantic web. In Ontologies and the
Semantic Web. Papers from the 2002 AAAI Workshop
WS-02-11, pages 63–70, 2002. AAAI Press.

[16] I. Horrocks, L. Li, D. Turi, and S. Bechhofer. The

instance store: DL reasoning with large numbers of
individuals. In Proc. of the 2004 Description Logic
Workshop (DL 2004), pages 31–40, 2004.

[17] I. Horrocks and P. F. Patel-Schneider. Reducing OWL

entailment to description logic satisﬁability. In Proc.
of the 2003 Int. Semantic Web Conf. (ISWC 2003),
2003.

[18] I. Horrocks, P. F. Patel-Schneider, H. Boley, S. Tabet,
B. Grosof, and M. Dean. SWRL: A semantic web rule
language combining OWL and RuleML. Member
submission 21 may 2004, W3C, 2004.

[19] I. Horrocks, P. F. Patel-Schneider, and F. van

Harmelen. From SHIQ and RDF to OWL: The
making of a web ontology language. Journal of Web
Semantics, 1(1):7–26, 2003.

[20] I. Horrocks and U. Sattler. Ontology reasoning in the

SHOQ(D) description logic. In Proc. of the
Seventeenth Int. Joint Conf. on Artiﬁcial Intelligence
(IJCAI2001), 2001.

[21] I. Horrocks, U. Sattler, and S. Tobies. Practical

[22] U. Hustadt, B. Motik, and U. Sattler. Reducing

reasoning for very expressive description logics. Logic
Journal of the IGPL, 8(3):239–264, May 2000.
SHIQ− description logic to disjunctive logic programs.
In Proc. of the 9th Int. Conf. on Knowledge
Representation and Reasoning KR2004.

[23] M. Kifer, G. Lausen, and J. Wu. Logical foundations
of object-oriented and frame-based languages. JACM,
42(4):741–843, 1995.

[24] A. Y. Levy and M.-C. Rousset. Combining horn rules

and description logics in CARIN. Artiﬁcial
Intelligence, 104:165 – 209, 1998.

[25] N. Noy, P. Hayes, B. McBride, A. Rector, and B.

Vatant. Representing classes as property values on the
semantic web. Working draft, W3C, 2004.
http://www.w3.org/TR/swbp-classes-as-values.

[26] J. Z. Pan and I. Horrocks. OWL-E: Extending OWL
with expressive datatype expressions. IMG Technical
Report, Victoria University of Manchester, 2004.
http://dl-web.man.ac.uk/Doc/IMGTR-OWL-E.pdf.

[27] P. F. Patel-Schneider, P. Hayes, and I. Horrocks. OWL
web ontology language semantics and abstract syntax.
Recommendation 10 February 2004, W3C, 2004.

[28] R. Ramakrishnan. Magic templates: A spellbinding

approach to logic programs. Journal of Logic
Programming, 11(3-4):189–216, 1991.

[29] G. Schreiber. The web is not well-formed. IEEE

Intelligent Systems, 17(2), 2002. Contribution to the
section Trends and Controversies: Ontologies KISSES
in Standardization.

[30] D. Tsarkov and I. Horrocks. Eﬃcient reasoning with

range and domain constraints. In Proc. of the 2004
Description Logic Workshop (DL 2004), pages 41–50,
2004.

[31] R. Volz. Web Ontology Reasoning with Logic

Databases. PhD thesis, AIFB, Karlsruhe, 2004.
[32] G. Yang, M. Kifer, and C. Zhao. FLORA-2: A

rule-based knowledge representation and inference
infrastructure for the semantic web. In Proc. of the
Second Int. Conf. on Ontologies, Databases and
Applications of Semantics (ODBASE), 2003.

