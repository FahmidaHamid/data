WEESA › Web Engineering for Semantic Web Applications

Gerald Reif

Distributed Systems Group

Vienna University of

Technology

Argentinierstrasse 8
1040 Vienna, Austria

reif@infosys.tuwien.ac.at

Harald Gall

Department of Informatics

University Zurich

Winterthurstrasse 190
8057 Zurich, Switzerland

gall@i(cid:2).unizh.ch

Mehdi Jazayeri

Distributed Systems Group

Vienna University of

Technology

Argentinierstrasse 8
1040 Vienna, Austria

jazayeri@infosys.tuwien.ac.at

ABSTRACT
The success of the Semantic Web crucially depends on the
existence of Web pages that provide machine-understandable
meta-data. This meta-data is typically added in the seman-
tic annotation process which is currently not part of the Web
engineering process. Web engineering, however, proposes
methodologies to design, implement and maintain Web ap-
plications but lack the generation of meta-data. In this pa-
per we introduce a technique to extend existing Web en-
gineering methodologies to develop semantically annotated
Web pages. The novelty of this approach is the de(cid:12)nition of
a mapping from XML Schema to ontologies, called WEESA,
that can be used to automatically generate RDF meta-data
from XML content documents. We further show how we in-
tegrated the WEESA mapping into an Apache Cocoon trans-
former to easily extend XML based Web applications to se-
mantically annotated Web application.

Categories and Subject Descriptors
H.3.5 [Information Systems]: Information Storage and
Retrieval; D.2 [Software]: Software Engineering

General Terms
Design

Keywords
Web Engineering, Semantic Web, Semantic Annotation, On-
tology

1.

INTRODUCTION

The existence of semantically annotated Web pages is cru-
cial to bring the Semantic Web to life. But it is still costly
to develop and maintain Web applications that o(cid:11)er both:
human-understandable information that can be displayed by
a Web browser and machine-understandable meta-data that
can be processed by computers.

Semantic annotation addresses this problem and aims to
turn human-understandable content into a machine-under-
standable form by adding semantic markup [7]. Many tools
have been developed that support the user during the anno-

Copyright is held by the International World Wide Web Conference Com›
mittee (IW3C2). Distribution of these papers is limited to classroom use,
and personal use by others.
WWW 2005, May 10›14, 2005, Chiba, Japan.
ACM 1›59593›046›9/05/0005.

tation process. But still, the annotation process is a separate
task and is not integrated in the Web engineering process.
Web Engineering focuses on the systematic and cost ef-
(cid:12)cient development and evolution of Web applications [6].
The outcome of the Web Engineering process are Web ap-
plications that provide Web pages that can be displayed in a
Web browser but these applications lack semantic markup.
In this paper we show how existing XML-based Web en-
gineering methodologies can be extended to engineer se-
mantically annotated Web pages. In the remainder of this
paper we call Web applications that not only o(cid:11)er human-
understandable content but also semantic meta-data Seman-
tic Web applications.

The contribution of this paper is the conceptual de(cid:12)ni-
tion and prototype implementation of a mapping from XML
Schema to ontologies that allows the e(cid:14)cient design of Se-
mantic Web applications based on existing Web engineering
artifacts. The mapping can then be used to automatically
generate RDF descriptions from XML content documents.
We call this approach WEESA (WEb Engineering for Se-
mantic web Applications). To our knowledge, WEESA is
the (cid:12)rst approach that integrates semantic annotation in
the Web engineering process.
In this paper we show the
integration of WEESA into an Apache Cocoon transformer
[4] and the use of this transformer to develop Semantic Web
applications.

The remainder of this paper is structured as follows. Sec-
tion 2 brie(cid:13)y introduces semantic annotation. Section 3 in-
troduces XML-based Web engineering. Section 4 explains
the idea of using an XML Schema { ontology mapping to
generate RDF descriptions from XML documents. Section 5
shows the implementation, and Section 6 the integration of
the mapping into a Cocoon transformer. Section 7 discusses
related work, Section 8 presents the case study and tool
support, and Section 9 gives an outlook on future work and
concludes the paper.

2. SEMANTIC ANNOTATION

The aim of semantic annotation is to transform documents
into machine-understandable artifacts by augmenting them
with meta-data that describes their meaning.
In the Se-
mantic Web, this meta-data description is done using the
Resource Description Framework (RDF) that references the
concepts de(cid:12)ned in an ontology. Ontologies formally de-
(cid:12)ne concepts used in a domain and the relationship between
these concepts. An ontology is de(cid:12)ned in an ontology de(cid:12)-
nition language such as RDFS, DAML+OIL, or OWL.

When adding semantic meta-data to documents, one faces

several problems [13]:

(cid:15) Annotating documents with Semantic markup is a time
consuming task and has to be performed in addition
to the authoring process.

(cid:15) The authors that annotate the documents are typically
not the ones who pro(cid:12)t from the existence of meta-
data. This reduces the author’s motivation to annotate
Web pages.

(cid:15) The granularity of the information found in the doc-
ument does not meet the needs of granularity in the
ontology. Several information items that can be found
in the document might be needed to compute the value
that (cid:12)ts a property in the ontology.

(cid:15) Looking at Web pages that provide RDF meta-data, so
called Semantic Web pages, we recognize that impor-
tant parts of the content are stored two times. First,
in HTML format that is displayed to the user via the
Web browser, second in the RDF description. This re-
dundancy leads to inconsistency problems when main-
taining the content of the Web page. Changes always
have to be done consistently for both types of infor-
mation.

(cid:15) Many Web pages are not static documents but are gen-
erated dynamically e.g. using a database. Annotating
dynamic documents leads to performing the same task
over and over for a speci(cid:12)c pattern of documents.

Several annotation tools have been proposed to overcome
the problems listed above. Early tools such as the SHOE
Knowledge Annotator [8] mainly concentrated on avoiding
syntactic mistakes and typos when referencing ontologies.
Current tools such a CREAM/OntoMat [7] are sophisticated
authoring frameworks that support the user while writing
and annotating the document and help maintaining the gen-
erated meta-data. Still, the annotation process is not inte-
grated in the engineering process of a Web application as
proposed by the Web engineering community.

3. XML›BASED WEB PUBLISHING

Web Engineering focuses on the systematic and cost ef-
(cid:12)cient design, development, maintenance, and evolution of
Web applications [6]. Most Web engineering methodologies
are based on separation-of-concerns to de(cid:12)ne strict roles in
the development process and to enable parallel development
[9]. The most frequently used concerns are the content, the
graphical appearance, and the application logic. When we
plan to design Web applications that in addition o(cid:11)er se-
mantic markup we have to introduce a new concern, the
meta-data concern.

Most Web engineering methodologies use XML and XSLT
for strict separation of content and graphical appearance.
XML focuses only on the structure of the content, whereas
XSLT is a powerful transformation language to translate
an XML input document into an output document such
as again an XML document, HTML, or even plain text.
Many Web development frameworks such as Cocoon [4] or
MyXML [10] exist that use XML and XSLT for separation-
of-concerns.

XML Schema

valid

WEESA
mapping
definition

generate

Ontology

uses terms

Design Level

Instance Level

XML document

RDF description

generate
via XSLT

HTML page

included in the <head> tag

Figure 1: Design and instance level

Based on this technology, editors responsible for the con-
tent only have to know the structure of the XML (cid:12)le and
the allowed elements to prepare the content pages. Design-
ers, responsible for the layout of the Web application, again
only have to know the structure and elements of the XML
(cid:12)le to write the XSLT stylesheets. Finally, programmers
responsible for the application logic have to generate XML
documents (or fragments) as output. An XML Schema de-
(cid:12)nes exactly the structure and the allowed elements in an
XML (cid:12)le that is valid according to this schema. Therefore,
XML Schema can be seen as a contract the editors, designers
and programmers have to agree on [9].

Since XML is widely used in Web engineering, our ap-
proach to engineer Semantic Web applications uses the XML
content to generate the RDF meta-data description from a
Web page. We also use the XML Schema as a contract and
map the elements de(cid:12)ned in the schema to concepts de(cid:12)ned
in an ontology. Our goal is to use the structure and the
content of the XML document to (cid:12)ll the RDF triples with
data.

In the proposed approach, the XML document is the basis
for the HTML page as well as for the RDF description. This
helps to overcome the inconsistency problem pointed out in
the Section before.

4. MAPPING XML SCHEMA TO

ONTOLOGIES

In our WEESA mapping we use the content of an XML
document to derive its RDF meta-data description. In the
design phase of the Web application, however, we have no
XML documents at hand. But we have the XML Schema
de(cid:12)nition that provides us with information about the struc-
ture of valid XML documents. We use this information to
de(cid:12)ne a mapping from XML elements to concepts used in
an ontology. Figure 1 shows the de(cid:12)nition of the WEESA
mapping on the design level and how this mapping is used
at instance level to automatically generate RDF meta-data
from XML documents.

In Section 2 we introduced the granularity problem when
annotating documents. We face the same problems when
de(cid:12)ning the WEESA mapping. It is possible that the con-
cept of an XML element/attribute can be mapped one-to-
one to a concept de(cid:12)ned in an ontology. In general, however,
this will not be the case. Therefore we propose to dynami-
cally compute the missing information from the information
available in the XML document. In some cases processing

is needed to reformat the element’s content to match the
datatype used in the ontology. In other situations it might
be necessary to use the content of more than one XML ele-
ment to generate the content for the RDF description.

For demonstration purpose, in this paper we take the (cid:12)c-
tive MyTunes online CD store as illustrative example. My-
Tunes o(cid:11)ers for each artist a Web page with their albums
and for each album a page with the album details. Some
XML elements such as the artist name or the track titles
can be mapped one-to-one to properties de(cid:12)ned in the cor-
responding class of the ontology. Other properties de(cid:12)ned
in the ontology such as the total play time of an album can
not be found in the XML document but calculated from the
play-times of each single track. In this case some additional
processing is needed to generate the information required by
the ontology from the data provided by the XML document.
Our MyTunes application o(cid:11)ers in addition a list of live per-
formances for each artist. Therefore an XML document with
the begin time and the duration of the performance is pro-
vided. The ontology, however, uses a di(cid:11)erent way to express
the performance times. It de(cid:12)nes properties for the begin
and end time of a performance in the event class. Therefore
the content of the begin time and the duration element have
to be processed to match the two properties.

Another possibility to address the mismatch in granular-
ity between the XML elements and the ontology concepts is
to adjust the XML Schema de(cid:12)nition in the design phase of
the Web application. The structure of the XML document
could be adopted to the kind of information needed by the
given ontology. But this would lead to several problems: (1)
Some information needed for the Web page might be lost.
(2) Over time a new ontology can become the standard on-
tology for the domain of the Web application. Therefore, the
XML Schema - ontology mapping should be (cid:13)exible enough
to allow to change the used ontology later in the life cycle of
the Web application. The change of the ontology would re-
sult in the change of the XML Schema which represents the
contract all parties agreed on. This would yield in the re-
design of the whole Web application. (3) It is possible that
we have to de(cid:12)ne the mapping for already existing XML
documents and do not have the possibility to change the
schema. Therefore, a (cid:13)exible way to map the content of one
or more XML elements to the information required by the
used ontology is needed. How this mapping can be imple-
mented is shown in the following section.

5.

IMPLEMENTATION

The generation of RDF meta-data based on XML content
is done in two steps. First, in the design phase for each XML
Schema, a mapping to the ontologies is de(cid:12)ned. Second, for
each XML page the mapping rules de(cid:12)ned in the previous
step are applied to generate the RDF representation.
5.1 De(cid:2)ning the mapping

The starting point of the mapping is on the one hand the
XML Schema that acts as a contract in the development
process and on the other hand the ontologies to be used.
The XML Schema provides us with the information of the
structure of a valid XML document and the elements be-
ing used. This information can be used to de(cid:12)ne XPath [3]
expressions to select an element or attribute from an XML
document. Once an element/attribute is selected, its con-
tent is mapped to a position in a RDF triple.

(cid:4)

(cid:5)

(cid:7)

<? xml v e r s i o n = " 1.0 " e n c o d i n g = " UTF -8 " ? >
< album id = " 1234 " >

< artist > Alanis M o r i s s e t t e </ artist >
< name > Alanis U n p l u g g e d </ name >
< price > 9.99 </ price >
< tracks >

< track number = " 1 " >

< name > You Learn </ name >
< time >4 :21 </ time >

</ track >
< track number = " 2 " >

< name > J o i n i n g You </ name >
< time >5 :09 </ time >

</ track >
< track number = " 3 " >

< name > No P r e s s u r e over C a p p u c c i n o </ name >
< time >4 :41 </ time >

</ track >
<! -- ... -- >
< track number = " 12 " >

< name > U n i n v i t e d </ name >
< time >4 :37 </ time >

</ track >

</ tracks >

</ album >

(cid:6)

Figure 2: XML document for an album.

The goal of the mapping de(cid:12)nition is to (cid:12)ll the subject,
predicate and object of RDF triples with data. In the map-
ping de(cid:12)nition various ways exist to specify the content of
the RDF triples: (1) a constant value, (2) an XPath ex-
pression, (3) the return value of a Java method, and (4) a
resource reference. In the following we describe each of these
ways in more detail.

(1) A constant value can be, for example, the URI refer-
ence to a concept de(cid:12)ned in the ontology. (2) An XPath
expression is used do select the content of an element/at-
tribute.
In this case, a RDF triple is generated for each
XPath match. (3) The content of more than one element/
attribute might be needed to compute the information to
match a property in the ontology or a datatype conversion
has to be performed. We use Java methods for this purpose.
These methods take the content of one or more elements/at-
tributes or constants as input parameters and return a string
value as content for a RDF triple. In the mapping de(cid:12)nition
we can de(cid:12)ne that the Java method has to be called for each
XPath match and a triple for each match is generated, or
that all XPath matches are handed over as a Vector to the
Java method and only one RDF triple is generated.

(4) Unique resource identi(cid:12)ers are needed to (cid:12)ll the sub-
ject. Since most XML documents provide more information
that is related to the same resource, we o(cid:11)er the possibility
to de(cid:12)ne a resource identi(cid:12)er that can later be referenced
to (cid:12)ll the RDF triples. The mapping also provides the pos-
sibility to de(cid:12)ne anonymous resources. They are used for
resources that never need to be referred to directly from out-
side the RDF description. To de(cid:12)ne an anonymous resource
in the mapping, the resource is labeled to be anonymous.

Figure 2 shows an example XML document for an album
in our MyTunes CD store. This example is used to demon-
strate the use of the four ways to specify the content for the
RDF triples as described above.

A WEESA mapping de(cid:12)nition (see Figure 3) consists of
two sections. The (cid:12)rst section de(cid:12)nes the resource identi-
(cid:12)ers that can later be used. The second section de(cid:12)nes the
subject, predicate, and object of the actual RDF triples.

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

38

39

40

41

42

43

44

45

46

47

48

49

50

51

52

53

54

55

56

57

58

59

60

(cid:7)

<? xml v e r s i o n = " 1.0 " e n c o d i n g = " UTF -8 " ? >
< m a p p i n g xmlns = " http: // www . i n f o s y s . tuwien . ac . at / WEESA # " >

< r e s o u r c e s >

< r e s o u r c e id = " album " >

< method >

< name > at . ac . tuwien . i n f o s y s . weesa . wf . M a p p i n g L i b . a d d P r e f i x </ name >
< param const = " http: // e x a m p l e . com / album # " type = " java . lang . String " / >
< param xpath = " / album / @id " type = " java . lang . String " / >

</ method >
</ r e s o u r c e >
< r e s o u r c e id = " track " a n o n y m o u s = " yes " var = " t r a c k _ i d " xpath = " / album / tracks / track / @ n u m b e r " / >

</ r e s o u r c e s >
< t r i p l e s >

< triple >

< s u b j e c t ref = " album " / >
< p r e d i c a t e const = " http: // www . w3 . org /1999/02/22 - rdf - syntax - ns # Type " / >
< object const = " http: // e x a m p l e . com / M y T u n e s # Album " r e s o u r c e = " yes " / >

</ triple >
< triple >

< s u b j e c t ref = " album " / >
< p r e d i c a t e const = " http: // e x a m p l e . com / M y T u n e s # h a s T i t l e " / >
< object xpath = " / album / name / text () " / >

</ triple >
< triple >

< s u b j e c t ref = " album " / >
< p r e d i c a t e const = " http: // e x a m p l e . com / M y T u n e s # t o t a l T i m e " / >
< object >

< method >

< name > at . ac . tuwien . i n f o s y s . weesa . wf . M a p p i n g L i b . s u m T i m e s </ name >
< param xpath = " / album / tracks / track / time / text () " type = " java . util . Vector " x r e s u l t A s V e c t o r = " yes " / >

</ method >

</ object >

</ triple >
< triple >

< s u b j e c t ref = " album " / >
< p r e d i c a t e const = " http: // e x a m p l e . com / M y T u n e s # h a s T r a c k " / >
< object ref = " track " / >

</ triple >
< triple >

< s u b j e c t ref = " track " / >
< p r e d i c a t e const = " http: // www . w3 . org /1999/02/22 - rdf - syntax - ns # Type " / >
< object const = " http: // e x a m p l e . com / M y T u n e s # Track " r e s o u r c e = " yes " / >

</ triple >
< triple >

< s u b j e c t ref = " track " / >
< p r e d i c a t e const = " http: // e x a m p l e . com / M y T u n e s # t r a c k N u m b e r " / >
< object const = " $$ t r a c k _ i d $$ " / >

</ triple >
< triple >

< s u b j e c t ref = " track " / >
< p r e d i c a t e const = " http: // e x a m p l e . com / M y T u n e s # p l a y T i m e " / >
< object xpath = " / album / tracks / track [ @ n u m b e r = ’$$ t r a c k _ i d $$ ’]/ time / text () " / >

</ triple >
< triple >

< s u b j e c t ref = " track " / >
< p r e d i c a t e const = " http: // e x a m p l e . com / M y T u n e s # t r a c k T i t l e " / >
< object xpath = " / album / tracks / track [ @ n u m b e r = ’$$ t r a c k _ i d $$ ’]/ name / text () " / >

</ triple >

</ t r i p l e s >

Figure 3: WEESA mapping de(cid:12)nition for the album example.

</ m a p p i n g >

(cid:6)

(cid:4)

(cid:5)

(cid:7)

(cid:6)

Class: Artist

-> h a s A r t i s t N a m e
-> h a s A l b u m ( range: Album )

Class: Album
-> h a s T i t l e
-> h a s T r a c k ( range: Track )
-> t o t a l T i m e
-> year

Class: Track

-> t r a c k T i t l e
-> p l a y T i m e
-> t r a c k N u m b e r

Class: Event

-> h a s E v e n t N a m e
-> h a s L o c a t i o n
-> b e g i n T i m e
-> e n d T i m e

Figure 4: Ontology used for our MyTunes example.

Figure 3 shows the WEESA mapping de(cid:12)nition for our
album example. At the beginning of the mapping we de-
(cid:12)ne the resources (lines 3-12). In the (cid:12)rst resource with the
id="album" attribute we de(cid:12)ne an XPath expression to se-
lect the id attribute of the album element in Figure 2. The
respective XPath expression is /album/@id. The content of
the attribute is then handed over to a Java method. The
method name is de(cid:12)ned in line 6.
In this case the Java
method adds a pre(cid:12)x to the attribute value to generate a
resource identi(cid:12)er. The parameters for the method are de-
(cid:12)ned in lines 7 and 8. The (cid:12)rst parameter is a constant used
for the pre(cid:12)x and the second parameter is the XPath expres-
sion to select the attribute. The return value of the method
is then used as the content in the RDF triple whenever the
resource with the id="album" is referenced.

In the resource with the id="track" (line 11) we show
how an anonymous resource can be de(cid:12)ned. This is done
using the anonymous="yes" attribute. In this case for each
XPath match an anonymous resource is generated.

Once we have de(cid:12)ned the resources, we can start de(cid:12)n-
ing the RDF triples. This is done in the triples section
(lines 13-59).
In the (cid:12)rst triple (lines 14-18) the subject
uses the ref="album" attribute to reference the resource
with the id="album". In the predicate we use the rdf:Type
constant to de(cid:12)ne the class the subject is an instance of.
The object of this triple is the URI reference to the class in
the ontology (http://example.com/MyTunes#Album). The
resource="yes" attribute is used to indicate that the value
of the object should be interpreted as a RDF resource. The
default interpretation would be a literal. Our sample on-
tology is shown in Figure 4. (For reasons of clarity, we do
not use the OWL Syntax in the example, but use a trivial
textual syntax instead.)

The following triples in our example mapping (cid:12)ll the prop-
erties of the #Album class. The predicate de(cid:12)nes the name
of the property and the object the value. The xpath at-
tribute of the object element de(cid:12)nes the XPath expres-
sion that has to be evaluated. The object element can
also contain a method element to de(cid:12)ne the Java method
to compute the content of the object. Lines 28-31 show
the use of a Java method where all XPath matches are
handed over as a Vector to the method indicated by the
xresultAsVector="yes" attribute.

In some cases we need additional information to select a
speci(cid:12)c element/attribute by an XPath expression. When
an XML document consists of multiple elements with the
same name at the same hierarchy level we need a technique
to select a speci(cid:12)c one. For this purpose we use variables. In
line 11 we use the var attribute to de(cid:12)ne the track id vari-
able. This variable can be used in any constant or XPath ex-

(cid:4)

(cid:5)

(cid:7)

r e c u r i s v e M a p p i n g ( r e s o u r c e S e t )

if r e s o u r c e S e t is empty

g e n e r a t e T r i p l e s ()
return

forall r e s o u r c e in r e s o u r c e S e t

if there are XPath m a t c h e s

r e s o u r c e S t a c k . push ( all XPath m a t c h e s )
s t a c k H a s h . put ( resource , r e s o u r c e S t a c k )

(cid:4)

while ( stack is not empty )

x p a t h _ m a t c h = stack . pop ()
c o n t e n t = p r o c e s s C o n t e n t ( x p a t h _ m a t c h )
g l o b a l e R e s o u r c e H a s h . put ( resource , c o n t e n t )
if r e s o u r c e d e f i n e s v a r i a b l e

g l o b a l e V a r i a b l e H a s h . put ( variable , x p a t h _ m a t c h )

r e c u r s i v e M a p p i n g ( r e s D e p e n d e n c y H a s h . get ( r e s o u r c e ))

else

r e c u r s i v e M a p p i n g ( empty Set )

(cid:6)

(cid:5)

Figure 5: Pseudo-code for processing the WEESA
mapping.

pression using the $$ escape sequence at the beginning and
the end of the variable name. The variable is replaced at
runtime with the actual value. Variables can be de(cid:12)ned to-
gether with the xpath attribute in resource de(cid:12)nitions only.
At the end of the triples section we show that anonymous
resources can be used as any other resource in the triple
de(cid:12)nition.
In the triple de(cid:12)ned in lines 34-38 the object
uses the reference to the anonymous resource track. The
following triples de(cid:12)ne the class and the properties for this
resource and show the use of the track id variable in the
WEESA mapping.

So far we have shown how the WEESA mapping is de(cid:12)ned.
The following section shows how this mapping can be used
to generate RDF descriptions from XML documents.

5.2 Generating the RDF Description

When a Web page is queried, the corresponding XML
document is fetched and the XSLT transformation is used
to generate the HTML page. Second, the RDF description
has to be generated and included into the <head> tag of
the HTML document. To generate this description all map-
pings de(cid:12)ned for the XML document have to be executed.
Therefore, the XPath expressions have to be evaluated on
this document and the result is either directly used to (cid:12)ll
a position in a RDF triple that is de(cid:12)ned in the mapping
or is handed over to a Java method (cid:12)rst. If the XPath ex-
pression matches multiple elements/attributes in the XML
document the procedure has to be repeated for each match
or the matches are handed over to the Java method as a
Vector.

The pseudo-code in Figure 5 shows the principle steps
that have to be applied to process the WEESA mapping
de(cid:12)nition. Before the recursiveMapping() method can be
called all dependencies between the de(cid:12)ned resources have
to be analyzed and stored in the global resDependencyHash.
A resource R1 is dependent on resource R2 if R1 uses a
variable that is de(cid:12)ned in R2 or R1 is used as object in
a triple with the subject R2.
In this case R2 has to be
processed before R1 can be resolved. The second condition
is necessary since triples that relate two resources (such as
de(cid:12)ned in lines 34-38) can only be generated if the values for
both resources have been processed. The initial parameter

ated RDF graph for our example can be found in Figure 6.
There are two known limitations to the current WEESA
implementation: (1) If a method call is de(cid:12)ned that takes
several XPath expressions as parameter, we do not generate
all permutations of the matches of the XPath expressions.
Instead we use the iter="yes" attribute to indicate over
which XPath matches should be iterated. For the other
parameters we use the (cid:12)rst XPath match. (2) Because of the
dependency rule between resources WEESA cannot generate
RDF graphs that include circles. In this case no independent
resource can be found to start the recursion.

6. WEESA AS COCOON TRANSFORMER

In the previous section we introduced the WEESA map-
ping and illustrated how this mapping can be used to gener-
ate RDF meta-data from XML documents. In this section
we show how we integrated WEESA into Cocoon transform-
ers and how to use these transformers in a Cocoon Web
application.

Apache Cocoon [4] is a component based Web develop-
ment framework that uses XML/XSLT for separation-of-
concerns. Cocoon uses component pipelines to build Web
applications where each component on the pipeline is spe-
cialized on a particular operation.

Figure 7 shows the pipeline of a typical Cocoon Web appli-
cation. Each pipeline consists of a generator, an arbitrary
number of transformers, and a serializer. A user request
causes the generator to read XML from a data source and
produces as output a stream of SAX events representing the
XML document. This output is the input of a transformer.
A transformer takes the SAX events, does some transforma-
tion (e.g. XSLT transformation), and the results are again
SAX events. This events can then be taken by another trans-
former or a serializer. In a typical Cocoon Web application
the business logic (e.g. SQL queries, Java code) is processed
by the transformers at the beginning of the pipeline. The
output of the business logic is an XML Schema valid XML
document which ful(cid:12)lls the contract de(cid:12)ned in the Web en-
gineering process. This document is then taken by the XSLT
transformer which uses the XSL stylesheet to produce the
HTML page. The serializer (cid:12)nally takes the SAX events and
processes them into a character stream for client consump-
tion. The steps of a conventional Cocoon Web application
are shown in Figure 7 as white pipeline components.

In the case of a Semantic Web application we introduce
two new steps to the pipeline. Since we need the Schema
valid XML document for the XSLT transformation and for
the WEESA meta-data generation, we have two choices. We
can either integrate WEESA in a modi(cid:12)ed XSLT transformer
that generates RDF and HTML or we can split up the
pipeline. In our approach we choose to split up the pipeline
using the WriteDOMSession transformer. This transformer
takes the input document and writes it (cid:12)rst as DOM into the
servlet session, and second as SAX events to its output. This
is how the pipeline is split up and the XML document can
be reused later in the pipeline. After the HTML page is gen-
erated by the XSLT transformer the WEESAReadDOMSession
transformer takes the DOM-XML from the session and uses
the WEESA mapping de(cid:12)nition to generate the RDF meta-
data representation. The meta-data is then added in the
<head> tag of the HTML page. The serializer (cid:12)nally delivers
the HTML+RDF page to the client. The additional steps
are shown in Figure 7 as light gray pipeline components.

Figure 6: Snippet from the generated RDF graph.

for the recursiveMaping() method is the Set of resources
that do not depend on any other resources and can therefore
be processed directly.

For better understanding we use the MyTunes example
mapping from Figure 3 to illustrate the execution of the
pseudo-code. We start with analyzing the resource depen-
dencies and (cid:12)nd out that the triple de(cid:12)ned in lines 34-38 uses
the resource album as subject and track as object. Follow-
ing the rule de(cid:12)ned above, track depends on the resource
album. This leaves us with album as the only independent
resource.

Now the method recursiveMapping() is called with album
as parameter. Since the resourceSet is not empty the pro-
cessing continues with the two nested loops. In the outer
loop the XPath expression is executed on the XML docu-
ment and the matches are put on the stack. In our example
the XPath /album/@id has only one match: 1234.

If there are XPath matches the inner loop is processed. In
the inner loop the XPath matches are taken from the stack,
the processContent() method is called, the variables are
assigned their values, and a recursive method call is done to
process all resources that depend on the current resource/
variable environment. The processContent() method takes
the XPath matches as parameter and computes the con-
tent for the resource as de(cid:12)ned in the mapping. If a Java
method is de(cid:12)ned, it causes the method call and uses the
return value as content. If there are no more dependent re-
sources the recursive call is done with an empty Set. This
causes the call of the generateTriples() method. The
generateTriples() method iterates through all triples de-
(cid:12)ned in the mapping and generates an instance for those
where the required resources and variables are de(cid:12)ned in
the globalVariableHash and globalResourceHash.

Coming back to our example, in the inner loop we take the
(cid:12)rst match (1234) from the stack, call the Java method de-
(cid:12)ned in line 6, compute the content for the resource (http:
//example.com/album#1234), and do the recursive method
call. The resourceSet for the recursive call contains the
track resource since it depends on the author resource as
explained above.
In the recursive method call the execu-
tion of the XPath expression returns with a match for each
track on the album and in the inner loop all the matches are
processed. Since no other resource depends on the track re-
source the recursive call is done with and empty Set and the
generateTriples() method is called. A part of the gener-

Cocoon Pipeline

Generator

XML Source

Busines Logic:
XSP, JSP, Filter,
SQL, etc.

SAX Events

Transformer

SAX Events

Transformer

Session

DOM

SAX Events

Schema valid XML document

WriteDOMSession

Transformer

SAX Events

Schema valid XML document

XSLT Transformer

XSL Stylesheet

SAX Events

HTML

WEESAReadDOM
SessionTransformer

WEESA Mapping

Definition

SAX Events

HTML + RDF

Serializer

HTML + RDF

Figure 7: WEESA meta-data generation in the Co-
coon pipeline.

Embedding the RDF/XML meta-data in the <head> tag
of a HTML document, however, breaks HTML 4.01 and
XHTML validity [14]. The recommended approach is to
not embed RDF/XML in HTML/XHTML but rather to use
the <link> element in the <head> element of the HTML/X-
HTML to point at a separate RDF/XML document [15].
The problem of embedding RDF/XML in HTML is exten-
sively discussed in [12]. Using the <link> element, the ref-
erence in our example looks as follows:

<link rel="meta" type="application/rdf+xml"

href="album1234.rdf"/>

We also support this way of associating RDF with HTML
using the WEESA transformer. This second type of trans-
former, the WEESA transformer, takes the XML document as
input from the pipeline and produces RDF/XML as out-
put. This output is then taken by a serializer and sent to
the client.
In this case the pipeline for the HTML page
is unchanged, only the <link> element has to be added to
the Web page. The pipeline for the RDF generation looks
similar to that for HTML. Using the <link> tag has the
advantage that the RDF description has to be generated on
request only. This, however, has the drawback, that the
schema valid XML document has to be generated a second
time.

7. RELATED WORK

To our knowledge not much work has been done to inte-
grate the Semantic annotation process into Web engineering.
In [13], the authors suggest an extension of the Web Site De-
sign Model (WSDM). In this approach object chunk entities
which are artifacts in the Web application design process are

mapped to concepts in the ontology. The WSDM extension
also enables the annotation of dynamic pages. Mismatches
in granularity are tackled with the help of intermediate on-
tologies which can only be used to concatenate object chunks
and does not allow any further (cid:13)exibility to address the gran-
ularity problem.

There exists other related work that is not directly re-
lated to Web engineering but analyzes the structure of an
XML document to access the semantic of the content. The
Meaning De(cid:12)nition Language (MDL) de(cid:12)nes what an XML
document may mean in terms of a UML class model, and de-
(cid:12)nes how that meaning is encoded in the nodes of the XML
document [16]. It enables tools and users to access XML at
the level of its meaning rather than its structure. A di(cid:11)erent
approach is taken in [1]. There the DTD and XPath is used
to establish a mapping between XML fragments and ontol-
ogy concepts. Both approaches do not support variables in
the mapping de(cid:12)nition, and do not o(cid:11)er the (cid:13)exibility to
further process the XML content in Java methods to better
match the ontology requirements.

There is further related work in the area of Semantic
annotation. CREAM/OntoMat [7] is a Semantic annota-
tion framework that o(cid:11)ers several annotation methods such
as manual annotation, authoring of annotated documents,
semiautomatic annotation, and the annotation of dynamic
pages. This (cid:13)exible approach is, however, not integrated in
the Web engineering process.

In the area of interpreting XML as RDF data several ap-
proaches exist. In [11], XML documents are interpreted as
RDF data via a RDF Schema to enable machines to in-
terpret XML unambiguously as a set of statements in the
RDF data model. The round-tripping tool between XML
and RDF [2] allows to directly interpret XML documents
with a RDF model using the XML Schema as basis for de-
scribing how XML is mapped into RDF and back. In [5] the
idea is that every element/attribute name maps to a RDF
property, viewing the structure of the XML document as re-
lational model between parent nodes and their children. All
these approaches rely on the equality of the XML element/
attribute names and those of the class/property names in
the ontology. This, however, cannot be guaranteed, since
ontologies are often de(cid:12)ned by third parties.

8. CASE STUDY AND TOOL SUPPORT

We have evaluated WEESA in the annual Vienna Interna-
tional Festival1 (VIF) industry case study. VIF is a database
supported Web application that comprises a ticket shop,
over 60 event descriptions, reviews, and an archive over the
last 52 years. The experiences of VIF shows that WEESA
is well suited to develop Semantic Web applications. How-
ever, since WEESA only uses the structure to identify the
concepts in the XML document, free-text and mixed con-
tent can not be annotated. Natural language understanding
would be needed to do so. To our experience, this is not a
problematic limitation since the concepts that can be found
in many ontologies can also be found in the structure of an
XML document.

The VIF case study further showed that database keys
should be accessible in the XML documents to be able to
generate unique resource identi(cid:12)ers for the RDF representa-
tion. The database keys help to ensure that the same identi-

1http://www.festwochen.at

(cid:12)er is used for the same resource throughout the whole Web
application.

At the moment we de(cid:12)ne the mapping (cid:12)les by hand. To
get a broader acceptance, tool support is needed to de-
(cid:12)ne the mapping. Currently we develop a tool that takes
an XML Schema and automatically generates the maximal
valid tree structure for this schema. Elements/attributes
can then be selected and the XPath expression is generated.
On the other hand, the class hierarchy and the properties
de(cid:12)ned in the ontology are graphically displayed.
In ad-
dition we present a list of available Java methods that can
be used to further process the element’s/attribute’s content.
This can then be used to de(cid:12)ne the mapping in a GUI via
drag&drop.

The prototype implementation of the WEESA mapper and

the WEESA transformer can be downloaded under:

http://www.infosys.tuwien.ac.at/WEESA

9. CONCLUSION AND FUTURE WORK

The deployment of the Semantic Web requires Web ap-
plications that are semantically annotated. Authoring Web
pages that o(cid:11)er data and meta-data is a costly task and
has the potential risk of inconsistencies in documents. But
inconsistent data weakens the acceptance of the Semantic
Web. Therefore, support is needed not only for designing
but also for maintaining Semantic Web applications.

This paper presented the WEESA approach to develop Se-
mantic Web applications that is based on established Web
Engineering methodologies. WEESA uses the same XML
documents as source for the HTML page and the RDF rep-
resentation. In the design phase, we de(cid:12)ne a mapping from
XML Schema documents to ontologies. This mapping can
then be used to automatically generate RDF descriptions
from XML documents. Our approach enables developers to
reuse existing Web engineering artifacts to generate seman-
tically tagged Web applications.

Based on our experiences gained from the (cid:12)rst prototype
and the case study we plan to revise the WEESA mapping.
The next version of WEESA should overcome the limitations
listed at the end of Section 5.2. The use of XPath 2 might
help to simplify the mapping de(cid:12)nition. We will further
investigate the possibilities to use WEESA’s (cid:13)exible mapping
approach to map between ontologies and to use WEESA for
ontology mediation.

Our approach focuses on the generation of the RDF rep-
resentation of individual Web pages. Looking at the meta-
data description of a single Web page, however, gives only
a very limited view of the information o(cid:11)ered by a Web ap-
plication. For querying and reasoning purpose it would be
better to have the whole meta-data model of the Web ap-
plication at hand. Therefore, we plan to accumulate meta-
data descriptions from Web pages at server side to obtain
the meta-data model of the whole Web application. This
model can be o(cid:11)ered for querying or for download in one
stream in contrast to to the current gatherers that open a
new connection for each page. Based on this idea we plan to
harvest meta-data models form Semantic Web applications
to build the knowledge base of a Semantic Search Engine.
Acknowledgements
We thank Pascal Fenkam and Engin Kirda for their valuable
comments and suggestions for improving the paper.

10. REFERENCES
[1] B. Amann, I. Fundulaki, M. Scholl, C. Beeri, and

A.-M. Vercoustre. Mapping XML fragments to
community web ontologies. In Proceedings 4th Int.
Workshop on the Web and Databases, 2001.

[2] S. Battle. Poster: Round-tripping between XML and

RDF. In International Semantic Web Conference
(ISWC), Hiroshima, Japan, November 2004. Springer.
[3] J. Clark and S. DeRose. XML Path Language (XPath)

Version 1.0. W3C Recommendation, 16 November
1999. http://www.w3.org/TR/xpath.

[4] The Apache Cocoon project homepage, Last visited

February 2005. http://cocoon.apache.org/.

[5] M. Ferdiand, C. Zirpins, and D. Trastour. Lifting xml

schema to owl. In 4th International Conference on
Web Engineering, pages 354{358, Munich, Germany,
July 2004.

[6] M. Gaedke and G. Graef. Development and evolution
of web-applications using the webcomposition process
model. In International Workshop on Web
Engineering at the 9th International WorldWide Web
Conference, Amsterdam, the Netherlands, May 2000.

[7] S. Handschuh and S. Staab. Annotation of the shallow

and the deep web. In S. Handschuh and S. Staab,
editors, Annotation for the Semantic Web, volume 96
of Frontiers in Arti(cid:12)cial Intelligence and Applications,
pages 25{45. IOS Press, Amsterdam, 2003.

[8] J. He(cid:13)in and J. Hendler. Searching the web with
SHOE. In Arti(cid:12)cial Intelligence for Web Search.
Papers from the AAAI Workshop, pages 35{40, Menlo
Park, CA, 2000. AAAI Press.

[9] C. Kerer. XGuide - Concurrent Web Development

with Contracts. PhD thesis, TU Vienna, 2003.

[10] C. Kerer and E. Kirda. Web engineering, software

engineering and web application development. In 3rd
Workshop on Web Engineering at the 9th World Wide
Web Conference, pages 135 { 147, Amsterdam, the
Netherlands, May 2000. Springer-Verlag.

[11] M. Klein. Using RDF Schema to interpret XML

documents meaningfully. In S. Handschuh and
S. Staab, editors, Annotation for the Semantic Web,
volume 96 of Frontiers in Arti(cid:12)cial Intelligence and
Applications. IOS Press, Amsterdam, 2003.

[12] S. B. Palmer. RDF in HTML: Approaches, June 2002.

http://infomesh.net/2002/rd(cid:12)nhtml/index.html.
[13] P. Plessers and O. D. Troyer. Annotation for the
semantic web during website development. In 4th
International Conference on Web Engineering, pages
349{353, Munich, Germany, July 2004.

[14] W3C: Frequently Asked Questions about RDF: How

do I put some RDF into my HTML pages?, September
2004. http://www.w3.org/RDF/FAQ/#How.

[15] W3C: RDF issue tracking: Issue faq-html-compliance:

The suggested way of including RDF meta data in
HTML is not compliant with HTML 4.01 or XHTML,
January 2004. http://www.w3.org/2000/03/rdf-
tracking/#faq-html-compliance.

[16] R. Worden. Meaning De(cid:12)nition Language (MDL),

Version 2.06, July 2002.
http://www.charteris.com/XMLToolkit/Downloads/
MDL206.pdf.

