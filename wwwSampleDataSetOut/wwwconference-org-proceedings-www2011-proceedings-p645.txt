A Better Uncle For OWL

Nominal Schemas for Integrating Rules and Ontologies

Markus Krötzsch
University of Oxford

markus.kroetzsch@comlab.ox.ac.uk

ABSTRACT
We propose a description-logic style extension of OWL 2
with nominal schemas which can be used like “variable nom-
inal classes” within axioms. This feature allows ontology lan-
guages to express arbitrary DL-safe rules (as expressible in
SWRL or RIF) in their native syntax. We show that adding
nominal schemas to OWL 2 does not increase the worst-case
reasoning complexity, and we identify a novel tractable lan-
guage SROELV 3(⊓,×) that is versatile enough to capture
the lightweight languages OWL EL and OWL RL.

Categories and Subject Descriptors
I.2.4 [Knowledge Representation Formalisms
and Methods]: Representation languages; F.4.1 [Mathe-
matical Logic]: Computational logic

General Terms
Languages, Complexity, Algorithms

Keywords
Web Ontology Language, Description Logic, SROIQ, Se-
mantic Web Rule Language, Datalog, tractability

1.

INTRODUCTION

Despite signiﬁcant recent progress, the search for a sat-
isfactory integration of ontologies and rules for the Seman-
tic Web is still ongoing [17, 23]. After the publication of
the 2004 W3C Recommendation for the Web Ontology Lan-
guage OWL [29], discussion of the problem centered on the
uncle rule

brotherOf(x, y) ∧ parentOf(y, z) → uncleOf(x, z),

which is easy to state using a simple rule language such as
Datalog, but which cannot be modeled at all in the 2004
version of OWL. From the perspective of OWL design cri-
teria, a core diﬃculty in allowing unrestricted Datalog rules
along with OWL axioms is that it leads to undecidability of
reasoning in the resulting combined language.

Subsequently, a signiﬁcant body of work has developed,
investigating the integration of description logics (DLs) [1],
which form the basis for OWL, and rule languages (typically
Datalog). Conceptually, one can distinguish two approaches.

Copyright is held by the International World Wide Web Conference Com-
mittee (IW3C2). Distribution of these papers is limited to classroom use,
and personal use by others.
WWW 2011, March 28–April 1, 2011, Hyderabad, India.
ACM 978-1-4503-0632-4/11/03.

Frederick Maier, Adila A. Krisnadhi,

Pascal Hitzler

Kno.e.sis Center, Wright State University
{fred,adila,pascal}@knoesis.org

On the one hand, description logics have been extended with
additional “description-logic-style” expressive features which
make it possible to express certain types of rules. OWL 2
[36], the 2009 revision of the OWL W3C Recommendation,
in fact can express the uncle rule mentioned above. By
combining new features of OWL 2, many rules with a tree-
shaped body can be expressed indirectly [26]. Decidability is
nevertheless retained. Many rules, however, such as
hasParent(x,y)∧hasParent(x,z)∧married(y,z) → C(x) (1)
which deﬁnes a class C of children whose parents are mar-
ried, are still not expressible.

On the other hand, there are approaches of a hybrid na-
ture, in the sense that both OWL axioms and rules are syn-
tactically allowed in ontologies, and a combined formal se-
mantics deﬁnes how the hybrid language is to be understood.
As already mentioned, such a combination generally leads to
undecidability. This is the case for the Semantic Web Rule
Language SWRL [19, 20], which is the most straightforward
rule extension of OWL, and for the combination of OWL DL
ontologies and the Rule Interchange Format RIF (even when
restricted to RIF Core) [4, 11]. A prominently discussed idea
for retaining decidability is to restrict the applicability of
rules to named individuals, i.e., to logical constants that are
explicitly mentioned in the ontology. Rules that are under-
stood in this sense are called DL-safe, and the combination
of OWL DL and DL-safe rules is indeed decidable [19, 33].
A generalization of DL-safe rules has been introduced in
[27] in the form of DL-safe variables, as part of the deﬁnition
of the tractable rule language ELP. Rather than restricting
all variables in a (DL-safe) rule to binding only to known
individuals, DL-safe variables allow the ontology engineer to
explicitly specify the variables to be treated this way. This
approach was subsequently generalized to obtain DL+safe
Rules as a class of expressive rule languages for which rea-
soning is still decidable [23].

In this paper, we expand on the above idea and improve
it in several ways. The key technical innovation is the in-
troduction of nominal schemas as new elements of DL syn-
tax. While the semantic intuition behind nominal schemas
is the same as that behind DL-safe variables, the diﬀerence
lies in the fact that DL-safe variables are tied to rule lan-
guages, while nominal schemas integrate seamlessly with DL
syntax. As a consequence, the language which we propose
encompasses DL-safe variable SWRL while staying within
the DL/OWL language paradigm.
It thus achieves within
the DL framework what has hitherto only been achieved by
hybrid approaches.

WWW 2011 – Session: Query and Ontology LanguagesMarch 28–April 1, 2011, Hyderabad, India645To give an initial example, consider again the rule (1)

extended by the axioms

hasParent(mary, john)
(∃hasParent.∃married.{john})(mary)

(2)

(3)

Axiom (2) asserts that John is a parent of Mary, while axiom
(3) states that Mary belongs to the class of individuals with
some (unnamed) parent who is married to John. Using a
ﬁrst-order logic semantics as in SWRL, rule (1) would thus
entail that Mary belongs to the class C. Interpreting rule
(1) as DL-safe, however, does not allow this conclusion, since
John’s spouse is not named by any constant in the ontology.
To retain the conclusion, one can weaken this restriction to
require only z to be DL-safe, while x and y can still take
arbitrary values. This is possible in the rule-based approach
of DL+safe Rules, but cannot be captured in an axiom of
existing description logics.

In contrast, using nominal schemas, rule (1) can be ex-

pressed as

∃hasParent.{z} ⊓ ∃hasParent.∃married.{z} ⊑ C.

(4)
The desired conclusion again follows. The expression {z} is
a nominal schema, which is to be read as a variable nominal
that can only represent nominals (i.e., z binds to known in-
dividuals), where the binding is the same for all occurrences
of the nominal schema in an axiom.

The main contributions of this paper are as follows:

1. We introduce nominal schemas as a new general con-
structor for description logics, denoted by the letter
V in the DL nomenclature, and deﬁne the expressive
DL SROIQV as an extension of the description logic
SROIQ underlying OWL 2.

2. We establish the complexity of the common reasoning
tasks to be N2ExpTime-complete, and thus not harder
than OWL 2 regarding worst-case complexity, even in
the DL SROIQV (Bs,×) that adds role constructors
to SROIQV.

3. We deﬁne SROELV n(⊓,×) (n ≥ 0) as a new fam-
ily of DLs with nominal schemas for which reasoning
is possible in polynomial time. In particular, the DL
SROELV 3(⊓,×) is expressive enough to incorporate
OWL EL and OWL RL, and to allow restricted seman-
tic interaction between the two.

The expressivity of nominal schemas is also witnessed by
the fact that it allows DLs to incorporate arbitrary DL-safe
rules, given that concept intersections, existential role re-
strictions, and the universal (top) role are available. Since
such rules preclude polytime reasoning, our tractable DLs
SROELV n(⊓,×) employ restrictions on the number of cer-
tain occurrences of nominal schemas in each axiom.

The close relationship to nominals suggests simple ways of
introducing nominal schemas into concrete syntactic forms
of OWL 2, e.g. by using the existing syntax for nominal
classes with special individual names that represent vari-
ables (using some suitable naming convention). This opens
a path for introducing this feature into practical applica-
tions. While the above worst-case complexity result for
SROIQV (Bs,×) may seem encouraging, we believe that
the tractable ontology language SROELV 3(⊓,×) is the most
promising candidate for implementations.

The paper is structured as follows. In Section 2 we intro-
duce the syntax and semantics of nominal schemas based on
the expressive DL SROIQV (Bs,×). The reasoning com-
plexity of SROIQV (Bs,×) is studied in Section 3. Sec-
tion 4 and 5 introduce the DLs SROELV n(⊓,×) and es-
tablish their tractability.
In Section 6 we show how DL-
safe rules can be expressed with nominal schemas, based on
which we can explain the relationship of SROELV 3(⊓,×)
and the tractable proﬁles of OWL 2 in Section 7. We ﬁnish
by discussing further related work (Section 8) before pre-
senting our conclusions (Section 9).

2. NOMINAL SCHEMAS FOR OWL

We start by introducing nominal schemas as an extension
of existing description logics. Our deﬁnition of the resulting
DL is self-contained but cannot replace introductory texts
like [1, 16, 23]. The Web Ontology Language OWL 2 DL
is based on the description logic SROIQ1 but we base our
extension on the slightly more expressive SROIQ(Bs,×).
This DL extends SROIQ with boolean constructors (¬,
⊓, ⊔) on simple roles, and with concept products C × D
that allow the construction of roles as Cartesian products
of concepts. It has been shown that this extension does not
increase worst-case complexities of reasoning [23, 39].
The DL languages we study are based on a signature
Σ = ⟨NI , NC , NR, NV ⟩, where NI , NC , NR, and NV are
ﬁnite and pairwise disjoint sets of individual names, concept
names, role names, and variables. The set NR is partitioned
into disjoint sets N s
R of non-
simple role names.

R of simple role names and N n

For the rest of this paper, we assume that a signature Σ
has been ﬁxed and so omit further references to it. The
basic building blocks of DLs are concepts and (simple or
non-simple) roles:

De(cid:12)nition 1. The sets C of SROIQV (Bs,×) concepts
and R (Rs/Rn) of (simple/non-simple) SROIQV (Bs,×)
roles are deﬁned by the following grammar:
R | (N s
− | U | ¬Rs | Rs ⊓ Rs | Rs ⊔ Rs | NC×NC
Rs ::= N s
R)
R | (N n
− | U | NC × NC
Rn ::= N n
R)
R ::= Rs | Rn
C ::= ⊤ | ⊥ | NC | {NI} | {NV } | ¬C | C ⊓ C | C ⊔ C |

∃R.C | ∀R.C | ∃Rs.Self | 6k Rs.C | >k Rs.C

where k is any non-negative integer. The constant U is the
universal role, and ⊤ and ⊥ are the top and bottom con-
cepts. Concepts {a} with a ∈ NI are called nominals, and
concepts {x} with x ∈ NV are called nominal schemas. The
set RC×D = {C × D | C, D ∈ C} ⊆ R is the set of all
concept products.
R∪N n
R are called inverse
roles. We deﬁne a function Inv : R → R as follows: For R ∈
) := R. For R, S ∈ R, set
NR, set Inv(R) := R
Inv(R⊓S) := Inv(R)⊓Inv(S), Inv(R⊔S) := Inv(R)⊔Inv(S),
and Inv(¬R) := ¬Inv(R). Set Inv(U ) := U and Inv(C × D) :
= D × C for C, D ∈ C.

Roles of the form R
−

with R ∈ N s
−

−

and Inv(R

SROIQV (Bs,×) knowledge bases are constructed from

axioms as follows.

1The exact relationship is explained in [16]. Here we just
note that OWL classes and properties are called concepts
and roles in DL.

WWW 2011 – Session: Query and Ontology LanguagesMarch 28–April 1, 2011, Hyderabad, India646De(cid:12)nition 2. Given roles R, Si ∈ R, a generalized role
inclusion axiom (RIA) is a statement of the form S1 ◦ ··· ◦
Sk ⊑ R, with either R /∈ Rn, or k = 1 and S1 ∈ Rs. A set
of RIAs is regular if there is a strict partial order ≺ on R
such that

• if R /∈ {S, Inv(S)}, then S ≺ R if and only if Inv(S) ≺

R; and

• every RIA has the form R ◦ R ⊑ R, Inv(R) ⊑ R,
R◦S1◦···◦Sk ⊑ R, S1◦···◦Sk◦R ⊑ R, or S1◦···◦Sk ⊑
R, with R, Si ∈ R and Si ≺ R for each i ∈ {1, . . . , k}.
An RBox axiom is a RIA. A TBox axiom (or general con-
cept inclusion axiom, GCI ) is an expression C ⊑ D where
C, D ∈ C. An ABox axiom is any expression of the form
C(a) or R(a, b) where C ∈ NC , R ∈ NR, and a, b ∈ NI . A
SROIQV (Bs,×) axiom is any ABox, TBox, or RBox ax-
iom, and a SROIQV (Bs,×) knowledge base is a regular set
of SROIQV (Bs,×) axioms.

Some presentations of SROIQ also include RBox axioms
for role characteristics which we omit here as they can al-
ready be expressed in SROIQV (Bs,×) anyway: the empty
(bottom) role E (∃E.⊤ ⊑ ⊥), role disjointness disj(S1, S2)
(S1 ⊓ S2 ⊑ E), asymmetry (disj(S, Inv(S)), reﬂexivity (⊤ ⊑
∃Saux.Self, Saux ⊑ R), irreﬂexivity (∃S.Self ⊑ ⊥), symmetry
(Inv(R) ⊑ R), transitivity (R ◦ R ⊑ R).
An example of a SROIQV (Bs,×) TBox axiom has been
given as axiom (4) above, where {z} is a nominal schema.
Intuitively, each nominal schema appearing in an axiom is
universally quantiﬁed, but ranges only over elements that
are referred to by an individual name.

I

I

I

I

De(cid:12)nition 3. An interpretation I = (∆

,·I
I ̸= ∅ and a function ·I

) consists of a
domain of discourse ∆
which maps
NC , NR, and NI to elements, sets, and relations of ∆
as
shown in Table 1. A variable assignment Z for an inter-
pretation I is a function Z : NV → ∆
such that for each
v ∈ NV , Z(v) = a
for some a ∈ NI . For any interpretation
I, assignment Z, and C(i) ∈ C, R(i) ∈ NR, t(i) ∈ T, the
function ·I;Z
I and Z satisfy a SROIQV (Bs,×) axiom α, written
I,Z |= α, if the corresponding condition shown in Table 1
holds. I satis(cid:12)es α, written I |= α, if I,Z |= α for all vari-
able assignments Z for I. I satis(cid:12)es a SROIQV (Bs,×)
knowledge base KB, written I |= KB, if I |= α for all
α ∈ KB, and KB is satis(cid:12)able if such an I exists. The
axiom α is entailed by KB, written KB |= α, if all models of
KB are also models of α.

is deﬁned as shown in Table 1.

The logic SROIQ(Bs) is obtained from SROIQV (Bs,×)
by disallowing nominal schemas; concept products are al-
ready covered by SROIQ(Bs) since they can be simulated
using role negations [39]. The logic SROIQ is in turn ob-
tained from SROIQ(Bs) by disallowing boolean role con-
structors. In Section 6, we show that SROIQV (Bs,×) is
also expressive enough to encompass DL-safe rules (and thus
DL-safe SWRL and DL-safe RIF-Core).

We note that it is straightforward to introduce nominal
schemas into the normative RDF syntax for OWL 2 [37].
One way to do this would be to provide URIs for vari-
ables in the OWL namespace, used instead of individuals
in owl:oneOf statements (which are used for the RDF syn-
tax for nominals in OWL 2).

3. REASONING WITH SROIQV (Bs;×)
We now show that the standard inferencing problems for
SROIQV (Bs,×) knowledge bases are decidable and have
the same worst-case complexity as for SROIQ. Speciﬁcally,
they are N2ExpTime-complete.

Many common inference problems for DLs require us to
check whether a certain axiom or set of axioms is entailed by
the given knowledge base. For example, a concept C is sub-
sumed by a concept D if C ⊑ D is entailed. It is well known
that such entailment questions can be reduced to checking
knowledge base satisﬁability, i.e. asking whether some axiom
is entailed is the same as asking if some (modiﬁed) knowl-
edge base is satisﬁable; see [1, 23] for details. Hence we focus
on satisﬁability checking only.
Reasoning with SROIQV (Bs,×) knowledge bases can be
simpliﬁed by ﬁrst grounding them, i.e. eliminating nominal
schemas by replacing them with the (ﬁnitely many) nom-
inals that they can represent. Reasoning in the resulting
SROIQ(Bs) knowledge base is then possible as in [39].

De(cid:12)nition 4. If α is a SROIQV (Bs,×) axiom, then its
grounding ground(α) is the set of all axioms that can be
obtained by uniformly replacing nominal schemas in α with
nominals of the given signature. Given a SROIQV (Bs,×)
knowledge base KB, ground(KB) :=

∪

(cid:11)∈KB ground(α).

Theorem 1. A SROIQV (Bs,×) knowledge base KB is
satis(cid:12)able if and only if ground(KB) is satis(cid:12)able. In partic-
ular, checking satis(cid:12)ability of SROIQV (Bs,×) knowledge
bases is decidable.
Proof. Consider any interpretation I of the signature,
which is the same for KB and ground(KB). For any TBox
axiom C ⊑ D ∈ KB and a variable assignment Z for I, it
is clear that I,Z |= C ⊑ D iﬀ I |= C
′ ⊑
where C
′ ∈ ground(KB) was obtained from C ⊑ D by replacing
D
each nominal schema {x} with a nominal {c} such that c
I
=
Z(x). A suitable constant c must exist for Z by Deﬁnition 3.
Conversely, every uniform replacement of nominal schemas
in C ⊑ D corresponds to a choice of Z. We conclude that
I |= C ⊑ D iﬀ I |= ground(C ⊑ D). Analogous arguments
apply to ABox and RBox axioms, showing the ﬁrst part of
the claim.
The second part follows as ground(KB) is a SROIQ(Bs)

′ ⊑ D

′

knowledge base, so satisﬁability can be checked as in [39].

Intuitively, every SROIQV (Bs,×) axiom represents an
exponential number of SROIQ(Bs) axioms that are ob-
tained by grounding. This yields an upper bound for the
complexity of reasoning with SROIQV (Bs,×) that is expo-
nentially larger than that of SROIQ(Bs), i.e. N3ExpTime.
We now prove that this result can be reﬁned to obtain an
N2ExpTime upper complexity bound, showing that this
reasoning problem must be N2ExpTime-complete. To ac-
complish this, we extend the original proof for the worst-case
complexity of SROIQ [22].
We ﬁrst recall the complexity proof of [22], including its
extension to SROIQ(Bs) [39]. The proofs are based on
an exponential reduction of DL knowledge bases to theo-
ries of C2, the two-variable fragment of ﬁrst-order logic with
counting quantiﬁers, for which satisﬁability can be checked
in NExpTime [38]. The reduction proceeds in three steps:
(1) axioms are transformed into a simpliﬁed normal form,
(2) complex RIAs are eliminated, and (3) the resulting ax-
ioms are expressed as formulae of C2.

WWW 2011 – Session: Query and Ontology LanguagesMarch 28–April 1, 2011, Hyderabad, India647Table 1: Semantics of SROIQV (Bs,×)

I

Name

concept name
role name
individual name
variable

A
V
a
x
⊤
top
⊥
bottom
{t}
nominal (schema)
∃R.C
existential restriction
∀R.C
universal restriction
∃R.Self
self restriction
¬C
concept complement
C ⊓ D
concept conjunction
C ⊔ D
concept disjunction
qualiﬁed number restrictions 6n R.C
>n R.C

universal role
inverse role
concept product
role negation
role conjunction
role disjunction

concept assertion (ABox)
role assertion (ABox)
TBox axiom
RBox axiom (RIA)

I;Z

I

I;Z}

I;Z}

Syntax

I;Z}
and ϵ ∈ C
we have ϵ ∈ C

Semantics
I ⊆ ∆
I
A
I ⊆ ∆
I × ∆
V
I ∈ ∆
I
a
Z(x) ∈ ∆
I
I
∆
∅
{t
I;Z}
{δ | there is ϵ with ⟨δ, ϵ⟩ ∈ R
{δ | for all ϵ with ⟨δ, ϵ⟩ ∈ R
I;Z
{δ | ⟨δ, δ⟩ ∈ R
I \ C
I;Z
∆
I;Z ∩ D
I;Z
C
I;Z ∪ D
I;Z
C
{δ | #{⟨δ, ϵ⟩ ∈ R
{δ | #{⟨δ, ϵ⟩ ∈ R
I × ∆
∆
{⟨δ, ϵ⟩ | ⟨ϵ, δ⟩ ∈ V
{⟨δ, ϵ⟩ | δ ∈ A
I;Z
I × ∆
) \ R
I
I;Z
(∆
I;Z ∩ S
I;Z
R
I;Z ∪ S
I;Z
R
I;Z ∈ A
A(t)
t
⟨t
I;Z
V (t, u)
, u
C ⊑ D
I;Z ⊆ D
C
R ⊑ S
I;Z ⊆ S
R
R1 ◦ ··· ◦ Rn ⊑ S R
I;Z
where ‘◦’ denotes the usual composition of binary relations
1

U
−
V
A × B
¬R
R ⊓ S
R ⊔ S

I;Z
I;Z
◦ ··· ◦ R

I;Z}
and ϵ ∈ B

I;Z | ϵ ∈ C
I;Z | ϵ ∈ C

I;Z} ≤ n}
I;Z} ≥ n}

I;Z
I;Z⟩ ∈ V

n ⊆ S
I;Z

I;Z

I;Z}

I;Z

I an interpretation; Z a variable assignment for I; A, B ∈ NC ; C, D ∈ C; V ∈ NR; R(i), S ∈ R; a ∈ NI ;
x ∈ NV ; t, u ∈ T.

d

Ai ⊑⊔

Bj
A ≡ {a}
A ≡ ∃S.Self

Step (1) yields an equisatisﬁable knowledge base that con-
tains only axioms of the following forms:
A ⊑ ∀R.B
A ⊑ >n S.B
A ⊑ 6n S.B
where R(i) ∈ NR and S1, S2 ∈ Rs, and C ≡ D is short for
{C ⊑ D, D ⊑ C}. This normalization can be done in linear
time; see [39] for details. The only axioms that are not read-
ily expressed in C2 are complex RIAs. They are eliminated
next, with exponential eﬀort.

S1 ⊑ S2
R1 ⊑ R
−
R1 ◦ ··· ◦ Rn ⊑ R

Step (2) applies a technique from [12] using nondetermin-
istic ﬁnite automata (NFA) to represent RIAs that entail
non-simple roles. Suitable NFA for SROIQ were deﬁned in
[18, 21]. We do not repeat the details of this construction
here, and merely quote the essential results. Proofs for the
following facts can be found in [18] and the accompanying
technical report.

Fact 1. Consider a SROIQ knowledge base KB. For
R, there is an NFA AR
each (possibly inverse) role R ∈ N n
over the alphabet NR such that the following holds for every
model I of KB, and for every word S1 . . . Sn accepted by AR:
If ⟨δi, δi+1⟩ ∈ S
I
.

for all i = 1, . . . , n, then ⟨δ1, δn+1⟩ ∈ R

I
i

Moreover, let ≺ denote a strict linear order that witnesses
regularity of KB as required in De(cid:12)nition 2. For each R ∈
R, the number of states of AR is bounded exponentially in
N n
the depth of KB that is de(cid:12)ned as:

max{n | there are S1 ≺ . . . ≺ Sn such that

Ti1 ◦ . . . ◦ Si ◦ . . . ◦ Timi

⊑ Si+1 ∈ KB}

It suﬃces to construct the respective NFA for non-simple
roles, and our additional role expressions thus do not in-
terfere with this construction. Now step (2) proceeds by
replacing every axiom of the form A ⊑ ∀R.B by the follow-
ing set of axioms, where AR is the NFA as introduced above,
and Xq are fresh concept names for each state q of AR:

A ⊑ Xq
Xq ⊑ ∀S.Xq′
Xq ⊑ B

q is the initial state of AR
AR has a transition q S→ q
q is a ﬁnal state of AR

′

Moreover, all complex RIAs of the form S1 ◦ . . . ◦ Sn ⊑ R
with n ≥ 2 are deleted. The number of new axioms (and
fresh concept names) that are introduced for each axiom of
the form A ⊑ ∀R.B is bounded by the sum of the number of
states and transitions in AR, and the number of transitions
in turn is linear in the number of role names and states. Ac-
cording to Fact 1, the number of axioms introduced for each
axiom A ⊑ ∀R.B is exponentially bounded in the depth of

WWW 2011 – Session: Query and Ontology LanguagesMarch 28–April 1, 2011, Hyderabad, India648the knowledge base. The overall size of the knowledge base
after step (2) therefore is bounded by a function that is lin-
ear in the size of the knowledge base and exponential in the
depth of the knowledge base.
Step (3), ﬁnally, is a simple rewriting to C2 that does not
increase the size of the knowledge base. To obtain the main
result of this section, it suﬃces to observe that grounding
does not increase the depth of the knowledge base:

Theorem 2. The problem of deciding satis(cid:12)ability in

SROIQV (Bs,×) KBs is N2ExpTime-complete.
Proof. By adopting a result from [23, Proposition 5.2.1],
one can show that for each SROIQV (Bs,×) knowledge base
KB, one can ﬁnd an equisatisﬁable SROIQV (Bs,×) knowl-
edge base without ×, the size of which is linear in the size
of KB. Thus assume that KB has no concept products. The
depth of KB is only aﬀected by RBox axioms. In the ab-
sence of concept products, RBox axioms are not aﬀected by
grounding, hence the depth of ground(KB) is equal to the
depth of KB.
Since ground(KB) is in SROIQ(Bs), one can apply the
transformation steps (1)–(3). This yields a C2 theory T that
is equisatisﬁable to ground(KB) [39] and thus to KB (The-
orem 1). The size of T is linear in the size of ground(KB)
and exponential in the depth of KB. Both measures are
exponential in the size of KB, and so is T . Deciding satis-
ﬁability of T can be done in NExpTime [38], thus deciding
satisﬁability of KB in N2ExpTime.
SROIQV (Bs,×) includes SROIQ, for which deciding
satisﬁability is N2ExpTime-hard [22]. From this, hardness
follows.

4. A TRACTABLE FRAGMENT
The result that reasoning in SROIQV (Bs,×) has the
same worst-case complexity as SROIQ (and OWL 2) is
encouraging, yet we are far from a practical reasoning pro-
cedure for this DL. In particular, Theorem 2 is based on
a procedure that still takes exponentially longer than the
original approach for SROIQ, without this aﬀecting the
worst-case complexity.
In this section, we therefore focus
on identifying cases where inferencing is possible in polyno-
mial time. This still leads to a rather expressive tractable
DL. Subsequent sections will highlight the relationship to
the tractable proﬁles of OWL 2.
Concretely, we deﬁne DLs SROELV n(⊓,×) for each in-
teger n ≥ 0, n restricting the number of “problematic” oc-
currences of nominal schemas detailed below. The DLs are
based on the tractable DL SROEL(⊓,×),
introduced as
In essence, SROEL(⊓,×)
an extension of OWL EL [24].
is SROIQ(Bs) restricted to operators ⊓, ∃ (possibly with
Self), ◦, and some uses of ×. To preserve tractability when
adding nominal schemas, we must avoid the increase in the
number of axioms during grounding, which is exponential in
the number of nominal schemas per axiom.

Unfortunately, one cannot reduce the number of nominal
schemas by normal form transformations in general, since
they represent complex dependencies that cannot be sim-
pliﬁed. But there are special cases where nominal schemas
on the left-hand side of TBox axioms can be eliminated,
or separated using independent axioms. One such case was
identiﬁed in [27] for the rule language ELP: if the dependen-
cies expressed in a rule body are tree-shaped then the rule
can always be reduced to a small set of normalized rules

with a limited number of variables in each. For example,
a rule body that consists of a conjunction A(x) ∧ R(x, z) ∧
S(x, y) ∧ B(y) ∧ T (y, z) is not tree-shaped since there are
parallel paths x R→ z and x S→ y T→ z in the corresponding
dependency structure.
In our case, binary predicates are
role names, unary predicates are concept names, and con-
stant symbols correspond to nominals. Variables can either
be “hidden” in the structure of the DL concept expression,
or occur explicitly as nominal schemas (the latter are called
DL-safe variables in ELP). For example, the above rule body
can be expressed as a concept A⊓∃R.{z}⊓∃S.(B⊓∃T.{z}).
Here, we do not introduce tree-shaped dependency struc-
tures as a general mechanism for ensuring that normal form
transformations are possible, and merely identify suﬃcient
conditions for which this is the case. This allows us to pro-
vide somewhat simpler proofs. An obvious condition that
implies tree-shaped dependencies is that a nominal schema
occurs only once, and only on the left-hand side of a TBox
axiom. As in [27], the tree-shape only refers to variables
(DL-safe or not), not to constants, in rule bodies. This
means that nominals (our syntax for constants) disconnect
a concept’s dependency structure. E.g., if B in the above
rule body is replaced by a nominal {a}, then the concept
would be tree-shaped. In such a case, we say that the nom-
inal {z} occurs in a safe environment, as deﬁned next.

De(cid:12)nition 5. An occurrence of a nominal schema {x} in
a concept C is safe if C has a sub-concept of the form
{a} ⊓ ∃R.D for some a ∈ NI , such that D contains the
occurrence of {x} but no other occurrence of any nominal
schema. In this case, {a} ⊓ ∃R.D is a safe environment for
this occurrence of {x}. S(a, x) will sometimes be used to
denote an expression of the form {a} ⊓ ∃R.D within which
{x} occurs safely.
A nominal schema {x} is safe for a SROIQV (Bs,×)
TBox axiom C ⊑ D if {x} does not occur in D, and at
most one occurrence of {x} in C is not safe.

De(cid:12)nition 6. Let n ≥ 0. A SROELV n(⊓,×) concept is a
SROIQV (Bs,×) concept that may contain ⊤, ⊥, ⊓, ∃, Self,
nominals and nominal schemas, but which does not con-
tain ⊔, ¬, ∀, 6k , and >k . SROELV n(⊓,×) roles (simple
or non-simple) are SROIQV (Bs,×) roles (simple or non-
simple) that may contain ⊓ (for simple roles) and U but no
inverse roles, ⊔, or ¬.
A SROELV n(⊓,×) TBox axiom is a SROIQV (Bs,×)
TBox axiom α that uses SROELV n(⊓,×) concepts only,
and where at most n nominal schemas are not safe for α.
An RBox axiom of SROELV n(⊓,×) is an RBox axiom of
SROIQV (Bs,×) using only SROELV n(⊓,×) roles. An
ABox axiom of SROELV n(⊓,×) is the same as an ABox
axiom of SROIQV (Bs,×).
For a knowledge base KB and role R ∈ NR, let ran(R) be
the set of all concepts B ∈ NC for which there is a set of the
form {R ⊑ R1, R1 ⊑ R2, . . . , Rn−1 ⊑ Rn, Rn ⊑ A × B} ⊆
KB with n ≥ 0 and R0 = R. KB is a SROELV n(⊓,×)
knowledge base if R1◦···◦Rn ⊑ S implies ran(S) ⊆ ran(Rn),
and R1 ⊓ R2 ⊑ S implies ran(S) ⊆ ran(R1) ∪ ran(R2).

The additional condition using ran is called admissibility
of range restrictions, see [24] for details. As explained below,
restricting to at most n non-safe nominal schemas per axiom
ensures that at most |NI|n axioms are introduced during
grounding. We will ﬁx n at a constant small value, so this

WWW 2011 – Session: Query and Ontology LanguagesMarch 28–April 1, 2011, Hyderabad, India649ll

increase is polynomial. It is easy to see that axiom (4) is an
example of a SROELV 1(⊓,×) axiom.
5. REASONING WITH SROELV n(⊓;×)
If n is constant, the problem of checking satisﬁability in
SROELV n(⊓,×) is possible in polynomial time w.r.t. the
size of the knowledge base. To show this, we provide a poly-
nomial transformation to the DL SROEL(⊓,×), which was
shown to be tractable in [24].
Let KB be a SROELV n(⊓,×) knowledge base. We deﬁne
a SROEL(⊓,×) knowledge base ground+(KB) as follows.
The RBox and ABox of ground+(KB) are the same as the
RBox and ABox of KB. For each TBox axiom α = C ⊑
D ∈ KB, the following axioms are added to ground+(KB):
1. For each nominal schema {x} safe for α, with safe oc-
currences in environments Si(ai, x) for i = 1, . . . , l,
introduce a fresh concept name Ox;(cid:11). For every indi-
vidual b ∈ NI in KB, ground+(KB) contains an axiom

∃U.Si(ai, b) ⊑ ∃U.({b} ⊓ Ox;(cid:11)),

i=1

where Si(ai, b) denotes Si(ai, x) with {x} replaced by
{b}, and the empty conjunction (l = 0) denotes ⊤.

′

2. A concept C

′

is obtained from C as follows. Initialize
:= C. For each nominal schema {x} that is safe for
C
by {a};
α: (a) replace all safe occurrences S(a, x) in C
(b) replace the non-safe occurrence (if any) of {x} in
′ ⊓ ∃U.Ox;(cid:11). After these
′
C
contains only nominal schemas that are not
steps, C
′ ⊑ D.
safe for α, and neither for C
′ ⊑ D) to ground+(KB).

Now add axioms ground(C

by Ox;(cid:11); (c) set C

:= C

′

′

′

Theorem 3. Given a SROELV n(⊓,×) knowledge base
KB, the size of ground+(KB) is exponential in n and poly-
nomial in the size of KB.

Proof. The size of the RBox and ABox of ground+(KB)
is linear in the size of KB and does not depend on n.
If
m is the number of individual names in KB, then step 1
above introduces at most mk axioms for each axiom α with
k nominal schemas. This is polynomial in the size of KB.
The second step introduces |ground(C
′ ⊑ D)| many axioms,
and hence at most mn axioms for each α.

Theorem 4. A SROELV n(⊓,×) knowledge base KB is

satis(cid:12)able if and only if ground+(KB) is satis(cid:12)able.
Proof. We ﬁrst introduce some notation to simplify the
proof. Let C be a SROELV n(⊓,×) concept. A position is a
word p ∈ {1, 2}∗
. The sub-concept C|p of C at position p is
deﬁned recursively, where ε denotes the empty word: D|" :=
D; (D1 ⊓ D2)|pi := Di|p (i ∈ {1, 2}); ∃R.D|p1 := D|p. The
positions of C are the positions p for which C|p is deﬁned.
Consider an interpretation I and variable assignment Z such
that δ ∈ C
. We non-deterministically
deﬁne witnesses δp ∈ ∆
for all positions p of C, such that
δp ∈ (C|p)
. Set δ" := δ. For the recursion, assume that
δp has been deﬁned. If C|p = D1 ⊓ D2, then δp1 := δp and
δp2 := δp. If C|p = ∃R.D, then δp ∈ (C|p)
implies that
and ϵ ∈ D
there is some ϵ with ⟨δp, ϵ⟩ ∈ R
. Set δp1 := ϵ.
Below, the selection of δp is always assumed to be arbitrary
but ﬁxed. To clarify the context, we say that δp is a witness

for some δ ∈ ∆

I;Z
I;Z

I;Z

I;Z

I

I

I

.

I;Z

I;Z

d

for δ ∈ C
of I that satisﬁes the semantic conditions for δ ∈ C

. Intuitively, δp thus witnesses a substructure
An interpretation I for ground+(KB) is O-minimal if the
following holds for all concept names Ox;(cid:11) introduced in step
I ̸=
1 and all b ∈ NI in KB: I |= Ox;(cid:11)(b) iﬀ
∅ (using the notation from step 1). Clearly, every model
of KB can be extended to an O-minimal interpretation of
ground+(KB). Conversely, if ground+(KB) is satisﬁable, it
surely has an O-minimal model. Namely, any model can
be made O-minimal by reducing the extensions of Ox;(cid:11) as
required. This does not aﬀect the truth of other axioms,
since Ox;(cid:11) only occurs in positive (non-negated) positions in
the premise of TBox axioms – reducing its extension makes
the premise smaller while not aﬀecting the conclusion.

∃U.Si(ai, b)

l
i=1

I;Z

I

′

′

= D

.

I;Z′

′I;Z′

′I;Z′
I;Z

′ ⊑ D and ground(C

So the claim can be obtained by showing: the O-minimal
extension of every model of KB is a model of ground+(KB),
and every O-minimal model of ground+(KB) is a model of
KB if we ignore the interpretation of concepts Ox;(cid:11). This
can be shown individually for each axiom of KB. It is im-
mediate for ABox and RBox axioms.
Now consider a TBox axiom α = C ⊑ D ∈ KB, and
′ ⊑ D constructed in step 2. By the proof of
the axiom C
′ ⊑ D)
Theorem 1, the models of C
are the same. To complete the proof, we show that an O-
′ ⊑ D. This
minimal model satisﬁes C ⊑ D iﬀ it satisﬁes C
is implied by the following property (∗): given an O-minimal
interpretation I of ground+(KB), we ﬁnd that δ ∈ C
for
some variable assignment Z iﬀ δ ∈ C
for some variable
assignment Z′
, where assignments in either direction of the
I;Z′
I;Z
claim can be chosen such that D
Indeed, if
I |= C ⊑ D and δ ∈ C
, then by (∗) we obtain Z with
, and δ ∈ D
, thus δ ∈ D
δ ∈ C
. The reverse
direction is similar.
We show both directions of (∗) by induction over the steps
used to construct C
from C. The claim holds initially when
C = C
. Now consider the modiﬁcations (a)–(c) for one
nominal schema {x} that is safe for α, and let C0, Ca, Cb,
and Cc denote C
in its initial state and after each of the
steps (a)–(c).
. We show
:= Z. Let Si(ai, x) be as in step 1.
δ ∈ C
̸= ∅, we
I;Z
Since all Si(ai, x) are sub-concepts of C0 and C
0
can apply our initial construction of witnesses δp to conclude
Si(ai, b)
=
Z(x). As I satisﬁes the axioms of step 1 (by O-minimality),
this shows ∃U.O
. Now
Cb is obtained by replacing sub-concepts E of C0 by concepts
′
in (a) and (b). Since all such E occur positively in C0, the
E
I;Z ⊆ E
claim follows from E
. For (a) this follows since
∈ {ai}I
. For (b), we have E = {x}, and thus
I
δSi(ai;x) = a
. Hence δSi(ai;x) ∈ Si(ai, b) for all i ∈ {1, . . . , l}
Z(x) = b
i
I;Z ⊆ E
follows the fact that I satisﬁes the axioms
′I;Z
so E
of step 1.
introduced in (c), we have ∃U.O
x;(cid:11) ̸= ∅, and
I
thus ∃U.O
I;Z′
If an
occurrence of {x} at position p in Ca was replaced by Ox;(cid:11)
in (b), then set ϵ := δp, where δp is a witness for δ ∈ C
I;Z′
.
Otherwise, if Ca = Cb, then select ϵ ∈ O
I
x;(cid:11) arbitrarily.
Deﬁne Z such that Z(x) = ϵ and Z(y) = Z′
(y) for all y ̸= x.
We claim δ ∈ C
I;Z′
above, and
= C
b

I ̸= ∅ for all i ∈ {1, . . . , l} and some b with b

For the “only if” direction, assume δ ∈ C

For the “if” direction, assume δ ∈ C

, i.e., we set Z′

x;(cid:11) ̸= ∅, so O
I

I;Z
I;Z
c = C
b

. This shows C
c

. We showed C
c

x;(cid:11) = ⊤I
I

. For the concept

I
x;(cid:11) = ∆

. We thus have C

= C
b

I;Z
0

I;Z
0

I;Z
c

I;Z′

I;Z′

c

I;Z′

.

b

′I;Z

I;Z

′

I

I

WWW 2011 – Session: Query and Ontology LanguagesMarch 28–April 1, 2011, Hyderabad, India650I;Z′

I;Z
= C
b

I;Z
b

. Now consider the witnesses δq for δ ∈ C

. Thus
as x does not occur in Cb, we have C
δ ∈ C
I;Z
b
.
b
It is easy to see that the same elements can be chosen as
witnesses for δ ∈ C
, showing that the latter holds. This
follows since ϵ ∈ {x}I;Z
(for the sub-concept replaced in
I
(b)), and since δS(ai;x) = a
(for the sub-concepts
i
replaced in (a)).

∈ {ai}I

I;Z
0

A knowledge base is unsatisﬁable if and only if it entails
{a} ⊑ ⊥ for arbitrary a ∈ NI . This reduces satisﬁability
testing to instance retrieval (checking if a is an instance of
⊥). Using the polynomial time instance retrieval method for
SROEL(⊓,×) from [24] together with Theorems 3 and 4,
we thus obtain the following result. Hardness for P follows
from the hardness of SROEL(⊓,×).

Theorem 5. If KB is a SROELV n(⊓,×) knowledge base
of size s, satis(cid:12)ability of KB can reduced to instance retireval
w.r.t. a set of Datalog rules of size proportional to sn and at
most four variables per rule. If n is constant, the problem is
P-complete.

6. DL-SAFE RULES

As shown here, an interesting feature of nominal schemas
is that they can be used to express arbitrary DL-safe rules
[33]. These are Datalog rules with unary and binary pred-
icates that are restricted – just like nominal schemas – to
apply to domain elements that are represented by individual
names.2 Identifying unary predicates with concept names,
binary predicates with role names, constants with individ-
ual names, and (DL-safe) variables with the variables in
nominal schemas, the syntax of DL-safe rules can be based
on a DL signature. As before, we assume the signature
Σ = ⟨NI , NC , NR, NV ⟩ to be ﬁxed and omit explicit ref-
erences to it. The set of terms T of Σ is NI ∪ NV . We can
now deﬁne the syntax and semantics of DL-safe rules.

De(cid:12)nition 7. A concept atom is an expression of the form
A(t) with t ∈ T and A ∈ NC ∪ {⊤,⊥}. A role atom is an
expression of the form R(s, t) with s, t ∈ T and R ∈ NR.
An atom is a concept or role atom.
If B is a ﬁnite and non-empty set of atoms and H is an
atom, then B → H is a DL-safe rule. B is called the body,
and H is called the head. A DL-safe rule that contains at
most n distinct variables is called an n-variable rule.

I;Z

I;Z ∈ A

, or F = R(s, t) and ⟨s

De(cid:12)nition 8. Interpretations I and variable assignments
Z for DL-safe rules are deﬁned as in Deﬁnition 3. An atom F
is satis(cid:12)ed by I and Z, written I,Z |= F , if either F = A(t)
. A
and t
set of atoms B is satis(cid:12)ed by I and Z, written I,Z |= B, if
I,Z |= F for all F ∈ B.
I satis(cid:12)es a DL-safe rule B → H, written I |= B → H, if
for all assignments Z for I, either I,Z |= H or I,Z ̸|= H.
A set of rules is satisﬁed if all of its elements are. Models,
satisﬁability, and entailment are deﬁned as in Deﬁnition 3.

I;Z⟩ ∈ A

I;Z

I;Z

, t

The above provides a ﬁrst-order logic semantics for DL-
safe rules that is fully compatible with the semantics of

2We here formalize DL-safe rules by restricting permissible
variable assignments. An equivalent alternative is to enforce
this restriction by additional premises in rules. See [16] for
a discussion.

SROIQV (Bs,×):
it uses the same kinds of models. As
such,
it is meaningful to combine DL-safe rules and DL
knowledge bases. The entailment relation is immediate: a
DL-safe rule or DL axiom φ is entailed by a DL knowledge
base KB extended with a set of rules RB if φ is satisﬁed by
all interpretations that satisfy both KB and RB.

DL-safe rules can also be used to capture the fragment of
the rule language Datalog with predicates of arity at most
2, given that we are interested in the ﬁrst-order semantics
of such Datalog rules.
DL-safe rules can be transformed into SROIQV (Bs,×)

axioms as follows.

∪

d

De(cid:12)nition 9. A syntactic transformation dl from atoms
and DL-safe rules to SROIQV (Bs,×) concepts and TBox
axioms is deﬁned as follows. For a unary atom A(t), set
dl(A(t)) := ∃U.({t} ⊓ A);
for a binary atom R(s, t), set
dl(R(s, t)) := ∃U.({s}⊓∃R.{t}). For a DL-safe rule B → H,
F∈B dl(F ) ⊑ dl(H). A set of DL-safe
set dl(B → H) :=
B→H∈RB dl(B → H).
rules RB is translated as dl(RB) :=
The function dl transforms rules into SROELV n(⊓,×)
TBox axioms, where n is the number of variables in the
rule. This ensures that none of the restrictions on simple
and non-simple roles, regularity, or admissibility of ranges
in SROELV n(⊓,×) are violated.
In consequence, dl(RB)
is a SROELV n(⊓,×) knowledge base if RB is a set of n-
variable rules. Before showing that dl actually preserves the
semantics of DL-safe rules, we present a useful lemma.

I;Z

I;Z

= ∆

I;Z ̸= ∅ and dl(F )

; (2) I,Z ̸|= F if and only if dl(F )
I

Lemma 1. For an atom F , interpretation I, and vari-
able assignment Z we have (1) I,Z |= F if and only if
= ∅.
dl(F )
Proof. Since dl(F ) has the form ∃U.D, there are only
I;Z
=
= ∅. Thus (2) is obtained as the contrapos-
Given dl(F ) = ∃U.D, it thus suﬃces to show that I,Z |=
I;Z
is
F iﬀ D
equivalent to (A⊓{t})
I;Z ̸= ∅. For F = R(s, t), the claim is
that ⟨s
I;Z⟩ ∈ R
I;Z ̸=
I;Z
∅. Both claims are clear from Deﬁnitions 3 and 8.

two options: either D
∅ and dl(F )
itive of (1), and we only need to show the latter.

I;Z ̸= ∅. If F = A(t), this claims that t
I;Z

I;Z ∈ A
is equivalent to ({s}⊓∃R.{t})

, or D

= ∆

I;Z

I;Z

I

, t

Theorem 6. The models of a set RB of DL-safe rules are
the same as the models of dl(RB), i.e. RB and dl(RB) are
semantically equivalent.
Proof. Consider interpretation I, an assignment Z for
I, and a rule B → H ∈ RB such that dl(B → H) = CB ⊑
CH . Lifting Lemma 1 to sets of atoms B, we ﬁnd I,Z ̸|= B
B = ∅. It is clear that this entails the claim: either
I;Z
iﬀ C
I,Z |= H and C

, or I,Z ̸|= B and C

B = ∅.
I;Z

I;Z
H = ∆

I

Importantly, this result conﬁrms that nominal schemas
are powerful enough to express arbitrary DL-safe rules. The
use of nominal schemas, however, in SROIQV (Bs,×) is
more general than the extension of SROIQ(Bs) with DL-
safe rules, since the latter correspond to a special form of
SROIQV (Bs,×) axioms only. Combining Theorem 5 with
the observation that dl(RB) is linear in the size of RB, we
can state the following:

Theorem 7. The problem of deciding whether a know-
ledge base RB ∪ KB is satis(cid:12)able, where RB is a set of n-
variable rules with n constant, and KB is a SROELV n(⊓,×)
knowledge base, is P-complete.

WWW 2011 – Session: Query and Ontology LanguagesMarch 28–April 1, 2011, Hyderabad, India651Table 2: OWL RL normal forms

− ⊑ T

R

A ⊑ C
A ⊑ ∀R.C
A ⊑ {a}

A ⊓ B ⊑ C
A ⊑ 61 R.C
{a} ⊑ C

R ⊑ T
R ◦ S ⊑ T
R ⊓ S ⊑ T

7. RELATION TO OWL PROFILES

The OWL 2 standard proposes three tractable pro(cid:12)les,
i.e. language fragments for which reasoning is possible in
(sub)polynomial time [31]. Each of the proﬁles is closely
related to a description logic: OWL EL is contained in
SROEL(×,⊓) [24], OWL RL is an extension of DLP [15],
and OWL QL is based on DL-Lite [10]. All OWL 2 pro-
ﬁles include special support for datatypes and concrete data
values that we have not considered here. The respective
extensions would not lead to any technical diﬃculty, since
dataype literals can be treated like individuals in all proﬁles.
Here, we note that with certain restrictions (speciﬁed be-
low), the proﬁles OWL RL and OWL EL are contained
within SROELV 3(⊓,×). The latter also covers most fea-
tures of OWL QL, but we also note that the typical applica-
tion areas of this proﬁle are not targeted by our approach.
The relation to OWL EL is obvious: a SROEL(×,⊓)
knowledge base is also a SROELV n(⊓,×) knowledge base,
for each n (including n = 3). So this approach subsumes the
proﬁle OWL EL without datatypes. Similar to OWL EL,
OWL RL disallows any kind of (truly) disjunctive informa-
tion, but it also excludes all forms of existential quantiﬁca-
tion. In return, this allows OWL RL to include inverse roles
and unrestricted range restrictions which are excluded from
OWL EL to preserve tractability. Due to the lack of disjunc-
tive and existential expressions, however, OWL RL axioms
can be faithfully represented using DL-safe rules only.

Concretely, OWL RL is based on a Horn Description
Logic, the axioms of which can be transformed into a number
of normal forms as shown in [25]. As discussed in [23], the
TBox and RBox axioms of OWL RL can thus be reduced to
the normal forms in Table 2, where A, B, C ∈ NC ∪{⊤,⊥},
R, S, T ∈ NR, and a ∈ NI . Only three of these axiom types
are not in SROELV n(⊓,×). Using DL-safe rules, we can
encode A ⊑ ∀R.C into A(x), R(x, y) → C(y), and R
− ⊑ T
into R(x, z) → T (z, x). For qualiﬁed functionality restric-
tions, an auxiliary “DL-safe equality” role R≈ is encoded
with the axiom {x} ⊓ ∃R≈.{y} ⊑ ∃U.({x} ⊓ {y}). The ax-
iom A ⊑ 61 R.C is then represented by the DL-safe rule

A(x), R(x, y1), C(x1), R(x, y2), C(x2) → R≈(y1, y2).

(5)

Transforming DL-safe rules as in Section 6 and keeping ABox
axioms without modiﬁcation, we thus obtain a simple trans-
lation from OWL RL (without datatype-related features) to
SROELV 3(⊓,×).

−

OWL QL, ﬁnally, is based on DL-Lite, which is designed
for its sub-polynomial AC0 data complexity [10]. This also
implies that no complex RIAs are included, but inverse roles
and some forms of existential quantiﬁcation are allowed. In-
verse roles R
can be replaced by new role names Rinv,
with the original semantics approximated by DL-safe rules
R(x, y) → Rinv(y, x) and Rinv(x, y) → R(y, x). As in the
case of OWL RL, this means that certain conclusions are
lost, while tractability is preserved. Furthermore, axioms
of the form ⊤ ⊑ ∃R
.C can be expressed as R ⊑ ⊤ × C.

−

The related restrictions of Deﬁnition 6 do not apply in the
absence of complex RIAs.

It must be noted that OWL RL axioms that are trans-
lated to DL-safe rules are no longer interpreted under their
ﬁrst-order semantics. Entailments of ABox axioms – the
main inference task in applications of OWL RL – are pre-
served, but translated axioms are not semantically equiva-
lent to the original ontology. Indeed, the DL obtained by al-
lowing unions of OWL EL and OWL RL knowledge bases is
2ExpTime-complete, as it encompasses all features of Horn-
SROIQ [35]. The combination of “DL-safe” OWL RL and
OWL EL, in contrast, is still tractable, but does not entail
all inferences that the unrestricted combination would.

Also, it should be pointed out that the typical uses of
OWL QL for ontology-based querying of large datasets is
not supported by SROEL(×,⊓), at least not as it is by
OWL QL. Namely, the low data complexity of OWL QL en-
ables an eﬃcient way of query rewriting that is not available
in SROEL(×,⊓). This limitation cannot be overcome, as
AC0 ( P. Conversely, SROEL(×,⊓) includes many fea-
tures not available in OWL QL, e.g, role transitivity.

8. RELATED WORK
8.1 Description Logic Rules

The DLs introduced here are closely related to Description
Logic Rules, i.e. ﬁrst-order rule languages that allow sets
of rules to be expressed in description logics [23, 26]. As
discussed in Section 6, nominal schemas are closely related
to variables in DL-safe rules [33].
In [27], ELP was proposed as an extension of DL Rules
for EL++ with additional DL-safe variables. ELP is more
general than the mere union of DL-safe rules and DL Rules,
since a single rule can contain some variables that are DL-
safe and others that are not. However, the deﬁnitions in
[27] aim at tractability, and do not allow all uses of DL-safe
variables. As discussed in Section 4, safe environments in
SROELV n(⊓,×) are closely related to this approach.

DL-safe variables in ELP do not encompass the unre-
stricted use of up to n nominal schemas that is permit-
ted in SROELV n(⊓,×). Like the general use of nomi-
nal schemas in SROIQV (Bs,×), this feature corresponds
rather to DL+safe Rules as introduced in [23]. DL+safe
Rules are obtained by allowing DL-safe variables to be used
in DL Rules, and they can be viewed as a rule version of our
approach. Our complexity proofs in Section 5 are based on
analogous proofs for DL+safe Rules. In [23], the term “vari-
able nominals” had been proposed for nominal schemas, but
no according DL syntax was introduced.
8.2 Existential Rules

Another approach toward integrating ontological model-
ing and rules are existential rules, that extend Datalog with
existential quantiﬁers in rule heads. This paradigm has at-
tracted much interest recently, and has been studied under a
variety of names such as Datalog+/{, ∀∃-rules, and – primar-
ily in the database community – tuple-generating dependen-
cies (TGDs) [2, 3, 6, 7, 8, 9, 13, 14]. As in the combination
of rules and DL, reasoning with existential rules is undecid-
able without further restrictions. A chief interest of many
of the above works thus is to establish formalisms for which
(conjunctive) query answering is decidable, possibly with a
low data complexity. For example, it has been shown that

WWW 2011 – Session: Query and Ontology LanguagesMarch 28–April 1, 2011, Hyderabad, India652certain dialects of Datalog+/– capture and extend languages
of the DL-Lite family [7, 10].

Although the general motivation of this research is similar,
there are signiﬁcant technical diﬀerences to our approach.
In particular, none of the above rule languages is expressive
enough to capture OWL EL. Moreover, features like cardi-
nality restrictions (or equality constraints) and disjunctive
modeling are hardly considered in current works. On the
other hand, many decidable fragments of existential rules
are highly expressive and exhibit combined complexities of
ExpTime and 2ExpTime.
8.3 Description Graphs

Extending DLs with description graphs and rules, as pro-
posed in [30], enables a more explicit way of modeling struc-
tured objects such as those found in the medical sciences
and ontologies. As noted in [32], in order to retain decidabil-
ity, DLs are often designed with some syntactic restrictions
which limit their ability to model non-tree-like structures as
featured in the uncle example earlier. On the other hand, de-
scription graphs allow us to explicitly state relationships be-
tween domain elements in the knowledge base which cannot
be expressed using standard DL constructs alone. In addi-
tion, this approach also allows description graphs to appear
as graph atoms in rules, thus allowing conditional statements
about the structured objects modeled by the graphs.

In its unrestricted form, extending DLs with description
graphs leads to undecidability even under acyclicity condi-
tions. Therefore, some restrictions to prevent roles in DL
axioms from interacting with roles appearing in graphs and
rules are imposed to retain decidability. Corresponding de-
cidability results for SHOQ+ and SHOIQ+ have been es-
tablished. However, we are not aware of any tractable frag-
ments of these formalisms that have been proposed.
Note that SROIQV (Bs,×) knowledge bases also induce
graph-like structures due to the presence of nominals and
nominal schemas, as evidenced by the fact that they can
model DL-safe rules. Yet, neither of the two languages –
SROIQV (Bs,×) and DLs extended with description graphs
and rules – contains the other. A merging of both ap-
proaches is conceivable, but remains to be worked out.

9. CONCLUSIONS AND FUTURE WORK
We have introduced nominal schemas as an extension to
DL-based ontology languages, that provides suﬃcient ex-
pressivity to incorporate rule-based modeling into ontolo-
gies. In particular, it supports the integration of Web rule
languages such as SWRL and RIF with OWL 2 ontologies.
An important next step is to realize these ideas for the con-
crete serialization formats of these languages, and to make
the corresponding modeling features available in practice.

The latter task especially includes the implementation of
inference algorithms to handle nominal schemas more eﬃ-
ciently. We have shown that our extension does not increase
the worst-case complexity of reasoning in OWL 2, and that
versatile tractable sub-languages exist. Whether and how
these theoretical results can be put into eﬃcient reasoning
algorithms is an important research question. Two diﬀer-
ent approaches seem viable to address this problem. On
the one hand, nominal schemas could be implemented by
modifying/extending existing OWL 2 implementations that
have good support for nominals, such as the OWL 2 rea-
soner HermiT [34]. This can be accomplished by treating

nominal schemas like nominals in the deduction procedure,
instantiating them with concrete individuals only when this
enables relevant deduction steps. This can be viewed as a
method of deferred grounding.

On the other hand, our light-weight ontology languages
could be implemented using rule-based procedures as pro-
posed for SROEL [24].
In this setting, nominal schemas
can be treated like DL-safe variables. Thus, the rule-based
deduction remains similar with the only modiﬁcation that
some variables can only be instantiated with certain con-
stants (the approach in [24] introduces new constant sym-
bols for eliminating existentials, and DL-safe variables are
not allowed to represent these auxiliary symbols).

In conclusion, the close relationship to nominals is not
merely of syntactic convenience, but prepares a path for
the further practical adoption of this feature.
Instead of
a paradigm shift from ontologies to rules, existing applica-
tions could be augmented with bits of rule-based modeling
to overcome restrictions of classical DLs. Nominal schemas
thus may provide an exceptional opportunity for enhanc-
ing the expressive power of ontologies without giving up on
established tools, format, or methodologies.

Acknowledgements This work was partially supported by
the National Science Foundation under award 1017225 “III:
Small: TROn—Tractable Reasoning with Ontologies” and
by EPSRC in project “HermiT: Reasoning with Large On-
tologies” (EP/F065841/1). The third author acknowledges
support by a Fulbright Indonesia Presidential Scholarship
PhD Grant 2010.

10. REFERENCES
[1] F. Baader, D. Calvanese, D. McGuinness, D. Nardi,

and P. Patel-Schneider, editors. The Description Logic
Handbook: Theory, Implementation, and Applications.
Cambridge University Press, second edition, 2007.

[2] J.-F. Baget, M. Lecl`ere, and M.-L. Mugnier. Walking

the decidability line for rules with existential
variables. In Lin et al. [28], pages 466–476.

[3] J.-F. Baget, M. Lecl`ere, M.-L. Mugnier, and E. Salvat.

Extending decidable cases for rules with existential
variables. In C. Boutilier, editor, Proc. 21st Int. Conf.
on Arti(cid:12)cial Intelligence (IJCAI’09), pages 677–682.
IJCAI, 2009.

[4] H. Boley, G. Hallmark, M. Kifer, A. Paschke,

A. Polleres, and D. Reynolds, editors. RIF Core
Dialect. W3C Recommendation, 22 June 2010.
Available at http://www.w3.org/TR/rif-core/.

[5] G. Brewka and J. Lang, editors. Proc. 11th Int. Conf.

on Principles of Knowledge Representation and
Reasoning (KR’08). AAAI Press, 2008.

[6] A. Cal`ı, G. Gottlob, and M. Kifer. Taming the inﬁnite

chase: Query answering under expressive relational
constraints. In Brewka and Lang [5], pages 70–80.

[7] A. Cal`ı, G. Gottlob, and T. Lukasiewicz. A general

datalog-based framework for tractable query answering
over ontologies. In J. Paredaens and J. Su, editors,
Proc. 28th Symposium on Principles of Database
Systems (PODS’09), pages 77–86. ACM, 2009.

[8] A. Cal`ı, G. Gottlob, and A. Pieris. Advanced

processing for ontological queries. Proceedings of
VLDB 2010, 3(1):554–565, 2010.

WWW 2011 – Session: Query and Ontology LanguagesMarch 28–April 1, 2011, Hyderabad, India653[9] A. Cal`ı, G. Gottlob, and A. Pieris. Query answering
under non-guarded rules in Datalog+/-. In P. Hitzler
and T. Lukasiewicz, editors, Proc. 4th Int. Conf. on
Web Reasoning and Rule Systems (RR 2010), volume
6333 of LNCS, pages 1–17. Springer, 2010.
[10] D. Calvanese, G. De Giacomo, D. Lembo,

M. Lenzerini, and R. Rosati. Tractable reasoning and
eﬃcient query answering in description logics: The
DL-Lite family. J. of Automated Reasoning,
39(3):385–429, 2007.

[11] J. de Bruijn. RIF RDF and OWL Compatibility. W3C

Recommendation, 22 June 2010. Available at
http://www.w3.org/TR/rif-rdf-owl/.

[25] M. Kr¨otzsch, S. Rudolph, and P. Hitzler. Complexity
boundaries for Horn description logics. In Proc. 22nd
AAAI Conf. on Arti(cid:12)cial Intelligence (AAAI’07),
pages 452–457. AAAI Press, 2007.

[26] M. Kr¨otzsch, S. Rudolph, and P. Hitzler. Description
logic rules. In M. Ghallab et al., editors, Proceedings
of the 18th European Conference on Arti(cid:12)cial
Intelligence, ECAI2008, pages 80–84. IOS Press, 2008.

[27] M. Kr¨otzsch, S. Rudolph, and P. Hitzler. ELP:

Tractable rules for OWL 2. In A. Sheth et al., editors,
Proceedings of the 7th International Semantic Web
Conference (ISWC-08), volume 5318 of Lecture Notes
in Computer Science, pages 649–664. Springer, 2008.

[12] S. Demri and H. Nivelle. Deciding regular grammar

[28] F. Lin, U. Sattler, and M. Truszczynski, editors. Proc.

logics with converse through ﬁrst-order logic. J. of
Logic, Language and Information, 14(3):289–329, 2005.

[13] A. Deutsch and V. Tannen. Reformulation of XML

queries and constraints. In D. Calvanese, M. Lenzerini,
and R. Motwani, editors, Proc. 9th Int. Conf. on
Database Theory (ICDT’03), volume 2572 of LNCS,
pages 225–241. Springer, 2003.

12th Int. Conf. on Principles of Knowledge
Representation and Reasoning (KR’10). AAAI Press,
2010.

[29] D.L. McGuinness and F. van Harmelen, editors. OWL

Web Ontology Language Overview. W3C
Recommendation, 10 February 2004. Available at
http://www.w3.org/TR/owl-features/.

[14] R. Fagin, P.G. Kolaitis, R.J. Miller, and L. Popa.

[30] B. Motik, B. Cuenca Grau, I. Horrocks, and

Data exchange: semantics and query answering.
Theoretical Computer Science, 336(1):89–124, 2005.

[15] B.N. Grosof, I. Horrocks, R. Volz, and S. Decker.

Description logic programs: combining logic programs
with description logic. In Proc. 12th Int. Conf. on
World Wide Web (WWW’03), pages 48–57. ACM,
2003.

[16] P. Hitzler, M. Kr¨otzsch, and S. Rudolph. Foundations

U. Sattler. Representing ontologies using description
logics, description graphs, and rules. Arti(cid:12)cial
Intelligence, 173(14):1275–1309, 2009.

[31] B. Motik, B. Cuenca Grau, I. Horrocks, Z. Wu,

A. Fokoue, and C. Lutz, editors. OWL 2 Web
Ontology Language: Pro(cid:12)les. W3C Recommendation,
27 October 2009. Available at
http://www.w3.org/TR/owl2-proﬁles/.

of Semantic Web Technologies. Chapman &
Hall/CRC, 2009.

[32] B. Motik and R. Rosati. Reconciling description logics

and rules. Journal of the ACM, 57(5), 2010.

[17] P. Hitzler and B. Parsia. Ontologies and rules. In

[33] B. Motik, U. Sattler, and R. Studer. Query answering

S. Staab and R. Studer, editors, Handbook on
Ontologies, pages 111–132. Springer, 2 edition, 2009.
[18] I. Horrocks, O. Kutz, and U. Sattler. The even more
irresistible SROIQ. In P. Doherty, J. Mylopoulos,
and C.A. Welty, editors, Proc. 10th Int. Conf. on
Principles of Knowledge Representation and
Reasoning (KR’06), pages 57–67. AAAI Press, 2006.
[19] I. Horrocks, P.F. Patel-Schneider, S. Bechhofer, and
D. Tsarkov. OWL Rules: A proposal and prototype
implementation. J. of Web Semantics, 3(1):23–40,
2005.

[20] I. Horrocks, P.F. Patel-Schneider, H. Boley, S. Tabet,

B. Grosof, and M. Dean. SWRL: A Semantic Web
Rule Language. W3C Member Submission, 21 May
2004. See http://www.w3.org/Submission/SWRL/.

[21] I. Horrocks and U. Sattler. Decidability of SHIQ with
complex role inclusion axioms. Arti(cid:12)cial Intelligence,
160(1):79–104, 2004.
[22] Y. Kazakov. RIQ and SROIQ are harder than
SHOIQ. In Brewka and Lang [5], pages 274–284.

[23] M. Kr¨otzsch. Description Logic Rules, volume 008 of
Studies on the Semantic Web. IOS Press/AKA, 2010.

[24] M. Kr¨otzsch. Eﬃcient inferencing for OWL EL. In

T. Janhunen and I. Niemel¨a, editors, Proc. 12th
European Conf. on Logics in Arti(cid:12)cial Intelligence
(JELIA’10), volume 6341 of LNAI, pages 234–246.
Springer, 2010.

for OWL DL with rules. J. of Web Semantics,
3(1):41–60, 2005.

[34] B. Motik, R. Shearer, and I. Horrocks. Hypertableau

reasoning for description logics. J. of Arti(cid:12)cial
Intelligence Research, 36:165–228, 2009.

[35] M. Ortiz, S. Rudolph, and M. Simkus. Worst-case

optimal reasoning for the Horn-DL fragments of
OWL 1 and 2. In Lin et al. [28], pages 269–279.

[36] W3C OWL Working Group. OWL 2 Web Ontology

Language: Document Overview. W3C
Recommendation, 27 October 2009. Available at
http://www.w3.org/TR/owl2-overview/.

[37] P.F. Patel-Schneider and B. Motik, editors. OWL 2
Web Ontology Language: Mapping to RDF Graphs.
W3C Recommendation, 27 October 2009. Available at
http://www.w3.org/TR/owl2-mapping-to-rdf/.

[38] I. Pratt-Hartmann. Complexity of the two-variable

fragment with counting quantiﬁers. J. of Logic,
Language and Information, 14:369–395, 2005.

[39] S. Rudolph, M. Kr¨otzsch, and P. Hitzler. Cheap

Boolean role constructors for description logics. In
S. H¨olldobler et al., editors, Proceedings of the 11th
European Conference on Logics in Arti(cid:12)cial
Intelligence (JELIA’08), volume 5293 of LNAI, pages
362–374. Springer, 2008.

WWW 2011 – Session: Query and Ontology LanguagesMarch 28–April 1, 2011, Hyderabad, India654