A Distributed Framework for Reliable and Efﬁcient Service

Choreographies

Young Yoon, Chunyang Ye, Hans-Arno Jacobsen

{yoon, chunyang}@msrg.utoronto.ca, jacobsen@eecg.toronto.edu

Department of Electrical and Computer Engineering, University of Toronto

10 King’s College Circle, Toronto, Ontario, M5S 3G4, Canada

ABSTRACT
In service-oriented architectures (SOA), independently developed
Web services can be dynamically composed. However, the com-
position is prone to producing semantically conﬂicting interactions
among the services. For example, in an interdepartmental business
collaboration through Web services, the decision by the marketing
department to clear out the inventory might be inconsistent with
the decision by the operations department to increase production.
Resolving semantic conﬂicts is challenging especially when ser-
vices are loosely coupled and their interactions are not carefully
governed. To address this problem, we propose a novel distributed
service choreography framework. We deploy safety constraints to
prevent conﬂicting behavior and enforce reliable and efﬁcient ser-
vice interactions via federated publish/subscribe messaging, along
with strategic placement of distributed choreography agents and
coordinators to minimize runtime overhead. Experimental results
show that our framework prevents semantic conﬂicts with negligi-
ble overhead and scales better than a centralized approach by up to
60%.

Categories and Subject Descriptors
D.2.11 [Software Architecture]: Service-oriented Architecture (SOA)

General Terms
Algorithms, Performance, Reliability

Keywords
Service choreography, semantic conﬂict prevention, service inter-
action, service composition, publish/subscribe, event processing

1.

INTRODUCTION

The service-oriented architecture (SOA) is an emerging software
engineering paradigm for developing distributed collaborative en-
terprise applications [19, 28, 29]. Proponents of SOA argue that au-
tonomously and independently developed Web services can seam-
lessly interact through message exchange to enable large distributed
composite applications [9, 32]. The resulting interactions among
collaborating services are referred to as a service choreography [30].
A choreography of distributed Web services, deployed across
different organizations, is prone to producing semantically conﬂict-
ing behavior [18, 21, 38]. For example, an interactive procurement

Copyright is held by the International World Wide Web Conference Com-
mittee (IW3C2). Distribution of these papers is limited to classroom use,
and personal use by others.
WWW 2011, March 28–April 1, 2011, Hyderabad, India.
ACM 978-1-4503-0632-4/11/03.

application may involve many autonomous participants such as re-
quester services, supplier services and evaluation services from dif-
ferent organizations. The interactions of these autonomous services
may generate unexpected behavior that violates the application se-
mantics. For instance, the sending of an item initiated by the sup-
plier service is not an intended application semantics, if the item
was already canceled by the requester service. The occurrence of
such events is referred to as a semantic conﬂict among collaborat-
ing Web services [21].

Semantic conﬂicts are unacceptable for SOA applications and
detrimental to business operations; often they result in loss of rev-
enue or intolerable consumer experiences. Thus, it is critical to
control the interactions among services to prevent conﬂicting sce-
narios at runtime. Existing approaches address this issue by deﬁn-
ing a global speciﬁcation (e.g., WS-CDL [37]) to coordinate the
behavior of all participants [36, 11, 12, 22]. The global speciﬁ-
cation deﬁnes allowable interactions to safeguard the collaborating
services from entering into conﬂicting situations. To implement
these approaches, the global speciﬁcation is decomposed into lo-
cal speciﬁcations that are deployed to each service involved in the
composition [36, 22]. Each local speciﬁcation represents the al-
lowable behavior for the corresponding participating service. By
conforming to their local speciﬁcation, the participating services
collaboratively guarantee conﬂict-free interactions when acting in
concert as part of the composition.

Although the aforementioned solution can be applied to control
the local behavior of each individually participating service so that
their global interactions do not violate the speciﬁed application-
level semantics, the solution suffers from two major limitations.

First, a global speciﬁcation about the behavior of interacting ser-
vices may not always be available, especially in a dynamic service
composition. In such a composition, the number of participating
services is not ﬁxed, services join or leave the composition freely,
and services are anonymous to each other without global knowl-
edge about the entire interaction. The characteristics of the dy-
namic composition make it difﬁcult to design a complete global
speciﬁcation in advance [27]. For example, in emerging social
commerce applications that form instant volume purchasing pro-
motions, the number of buyer services is unknown in advance, and
the strategies, among sellers that form a network dynamically, can
change frequently [33].

Second, even if a global speciﬁcation is available, the global
speciﬁcation may be non-realizable [1, 13], in the sense that there
exist no local speciﬁcations that can implement and conform to the
behavior deﬁned by the global speciﬁcation. Existing approaches
address the non-realizability issue by extending the global speci-
ﬁcation with extra synchronization messages and coordinators [6,
31]. As shown in Section 5.4, the additional synchronization mes-

WWW 2011 – Session: Web ApplicationsMarch 28–April 1, 2011, Hyderabad, India785sages processed by a centralized coordinator for the extended global
speciﬁcation may introduce heavy end-to-end latency in the service
composition, compromising its performance.

To address these limitations, we propose a novel distributed chore-
ography framework for developing a semantic conﬂict-free chore-
ography of interacting services in loosely coupled and dynamic ser-
vice compositions. In our framework, no pre-deﬁned and carefully
crafted global speciﬁcation is needed. Services can join or leave a
service composition dynamically by connecting and disconnecting
to access points of the distributed framework that forms a service
bus. Through the choreography framework, services can interact
with partners in a ﬂexible manner by publishing messages to other
services and by subscribing to messages of interest from partners.
Moreover, instead of deploying a complete global speciﬁcation to
deﬁne the allowable interaction behavior among collaborating ser-
vices, we model only the conﬂicting interactions as disallowable
behavior and deploy them as safety constraints into the framework.
In order to avoid semantically conﬂicting behavior among in-
teracting services, our framework proactively controls the interac-
tions among collaborating services to keep the safety constraints
satisﬁed. To reduce the extra overhead (e.g., latency) introduced
by the enforcement of safety constraints, we decompose the safety
constraints into sub-constraints, and deploy them to speciﬁcally se-
lected locations to best reduce latency in the distributed runtime en-
vironment. We establish that the satisfaction of the sub-constraints
can guarantee semantic conﬂict-free interactions among collabo-
rating services. Our approach has been fully implemented and our
experimental evaluation shows that it exhibits better performance
for service compositions than existing approaches.

The main contributions of this paper are four-fold: (1) we pro-
pose a novel framework to coordinate services that can dynami-
cally join and leave a ﬂexibly deﬁned and loosely-coupled service
composition; (2) for the composition, we model conﬂicting inter-
actions among collaborating services and propose an algorithm to
decompose safety constraints that prevent semantically conﬂicting
behavior; (3) we develop an algorithm to optimize the deployment
of the safety constraints to minimize the coordination overhead;
and (4) we conduct extensive experiments to evaluate the beneﬁts
and characteristics of our solution.

The rest of this paper is organized as follows: Section 2 provides
motivating examples to illustrate semantic conﬂicts. Section 3 re-
ﬁnes our problem statement and analyses the research challenges.
Section 4 introduces the design of our framework including: (1)
the algorithm to decompose the safety constraints, along with the
establishment of its correctness; and (2) the algorithm to optimize
the deployment of safety constraints in the distributed runtime plat-
form. Section 5 evaluates our framework empirically. Section 6
discusses the limitations of our current solution and suggests po-
tential directions for improvements. Section 7 compares our work
to the state-of-the-art.

2. MOTIVATING EXAMPLES

Semantically conﬂicting behavior in dynamically and loosely
coupled service compositions can be found in many real world sce-
narios. For example, the following scenario was reported to us
about an automobile manufacturer: Due to decreasing oil prices,
demand for the company’s hybrid vehicles dropped and sales lagged.
As a strategic business decision, the manufacturer’s headquarter or-
dered designated dealerships to clear out their inventory through a
sales promotion. The promotion resulted in a temporary increase in
sales, which triggered a notiﬁcation to the assembly line to increase
production of vehicles. Thus, the net effect of the order to clear out
excess inventory was the creation of additional inventory.

(cid:39)(cid:1004)

(cid:44)(cid:89) (cid:381)(cid:396)(cid:282)(cid:286)(cid:396)(cid:400)(cid:3)(cid:24)(cid:286)(cid:258)(cid:367)(cid:286)(cid:396)(cid:400) (cid:410)(cid:381)(cid:3)(cid:272)(cid:367)(cid:286)(cid:258)(cid:396)(cid:3)(cid:381)(cid:437)(cid:410)

(cid:39)(cid:454)
(cid:24)(cid:286)(cid:258)(cid:367)(cid:286)(cid:396)(cid:400)(cid:3)(cid:410)(cid:381)(cid:3)(cid:258)(cid:400)(cid:364)(cid:3)(cid:18)(cid:381)(cid:381)(cid:396)(cid:282)(cid:349)(cid:374)(cid:258)(cid:410)(cid:381)(cid:396)(cid:3)(cid:410)(cid:381)(cid:3)

(cid:393)(cid:349)(cid:272)(cid:364)(cid:3)(cid:410)(cid:346)(cid:286)(cid:3)(cid:374)(cid:286)(cid:454)(cid:410)(cid:3)(cid:410)(cid:258)(cid:400)(cid:364)

(cid:39)(cid:1005)

(cid:68)(cid:258)(cid:396)(cid:364)(cid:286)(cid:410)(cid:349)(cid:374)(cid:336)(cid:3)(cid:410)(cid:286)(cid:258)(cid:373)(cid:3)

(cid:258) (cid:286)(cid:410) (cid:336) (cid:410)(cid:286)(cid:258)

(cid:374)(cid:381)(cid:410)(cid:349)(cid:296)(cid:349)(cid:286)(cid:400)(cid:3)(cid:400)(cid:258)(cid:367)(cid:286)(cid:400)(cid:3)(cid:437)(cid:393)(cid:282)(cid:258)(cid:410)(cid:286)(cid:3)

(cid:410)(cid:381)(cid:3)(cid:38)(cid:258)(cid:272)(cid:410)(cid:381)(cid:396)(cid:455)

(cid:39)(cid:1006)
(cid:75)(cid:393)(cid:286)(cid:396)(cid:258)(cid:410)(cid:349)(cid:381)(cid:374)(cid:400)(cid:3)(cid:373)(cid:258)(cid:374)(cid:258)(cid:336)(cid:286)(cid:396)(cid:3)
(cid:381)(cid:396)(cid:282)(cid:286)(cid:396)(cid:400)(cid:3)(cid:393)(cid:396)(cid:381)(cid:282)(cid:437)(cid:272)(cid:410)(cid:349)(cid:381)(cid:374)(cid:3)(cid:396)(cid:258)(cid:410)(cid:286)(cid:3)

(cid:272)(cid:346)(cid:258)(cid:374)(cid:336)(cid:286)(cid:3)(cid:410)(cid:381)(cid:3)(cid:38)(cid:258)(cid:272)(cid:410)(cid:381)(cid:396)(cid:455)

Figure 1: Hidden pick coordination task in choreography spec-
iﬁcation from a hybrid car manufacturing use case.

(cid:39)(cid:1004)

(cid:39)(cid:454)

(cid:39)(cid:1005)

(cid:4)(cid:437)(cid:282)(cid:349)(cid:410)(cid:349)(cid:374)(cid:336)(cid:3)(cid:393)(cid:258)(cid:396)(cid:410)(cid:374)(cid:286)(cid:396)(cid:3)(cid:400)(cid:286)(cid:374)(cid:282)(cid:400)(cid:3)(cid:296)(cid:396)(cid:258)(cid:437)(cid:282)(cid:3)(cid:449)(cid:258)(cid:396)(cid:374)(cid:349)(cid:374)(cid:336)(cid:400)(cid:3)

(cid:410)(cid:381)(cid:3)(cid:4)(cid:272)(cid:272)(cid:381)(cid:437)(cid:374)(cid:410)(cid:349)(cid:374)(cid:336)(cid:3)(cid:393)(cid:258)(cid:396)(cid:410)(cid:374)(cid:286)(cid:396)

(cid:4)(cid:272)(cid:272)(cid:381)(cid:437)(cid:374)(cid:410)(cid:349)(cid:374)(cid:336)(cid:3)(cid:393)(cid:258)(cid:396)(cid:410)(cid:374)(cid:286)(cid:396)(cid:3)(cid:381)(cid:396)(cid:282)(cid:286)(cid:396)(cid:400)(cid:3)(cid:272)(cid:437)(cid:400)(cid:410)(cid:381)(cid:373)(cid:286)(cid:396)(cid:3)

(cid:400)(cid:286)(cid:396)(cid:448)(cid:349)(cid:272)(cid:286)(cid:3)(cid:410)(cid:381)(cid:3)(cid:349)(cid:400)(cid:400)(cid:437)(cid:286)(cid:3)(cid:396)(cid:286)(cid:296)(cid:437)(cid:374)(cid:282)(cid:3)

(cid:18) (cid:410)
(cid:282) (cid:410)
(cid:18)(cid:437)(cid:400)(cid:410)(cid:381)(cid:373)(cid:286)(cid:396)(cid:3)(cid:400)(cid:286)(cid:396)(cid:448)(cid:349)(cid:272)(cid:286)(cid:3)(cid:349)(cid:400)(cid:400)(cid:437)(cid:286)(cid:400)(cid:3)(cid:396)(cid:286)(cid:296)(cid:437)(cid:374)(cid:282)(cid:3)(cid:410)(cid:381)

(cid:296)

(cid:349)

(cid:349)

(cid:18)(cid:437)(cid:400)(cid:410)(cid:381)(cid:373)(cid:286)(cid:396)

Figure 2: Implicit coordination between consecutive tasks from
a credit card processing use case.

Suppose the collaboration was designed and implemented into
executable processes using Web services that are independently de-
veloped for the partners as shown in Figure 1. G0, for instance,
is an interaction between the "HQ" service and the "Dealers" ser-
vice.
If there was no designated coordinator (as represented by
the hidden task Gx) that governs and enforces a reliable picking
of subsequent tasks given some business situation, e.g., inventory
clear-out, then the partners in the collaboration can behave arbi-
trarily, i.e., marketing service notifying sales increase to the factory
rather than having the operation management service order produc-
tion decrease to the factory.

A further real world-inspired use case stems from a credit card
processing scenario. In the example, the auditing department de-
tects fraudulent transaction on some client’s account and requests
the accounting department to compensate the client by crediting
the amount in question back to the client’s account. However, at
the same time, the client identiﬁes the fraud on her account and
demands immediate refund from the customer service department.
The customer service department, not knowing the auditing depart-
ment’s action, processes the refund for the client as well. The net
result for the client being a double credit.

Suppose this example was also implemented with Web services
as shown in Figure 2. The implementation implicitly imposes the
coordination between the accounting service partner and the cus-
tomer service partner as shown in the task Gx such that the cus-
tomer service can issue the refund only if it receives the refund
order from the accounting service. The conﬂict in the use case was
caused for the simple reason that the coordination was not actually
implemented, therefore, there was nothing preventing the customer
service to behave arbitrarily.

The original business logic speciﬁed in Figure 1 and Figure 2
is accurate from a business operations perspective. However, the
speciﬁed interactions are agnostic to crucial details resulting from

WWW 2011 – Session: Web ApplicationsMarch 28–April 1, 2011, Hyderabad, India786the distributed runtime behavior that are not explicitly captured in
the speciﬁcation. The result is that the aforementioned semantic
conﬂicts occur unintentionally.

The meticulous speciﬁcation of constraints as safeguards against
the conﬂicts in advance is infeasible, especially in a ﬂexible en-
vironment that allows loose-coupling of Web services. The dy-
namic nature of loosely coupled Web service compositions, that
is, anonymity and lack of a priori knowledge of the entire interac-
tion, only exacerbates the problem. A passive and naïve solution
to resolve the issue is to devise an error monitoring tool and apply
an error recovery approach to restore the service composition from
the conﬂicting scenarios. However, such a solution incurs unneces-
sary value loss for compensating conﬂicting interactions (e.g., the
charges incurred for re-sending the canceled products to the suppli-
ers).

Intrigued by these examples and by the lack of a reasonable solu-
tion, we develope a framework to automatically extract the hidden
safety constraints, formally articulated in Section 4. The frame-
work enforces the constraints to prevent semantic conﬂicts in a ser-
vice choreography.

3. PROBLEM AND CHALLENGES

In this section we discuss the need for mechanisms to enforce
conﬂict-free interactions in service choreographies and outline the
main challenges in designing and implementing these mechanisms.
As mentioned in Section 2, the choreography of autonomous
services in a loosely-coupled and dynamic service composition is
prone to producing conﬂicting interactions that violate the applica-
tion semantics. Enabling a conﬂict-free choreography among dy-
namically composed services is a challenging task for three main
reasons: (1) Services can participate in the choreography at any
time and from any location; (2) the number of services is a pri-
ori unknown; and (3) participating services may only have a par-
tial view of the entire collaboration and remain anonymous to each
other.

In addition, preventing semantic conﬂicts in a choreography is
challenging as well. Existing approaches that guarantee conﬂict-
free interactions require a carefully crafted global speciﬁcation in
advance and can not handle the ﬂexibility imposed by dynamic
compositions, where no global speciﬁcation exists a priori [27].
Instead, proactive exclusion of conﬂicting interactions from the
choreography is a more desirable approach.

In a choreography, services tend to be distributed across orga-
nizations, which precludes the use of a centralized mechanism to
monitor interactions for conﬂicts. Centralized coordination is in-
efﬁcient, not scalable, and might be difﬁcult to enforce adminis-
tratively in distributed settings [20]. Therefore, a distributed co-
ordination mechanism is needed. However, more importantly, the
distributed mechanism of excluding the conﬂicting behavior may
unintentionally overlook some conﬂicts due to the distributed na-
ture of the service choreography.

For example, suppose a sample service choreography is given
in Figure 3(a) where Gi identiﬁes an interaction between collabo-
rating partners, and any message interaction sequence, except m1,
m2, m4 or m1, m3, m4, should be excluded. A distributed control
mechanism is enabled in Figure 4 through a conventional decom-
position method [40]. ϕ(Gi) denotes a projection of Gi to a lo-
cal task, Lxy for the collaborating partner rx with y as the unique
identiﬁer. The control mechanism may overlook the violations of
message ordering, as depicted in Figure 3(a). In fact, the control
mechanism can produce disallowed message patterns, if nothing
prevents r3 from arbitrarily starting the task of sending m2 before

(cid:39)(cid:1005)

(cid:373)(cid:1005)

(cid:396)(cid:1005) (cid:198)(cid:198)(cid:198)(cid:198) (cid:396)(cid:1006)

(cid:39)(cid:1006)

(cid:373)(cid:1006)

(cid:396)(cid:1007) (cid:198)(cid:198)(cid:198)(cid:198) (cid:396)(cid:1008)

(cid:373)(cid:1007)

(cid:396)(cid:1005) (cid:198)(cid:198)(cid:198)(cid:198) (cid:396)(cid:1009)

(cid:39)(cid:1007)

(cid:39)(cid:1006)

(cid:39)(cid:1005)

(cid:373)(cid:1005)

(cid:396)(cid:1005) (cid:198)(cid:198)(cid:198)(cid:198) (cid:396)(cid:1006)

(cid:272)(cid:1005)

(cid:396)(cid:1006) (cid:198)(cid:198)(cid:198)(cid:198) (cid:396)(cid:1007)

(cid:272)(cid:1006)

(cid:396)(cid:1006) (cid:198)(cid:198)(cid:198)(cid:198) (cid:396)(cid:1005)

(cid:373)(cid:1006)

(cid:396)(cid:1007) (cid:198)(cid:198)(cid:198)(cid:198) (cid:396)(cid:1008)

(cid:272)(cid:1007)

(cid:396)(cid:1008) (cid:198)(cid:198)(cid:198)(cid:198) (cid:396)(cid:1005)

(cid:373)(cid:1007)

(cid:396)(cid:1005) (cid:198)(cid:198)(cid:198)(cid:198) (cid:396)(cid:1009)

(cid:39)(cid:1007)

(cid:272)(cid:1008)

(cid:396)(cid:1009) (cid:198)(cid:198)(cid:198)(cid:198) (cid:396)(cid:1005)

(cid:373)(cid:1008)

(cid:39)(cid:1008) (cid:396)(cid:1005) (cid:198)(cid:198)(cid:198)(cid:198) (cid:396)(cid:1007)

(a)

(cid:373)(cid:1008)

(cid:39)(cid:1008) (cid:396)(cid:1005) (cid:198)(cid:198)(cid:198)(cid:198) (cid:396)(cid:1007)

(b)

Figure 3: Implicit constraints in service choreography.

(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1005)(cid:895)(cid:3)(cid:1089)(cid:3)(cid:62)(cid:1005)(cid:1005)

(cid:454)(cid:894)(cid:373)(cid:1005)(cid:895)

(cid:454)(cid:894)(cid:373)(cid:1008)(cid:895)
(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1008)(cid:895)(cid:3)(cid:1089)(cid:3)(cid:62)(cid:1005)(cid:1006)
(cid:62)(cid:1006)(cid:1005) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1005)(cid:895)

(cid:62) (cid:1089) (cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39) (cid:895)
(cid:62)(cid:1007)(cid:1005) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1006)(cid:895)

(cid:454)(cid:894)(cid:373)(cid:1007)(cid:895)
(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1007)(cid:895)(cid:3)(cid:1089)(cid:3)(cid:62)(cid:1005)(cid:1007)
(cid:454)(cid:894)(cid:373)(cid:1005)(cid:895)
(cid:894)
(cid:895)
(cid:454)(cid:894)(cid:373)(cid:1006)(cid:895)

(cid:62)(cid:1007)(cid:1006) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1008)(cid:895)

(cid:454)(cid:894)(cid:373)(cid:1008)(cid:895)

(cid:62)(cid:1008)(cid:1005) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1006)(cid:895)

(cid:62)(cid:1009)(cid:1005) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1007)(cid:895)

(cid:454)(cid:894)(cid:373)(cid:1006)(cid:895)
(cid:454)(cid:894)(cid:373)(cid:1007)(cid:895)

(cid:396)(cid:1005)

(cid:396)(cid:1006)

(cid:396)(cid:1007)

(cid:396)(cid:1008)
(cid:396)(cid:1009)

Figure 4: Incorrect decomposition of constraints.

r1 sends out m1, as depicted in Figure 4. The ordering of the mes-
sages is clearly violated, rendering the safety constraint unsatisﬁed.
Another common type of semantic conﬂict that may be over-
looked by a distributed control mechanism is a pick violation1.
Given the example in Figure 3(a), once G2 is picked, no message
sequence other than m2, m4 should be excluded. However, r1 in
G3 can still be triggered to send m3, unless there is a mechanism to
discover the hidden constraints in the pick activity to synchronize
all the branches, as shown in Figure 3(b), e.g., m1 should strictly
precede m2 or m3 by a conﬁrmation message to be sent from r2 of
G1 to r3 of G2. The safety constraints cannot be enforced correctly
unless the hidden constraints are discovered and enforced.

Finally, reducing the overhead introduced by the enforcement of
safety constraints in a service choreography constitutes a further
challenge. Figure 3(b) shows that a distributed control mechanism
to enforce safety constraints introduces extra synchronization mes-
sages c1 and c2 generated by the coordinator. This overhead is
manifest, as increase in latency depends on the location of the co-
ordinator in the distributed environment. Suppose the coordinator
is placed in an organization to govern the pick between G2 and G3
in Figure 3(a). It is apparent that the farther the coordinator is from
the senders of G2 and G3, the more time it will take to send the
synchronization messages to the senders. Given a set of safety con-
straints and a number of distributed services, the deployment of the
constraints into speciﬁcally selected locations to reduce overhead
is a practical goal, not previously studied.

In the remainder of paper, we address all of these challenges

through our novel choreography framework.

1Pick and ﬂow are choice operations speciﬁed in WS-CDL [37].

WWW 2011 – Session: Web ApplicationsMarch 28–April 1, 2011, Hyderabad, India787(cid:62)(cid:1005)(cid:1005) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1005)(cid:895)

(cid:454)(cid:894)(cid:373)(cid:1005)(cid:895)

(cid:396)(cid:1006)
(cid:454)(cid:894)(cid:373)(cid:1005)(cid:895)

(cid:62)(cid:1006)(cid:1005) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1005)(cid:895)

(cid:62)(cid:1005)(cid:1006) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1006)(cid:895)

(cid:454)(cid:894)(cid:272)(cid:1007)(cid:895)

(cid:454)(cid:894)(cid:272)(cid:1006)(cid:895)

(cid:62)(cid:1005)(cid:1007) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1005)(cid:895)

(cid:62)(cid:1006)(cid:1006) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1005)(cid:895)

(cid:454)(cid:894)(cid:272)(cid:1005)(cid:895)

(cid:454)(cid:894)(cid:272)(cid:1006)(cid:895) (cid:62)(cid:1006)(cid:1007) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1005)(cid:895)

(cid:62)(cid:1007)(cid:1005) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1005)(cid:895)

(cid:62)(cid:1007)(cid:1006) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1006)(cid:895)

(cid:396)(cid:1007)
(cid:454)(cid:894)(cid:272)(cid:1005)(cid:895)

(cid:62)(cid:1007)(cid:1007) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1008)(cid:895)

(cid:454)(cid:894)(cid:373)(cid:1006)(cid:895)

(cid:454)(cid:894)(cid:373)(cid:1008)(cid:895)

(cid:454)(cid:894)(cid:373)(cid:1007)(cid:895)

(cid:62)(cid:1005)(cid:1009) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1007)(cid:895)

(cid:62)(cid:1005)(cid:1008) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1008)(cid:895)

(cid:454)(cid:894)(cid:373)(cid:1008)(cid:895)

(cid:454)(cid:894)(cid:272)(cid:1008)(cid:895) (cid:62)(cid:1005)(cid:1010) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1007)(cid:895)

(cid:396)(cid:1005)

(cid:62)(cid:1009)(cid:1005) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1007)(cid:895) (cid:454)(cid:894)(cid:373)(cid:1007)(cid:895)
(cid:1009)(cid:1005) (cid:77)(cid:77)(cid:77)(cid:77)(cid:894) (cid:1007)(cid:895)
(cid:454)(cid:894)(cid:373)(cid:1007)(cid:895)

(cid:62)(cid:1009)(cid:1006) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1007)(cid:895)
(cid:396)(cid:1009)

(cid:454)(cid:894)(cid:272)(cid:1008)(cid:895)

(cid:62)(cid:1008)(cid:1005) (cid:1089) (cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1006)(cid:895)
(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1006)(cid:895)
(cid:62)(cid:1008)(cid:1005)

(cid:454)(cid:894)(cid:373)(cid:1006)(cid:895)
(cid:454)(cid:894)(cid:373)(cid:1006)(cid:895)

(cid:62)(cid:1008)(cid:1006) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1007)(cid:895)
(cid:396)(cid:1008)

(cid:454)(cid:894)(cid:272)(cid:1007)(cid:895)

Figure 5: Example of reliable decomposition.

4. RELIABLE SERVICE CHOREOGRAPHY
In this section, we provide both abstract and practical solutions
for a semantic conﬂict-free service choreography in a dynamic and
loosely coupled service composition.

4.1 Overview

We coordinate service interactions by implementing service chore-

ography on top of a distributed content-based publish/subscribe
system [10]. The publish/subscribe system is comprised of a set
of brokers interconnected to form a federated overlay to route mes-
sages from data producers to consumers [20]. As opposed to tightly-
coupled, end-to-end delivery solutions, a publish/subscribe system
offers efﬁcient many-to-many communication patterns, full data
source and sink decoupling, loose-coupling, message correlation
capabilities, in-network content-based ﬁltering capabilities, and lo-
cation transparency [20].

Based on these capabilities, distributed services can easily inter-
act with each other in a loosely-coupled manner by publishing mes-
sages to partner services and by subscribing to messages of interest
from partner services. In this way, autonomous services can join or
leave a composition dynamically by connecting or disconnecting to
brokers in the publish/subscribe system at any time. However, The
decomposition of safety constraints into sub-constraints, as men-
tioned in Section 3, may neglect to capture conﬂicting scenarios
due to missing synchronization messages. To address this issue,
our solution derives missing synchronization messages and auto-
matically incorporates them explicitly into the decomposed sub-
constraints.

To sketch out the solution, we revisit the sample safety con-
straint from Figure 3. The safety constraint is decomposed into
sub-constraints for partner services r1, - ,r5. Note that the key
difference between Figure 4 and Figure 5 is that coordination mes-
sages, ci, where i = 1, 2, 3, 4, are derived and mapped to appro-
priate sub-constraints. For example, between G1 and G2, a coordi-
nation is necessary as the safety constraint implicitly states that r3
should not send out message, m2 until r2 receives the message m1
from r2. In this particular example, every run of the service chore-
ography, controlled by the decomposed set of sub-constraints with
the introduction of explicit coordination among the sub-constraints,
guarantees to exclude invalid message sequences that are implicitly
speciﬁed, as in Figure 3(b). In this example, the message sequences
other than m1, c1, m2, c3, m4 or m1, c2, m3, c4, m4 are invalid.

To minimize coordination overhead, we propose an algorithm
to place coordinators, introduced by the decomposition of safety
constraints, in the publish/subscribe system to best reduce latency
for the service composition. The algorithm is designed based on

the safety constraints and the broker overlay topology of the pub-
lish/subscribe system. It takes the aggregated weights of latency
for a service composition introduced by extra coordinators into ac-
count. Then, the algorithm places coordinators at speciﬁcally se-
lected brokers to best reduce the overall latency. In the next sec-
tion, we turn our attention to the technique of safety constraints
enforcement.
4.2 Enforcement of Safety Constraints

As mentioned earlier, we model conﬂicting interactions as dis-
allowable behavior and enforce safety constraints to exclude them.
Speciﬁcally, the safety constraints are decomposed into sub-constraints
and deployed into the distributed runtime platform. In this section,
we formalize the safety constraints and the decomposition algo-
rithm to serve as a theoretical basis for our solution. We model the
safety constraints as an interaction process among services.

Deﬁnition 1. An interaction process P is deﬁned as follows:
m⇒ r2,

P ≡ (aint. · P ) | (P (cid:3) P ) | (P + P ) | 0, aint. ≡ r1

where aint. represents an interaction. i.e., r1 sends a message m
to r2. Operators ’·’, ’(cid:3)’, and ’+’ formally represent the sequence,
parallel, and choice operators in WS-CDL, respectively. The ter-
mination process is represented as 0.

Decomposing an interaction process into local processes to gov-
ern the behavior of each participating service may generate inter-
action that are different from what the original interaction process
speciﬁes. Formally, let P be an interaction process and LSri repre-
sents the decomposed sub-constraints for a partner service, ri, and
there exists an interaction sequence a1,a2, ··· ,ak among the part-
ner services. If the interaction sequence is the outcome of the com-
position of local interaction processes(LSr1 (cid:3) ··· (cid:3) LSrm), but
not the outcome of P , then the decomposition results in different
behavior between the local processes and the original interaction
process. Note that this difference is caused by the loss of synchro-
nizations during the decomposition. Therefore, to correctly enforce
the safety constraints, we need to explore and incorporate the miss-
ing synchronizations into the interaction processes. The following
rules show how this is done:
Deﬁnition 2. Let P be an interaction process, and a transforma-
tion function, P (cid:2) ≡ Ω(P ), is deﬁned recursively by the following
rules:
1. Ω(aint. · bint. · P )= aint. · cint.· Ω(bint. · P ), where aint. ≡
m1⇒ r2, bint. ≡ r3
2. Ω(aint. · bint. · P )= aint.· Ω(bint. · P ), where aint. ≡ r1
m1⇒
3. Ω(aint.·P1+bint.·P2)= cint.1· Ω(aint.·P1) + cint.2·Ω(bint.·
m2⇒ r4, r1 (cid:5)= r3,

r1
r2, bint. ≡ r3
P2), where aint. ≡ r1

m2⇒ r4, r2 (cid:5)= r3, cint. ≡ r2

m1⇒ r2, bint. ≡ r3

m2⇒ r4, r2 = r3.

c1⇒ r3.

WWW 2011 – Session: Web ApplicationsMarch 28–April 1, 2011, Hyderabad, India788cint.1 ≡ rc
aint. ≡ r1

c2⇒ r3.
m2⇒r4, r1 = r3.

c1⇒ r1, cint.2 ≡ rc
4. Ω(aint.·P1 +bint.·P2) = Ω(aint.·P1) + Ω(bint.·P2), where
m1⇒ r2, bint. ≡ r3
5. Ω(P1 (cid:3) P2) = Ω(P1) (cid:3) Ω(P2).
6. Ω(aint. · 0) = aint. · 0
7. Ω(0) = 0.
Based on the rules in Deﬁnition 2, we can enrich a safety con-
straint with extra coordination messages and coordinators to make
the decomposed sub-constraints consistent with the safety constraints.
In particular, Rule 1 addresses the out-of-order messages by adding
a synchronization message between two consecutive global tasks,
(i.e., interactions) where the receiver in the ﬁrst one is different
from the sender in the second one. Rule 3 addresses the invalid pick
problem by adding a coordinator to coordinate the two branches, if
the senders in the different branches belong to different partners.
Rule 2 states that if the receiver in an interaction is also the sender
in the immediately following interaction, then no synchronization
is needed. Similarly, Rule 4 states that if the senders in the ﬁrst
interactions in two branches are from the same partner, then no
synchronization is needed. In addition, Rule 5 states that the two
interaction processes can be enriched individually in parallel. Rules
6 and 7 specify the termination conditions of enriching an interac-
tion process. The following theorem guarantees the correctness of
our approach.
Theorem 1. Given an interaction process P and P (cid:2) ≡ Ω(P ),
then every interaction sequence of P (cid:2)
is also an interaction se-
quence of LSr1 (cid:3) ··· (cid:3)LSrm, and vice versa, where LSri is the
decomposed local process of P (cid:2)

.

The proof of Theorem 1 is based on the rules in Deﬁnition 2.

The full proof is provided in our technical report [40].

In the next section, we design algorithms to implement these

rules.
4.3 Reliable Decomposition Framework

Algorithm 1: Decomposition(G)
Input: Safety constraints G,
Set of partners R = {ri|i = 1, 2, ...n}
Output: Set of local sub-constraints LS
if G is not decomposed then
foreach r ∈ R do

if G is a successor of junction task then

CurrentT ask_r = junction task;

(LS_currentSender)_G.AddTask(G.id(), x(current_message));
(LS_currentReceiver)_G.AddTask(G.id(),
x(current_message));
foreach nextTask of G do

if (nextTask.sender (cid:3)= currentReceiver) or (G is P ICK) then

LS_currentReceiver.AddTask(G.id(), x(c));
LS_(nextT ask_sender).AddTask(G.id(), x(c));

foreach nextTask of G do

if nextTask is not decomposed then

Decomposition(nextTask);

else
LS_(nextT ask_sender).AddTransition(nextTask.id());
if currentSender = nextReceiver | currentReceiver = nextReceiver
then

LS_(nextT ask_receiver).AddTransition(nextTask.id());

1
2
3
4
5
6

7
8
9
10
11
12
13
14
15
16

17

In the previous section, we showed that the new coordination
mechanism guarantees correct decomposition of safety constraints.
In this section, we present techniques to implement the coordina-
tion mechanism.

Algorithm 1 determines the arrangement of coordination mes-
sages between partners. Suppose the two subsequent global tasks,
G followed by G(cid:2)
, are given. If the receiver of G is a different part-
ner as the sender of G(cid:2)
, then the algorithm must let the receiver of G

Algorithm 2: AddTask(id, Lnew)
Input: Sub-constraints LS,
Hash(k, List) where k = global task id, Last_k
Hash.put(id, Lnew);
if Lnew is PICK or FLOW then

Llast = Hash.get(Last_k).getF irstElement();

Llast = Hash.get(Last_k).getLastElement();

else
Succ_Llast ← Succ_Llast ∪ Lnew.id();
P rec_Lnew ← P rec_Lnew ∪ Llast.id();
Last_k ← id;

1
2
3
4
5
6
7
8

Algorithm 3: AddTransition(id)
Input: Hash(k, List(L, L
Last_k
Lf rom = Hash.get(id).getLastElement();
Lto = Hash.get(Last_k).getLastElement();
P rec_(Lf rom) ← P rec_(Lf rom) ∪ Lto.id();
Succ_(Lf rom) ← Succ_(Lf rom) ∪ Lf rom.id();

(cid:2))) where k = global task id,

1
2
3
4

include a local task of sending out a coordination message toward
the sender of G(cid:2)
into its sub-constraints as in (Algorithm 1: 6- 10).
Unlike the conventional faulty decomposition methods, multiple
local tasks can be produced by a single projection of a global inter-
action(Algorithm 1: 6- 7) for a sender and a receiver.

The mapping between the global and the local tasks is main-
tained in a hash table (Algorithm 2: Input). First, the local task
of sending a coordination message makes a transition from the
branching task (pick/ﬂow) in the local process (Algorithm 3:2-3),
if the local task is projected by a global branching task, as r2 in
Figure 5. When the decomposition framework explicitly requests
(Algorithm 1:15-17) to set up a transition using AddTransition (Al-
gorithm 3) from the task added by the previously projected global
task (Last_k), then there is a choice to be made to which element
should the last added task make a transition to, because the map-
ping returns a list of local tasks. Our framework simply chooses
the last element (Algorithm 3:2) and adds the transition by updat-
ing the pointers to immediately preceding (P rec) or succeeding
(Succ) tasks (Algorithm 3:3-4).

The newly derived service choreography, as in Figure 5, always
excludes the invalid message sequences thanks to the strict serial-
ization through explicit arrangement of coordination among part-
ners. Particularly for Figure 5, there is a globally unique initial
send task (L1 of r1) while others are under the constraint to start to
send a message only after receiving some message ﬁrst.
4.4 Runtime Choreography Platform

We employ a platform that can support the execution of chore-
ographies of independently developed Web services at global scale.
To enable the exchange of large volumes of messages between Web
services placed at geographically distributed locations, a scalable
and efﬁcient messaging substrate is essential. We adopt the feder-
ated content-based pub/sub messaging system, PADRES [10], al-
ready proven as distributed business process execution platform [20]
and as management platform for SOA applications in large deploy-
ments [17, 24, 39]. We use the efﬁcient and reliable routing mecha-
nism of PADRES for choreography message exchange as shown in
Figure 6. Each participating Web service is attached to a choreog-
raphy agent. A choreography agent interprets and translates local
processes into pub/sub constructs, e.g., advertisements, subscrip-
tions, and publications. Upon translation of the local processes,
the agent advertises and subscribes to messages to be sent out and
received, respectively. Once the initialization is complete, agents

WWW 2011 – Session: Web ApplicationsMarch 28–April 1, 2011, Hyderabad, India789(cid:62)(cid:87)

(cid:18)(cid:4)
(cid:17)

(cid:18)(cid:4)
(cid:17)

(cid:62)(cid:87)

(cid:18)(cid:381)(cid:381)(cid:396)(cid:282)(cid:349)(cid:374)(cid:258)(cid:410)(cid:381)(cid:396)
(cid:17)

(cid:17)

(cid:17)

(cid:18)(cid:381)(cid:374)(cid:400)(cid:410)(cid:396)(cid:258)(cid:349)(cid:374)(cid:410)(cid:3)
(cid:24)(cid:286)(cid:393)(cid:367)(cid:381)(cid:455)(cid:286)(cid:396)

(cid:18)(cid:381)(cid:381)(cid:396)(cid:282)(cid:349)(cid:374)(cid:258)(cid:410)(cid:381)(cid:396)
(cid:62)(cid:87)

(cid:62)(cid:87)

(cid:17)

(cid:17)

(cid:62)(cid:87)

(cid:62)(cid:87)
(cid:18)(cid:4)

(cid:18)(cid:4)

(cid:62)(cid:87)(cid:3)(cid:894)(cid:94)(cid:437)(cid:271)(cid:882)(cid:272)(cid:381)(cid:374)(cid:400)(cid:410)(cid:396)(cid:258)(cid:349)(cid:374)(cid:410)(cid:400)(cid:895)(cid:855)
(cid:62)(cid:381)(cid:272)(cid:258)(cid:367)(cid:3)(cid:87)(cid:396)(cid:381)(cid:272)(cid:286)(cid:400)(cid:400)
(cid:18)(cid:4)(cid:855)
(cid:18)(cid:346)(cid:381)(cid:396)(cid:286)(cid:381)(cid:336)(cid:396)(cid:258)(cid:393)(cid:346)(cid:455)(cid:3)(cid:4)(cid:336)(cid:286)(cid:374)(cid:410)
(cid:17)(cid:855)(cid:3)(cid:87)(cid:437)(cid:271)(cid:876)(cid:94)(cid:437)(cid:271)(cid:3)(cid:17)(cid:396)(cid:381)(cid:364)(cid:286)(cid:396)

(cid:349)

(cid:396)
(cid:381)
(cid:381)
(cid:410)
(cid:258)
(cid:374)
(cid:282)
(cid:396)
(cid:381)
(cid:381)
(cid:18)
(cid:3)
(cid:876)
(cid:3)
(cid:4)
(cid:18)

(cid:62)(cid:381)(cid:272)(cid:258)(cid:367)
(cid:62)(cid:381)(cid:272)(cid:258)(cid:367)(cid:3)
(cid:87)(cid:396)(cid:381)(cid:272)(cid:286)(cid:400)(cid:400)(cid:3)
(cid:47)(cid:374)(cid:410)(cid:286)(cid:396)(cid:393)(cid:396)(cid:286)(cid:410)(cid:286)(cid:396)

(cid:87)(cid:396)(cid:381)(cid:272)(cid:286)(cid:400)(cid:400)
(cid:87)(cid:396)(cid:381)(cid:272)(cid:286)(cid:400)(cid:400)(cid:3)
(cid:47)(cid:374)(cid:400)(cid:410)(cid:258)(cid:374)(cid:272)(cid:286)(cid:3)
(cid:47)(cid:374)(cid:349)(cid:410)(cid:349)(cid:258)(cid:367)(cid:349)(cid:460)(cid:286)(cid:396)

(cid:18)(cid:346)(cid:381)(cid:396)(cid:286)(cid:381)(cid:336)(cid:396)(cid:258)(cid:393)(cid:346)(cid:455)
(cid:18)(cid:346)(cid:381)(cid:396)(cid:286)(cid:381)(cid:336)(cid:396)(cid:258)(cid:393)(cid:346)(cid:455)(cid:3)

(cid:18)(cid:346)(cid:381)(cid:396)(cid:286)(cid:381)(cid:336)(cid:396)(cid:258)(cid:393)(cid:346)(cid:455)
(cid:18)(cid:346)(cid:381)(cid:396)(cid:286)(cid:381)(cid:336)(cid:396)(cid:258)(cid:393)(cid:346)(cid:455)(cid:3)

(cid:68)(cid:286)(cid:400)(cid:400)(cid:258)(cid:336)(cid:286)(cid:3)
(cid:39)(cid:286)(cid:374)(cid:286)(cid:396)(cid:258)(cid:410)(cid:381)(cid:396)

(cid:68)(cid:286)(cid:400)(cid:400)(cid:258)(cid:336)(cid:286)(cid:3)
(cid:62)(cid:349)(cid:400)(cid:410)(cid:286)(cid:374)(cid:286)(cid:396)

(cid:87)(cid:437)(cid:271)(cid:876)(cid:94)(cid:437)(cid:271)(cid:3)(cid:100)(cid:396)(cid:258)(cid:374)(cid:400)(cid:367)(cid:258)(cid:410)(cid:381)(cid:396)(cid:3)

(cid:87)(cid:437)(cid:271)(cid:876)(cid:94)(cid:437)(cid:271)(cid:3)(cid:18)(cid:381)(cid:373)(cid:373)(cid:437)(cid:374)(cid:349)(cid:272)(cid:258)(cid:410)(cid:349)(cid:381)(cid:374)(cid:3)(cid:47)(cid:374)(cid:410)(cid:286)(cid:396)(cid:296)(cid:258)(cid:272)(cid:286)(cid:3)

Figure 6: Choreography platform architecture.

step through the local processes by either publishing messages or
listening (subscribing) to pending messages. Local processes are
guaranteed to receive coordination messages as PADRES ensures
reliable, duplicate-free, per-source ordering.

A difﬁculty arises for the pick task. Placing a single coordina-
tor in a large messaging overlay is not desirable because it cannot
efﬁciently handle multiple pick tasks issued concurrently at differ-
ent locations in the overlay. We therefore opt to allocate multiple
coordinators per pick task instead. The challenge is to determine
a placement of coordinators in the messaging overlay that reduces
coordination overhead. Our solution aims to minimize the mes-
saging overhead involved with pick tasks. Given a list of services
r1, r2, . . . , rn that are potential recipients of the pick decision, the
coordination overhead, L, is formally deﬁned as

L =

n(cid:2)

i=1

wri dri ,

where ri is a partner service, wri is the weight expressed as an
average time to execute the end-to-end local interaction process of
ri and dri is a distance metric which is measured in terms of hop
counts from ri to the coordinator at the candidate location in the
messaging overlay. The weight, w, is to give higher precedence
to a task that contributes to the pick overhead over time, e.g., a
task with many subsequent tasks or with lengthy local processes.
The weight can be more accurately computed by incorporating the
pick probability distribution over time, i.e., the task with higher
probability to be picked obtains a higher weight.

A further issue is that there can be another pick task among the
subsequent tasks of the process contributing to the overhead of the
current pick task. Therefore, the placement of a pick coordinator
should be pending subject to the placement of pick coordinators
for subsequent pick tasks. To achieve this, our solution is based on
recursive algorithms as presented in Algorithm 4, 5.

Revisiting the overall architecture of the platform in Figure 6,
the coordinators are deployed to the overlay and follow the coordi-
nation processes just as the choreography agents follow their local
processes.

Algorithm 4: Overhead(task)
overhead = 0
List
if task is leaf then

return Overhead = runtime of task;

else

Overhead += runtime of task;
foreach child of task do

add Overhead(child) to List;

return Overhead+ =P laceCoordinator (List);

Algorithm 5: PlaceCoordinator(List)
minimumOverhead = 0
totalOverhead = 0
bestBroker
foreach broker of Brokers do

foreach task of List do

totalOverhead+ =
Distance(task.sender, broker) ∗ overhead;
if minumOverhead > totalOverhead then

minimumOverhead = totalOverhead;
bestBroker = broker;

Assign a coordinators to bestBroker

return minimumOverhead;

1

2
3
4

5
6

1

2
3

4
5

6
7

implemented on a cluster of IBM x3550 machines. The machines
in the cluster communicate over a 1Gbps switched Ethernet con-
nection, and each machine contains two Intel Xeon 5120 dual-core
1.86GHz processors and 4GB of RAM. The resulting decomposed
sub-constraints are deployed to each partner that is randomly con-
nected to one of the broker on a PADRES2 messaging overlay.

Safety constraints for the service choreography are randomly
generated as an interaction process in a directed graph. The pro-
cesses vary in number of tasks, partners, and task executions. Each
task speciﬁes a pair of sender and receiver and a message to be
exchanged. Every edge denotes a transition between two tasks.
Given the set of partners whose initial task is to send a message,
our framework randomly chooses an initial sender and triggers it at
a constant rate to execute the sending task during every instance of
the service choreography.

In the following subsections, we empirically assess how much
the service choreography based on the conventional decomposi-
tion [40] is prone to producing message communication patterns
that do not conform to the implicit and hidden safety constraints.
Speciﬁcally, we measure the number of messages delivered out-of-
order and the number of pick violations that reﬂect the degree of
potential semantic conﬂicts. Then, we assess the beneﬁts of the
distributed coordination mechanism as oppose to centralized coor-
dination in the runtime platform in terms of end-to-end latency of
a choreography. Finally, we measure the overhead of the new ap-
proach to avoid potential semantic conﬂicts in terms of the number
of coordination messages to be sent, and evaluate the runtime cost
to execute the decomposition framework. Also, we measure the in-
crease of local tasks along with the size of the rules our framework
has to maintain in order to monitor invalid message patterns during
runtime.
5.1 Assessment of Conﬂicts

5. EVALUATION

This section presents experimental evaluation of the algorithm
for reliable decomposition of safety constraints and the efﬁciency
of the runtime choreography platform. The decomposition algo-
rithm was tested on a machine with Intel Core2 Duo 1.80GHz pro-
cessors and 2GB of RAM. The runtime framework has been fully

Figure 7 and Figure 8 show minimum, maximum and average
number of violations of the ordering and pick constraints. They
indicate that the number of violations grows proportionally to the
number of tasks and the number of executions. The number of vio-
lations is not affected by the number of peers, as the constraints on

2http://msrg.org/projects/padres/

WWW 2011 – Session: Web ApplicationsMarch 28–April 1, 2011, Hyderabad, India790s
n
o

i
t

l

a
o
V

i

 
r
e
d
r
O

 
f

o

 
r
e
b
m
u
N

s
n
o

i
t

l

i

a
o
V
 
k
c
P

i

 
f

o

 
r
e
b
m
u
N

 600

 500

 400

 300

 200

 100

 0

 0

 500

 400

 300

 200

 100

 0

 0

PICK-avg
PICK
FLOW-avg
FLOW

s
n
o

i
t

l

a
o
V

i

 
r
e
d
r
O

 
f

o

 
r
e
b
m
u
N

 200

 400

 600

 800

 1000

 300

 250

 200

 150

 100

 50

 0

PICK
PICK-avg.
FLOW
FLOW-avg.

 0

 200

 400

 600

 800

 1000

Number of Tasks

Number of Partners

(a)

(b)

Figure 7: Number of ordering violations.

PICK-avg
PICK

s
n
o

i
t

l

i

a
o
V
 
k
c
P

i

 
f

o

 
r
e
b
m
u
N

 200

 400

 600

 800

 1000

 600

 500

 400

 300

 200

 100

 0

 0

PICK-avg
PICK

 200

 400

 600

 800

 1000

 
f

o

 
r
e
b
m
u
N

s
n
o

i
t

l

a
o
V

i

 
r
e
d
r
O

 
f

o

 
r
e
b
m
u
N

s
n
o

i
t

l

i

a
o
V
 
k
c
P

i

 600

 500

 400

 300

 200

 100

 0

 0

 500

 400

 300

 200

 100

 0

 0

PICK-avg
PICK
FLOW-avg
FLOW

 200

 400

 600

 800

 1000

Number of Executions

(c)

PICK-avg
PICK

 200

 400

 600

 800

 1000

Number of Tasks

Number of Partners

Number of Executions

(a)

(b)

(c)

Figure 8: Number of pick violations.

the message communication sequences from the global perspective
are agnostic of the participating peers, i.e., no matter how many dif-
ferent partners are involved in the process, ordering requirements
must be met. About 20% of 2,000 task executions violated the
constraints. The results show high variance in the degree of the vi-
olations. Identifying the structural properties that make safety con-
straints prone to the violations is subject to future work. The fact
that different partners contribute to the violations at different times
and locations makes it a complicated and costly task to identify the
root cause of the violation and to roll back the tasks already exe-
cuted. The signiﬁcant amount of violations reﬂects that detrimental
damage already has been done to the collaboration through the un-
reliable service choreography. Figure 9(b) shows the size of the

5.2 Overhead of Decomposition

We measured the elapsed time to decompose safety constraints.
Given a service choreography with 1,000 tasks and 10 partners, it
required from 38% and 30% more time on average to decompose
the process in a pick and a ﬂow pattern, respectively, as shown on
Figure 10. With the varying number of partners, up to 1,000, our
decomposition method took 72% and 56% more time on average
for a pick and a ﬂow pattern, respectively. The general increase ex-
hibited in our experiment is due to the additional arrangement of the
coordination among partners. Yet, on average the elapsed time still
remains within sub-milliseconds, thus our method does not cost
signiﬁcantly more than the conventional decomposition method, in
terms of computation.

r
e
n

t
r
a
P

 
r
e
p

 
s
k
s
a
T

 
f

o

 
r
e
b
m
u
N

 500

 400

 300

 200

 100

 0

 0

Reliable
Faulty

 200

 400

 600

 800

 1000

)

B
K

(
 
s
e
u
R

l

 
r
e
d
r
O

 
r
o

f
 

e
c
a
p
S

 10

 8

 6

 4

 2

 0

Order Rules
Pick Rules

 1200

 1000

 800

 600

 400

 200

 0
 200  400  600  800  1000

 0

)

B
K

l

(
 
s
e
u
R
 
k
c
P

i

 
r
o

f
 

e
c
a
p
S

)
s
u
(
 

i

e
m
T
n
o

 

i
t
i
s
o
p
m
o
c
e
D

 150

 120

 90

 60

 30

 0

 0

Reliable-FLOW
Reliable-PICK
Faulty-FLOW
Faulty-PICK

)
s
u
(
 

i

e
m
T
n
o

 

i
t
i
s
o
p
m
o
c
e
D

 200

 400

 600

 800

 1000

 80

 60

 40

 20

 0

 0

Reliable-FLOW
Reliable-PICK
Faulty-FLOW
Faulty-PICK

 200

 400

 600

 800

 1000

Number of Initial Tasks

Number of Tasks

Number of Partners

Number of Tasks

(a)

(b)

Figure 9: Coordination overhead.

(a)

(b)

Figure 10: Decomposition runtime.

rules that are used to detect conﬂicts by the broker in production.
About 10KB and 1MB are needed for the rules to detect ordering
and pick violations, respectively, given 1,000 tasks and 10 partners.
Figure 9(a) shows that each partner may experience about 130% in-
crease in the number of tasks in its sub-constraint, as the tasks of
either sending or receiving coordination messages are newly added
through the new decomposition method.

5.3 Overhead of Execution

The conﬂict-free service choreography is realized at the cost of
strictly coordinating the messages exchanged among the partners
when necessary as implied in the safety constraints. Figure 11
shows that the number of coordination messages increases with the
number of tasks and the number of executions, both for the pick and

WWW 2011 – Session: Web ApplicationsMarch 28–April 1, 2011, Hyderabad, India791s
e
g
a
s
s
e
M
n
o

 

i
t

i

a
n
d
r
o
o
C

 
f

o

 
r
e
b
m
u
N

 3000

 2500

 2000

 1500

 1000

 500

 0

 0

PICK-avg
PICK
FLOW-avg
FLOW

 200

 400

 600

 800

 1000

s
e
g
a
s
s
e
M
n
o

 

i
t

i

a
n
d
r
o
o
C

 
f

o

 
r
e
b
m
u
N

 4000
 3500
 3000
 2500
 2000
 1500
 1000
 500
 0

PICK-avg
PICK
FLOW-avg
FLOW
 600

 800

 1000

 0

 200

 400

s
e
g
a
s
s
e
M
n
o

 

i
t

i

a
n
d
r
o
o
C

 
f

o

 
r
e
b
m
u
N

PICK-avg
PICK
FLOW-avg
FLOW

 2000

 1500

 1000

 500

 0

 0

 200

 400

 600

 800

 1000

Number of Tasks

Number of Partners

Number of Executions

(a)

(b)

(c)

Figure 11: Number of coordination messages exchanged among partners.

ﬂow patterns. Pick patterns yielded more coordination messages
than the ﬂow patterns, since not only a coordination message has to
be exchanged between two consecutive tasks if necessary, but also a
coordination message is required between the partner services and
pick coordinators. In our experiment each control message simply
consists of a 1 byte character to distinguish the type of message
and a 4 byte integer to identify the message. Thus, for 2,000 ex-
ecutions, a total of only 14KB on average are used by the system.
In practice, the control message does not have to be signiﬁcantly
larger than ours.

5.4 Runtime Latency

)
c
e
s
(
 

e
m

i
t

n
u
R

 900
 800
 700
 600
 500
 400
 300
 200
 100
 0

Distributed
Central

 0

 20

 40

 60

 80

 100

)
c
e
s
(
 

e
m

i
t

n
u
R

 900
 800
 700
 600
 500
 400
 300
 200
 100
 0

Distributed
Central

 0

 2

 4

 6

 8

 10

Number of pick tasks

Number of Concurrent Instances

(a)

(b)

Figure 12: Latency in service choreography.

We measured the end-to-end latency of completing a set of chore-
ographies with the varying number of pick coordination tasks and
the varying degree of concurrency. An acyclic PADRES broker
overlay with fanout of up to 2 is randomly generated on 15 nodes in
our cluster. 20 unique services are randomly assigned to the nodes
in the overlay. For benchmarking purpose, we tuned Algorithm 4, 5
to create coordination mechanism. Instead of assigning the broker
at Algorithm 5:6, Algorithm 4 collects every intermediate overhead
statement into a list which is iterated over to pick one coordination
location in the overlay after the collection is completed.

The distributed coordination mechanism outperforms the cen-
tralized one from 2% to 14% with a single process instance with
from 20 to 100 unique pick coordination tasks, respectively. The
beneﬁt of the distributed coordination mechanism becomes bigger
when multiple process instances run concurrently (Figure 12(a)).
With 10 independent choreography instances (each with 20 ser-
vices and 20 picks) starting at the same time and running concur-
rently, the distributed coordination performed 60% better than the
centralized in terms of the latency (Figure 12(b)). Therefore, the
distributed coordination promises more scalable approach to host
multiple choreographed processes.

6. DISCUSSION

Services that participate in the collaboration may re-locate fre-
quently to cause coordination overhead to change. This may re-
quire adaptive re-computation of the the locations for the pick co-
ordinators.

Note that our coordination mechanism is enabled per instance.
As a future work, our framework can be extended to support coor-
dination for interaction among multiple instances. An alternative
approach to our coordination mechanism is to allow individual ser-
vices to govern the pick operation. But this can lead to wrong pick
decision making by a malicious service. Moreover, services may
have afﬁnity to particular locations, therefore, controlling the over-
head of coordination such as latency can be less ﬂexible.

In our solution, we enrich the safety constraints with extra co-
ordination messages to avoid potential overlooked semantic con-
ﬂicts. Such coordination messages may not exactly reﬂect the de-
sign intention of the choreography and thus restrict the behavior
of services, but our solution discovers only the hidden and missing
synchronizations among the service conversations. Choreography
designers can check whether the hidden and missing synchroniza-
tions identiﬁed by our framework are design faults and choose to ﬁx
the problems using our recommended solution or other solutions.
In a more ﬂexible environment, safety constraints can evolve
and multiple versions of decomposed constraints can co-exit dur-
ing runtime, which inevitably causes semantic conﬂicts. In order to
avoid such a problem, management tools that can monitor the sta-
tus of choreography instances and stop/resume them, if necessary,
is required. We have already started investigating the adaptation of
relevant workﬂow management standards [15].

7. RELATED WORK

In this section, our work is put in context of existing techniques
in service composition, veriﬁcation of service choreography and
decomposition algorithms.

Coordination Framework for Dynamic Service Compositions.
Dynamic composition of services is challenging but of beneﬁt to
changing business requirements [29]. Several approaches have been
proposed to provide infrastructure support for dynamic composi-
tion of services [16]. For example, eFlow [5] is a framework sup-
porting adaptive and dynamic composition of services. eFlow al-
lows the business logic of a service composition to be modiﬁed
dynamically. Bultan et al. proposed a theoretical framework to
model service conversation speciﬁcations and studied realizability
of service compositions [4]. Nezhad et al. designed a business con-
versation manager to support business conversations among people
around best practices [26]. Brambilla et al. proposed a CASE tool
together with a web engineering methodology to model and revise

WWW 2011 – Session: Web ApplicationsMarch 28–April 1, 2011, Hyderabad, India792processes in web applications. A global speciﬁcation is assumed
as a template in these approaches to guide the adaptation or coordi-
nation of service interactions. Our framework coordinates service
interactions in a more ﬂexible and loosely-coupled way, especially
when a global speciﬁcation is not available.

There also exist approaches based on message-oriented middle-
ware to support service orchestration and choreography. For ex-
ample, Li et al. proposed a framework to deploy a centralized
BPEL process into a set of distributed execution engines on top
of a pub/sub middleware [20]. Overbeek et al. combined SOA
and event-driven architectures to deliver services in a pub/sub net-
work [27]. Tai et al. proposed to use message-oriented middle-
ware for service interactions [34].
In addition, some industrial
Web service coordination frameworks and standards are also pro-
posed to develop service-oriented applications. For example, WS-
Coordination (WS-C)3 is a framework that provides protocols to
coordinate the activities of involved services in a service composi-
tion. Web Services Composite Application Framework (WS-CAF)4
coordinates the activities and propagates the contexts among the in-
volved services. The difference is that we applied a pub/sub mid-
dleware not only to route messages, but also to coordinate loosely
coupled, ﬂexible and dynamic service compositions. Moreover, we
also deployed safety constraints into the distributed framework to
prevent semantically conﬂicting interactions with acceptable pro-
cessing overhead.

Resolving Mismatches for Service Choreography. Many re-
search efforts have been devoted to constructing a choreography for
independently developed services. To resolve mismatches between
interacting services, Nezhad et al. proposed a semi-automated ap-
proach to adapt service interactions based on a constructed mis-
match tree [23]. Benatallah et al. proposed a framework to de-
velop adapters for service interoperability based on mismatch pat-
terns [2]. Dumas et al. resolved mismatches between services by
adapting their behavioral interfaces with algebra and visual nota-
tions [8]. These approaches can be applied to resolve semantic
conﬂicts for interacting services by introducing adapters to bridge
mismatches. However, these solutions are incapable of handling
loosely coupled and dynamic service compositions, as the adapters
designed to model mismatches may not be able to anticipate new
mismatches introduced by dynamically joining services.

Doganata et al. suggested to detect compliance failures in busi-
ness processes using automatic auditing tools [7]. Our work pro-
vides a more ﬂexible coordination framework to resolve semantic
conﬂicts among interacting services in dynamic service composi-
tions. Instead of adapting the involved services, our framework en-
forces safety constraints to control interactions among services to
prevent service compositions from entering into semantically con-
ﬂicting situations.

Conformance Checking for Service Choreography. Another
solution to prevent conﬂicts in service choreography is to select
services that correctly implement a global speciﬁcation. This re-
quires to check the conformance between selected services and the
global speciﬁcation of the service composition. Aalst et al. [36]
evaluated the conformance relationships between service behavior
at runtime and its global speciﬁcation in terms of two properties,
that is, ﬁtness and appropriateness. Montali et al. [22] described
the global speciﬁcation with a declarative language and veriﬁed the
services’ behavior based on logic. Fu et al. [12] used automata
to verify service compositions with asynchronous communication.
Foster et al. [11] veriﬁed the safety and liveness properties of ser-

3http://docs.oasis-open.org/ws-tx/wscoor/
4http://www.oasis-open.org/committees/ws-caf/

vice compositions based on process algebra. All these approaches
are restricted to a service composition with a fully deﬁned global
speciﬁcation.
In a loosely coupled and dynamic service compo-
sition where the number of services is unknown and services can
join or leave dynamically, a well planned global speciﬁcation is
not available in advance [27]. Therefore, our framework enforces
safety constraints instead of a full global speciﬁcation to prevent
conﬂicts in loosely coupled and dynamic service interactions.

Realizability Issue. In service choreography, the local speciﬁca-
tion orchestrates the behavior of each service so that their interac-
tion conforms to the global speciﬁcation. An assumption is that the
global speciﬁcation should be realizable, in the sense that the global
speciﬁcation can be implemented by a set of distributed services.
Verifying the realizability of a global speciﬁcation is undecidable
in general [1, 13]. Existing approaches enrich a global speciﬁca-
tion with additional synchronization messages and coordinators to
render global speciﬁcations realizable [6, 31]. Our approach also
adds synchronization messages and coordinators to guarantee that
the distributed sub-constraints conform to the safety constraints
that are deﬁned to exclude conﬂicting scenarios. The difference
between our work and the aforementioned work is that our work
is to exclude disallowable behavior as opposed to specifying al-
lowable behavior. Moreover, we also developed an algorithm to
deploy sub-constraints to speciﬁcally selected locations in the dis-
tributed framework to reduce the enforcement overhead associated
with safety constraints, which is not addressed in existing work.

Decomposition Algorithms. In a top-down service composition
approach, service developers develop a global speciﬁcation (e.g., in
WS-CDL [37]) and decompose it into local speciﬁcations. Services
are then selected to implement the local speciﬁcations. Aalst et al.
applied a Petri-net based approach to decompose global speciﬁ-
cations into local public views with four kinds of consistency re-
lationships [35]. Broy et al. proposed a formal model to split a
service into sub-services by projection [3]. Giese et al. developed
a modular approach to design, decompose, reﬁne and verify com-
plex systems [14]. Nanda et al. introduced an approach to partition
a composite Web service written as a single BPEL program into
an equivalent set of decentralized processes [25]. In our work, we
also provided an algorithms to decompose safety constraints into
a set of distributed sub-constraints. The difference is that our ap-
proach is applied to exclude semantically conﬂicting interactions in
the framework whereas existing approaches are used to specify the
allowable behavior of each involved service.

8. CONCLUSIONS

This paper introduces a novel distributed framework to coor-
dinate semantic conﬂict-free interactions among autonomous ser-
vices in a dynamic service composition. The framework allows
services to interact with each other in a ﬂexible and loosely-coupled
way by publish/subscribe messaging. To prevent arbitrary interac-
tions among services that violate application semantics, we pro-
vide algorithms to enforce safety constraints for dynamic service
compositions. The algorithms decompose the safety constraints
into sub-constraints which are deployed into the distributed run-
time framework. We prove that these sub-constraints can collabo-
ratively prevent semantic conﬂicting interactions among the partic-
ipating services. We also develope an algorithm to place the sub-
constraints to well selected locations in the distributed framework
to reduce the enforcement overhead for safety constraints. Accord-
ing to our evaluation, the framework exhibits negligible overhead
in enforcing the safety constraints and higher scalability than a cen-
tralized approach.

WWW 2011 – Session: Web ApplicationsMarch 28–April 1, 2011, Hyderabad, India7939. REFERENCES
[1] R. Alur, K. Etessami, and M. Yannakakis. Realizability and

veriﬁcation of msc graphs. Theor. Comput. Sci.,
331(1):97–114, 2005.

[2] B. Benatallah, F. Casati, D. Grigori, H. R. M. Nezhad, and

F. Toumani. Developing adapters for web services
integration. In CAiSE, pages 415–429, 2005.

[3] M. Broy, I. H. Krüger, and M. Meisinger. A formal model of
services. ACM Trans. Softw. Eng. Methodol., 16(1):5, 2007.

[4] T. Bultan, X. Fu, R. Hull, and J. Su. Conversation

speciﬁcation: a new approach to design and analysis of
e-service composition. In WWW ’03, pages 403–410, New
York, NY, USA, 2003. ACM.

[5] F. Casati and M.-C. Shan. Dynamic and adaptive

composition of e-services. Inf. Syst., 26(3):143–163, 2001.

[6] G. Decker, A. Barros, F. M. Kraft, and N. Lohmann.

Non-desynchronizable service choreographies. In ICSOC
’08, pages 331–346, Berlin, Heidelberg, 2008.
Springer-Verlag.

[7] Y. N. Doganata and F. Curbera. Effect of using automated

auditing tools on detecting compliance failures in
unmanaged processes. In BPM, pages 310–326, 2009.

[8] M. Dumas, K. W. Wang, and M. L. Spork. Adapt or perish:
Algebra and visual notation for service interface adaptation.
2006.

[9] S. Dustdar and W. Schreiner. A survey on web services

composition. Int. J. Web Grid Serv., 1(1):1–30, 2005.

[10] E. Fidler et al. Distributed publish/subscribe for workﬂow

management. In ICFI, 2005.

[11] H. Foster, S. Uchitel, J. Magee, and J. Kramer. Model-based
veriﬁcation of web service compositions. In ASE ’03, pages
152–161, Los Alamitos, CA, USA, 2003.

[12] X. Fu, T. Bultan, and J. Su. Analysis of interacting bpel web
services. In WWW ’04, pages 621–630, New York, NY, USA,
2004. ACM.

[13] X. Fu, T. Bultan, and J. Su. Synchronizability of

conversations among web services. IEEE Trans. Softw. Eng.,
31(12):1042–1055, 2005.

[14] H. Giese, S. Burmester, W. Schäfer, and O. Oberschelp.

Modular design and veriﬁcation of component-based
mechatronic systems with online-reconﬁguration. In
SIGSOFT ’04/FSE-12, pages 179–188, New York, NY, USA,
2004. ACM.

[15] D. Hollingsworth. Workﬂow management coalition - the

workﬂow reference model. Technical report, Workﬂow
Management Coalition, Jan. 1995.

[16] R. Hull and J. Su. Tools for composite web services: a short

overview. SIGMOD Rec., 34(2):86–95, 2005.

[17] H.-A. Jacobsen and Muthusamy. BPM in cloud architectures:

Business process management with SLAs and events. In
BPM ’10, Hoboken, NJ, USA, 2010.

[18] R. Kazhamiakin, A. Metzger, and M. Pistore. Towards

correctness assurance in adaptive service-based applications.
In ServiceWave ’08, pages 25–37, Berlin, Heidelberg, 2008.
Springer-Verlag.

[19] D. Kuropka. What does service-oriented computing really

mean? In Service Oriented Computing, 2005.

[20] G. Li, V. Muthusamy, and H.-A. Jacobsen. A distributed

service-oriented architecture for business process execution.
ACM Trans. Web, 4(1):1–33, 2010.

[21] L. T. Ly, S. Rinderle, and P. Dadam. Integration and

veriﬁcation of semantic constraints in adaptive process
management systems. Data Knowl. Eng., 64(1):3–23, 2008.

[22] M. Montali, M. Pesic, W. M. P. v. d. van der Aalst,

F. Chesani, P. Mello, and S. Storari. Declarative speciﬁcation
and veriﬁcation of service choreographiess. ACM Trans.
Web, 4(1):1–62, 2010.

[23] H. R. Motahari Nezhad, B. Benatallah, A. Martens,

F. Curbera, and F. Casati. Semi-automated adaptation of
service interactions. In WWW ’07, pages 993–1002, New
York, NY, USA, 2007. ACM.

[24] V. Muthusamy et al. SLA-driven business process

management in SOA. In CASCON ’09, pages 86–100, New
York, NY, USA, 2009. ACM.

[25] M. G. Nanda, S. Chandra, and V. Sarkar. Decentralizing

execution of composite web services. In OOPSLA ’04, pages
170–187, New York, NY, USA, 2004. ACM.

[26] H. R. M. Nezhad, S. Graupner, and S. Singhal. Business
conversation manager: Facilitating people interactions in
outsourcing service engagements. In ICWE, pages 468–481,
2010.

[27] S. Overbeek, B. Klievink, and M. Janssen. A ﬂexible,

event-driven, service-oriented architecture for orchestrating
service delivery. IEEE Intelligent Systems, 24(5):31–41,
2009.

[28] M. P. Papazoglou, P. Traverso, S. Dustdar, F. Leymann, and

B. J. Krämer. Service-oriented computing: A research
roadmap. In Service Oriented Computing, 2005.

[29] M. P. Papazoglou, P. Traverso, I. Ricerca, and

S. Tecnologica. Service-oriented computing: State of the art
and research challenges. IEEE Computer, 40:2007, 2007.

[30] C. Peltz. Web services orchestration and choreography.

Computer, 36(10):46–52, 2003.

[31] G. Salaün and T. Bultan. Realizability of choreographies

using process algebra encodings. In IFM ’09, pages
167–182, Berlin, Heidelberg, 2009. Springer-Verlag.

[32] B. Srivastava. Web service composition - current solutions

and open problems. In ICAPS ’03, pages 28–35, 2003.

[33] A. T. Stephen and O. Toubia. Deriving Value from Social

Commerce Networks. SSRN eLibrary, 2009.

[34] S. Tai, T. A. Mikalsen, and I. Rouvellou. Using

message-oriented middleware for reliable web services
messaging. In WES, pages 89–104, 2003.

[35] W. M. P. van der Aalst and T. Basten. Inheritance of

workﬂows: an approach to tackling problems related to
change. Theor. Comput. Sci., 270:125–203, January 2002.
[36] W. M. P. van der Aalst, M. Dumas, C. Ouyang, A. Rozinat,
and E. Verbeek. Conformance checking of service behavior.
ACM Trans. Internet Technol., 8(3):1–30, 2008.

[37] W3C. Web services choreography description language

version 1.0, 2005. http://www.w3.org/TR/ws-cdl-10.

[38] I. Weber, J. Hoffmann, and J. Mendling. Beyond soundness:

on the veriﬁcation of semantic business process models.
Distrib. Parallel Databases, 27(3):271–343, 2010.

[39] W. Yan, S. Hu, V. Muthusamy, H.-A. Jacobsen, and L. Zha.

Efﬁcient event-based resource discovery. In DEBS ’09, pages
1–12, New York, NY, USA, 2009. ACM.

[40] Y. Yoon, C. Ye, and H.-A. Jacobsen. On semantics conﬂict in

service choreography. In Middleware Systems Research
Group Technical Report, Toronto, Canada, March 2010.

WWW 2011 – Session: Web ApplicationsMarch 28–April 1, 2011, Hyderabad, India794