DIANE - An Integrated Approach to Automated Service

Discovery, Matchmaking and Composition

Ulrich Küster and Birgitta König-Ries

Institute of Computer Science

Friedrich-Schiller University Jena

Jena, Germany

Mirco Stern and Michael Klein

Institute for Program Structures and Data

Organization

University Karlsruhe, Germany

ukuester|koenig@informatik.uni-jena.de

mirco.stern|kleinm@ipd.uni-karlsruhe.de

ABSTRACT
Automated matching of semantic service descriptions is the
key to automatic service discovery and binding. But when
trying to ﬁnd a match for a certain request it may often hap-
pen, that the request cannot be serviced by a single oﬀer but
could be handled by combining existing oﬀers. In this case
automatic service composition is needed. Although auto-
matic composition is an active ﬁeld of research it is mainly
viewed as a planning problem and treated separatedly from
service discovery. In this paper we argue that an integrated
approach to the problem is better than seperating these is-
sues as is usually done. We propose an approach that inte-
grates service composition into service discovery and match-
making to match service requests that ask for multiple con-
nected eﬀects, discuss general issues involved in describing
and matching such services and present an eﬃcient algo-
rithm implementing our ideas.

Categories and Subject Descriptors
H.3.5 [Information Systems]: Online Information Ser-
vices—Web-based services; D.2.12 [Software Engineer-
ing]: Interoperability; D.2.m [Software Engineering]: Mis-
cellaneous

General Terms
Algorithms

Keywords
Automated service composition, service discovery, service
matchmaking

1.

INTRODUCTION

An important vision of service oriented computing is to
enable dynamic service binding, i.e., it should become pos-
sible to automatically choose and invoke service providers
at runtime. To achieve this, appropriate means to describe
and match services are needed.
In our previous work we
have presented such means, namely a service description
language and an eﬃcient matching algorithm for this lan-
guage [5, 6, 7]. However, when trying to ﬁnd a match for a
certain request it may often happen, that the request can-
not be serviced by a single oﬀer alone but could be handled
Copyright is held by the International World Wide Web Conference Com-
mittee (IW3C2). Distribution of these papers is limited to classroom use,
and personal use by others.
WWW 2007, May 8–12, 2007, Banff, Alberta, Canada.
ACM 978-1-59593-654-7/07/0005.

by combining existing oﬀers. Traditional service matching
mechanisms fail in these cases but techniques of automatic
service composition oﬀer a solution. Although automatic
composition is a very active ﬁeld of research it is mainly
viewed as a planning problem and usually treated separately
from service discovery. Most composition approaches do not
deal with semantic discovery at all and many use proprietary
request (or better goal) description languages suitable for
planning and composition, but not for discovery. Further-
more, most frameworks for automated service composition
have no or at least only a very limited notion of the quality
of a created composition or preferences among alternative
compositions. This is partly due to the fact that classical
planning (where many service composition approaches root
in) usually does not even attempt to ﬁnd an optimal plan,
but only to ﬁnd a plan at all. Furthermore, expressing pre-
cise preferences that usually involve competing optimization
goals (like quality versus price) is a diﬃcult problem on its
own. Clearly automated service composition could beneﬁt
here from service discovery and matchmaking where prefer-
ences among competing oﬀers naturally play a central role.
Thus, in this paper we propose an approach that integrates
service composition into service discovery and matchmak-
ing. On the one hand we can leverage previous work on
preference modelling for use in automated service compo-
sition, on the other hand, we increase the likelihood to be
able to service a given request in a fully automated fashion
by integrating automated composition into service discov-
ery and matchmaking.
In this paper we focus on a class
of service requests that ask for multiple connected eﬀects
(like purchasing of a good and delivery of the purchased
good to a certain destination). We discuss general issues in-
volved in describing and matching such services and extend
the matching algorithm introduced in [5, 7] in theory and
practice to be able to successfully match such requests.
2. A MOTIVATING EXAMPLE

Imagine an automotive manufacturer with several locally
distributed factories. At each site, several parts are needed
to construct the cars, most of which are purchased from ex-
ternal component suppliers and delivered to the appropriate
sites by third party shippers. As an example, a factory in
Karlsruhe could

• require a quantity of screws with a countersunk head,

zinc plated and a size of 5x40 mm

• which have to be delivered to Karlsruhe ideally on De-

cember 8th, but not earlier than December 3rd.

In order to detect appropriate service providers, these ef-
fects need to be captured by a semantic service request de-
scription. We call requests like this one, that contain more
than one eﬀect (in this case purchasing and delivery) which
are dependent on each other (e.g. delivery has to depart
at the location where the screws are purchased), requests
with multiple connected eﬀects. Generally the formulation
of any service request should be driven by the desired eﬀects,
only. It should not be necessary for the requester to take
into consideration which services are available at any given
time. This is particularly important in dynamic environ-
ments, where the set of service providers may change over
time. While the manufacturer will probably need screws
on a regular basis, instead of statically binding to a certain
(combination of) provider(s), the most appropriate service
providers should be identiﬁed anew each time the respec-
tive request is issued. Thereby, we ensure that each time
the best matching provider is chosen (e.g., changes in prize
or quality are taken into account) and that we consider all
service providers that are available at this point of time and
only those.

The requester does not necessarily have knowledge about
the service landscape at execution time, and thus, doesn’t
know at which granularity services are oﬀered. This implies,
that it should not be necessary for the requester to divide
the request into parts so that each part can be fulﬁlled by
a single service oﬀer. As an example, the following set of
oﬀers could be present:

• Service 1: a component supplier could sell 2000 diﬀer-
ent types of high quality screws to customers within
the EU. Screws can be picked up at a number of listed
warehouses (e.g. Hamburg, Paris, Berlin, . . . ).

• Service 2: a shipper could deliver goods within Ger-
many, Austria and Switzerland, if the goods do not
need any cooling or freezing and their packages adhere
to certain maximum weights and sizes.

• Service 3: a component supplier could sell and ship
1000 diﬀerent types of screws and bolts to customers
within Germany and Austria.

For a human, it is quite obvious, that either a combination
of the ﬁrst two services or the third service alone might be
able to fulﬁll the service request. For an automated matcher
this problem is far from trivial. The matcher does not only
have to realize that a combination of services provide the
desired eﬀects, it also has to ensure certain constraints on
the composition like whether Service 2 is able to ship from
Service 1’s location to Karlsruhe and whether the package
that Service 1 will provide the screws in adheres to Service
2’s restrictions on weights and sizes.

This is, where planning-based approaches to composition
have their weakness. A planner typically will be able to
determine that the request could be answered by a com-
bination of a manufacturer and a shipment service. How-
ever, since these planners are executed separate of service
discovery, the enforcing of the constraints has to be han-
dled separately. Also, there is no guarantee, that suitable
services will be available at runtime. In our approach, on
the contrary, only currently valid oﬀers are taken into con-
sideration, constraint enforcement is an integrated part of
service composition and diﬀerent combinations of providers
are ranked according to the requester’s preferences.

The goal of our approach is to build an automated matcher
that is able to compose services, provides ﬁne-grained and
precise ranking among competing oﬀers (single ones as well
as automatically composed ones) and is able to automat-
ically invoke the best oﬀer. Thus, we need the ability to
express constraints like the ones listed above within the ser-
vice descriptions and we need an algorithm that is able to
handle requests containing multiple connected eﬀects.

In the following two sections we will quickly recap previous
work on describing services and matching such descriptions
without the ability to cover multiple connected eﬀects. In
Section 5 we will introduce a conceptual foundation for ex-
tending the language and the matching algorithm to cover
multiple connected eﬀects and enable automatic composi-
tion for these cases. In Section 6 we will explain the imple-
mentation of our ideas in our matching algorithm in detail.
Thereafter, we will evaluate our approach, give an overview
of the related work and conclude.

3. WHAT IS DSD?

DSD (DIANE Service Descriptions) is a service descrip-
tion language based on its own light-weight ontology lan-
guage that is specialized for the characteristics of services
and can be processed eﬃciently at the same time. For the
following an intuitive understanding of DSD is suﬃcient,
since the concepts of the matching algorithm are not spe-
ciﬁc to DSD. We will explain the basic features of DSD on
the basis of a simple example shown in Figure 1 that shows
a request for a shipment service formulated in DSD. More
comprehensive information about DSD and the matching
algorithm can be found in [5, 6, 7].

The basis for DSD is standard object orientation which is

extended by four additional elements:

• operational elements: Services change the state of the
real-world (or the information space). Operational el-
ements allow to express this world-altering capacity.
In Figure 1, you’ll ﬁnd the operand eﬀect, describing
that we are looking for a service that creates a state of
the world where something is shipped. We view these
operational elements as the most central property of a
service, thus, in DSD, services are primarily described
by their eﬀects – all other aspects (as ﬂow of informa-
tion, choreography etc.) are seen as secondary, derived
properties. Concepts like states are declaratively de-
ﬁned which leads to descriptions as trees as seen in
Figure 1.

• aggregating elements: A service is typically able to of-
fer not one speciﬁc eﬀect, but a set of similar eﬀects.
A shipment service for instance will be able to oﬀer
transport of diﬀerent kinds of goods from one arbitrary
destination to another. That means, services oﬀer to
provide one out of a set of similar eﬀects. Requesters
on the other hand, typically are looking for the per-
fect service, but accept services that deviate from this
service to a certain degree with lower preference (e.g.
a slightly more expensive service is acceptable if no
cheaper service is available). Thus, the eﬀect of a ser-
vice (request or oﬀer) is typically not a single but a set
of states, depicted in DSD by a small diagonal line in
the upper left corner of a concept. This way, oﬀers de-
scribe the set of possible eﬀects they can provide and

Figure 1: Simpliﬁed DSD shipping request

requests describe the set of eﬀects they are willing to
accept.

• selecting elements: While a service will oﬀer diﬀerent
eﬀects, upon invocation, the requester needs to choose
which of these eﬀects the service should provide in this
speciﬁc instance. Meanwhile, after service execution
the requester might need to receive results about the
speciﬁc eﬀect performed by the invocation. In DSD,
variables (denoted by a grayed rectangle) are used to
support this. In oﬀers, variables allow the requester to
conﬁgure the oﬀer and to choose the particular desired
eﬀect to provide. In the request seen in Figure 1, the
requester requires to retrieve the exact price of the
shipment after service invocation.

• rating elements: This type of element is used in service
requests only. As mentioned, requesters will typically
be willing to accept services with slightly diﬀering ef-
fects although with diﬀering preference. These prefer-
ences can be expressed by fuzzy instead of crisp sets
in request descriptions – the larger the membership
value, the higher the preference. Rating elements are
a key feature of DSD and are the main feature used to
choose among competing oﬀers. This will be explained
in more detail in the following section.

4. THE BASIC MATCHING ALGORITHM

FOR SINGLE EFFECTS

A matcher for service descriptions generally has two tasks:
First and foremost it has to determine if - and how well -
an oﬀer description ﬁts a given request description. But
if service oﬀers are conﬁgurable (and usually they are) it
also has to ﬁnd an optimal conﬁguration of the oﬀer. This
is necessary to determine precisely how well an oﬀer ﬁts
a request and to be able to automatically invoke the best
oﬀer service later [8]. In DSD this conﬁguration is done by
choosing and assigning concrete values to all variables in an
oﬀer description during the matching process.

Since any description language should be capable of ex-
pressing preferences among competing oﬀers, the result of
matching a request with an oﬀer should not be a Boolean

value but rather some metric of the degree of correspon-
dence. In the following we refer to this result as a ”matching
value” normalized in the interval [0,1]. The basic problem of
matching a DSD oﬀer o against a DSD request r can thus be
stated as follows: Compute the fuzzy containment value (out
of [0, 1]) of o’s eﬀect sets in r’s eﬀect sets and - while doing
this - where possible conﬁgure o in a way that maximizes this
value. Since DSD request as well as oﬀer descriptions are
trees stemming from similar ontological concepts (classes),
an obvious basic technique for comparing both descriptions
is a graph matching approach. Beginning with the root el-
ement of type Service, the two descriptions are traversed
synchronously and compared step by step. This algorithm
has been introduced in [5, 6, 7].

The matching value of a leaf of a description is computed
using the fuzzy membership value of the oﬀer element set in
the corresponding request element set. In our example (see
Figure 1), the requester is willing to pay any price below 50
USD but would prefer lower prices over higher ones1. Alike
the requester would like to have the shipping time less than
ten days, but is willing to accept a standard deviation up to
ten percent again with linearly decreasing preference. The
matching value of an inner node is basically computed by
combining the matching values of it’s child nodes. The way
how to do this (called connecting strategy) can be conﬁg-
ured by a requester. Naturally any requester prefers shorter
shipping time and lower prices, but in the example the re-
questor emphasizes that the prize is more important to him
than the shipping time by specifying how to compute the
membership value for the Shipped set by using a weighted
sum (0.3 ∗ shippingT ime + 0.7 ∗ price) of the membership
values for the shippingTime and the price. DSD’s rating
features (fuzzy sets combined with customizable connecting
strategies) allow to prescribe the desired eﬀect very precisely
yet allow for a certain ﬂexibility, thus maximizing the like-
lihood of ﬁnding an appropriate service.

The issues related to the optimal conﬁguration of an oﬀer
during the matching process are beyond the scope of this
paper (see [7] for details) but it is important to mention
1Actually the formula ”∼== [0, 50] 0” denotes that a price
of 0 is requested, but a deviation up to 50 is accepted with
lower preference.

unit(cid:13)upper(cid:13)request(cid:13): (cid:13)Service(cid:13)upper.profile(cid:13): (cid:13)ServiceProfile(cid:13)presents(cid:13)effect(cid:13)Shipped(cid:13)0.3 * shippingTime + 0.7 * price(cid:13)toAddress(cid:13)cargo(cid:13)Address(cid:13)String(cid:13)== "Mr. Barney Gumble"(cid:13)name(cid:13)String(cid:13)== "320 East 7th Street"(cid:13)street(cid:13)String(cid:13)== "10021"(cid:13)zipCode(cid:13)City(cid:13)== newyork(cid:13)city(cid:13)domain.measure(cid:13): (cid:13)WeightMeasure(cid:13)weight(cid:13)val(cid:13)domain.measure(cid:13)pound(cid:13): (cid:13)WeightUnit(cid:13)top(cid:13): (cid:13)PhysicalEntity(cid:13)Integer(cid:13)== 10(cid:13)Price(cid:13)OUT,e,1(cid:13)Currency(cid:13)== usd(cid:13)Double(cid:13)~==[0,50] 0(cid:13)currency(cid:13)val(cid:13)price(cid:13)Duration(cid:13)~<= <P10DT>(cid:13)shippingTime(cid:13)that DSD has been designed in a way that largely allows
the matcher to optimize variable ﬁllings locally. This ensures
eﬃcient processability. To maintain this feature is one of the
biggest obstacles in extending the basic matching algorithm
for single eﬀects2 to cover multiple connected eﬀects also.
We will illustrate this issue in the next section.

5. CONCEPTIONAL FOUNDATION OF

HANDLING MULTIPLE EFFECTS

Although at ﬁrst glance it seems straightforward to ex-
tend the above explained procedure that is capable of han-
dling single eﬀect services to also cover multiple eﬀects, on
closer inspection some problems arise. These problems are
mainly due to the fact that multiple eﬀect services usually
contain relations between eﬀects. Recall the example from
Section 2. Here, the place of manufacture needs to corre-
spond to the location where the shipping company picks up
the goods. Also, the restrictions on the shipping service’s
delivered weights and sizes need to correspond to the pack-
ages used by the manufacturer.

Such connections between eﬀects are the main reason why
we need service descriptions containing multiple eﬀects. If
the eﬀects were unrelated, the user could as well simply
pose multiple requests each one consisting of a single eﬀect.
It turns out that when using straightforward extensions to
the service description language the matchmaking becomes
ineﬃcient and doesn’t scale anymore. This problem as well
as our solution is in the focus of this section.
5.1 An Intuitive Approach

The central issue in describing a service covering multi-
ple eﬀects is how relations between those eﬀects can be ex-
pressed. Regarding our example, we are looking for a way
to request a particular quantity of screws (Eﬀect 1: owning
screws) as well as their delivery within a certain amount of
time (Eﬀect 2: delivery). Since at the time of establish-
ing the request it is unclear which suitable manufacturer is
available, it is also unknown where the delivery departs. All
that can be said is that the shipping service has to pick up
the screws where the manufacturer is located. That is, the
place where the manufacturer is located and the departure
of the delivery are the same. Furthermore, the purchased
screws are the good that is to be transported. This is im-
portant for instance to compute the price of the shipment
depending on the weight of the good.

An intuitive approach to describing such a connection is
by having both eﬀects pointing to the same concept. This is
shown in Figure 2 which shows the central aspects of a re-
quest description corresponding to the example introduced
in Section 2. Clearly, this is suﬃcient to express the desired
request. However, it breaks the tree structure of the service
description which poses a problem when variables have to
be ﬁlled by the matcher. In the example the address of the
preferred warehouse needs to be given to the screw manu-
facturer and the address of that warehouse as well as certain
properties of the screws need to be given to the shipping ser-
vice. But the address of the warehouse cannot be optimized
locally. If one wants to match this request with a composi-

2Note that the term single eﬀect is somewhat misleading
since the above mentioned procedure does work for multiple
eﬀects if they are unconnected and thus do not break the
tree structure of DSD service descriptions.

Figure 2: Intuitive approach for connected eﬀects.

tion of two distinct oﬀers, one for purchasing the screws and
one for shipping them, several problems arise.

Assume that we found a manufacturer having warehouses
in Hamburg and in Paris and assume that we choose the
warehouse in Paris since this is closer to Karlsruhe where
we need the screws.
It might turn out later when conﬁg-
uring the shipping provider that it would have been much
better, if we had chosen the warehouse in Hamburg because
shipping within Germany is cheaper than shipping between
France and Germany. It might even turn out that we cannot
ﬁnd a shipper that operates between France and Germany
at all. Thus the location of the warehouse cannot be opti-
mized locally. To ﬁnd the optimal conﬁguration a matcher
would have to build all possible combinations of warehouses
and shipping options and compare each with the request.
Note that there are two sources of choice for the matcher.
There may be diﬀerent service oﬀers (like competing screw
manufacturers) as well as diﬀerent conﬁgurations of each
of these oﬀers (like diﬀerent screw types and warehouses of
a single manufacturer). Thus, more precisely, the matcher
would have to build all possible combinations of all conﬁgu-
rations of all diﬀerent oﬀers. In general, with n eﬀects, the
complexity amounts to O(m1 · m2 · . . .· mn) where mi is the
number of diﬀerent conﬁgurations of the various oﬀers for
one eﬀect that have to be compared against the correspond-
ing requested eﬀect i, which can be estimated to O(mn)
for m being the maximum of all mi. This complexity is
not tractable in practice, since m can grow to very large
numbers: Even if there are not that many suitable oﬀers
(which is reasonable to assume), there will usually be many
ways to conﬁgure each oﬀer, e.g. shipping services will oﬀer
shipment to a huge number of locations, possibly yielding
diﬀerent prices.

Thus, we argue that conﬁguring multiple eﬀects by using
an intuitive global optimization of the ﬁllings isn’t a suitable
approach for on the ﬂy composition. The central problem
here is that the time performance of the algorithm will dras-
tically deteriorate. Opposed to our example in Figure 2, the
number of possible parameter ﬁllings can be very high in ev-
ery eﬀect involved. In addition, the number of connected ef-
fects can easily exceed two. For instance, the requester could
demand an insurance for the delivery, whose price could also

Address(cid:13)Screw(cid:13)Shipped(cid:13)Owned(cid:13)upper(cid:13)request(cid:13): (cid:13)Service(cid:13)upper.profile(cid:13): (cid:13)ServiceProfile(cid:13)Address(cid:13)presents(cid:13)cargo(cid:13)entity(cid:13)effect(cid:13)effect(cid:13)location(cid:13)fromAddress(cid:13)toAddress(cid:13)the ﬁrst eﬀect, take the optimal result and calculate the m2
matching values for the second eﬀect with it and so on. Al-
together, this way the matching algorithm has a complexity
of O(m1 + m2 + . . . + mn) or O(m · n) if m is the maximum
of all mi, thus leading to a linear complexity. Naturally this
comes at a price. Although our modiﬁed semantics yields
a well deﬁned result which can be stipulated by the user
(by ordering the eﬀects), we are not looking anymore for a
globally optimal solution. However, we believe that this re-
striction is not critical: In real world examples, eﬀects will
often be naturally ordered, i.e. one eﬀect can be seen as a
”main eﬀect” whereas the others are dependent eﬀects (e.g.,
in our example, owning a correct screw is the main goal of
the requester, its delivery is necessary but dependent on this
main eﬀect). Furthermore, in contrast to a heuristic which
limits the search space without letting the requester inﬂu-
ence the limitation, our strategy allows to restrict the search
space in a well-deﬁned, user-driven and predictable manner.
After having explained the basic concepts of our approach
we will now introduced the extended matching algorithm for
multiple connected eﬀects.

6. A MATCHING ALGORITHM FOR MUL-

TIPLE EFFECTS

A structural overview of the extended matching algorithm
using the example from Section 2 is shown in Figure 4. To
master the complexity of the matching process and to im-
prove eﬃciency the matching process is performed as a three
step process; each step will be discussed in turn.

The Plug-In Match. The ﬁrst extension to the basic match-
ing procedure for single eﬀects is that of using a plug-in se-
mantics for matchmaking. That is, when we start matching
an available oﬀer with a request we only ask whether the
oﬀer is capable of fulﬁlling a subset of the requested eﬀects.
The aspect of completely fulﬁlling a request is delayed until
later in the matching process. This approach is motivated
by the insight that even if an oﬀer doesn’t completely cover
a request, it still can be used in a composition of services
and consequently shouldn’t be dismissed.

To improve eﬃciency we ﬁrst ignore all composition re-
lated issues and concentrate on reducing the number of oﬀers
that need to be regarded during the following composition
process as much as possible. This is done by matching oﬀers
in isolation. Note that variables cannot be ﬁlled correctly
without regarding the restrictions related to connections be-
tween requested eﬀects (i.e. without regarding issues related
to the composition process). By deferring the consideration
of connections we reduce code complexity through separat-
ing concerns and improve the eﬃciency as this work isn’t
done on obviously unsuitable oﬀers.

Thus, as a ﬁrst step in the matching process (marker A
in Figure 4) each oﬀer is examined wrt. whether all of its
eﬀects match the requested ones. This corresponds to the
above mentioned plug-in match. On the one hand we do not
care whether an oﬀer provides all requested eﬀects, on the
other hand an oﬀer providing an eﬀect that is not requested
is obviously unsuitable4. The check whether a single oﬀer

Figure 3: Alternative value propagation semantics.

depend on the departure and destination of the route.
5.2 "Value Propagation" - Semantics for De-

scribing Multiple Connected Effects

In order to address this problem, we propose a ”value
propagation”-semantics, i.e. the idea is to modify the seman-
tics of when an oﬀer is considered optimal. At the heart of
our proposed solution is the introduction of an ordering on
the eﬀects. This ordering is deﬁned by the requester who
thereby is given a further ability to express his preferences.
The idea now is to locally optimize the parameter’s ﬁllings
based on the ordering as deﬁned by the user. This approach
is illustrated in Figure 3. Here, the eﬀect of buying screws
is considered to be more important by the user and thus is
chosen to be eﬀect number one. Consequently, this is the
eﬀect that is processed ﬁrst by the matchmaker. The pa-
rameters are ﬁlled optimally with respect to this eﬀect with
the only constraint that the ﬁlling must not be chosen in a
way that completely precludes to ﬁnd a match for the other
eﬀects3. Thus, the eﬀect is regarded mainly in isolation and
deﬁnes the location, which is stored in a variable $x.

The chosen conﬁguration might restrict the possible choices
for those parameters contained in the following eﬀects. Re-
garding the example, after having chosen the warehouse’s
location in x, this value restricts the possible ﬁllings of the
route’s departure (in fact, it completely determines the ﬁll-
ing which, in general, isn’t necessarily the case). In order
to take this into consideration, these restrictions (which can
only occur on connections) will be propagated in order to
be taken into account when conﬁguring the following eﬀects,
hence the name ”value propagation”.

Using this approach we ﬁrst have to annotate all oﬀer de-
scriptions we plan to use combined to service a request to
prevent choosing a conﬁguration for one oﬀer that precludes
to combine it with the other oﬀers. This can be done in
linear time in the number of conﬁguration options as will
be explained in Section 6. We then can match the eﬀects in
isolation, thus we have to calculate m1 matching values for

3E.g. if no available shipping provider ships outside of Eu-
rope, it is assured that no screw factory outside of Europe
will be chosen as provider of the screws. This constraint can
be assured eﬃciently, as will be shown in Section 6

4We are aware that in many cases an oﬀer that provides
more eﬀects than requested might be a match (”We get even
more than we asked for”). However, the unrequested eﬀect
might just as well be harmful, if it results in buying (and

Address(cid:13)Screw(cid:13)Shipped(cid:13)Owned(cid:13)upper(cid:13)request(cid:13): (cid:13)Service(cid:13)upper.profile(cid:13): (cid:13)ServiceProfile(cid:13)Address(cid:13)presents(cid:13)effect 2(cid:13)effect 1(cid:13)location(cid:13)fromAddress(cid:13)toAddress(cid:13)Screw(cid:13)Address(cid:13)Screw(cid:13)defines $x(cid:13)Screw(cid:13)uses $x(cid:13)Address(cid:13)defines $y(cid:13)Address(cid:13)uses $y(cid:13)entity(cid:13)cargo(cid:13)Figure 4: Overview of the Multiple Eﬀect Matching Process described in Section 6

eﬀect matches a certain request eﬀect is done by calling the
algorithm for matching single eﬀects from Section 4.

Computing Compositions. After having performed the plug-
in match the compositions can be computed (marker B in
Figure 4). This involves two tasks. First we compute all
possible compositions (called coverages) of the oﬀers left by
the plug-in match so that every requested eﬀect is covered
by an oﬀer exactly once. This can be thought of as de-
composing the request’s eﬀects into subsets so that for each
subset a suitable service provider exists.

After having computed the possible coverages we need
to prepare these coverages for the matching with the value
propagation semantics (which will form the last step of the
matching process). The problem is, that if there is a re-

paying for) something we didn’t want. A complete discus-
sion of this issue is beyond the scope of this paper.

lation speciﬁed in the request like the common location in
our example and a corresponding connection is not speciﬁed
in the oﬀer (for instance because the eﬀects stem from dis-
tinct services that are merely composed to yield a coverage
of the request), a wrong ﬁlling of parameters might prevent
a successful matchmaking. Assume we use Coverage 1 with
Service 1 having warehouses in Germany and France and
Service 2 that ships within Germany, Austria and Switzer-
land. Assume now we match the vending request eﬀect ﬁrst
and choose a French warehouse (e.g. in Paris) as it is closer
to Karlsruhe where we need the screws. When matching
the shipping request eﬀect later the coverage will fail since
the chosen shipper does not service France. If we had cho-
sen Hamburg as the warehouse’s location in the ﬁrst place
the composition would have been suitable. There are two
possible ways to address this problem. On the one hand,
we could implement some kind of backtracking that tries to

           Coverage 2(cid:13)Coverage 1(cid:13)Service 3'(cid:13)(300 packages(cid:13)of screw #93 to(cid:13)Karlsruhe)(cid:13)Service 1'(cid:13)(500 packages(cid:13)of screw #384(cid:13)in Hamburg)(cid:13)Service 2'(cid:13)(shipping from(cid:13)Hamburg to(cid:13)Karlsruhe)(cid:13)Plug-In Matcher(cid:13)(effect - to – effect, ignores variables)(cid:13)Service(cid:13)request(cid:13)descrip-(cid:13)tion(cid:13)Service(cid:13)offer(cid:13)descrip-(cid:13)tions(cid:13)Service Composer(cid:13)(1. compute effect coverages, 2. restrict variables)(cid:13)Final Matcher(cid:13)(effect - to - effect, fills variables)(cid:13)Service 4(cid:13)(shipping(cid:13)between(cid:13)US-DE)(cid:13)Service 3(cid:13)(vendor(cid:13)with(cid:13)shipping)(cid:13)Service 2(cid:13)(shipping(cid:13)in DE,(cid:13)AU, CH)(cid:13)Coverage 2(cid:13)Service 3(cid:13)(vendor(cid:13)with(cid:13)shipping)(cid:13)Coverage 1(cid:13)Service 1*(cid:13)(vendor in(cid:13)DE)(cid:13)Service 2*(cid:13)(shipping(cid:13)in DE)(cid:13)*) Variables are restricted (e.g.(cid:13)warehouses outside of operation(cid:13)range of shipper are excluded)(cid:13)MV: 0.7(cid:13)MV: 0.9(cid:13)MV: 0.8(cid:13)MV: 0.72(cid:13)Remaining(cid:13)offers(cid:13)Service 1(cid:13)(vendor in(cid:13)DE, FR)(cid:13)Service 5(cid:13)(vendor in(cid:13)Asia)(cid:13)Remaining(cid:13)offers(cid:13)(all combinations(cid:13)containing Service(cid:13)4 and 5 can not be(cid:13)restricted properly(cid:13)in step 2 and are(cid:13)dismissed)(cid:13)MV: 0.7(cid:13)Final result(cid:13)(two readily(cid:13)configured options,(cid:13)Coverage 1 being(cid:13)slightly better than(cid:13)Coverage 2)(cid:13)A(cid:13)B(cid:13)C(cid:13)re-conﬁgure the ﬁrst eﬀect in case this happens. Unfortu-
nately, this approach has an exponential complexity (which
to avoid was the primary task of the value propagation se-
mantics). We take an alternative approach at this point
and compute the cut on the parameters involved from the
diﬀerent eﬀects that need to be aligned. Service 1 has ware-
houses in Germany and France and Service 2 ships within
Germany, Austria and Switzerland, thus the cut on both
sets yields all German warehouses of Service 1 and restricts
Service 2 to their locations. If a coverage yields an empty
cut like a composition of Vending Service 5 and Shipping
Service 4 in Figure 4 that do not share a common location
it will be dismissed. The cut computation can be done ef-
ﬁciently (in the best case by a symbolic comparison (e.g. if
the instances in question are numbers), in the worst case
by iterating over the possible ﬁllings (e.g. all listed ware-
house locations)). After computing the cut we annotate the
oﬀer descriptions used in the coverage at hand to restrict
the concerned parameters to the instances contained in the
cut, i.e. to those instances that are contained in all eﬀects
that need to be connected. Thus we remove all warehouse
locations outside Germany from the oﬀer description of the
screw manufacturer and alter the description of the shipper
used in Coverage 1 as if it accepted only addresses in Ger-
many as pickup locations (compare to Figure 4). This will
allow us in a ﬁnal step to ﬁll the parameters (in this case
choosing a concrete warehouse) by again solely regarding a
single eﬀect at a time but still be safe not to choose a ﬁlling
that will break the composition in another eﬀect.

Final Result Computation.. As indicated above there are
two steps left. We still need to optimally conﬁgure each of-
fer and compute the overall matching value of each coverage.
Due to the value-propagation semantics and work in the pre-
ceding steps this again can be done by considering the eﬀects
in isolation according to the order deﬁned by the requester
(marker C in Figure 4). For each oﬀer in each coverage,
each eﬀect is matched against the corresponding request ef-
fect. This is again mainly done using the algorithm intro-
duced in Section 4, this time regarding variables and ﬁlling
them optimally, thereby conﬁguring the oﬀer. When the re-
quest is matched against Coverage 1, the Owned Eﬀect will
be matched ﬁrst. Assume the warehouse in Hamburg will
be picked. Consequently the pickup address of the shipping
service is set to its address. Overall the resulting conﬁgura-
tions of Service 1 and Service 2 might yield matching results
of 0.9 and 0.8 resprectively, leading to a result of 0.72 for
the overall compositions (note that the way how to combine
the single results from each eﬀect can be conﬁgured by the
requestor). Similarly the resulting conﬁguration of Service
3 might yield a result of 0.7 which corresponds to the over-
all result of Coverage 2. Consequently, the composition of
Service 1 and Service 2 will be returned as the best oﬀer5.

7. EVALUATION

As discussed in Section 1 our integrated approach to ser-
vice discovery and composition tackles situations where sim-

5Actually it is quite debatable how to value a composition
compared to an oﬀer from a single provider for various rea-
sons. Generally a composition will contain more potential
points of failure during execution. Thus it might be reason-
able to add a preference-penalty for compositions depending
on the number of services involved.

Component

Complexity

Prematch

Plug-In Match

O(n)
O(σ1 · n · m)
O((σ1σ2 · n)const)

Computing Compo-
sitions
Result Computation O(σ3 · (σ1σ2n)const · m)

Table 1: Overview: Complexity of the components

Overall number of oﬀered services

n
m Mean number of diﬀerent conﬁgurations

of an oﬀer eﬀect
Selectivity of the pre-matcher, σ1 (cid:191) 1
Selectivity of the plug-in-matcher, σ2 < 1
Selectivity of the composition-process, σ3 < 1

σ1
σ2
σ3

Table 2: Meaning of the variables.

ple discovery looking at a single matching service fails, but a
composition of existing services is able to fulﬁll a goal. This
approach has to suit an important requirement: In order not
to give up on the idea of dynamic discovery, the composition
has to be performed on the ﬂy reacting to a request. Thus,
eﬃciency of the composition algorithm is a central issue. In
this section, we evaluate our composition approach with a
special focus on this requirement. We will show that its time
consumption is well suited for real world deployments and
that our approach scales well with the number of available
oﬀers.
7.1 Scalability

When it comes to scalability, three parameters have to
be discussed: The size of the request description (or num-
ber of requested eﬀects), the number of available oﬀers and
the number of ways to conﬁgure a single oﬀer by choosing
diﬀerent ﬁllings for its input variables.

Regarding the ﬁrst parameter we feel that it is unrealistic
to have requests coverings thousands of eﬀects. A realistic
number would be anywhere between one eﬀect for a simple
request, e.g. searching a printer or reserving a ﬂight, two
eﬀects for a large class of services that involve payment, up
to maybe ten eﬀects for more complex tasks. Keep in mind
that in order for a request consisting of multiple eﬀects to
make sense, these eﬀects need to be related to each other.
Otherwise they constitute separate requests.

Thus in the following we treat the number of eﬀects and
the size of the request description as constant and address
the issue of scalability in the other two parameters by a dis-
cussion of our architecture’s complexity which is given in
Table 1 as an overview. The notation used throughout this
discussion is provided in Table 2. The architecture imple-
mented diﬀers from the algorithm introduced in Section 6
in that an additional selective matching run is performed
before the actual algorithm starts. This prematch processes
only those parts of the service descriptions which can be pro-
cessed extremely eﬃciently in order to reduce the number of
services that need to be considered by the actual matching
algorithm. In case of question it acts conservatively, thus it
doesn’t dismiss a service that might match (recall of 1.0).

The pre-matcher: The pre-matcher considers each of-
fer exactly once and doesn’t check for diﬀerences regarding
variable ﬁllings. Thus the complexity of the pre-matching
is in O(n). Despite that, the pre-matcher has a very good
selectivity σ1 (cid:191) 1. Thus σ1 · n, the number of oﬀers that
subsequent steps need to regard, is typically by several or-
ders of magnitude smaller than n.

The plug-in-matcher: In the next step, every remain-
ing oﬀer is again considered exactly once but unlike in the
prematch all information from the service descriptions is
used, in particular the options how to ﬁll input variables
are regarded. This results in a complexity of O(σ1 · n · m)
where m is the mean number of ways to conﬁgure a single
oﬀer eﬀect. The number of distinct conﬁgurations of an ef-
fect depends on the use case but can reach magnitudes of
thousands or more (e.g. transportation may be possible to
all German cities yielding diﬀering prices). This complexity
is paid oﬀ by a very precise matching result eliminating all
oﬀers that are unsuitable on an eﬀect-to-eﬀect basis (selec-
tivity σ2 < 1). As a result the number of oﬀers that have to
be considered during the next steps of the matching process
will typically range from a couple of services to a few dozend
or hundred services at the very most.

Creating Coverages: The Service-Composer determines
those combinations that should be considered further.
In
our current implementation, we simply consider every com-
bination of oﬀers that is suitable for covering the request’s
eﬀects. This yields a polynomial number of coverages with
respect to the available oﬀers: O((σ1 · σ2 · n)c) (where c is an
upper bound for the number of requested eﬀects). After de-
termining the possible coverages, the multi-eﬀect-manager is
concerned with a preparation step for ﬁlling the parameters,
in which the cut on those sets of possible parameter ﬁllings
is computed that inﬂuence each other due to connections be-
tween the corresponding eﬀects. This cut computation can
be performed without knowing the precise matching value a
single parameter ﬁlling will yield and can thus be performed
in time linear in the size of the coverage being inspected. It
therefore doesn’t increase the theoretical complexity bound.
Coverages with empty cuts are dismissed leading to a selec-
tivity of σ3.

Computing the Final Result:

In order to compute
the ﬁnal result the exact parameter ﬁllings have to be de-
termined. Thanks to the previous cut computation and the
value-propagation semantics discussed in section 5 and 6
this can be done on a single eﬀect basis for each coverage,
yielding a complexity bound of O(σ3 · (σ1σ2 · n)c · m). The
computation of the ﬁnal matching value performed as a last
step is linear in the number of remaining coverages and thus
uncritical.

Summing up, the time consumption of our approach is
dominated by the number of coverages computed on the
one hand and the number of possible variable ﬁllings on the
other hand. By introducing the value propagation semantics
we were able to avoid a combinatorial explosion of the last
one.

In the following section we will introduce our experimen-
tal results that indicate that for typical scenarios the un-
avoidable cost of determining the optimal variable ﬁllings
still outweights the cost of determining the coverages (i.e.
the composition). Thus we expect our approach to be well
suited for real world scenarios under the given constraint of
dynamic composition.

7.2 Experimental evaluation

In order to test our approach with regard to the require-
ment of eﬃcient composition, we ran a series of tests with
our implementation. We created a set of 11 service oﬀers
which were designed according to some real world web ser-
vices in order to have a realistic complexity of the services.
(Although this is not a huge number this is not critical in
terms of the evaluation. Only service oﬀers that suit pretty
well are considered further after the prematching and the
prematching scales extremely well. Thus, even if we had
used a much bigger number of oﬀers, the number of of-
fers considered during most of the matching process would
not have increased drastically.) The test services were cho-
sen from the domains cinema reservation, ﬂight reserva-
tion/booking, hotel reservation/booking as well as combi-
nations thereof representing travel agencies’ services. Note
that in our modelling the booking of a hotel or ﬂight involves
charging a credit card as a further eﬀect.

After establishing the oﬀer descriptions we asked a volun-
teer to come up with 11 service requests from the domains
hotel, ﬂight and cinema. The requests diﬀered in the num-
ber of eﬀects ranging from one to four as well as the number
of connections which also ranged from one to four. Overall,
for the 11 requests there existed 40 diﬀerent possibilities of
matching a request with a subset of the available services
such that the requests can be fulﬁlled. The runtime to com-
pute each of these fourty oﬀer combinations ranged from
0.2s to 2.3s with a mean of less than 1s.

Figure 5 shows the mean shares of the overall runtime
of the diﬀerent matching components. The measurements
shown correspond to the 40 diﬀerent possibilities of match-
ing a request with a composition of oﬀers, but for reasons of
presentation similar results have been merged, thus result-
ing in the ten (instead of fourty) displayed measurements.
It can be seen in the ﬁgure that each run is dominated by
the single-eﬀect-matcher (plug-in match) rather than the
multi-eﬀect-manager (creating the compositions) thus un-
derpinning our claim that the composition performed does
not compromise the eﬃciency of the matching as such.

8. RELATED WORK

The most closely related work with regard to discovery is
the recently presented WSMO-MX Matchmaker by Kaufer
and Klusch [3]. WSMO-MX is a hybrid matchmaker for
WSML services that borrows the graph-matching approach
from the DSD Matchmaker, but combines it with other con-
cepts developed within other matchmakers which the DSD
Matchmaker is lacking. What distinguishes the DSD Match-
maker most from WSMO-MX, as from all other discovery
approaches is DSD’s concept of precise ﬁne-grained prefer-
ences and ranking. Most matchers proposed for OWL-S (see
e.g. [11] for a typical example) rely on subsumption match-
ing of inputs and outputs and do not take the eﬀects of
the service into account. The matcher proposed recently in
[17] additionally matches service product and classiﬁcation.
In contrast, DSD’s matching is purely state-based. This
has two advantages: First, DSD compares whether a service
provides the desired eﬀect or not, second, DSD can abstract
from diﬀering interface and ﬁnd functionally matching ser-
vices even if their interface diﬀer.

For WSMO, a discovery mechanism that abstracts from
the individual eﬀect to a desired, more generic goal is pro-

Figure 5: Distribution of the overall runtime among the components for groups of similar results

posed.
In [4] the developers argue that this abstraction
is necessary due to performance considerations. Likewise,
OWL-S [2], e.g., inherits diﬃculties with reasoning on the in-
stance level from the description logics it is based on. Tools
for OWL-S thus tend to not use instance information. In
both cases, the eﬀort of determining whether a found service
is really able to answer a speciﬁc request does not disappear,
but is simply shifted to the execution phase.

None of the above mentioned matchmakers integrate auto-
mated composition like our approach does. This is probably
due to the fact that service composition is usually viewed as
a problem separated from service discovery and matchmak-
ing, thus most approaches focus on one of both. This diﬀers
from our approach where we use service composition as an
integral part of service matchmaking in order to address dy-
namically on the ﬂy situations where no single service does
match a request. One of the main beneﬁts from integrat-
ing the service composition into the matchmaking is that
we do not only attempt to ﬁnd some ﬁtting composition but
instead are able to ﬁnd the composition that suits best to
the given request’s precise preferences. To the best of our
knowledge this distinguishes our composition approach from
related work.

The METEOR-S framework [18, 1] provides dynamic bind-
ing of services, but works with composite service templates
and does not attempt to dynamically synthesize service com-
positions as we do. Although METEOR-S stresses the im-
portance to select component services optimized with regard
to certain global optimization criteria like overall monetary
cost, it is lacking ﬁnegrained user preferences as realized by
DSD’s fuzzy sets.

Regarding service composition there are many approaches
that apply sophisticated AI-Planning techniques to this do-
main. A comprehensive discussion of these approaches is
beyond the scope of this article, see [9, 12] for an overview.
The application of the HTN-Planner Shop2 to the web ser-
vice composition problem by the Mindswap group [16, 10]
may serve as an example. Although accomplishing impres-
sive results in terms of the necessary compromise between
planning power, completeness and expressivity on the one
hand and planning complexity on the other, in [15] Sirin
et. al.
identify a number of severe problems related to
the original approach (e.g. the complete lack of a notion
of preference among competing plans).
In the same work

they extend their approach to address template based com-
positions (similar as METEOR-S does). They couple Shop2
with an OWL-DL reasoner and are thus able to overcome
some of the shortcomings. However, this way complexity
issues related to OWL-DL reasoning are introduced to the
otherwise very eﬃcient planning process [14]. It remains an
open problem whether precise, expressive and yet eﬃcient
discovery as realized by the DSD Matchmaker can be eﬃ-
ciently coupled with more general planning as for instance
realized by Shop2.

Finally a large number of composition approaches deal
mainly with chaining of services. This typically addresses
situations where either additional knowledge gathering or
some form of data transformation is needed to service a user
request with the available oﬀers. An exemplary example for
such an approach is [13]. Problems typically addressed by
chaining approaches are complementary to the problem of
multiple connected eﬀects as dealt with in this work.

9. SUMMARY

In this paper we motivated the need to integrate auto-
mated service composition into matchmaking. In particular
we dealt with a common class of service requests asking for
multiple connected eﬀects that – depending on the service
landscape at that time – cannot be serviced by any single
one of the available oﬀers. As a ﬁrst step towards being ca-
pable of automatically dealing with such requests, we have
considered the problem on a conceptional level. By using a
”value propagation” semantics for service descriptions that
cover multiple eﬀects we succeed in avoiding exponential
complexity for determining an optimal conﬁguration of the
oﬀers used for a composition. The basis of our approach to
service composition on a practical level is the idea of ﬁrst
using a plug-in matching, i.e. when examining available of-
fers we look whether they are suitable for fulﬁlling at least a
subset of the requested eﬀects. The underlying idea is that if
they don’t completely cover the request they still can be used
as a component in a composition. Our ﬁnal step towards
an eﬃcient composition approach is to compute a cut on
possible parameter ﬁllings in separate but connected eﬀects.
This enables us to avoid a costly backtracking in the process
of ﬁlling parameters. We implemented our concepts within
the DSD matchmaker and thus integrated automated com-
position into the matchmaking process. On the one hand

0(cid:13)500(cid:13)1000(cid:13)1500(cid:13)2000(cid:13)2500(cid:13)1(cid:13)2(cid:13)3(cid:13)4(cid:13)5(cid:13)6(cid:13)7(cid:13)8(cid:13)9(cid:13)10(cid:13)groups of request-offer-pairs(cid:13)runtime (ms)(cid:13)Pre-Matcher(cid:13)Single-Effect-Matcher(cid:13)Multi-Effect-Manager(cid:13)Final Result Computation(cid:13)Service-Composer(cid:13)this way we enabled the matchmaker to successfully match
a large class of requests it couldn’t successfully match pre-
viously. On the other hand we could leverage distinguish-
ing features of our matchmaker for the composition process,
most notably its sophisticated means of dealing with user
preferences to choose among competing alternatives. Thus
we are not only able to automatically synthesize a compo-
sition but ﬁnd the best available option with regard to the
preferences of the user as speciﬁed in its request. In our eval-
uation we presented a theoretical analysis of the complexity
of our approach as well as experimental measurements of the
runtime performance. The results emphasize the claim that
our approach is scalable and eﬃcient enough to be used for
dynamic on the ﬂy matchmaking and composition, even in
real world settings.

10. REFERENCES
[1] R. Aggarwal, K. Verma, J. A. Miller, and W. Milnor.

Constraint driven web service composition in
meteor-s. In Proceedings of the 2004 IEEE
International Conference on Services Computing
(SCC 2004), Shanghai, China, September 2004.

[2] M. H. Burstein, J. R. Hobbs, O. Lassila, D. L. Martin,

D. V. McDermott, S. A. McIlraith, S. Narayanan,
M. Paolucci, T. R. Payne, and K. P. Sycara. Daml-s:
Web service description for the semantic web. In First
International Semantic Web Conference (ISWC2002),
Sardinia, Italy, June 2002.

[3] F. Kaufer and M. Klusch. WSMO-MX: a logic

programming based hybrid service matchmaker. In
Proceedings of the 4th IEEE European Conference on
Web Services (ECOWS2006), Z¨urich, Switzerland,
December 2006.

[4] U. Keller, R. Lara, A. Polleres, I. Toma, M. Kifer, and

D. Fensel. WSMO web service discovery - WSML
working draft 12 11 2004. Technical report, DERI,
2004.

[5] M. Klein and B. K¨onig-Ries. Coupled signature and
speciﬁcation matching for automatic service binding.
In Proceedings of the European Conference on Web
Services (ECOWS 2004), Erfurt, Germany, September
2004.

[6] M. Klein and B. K¨onig-Ries. Integrating preferences

into service requests to automate service usage. In
First AKT Workshop on Semantic Web Services,
Milton Keynes, UK, Dezember 2004.

[7] M. Klein, B. K¨onig-Ries, and M. M¨ussig. What is

needed for semantic service descriptions - a proposal
for suitable language constructs. International Journal
on Web and Grid Services (IJWGS), 1(3/4):328–364,
2005.

[8] U. K¨uster and B. K¨onig-Ries. Dynamic binding for

BPEL processes - a lightweight approach fo integrate
semantics into web services. In Second International
Workshop on Engineering Service-Oriented
Applications: Design and Composition (WESOA06) at
4th International Conference on Service Oriented
Computing (ICSOC06), Chicago, Illinois, USA,
December 2006.

[9] U. K¨uster, M. Stern, and B. K¨onig-Ries. A

classiﬁcation of issures and approaches in service
composition. In Proceedings of the First International
Workshop on Engineering Service Compositions
(WESC05), Amsterdam, Netherlands, December 2005.
[10] U. Kuter, E. Sirin, B. Parsia, D. Nau, and J. Hendler.
Information gathering during planning for web service
composition. Journal of Web Semantics,
3(2-3):183–205, 2005.

[11] M. Paolucci, T. Kawamura, T. R. Payne, and K. P.

Sycara. Semantic matching of web services
capabilities. In I. Horrocks and J. A. Hendler, editors,
International Semantic Web Conference, volume 2342
of Lecture Notes in Computer Science, pages 333–347.
Springer, 2002.

[12] J. Peer. Web service composition as AI planning - a

survey. Technical report, University of St. Gallen,
Switzerland, 2005.

[13] S. R. Ponnekanti and A. Fox. SWORD: A developer
toolkit for web service composition. In Proceedings of
the 11th International WWW Conference
(WWW2002), Honolulu, HI, USA, 2002.

[14] E. Sirin and B. Parsia. Planning for semantic web

services. In Semantic Web Services: Preparing to Meet
the World of Business Applications, workshop at the
Third International Semantic Web Conference (ISWC
2004), Hiroshima, Japan, November 2004.

[15] E. Sirin, B. Parsia, and J. Hendler. Template-based

composition of semantic web services. In Aaai fall
symposium on agents and the semantic web, Virginia,
USA, November 2005.

[16] E. Sirin, B. Parsia, D. Wu, J. Hendler, and D. Nau.

HTN planning for web service composition using
SHOP2. Journal of Web Semantics, 1(4):377–396,
2004.

[17] N. Srinivasan, M. Paolucci, and K. Sycara. Semantic
web service discovery in the owl-s ide. hicss, 6:109b,
2006.

[18] K. Verma, K. Gomadam, A. P. Sheth, J. A. Miller,

and Z. Wu. The METEOR-S approach for conﬁguring
and executing dynamic web processes. Technical
Report 6-24-05, LSDIS Lab, University of Georgia,
Athens, Georgia, USA, 2005.

