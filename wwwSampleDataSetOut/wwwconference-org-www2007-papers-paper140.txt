Compiling Cryptographic Protocols

for Deployment on the Web

Jay McCarthy
Brown University

Joshua D. Guttman

MITRE Corporation

Shriram Krishnamurthi

Brown University

John D. Ramsdell
MITRE Corporation

ABSTRACT
Cryptographic protocols are useful for trust engineering in Web
transactions. The Cryptographic Protocol Programming Language
(CPPL) provides a model wherein trust management annotations are
attached to protocol actions, and are used to constrain the behavior
of a protocol participant to be compatible with its own trust policy.
The ﬁrst implementation of CPPL generated stand-alone, single-
session servers, making it unsuitable for deploying protocols on
the Web. We describe a new compiler that uses a constraint-based
analysis to produce multi-session server programs. The resulting
programs run without persistent TCP connections for deployment
on traditional Web servers. Most importantly, the compiler pre-
serves existing proofs about the protocols. We present an enhanced
version of the CPPL language, discuss the generation and use of
constraints, show their use in the compiler, formalize the preser-
vation of properties, present subtleties, and outline implementation
details.

Categories and Subject Descriptors
C.2 [Network Protocols]: Protocol Veriﬁcation

General Terms
Performance, Security, Languages, Theory, Veriﬁcation

Keywords
CPPL, Cryptographic Protocols, HTTP, Sessions

1. PROBLEM AND MOTIVATION

A growing array of services, such as third-party credit-card han-
dling as offered by several banks, is now offered via Web-based
protocols. These services need to be reliable in several ways: (a)
they must be cryptographically trustworthy, (b) their implementa-
tions must be sound, and (c) their implementations must scale to
handle high customer loads.

As the number of custom protocols increases, there is increas-
ing interest in domain-speciﬁc programming languages for deﬁning
cryptographic protocols. A good representative example is CPPL [4],
which makes protocol speciﬁcation relatively easy (compared to
writing the deﬁnition in a regular programming language), and which
automatically compiles to trustworthy cryptographic libraries to
avoid programmer errors in their selection and use. By also sup-
porting effective rely-guarantee proof techniques for reasoning about
Copyright is held by the International World Wide Web Conference Com-
mittee (IW3C2). Distribution of these papers is limited to classroom use,
and personal use by others.
WWW 2007, May 8–12, 2007, Banff, Alberta, Canada.
ACM 978-1-59593-654-7/07/0005.

security properties [5], CPPL discharges reliability requirements (a)
and (b). For instance, CPPL has successfully described almost all
of the protocols in the SPORE [10] repository.

The compiler for CPPL, unfortunately, does not produce scal-
able implementations. It generates executables that open a spec-
iﬁed TCP port and keep it open while handling one protocol run
(or “session”). While this is sufﬁcient for demonstration purposes,
this reliance on open ports and on single sessions makes the cur-
rent CPPL implementation untenable for scalable deployment over
the stateless HTTP Web protocol, which has been a cornerstone of
the Web.

Compiling to handle multiple sessions atop HTTP is not trivial.
It requires being able to unambiguously determine which session
should receive an incoming message; faulty identiﬁcation means
the actual recipient may get into an inconsistent state or even leak
information, while the intended session will starve. As the paper
explains, precise deﬁnition of the “right” session, and of progress of
a session, is quite subtle, especially in the presence of cryptography
(Sec. 5.3).

This work presents a static analysis that generates constraints
from a protocol description and compiles them into an extended de-
scription of the protocol (Sec. 4). A generic dispatcher, deployable
on a stock Web server, employs the embedded constraints to route
each incoming protocol message to the correct session (Sec. 5).
We also brieﬂy describe the compiler that implements this process
(Sec. 6).

Not all protocols have sufﬁcient constraints to make them dis-
patchable (Sec. 3). It can be tempting to modify protocols to cir-
cumvent this problem, but this is not always acceptable. Obvi-
ously, it can be difﬁcult to modify deployed Web service clients.
More importantly, the protocols have already been subject to proof,
and changes to them can potentially invalidate these proofs—and
as experience has shown, protocols are already quite subtle and are
sensitive to small changes. Our analysis nevertheless points to the
source of weakness in the protocol to suggest places where it could
be modiﬁed (Sec. 6).

Though this is a practical paper, it must perforce present a theo-
retical account. This theory is to qualify and prove that (1) the com-
pilation process preserves the existing proofs about CPPL programs
and (2) the dispatcher never delivers a message to the wrong session
(Sec. 4.5 and Sec. 5.3). These proofs are necessary to demonstrate
that we have preserved criteria (a) and (b) while enabling (c).

Reciprocating the beneﬁts that Web technology confers on CPPL,
there are beneﬁts that CPPL offers the Web. As increasingly im-
portant applications reside on the Web and as security concerns
correspondingly grow, programmers would beneﬁt from employ-
ing secure protocols to establish trust between client and server.
Systems like CPPL provide a way of describing and analyzing such

WWW 2007 / Track: Security, Privacy, Reliability, and EthicsSession: Access Control and Trust on the Web687protocols. This work takes a step toward making the fruits of such
analysis accessible to Web programmers. Web programmers will
eventually be able to analyze the protocols they currently employ
atop SSL and AJAX communication, as they must do.

SSL by itself only authenticates the server to the client, not the
other way around. Client SSL does authenticate clients to servers.
Unfortunately client SSL is often not enabled. Even if it is, how-
ever, it does not help in the case where a client wants to instantiate
multiple distinct sessions of a service, as when running distinct ses-
sions in different tabs of a Web browser. Thus, even client SSL is
insufﬁcient to provide the key criterion that we call distinguishabil-
ity, which we deﬁne and show how to implement in Section 5.

2.

INTRODUCTION TO CPPL

CPPL is a domain speciﬁc language for expressing cryptographic
protocols with trust annotations. It matches the level of abstraction
of the Dolev-Yao model [2], in the sense that the programmer re-
gards the cryptographic primitives as black boxes, and concentrates
on the structural aspects of the protocol. CPPL allows the program-
mer to control protocol actions using trust constraints [5], so that
an action such as transmitting a message will occur only when the
indicated trust constraint is satisﬁed.
Semantic Interpretation. The CPPL semantics identiﬁes a set of
strands [11] annotated with trust formulas as the meaning of a role
in a protocol. A strand merely speciﬁes what messages are sent and
received. The representation does not specify to whom message are
sent or from whence they are received. This corresponds to a model
that allows an adversary to have maximal power to manipulate the
protocol by modifying, redirecting, and generating messages ex ni-
hilo. This ensures that proofs built on the semantics are secure in
face of a powerful adversary.

A strand as the meaning of a protocol is local in the sense that
it describes what one principal P does.
It says nothing about how
messages are routed on a network; nothing about what another prin-
cipal P′ does with messages received from P; nothing about how
another principal P′ created the messages that P receives; etc.
In
essence, it describes only a single principal executing a single run.
We must specify how to combine strands to fully reason about
CPPL programs. This global semantics has been provided by ear-
lier work [4]. It deﬁnes a regular strand—a strand that conforms to
the semantic interpretation of some protocol. It then explains how
we may reason that multiple regular strands must be communicat-
ing, given the values they share. We may then reason about whether
secrecy and other protocol goals are reached. However, the details
of all this are not important for our purposes, because this work
focuses on preserving the local semantics under a different imple-
mentation, rather than developing a new global semantics.
Trust Management. The sender of a message must guarantee the
formula associated with sending the message, by showing the for-
mula is a consequence of its local theory. The receiver of a message
relies on a formula associated with receiving the message by adding
the formula to its local theory for use in later deductions. Relying
on a formula is justiﬁed when the protocol is sound.

A protocol is sound if in every execution, whenever a message
is received and its formula is relied upon, there were correspond-
ing message transmissions with guaranteed formulas that allow it
to be deduced. A protocol designer is responsible for demonstrat-
ing a protocol is sound. A sound protocol is easily implemented
using CPPL. The language is designed around a few simple con-
cepts: branching on incoming and outgoing messages, and consult-
ing a trust management engine [5] during messaging. These simple
concepts are natural to the designer of cryptographic protocols and
proof authors. This is beneﬁcial because there is no impedance mis-

p → proc f y∗ Y
c → return F
x∗

c

|
|
|
|
|

let x = new in c
let x = accept in c
let x = channel y in c
(sb∗) | (x rb∗) | (cb∗)
(x mb∗)

x m c

sb → send F
rb → recv m Y
c
mb → match m c
cb → call F
m → x

f x∗ y∗ Y
| m, m′

|

(m)

|

c

r m
|

{ m } x

|
[ m ] x

Figure 1: CPPLm Language

match between the description a designer uses to show soundness
and the CPPL program that implements the protocol.
The Core Language. The syntax of the CPPLm core language is
presented in Figure 1. The CPPL core language has procedure dec-
larations and seven types of code statements. A minor extension of
the language, CPPLm, introduces one more code statement. There-
fore, every CPPL program is syntactically a CPPLm program, al-
though we often distinguish between the two languages in the body.
The previous work did not describe match statements, because
they do not induce message transmission or require message recep-
tion. They were therefore left out of the earlier semantics, although
they were included in the earlier implementation. We describe them
because they play an important role in our work. In addition, they
are essential to building useful protocols.

Programming language identiﬁers are indicated by x and y, lists
of identiﬁers by x∗, message tags (such as High) by r, and proce-
dure names by f . When used to concatenate message patterns, the
comma operator is right associative, and tagging binds less tightly
than comma. The language has syntax for guarantees and relies—
by convention we write guarantees as F
and relies as Y —which are
ﬁnite lists of trust management formulas. We use ﬁnite lists, which
we interpret conjunctively.

A procedure declaration speciﬁes the name f of the procedure, a
list (y∗) of formal parameters, and a list of preconditions Y
in-
volving the formal parameters. The body of the procedure is a
code statement c. A code statement may be: a return instruction,
which speciﬁes a list of postconditions F
and return parameters
(x∗); a let-statement; or a list of send branches, receive branches,
call branches, or match branches. An identiﬁer x is either a low-
ercase identiﬁer id, or else an identiﬁer with typing information
id:type. We write ide(X) for the set of identiﬁers used in the
phrase X. We write Free(S
, X) for the set of identiﬁers free in X,
where S

represents bound identiﬁers.

A well-formed code statement c with two return statements at
and return

different locations must have the same postconditions F
parameters x∗.
The Runtime Environment. The language is organized around
a speciﬁc view of protocol behavior. In this view, as a principal
executes a single local run of a protocol, it builds up an environment
that binds identiﬁers to values encountered. These bindings are
commitments, never to be updated; once a value has been bound
to an identiﬁer, future occurrences of that identiﬁer must match the
value or else execution of this run aborts.
In particular, when a
known value is expected in an incoming message, any other value
will prevent execution of this run from continuing.

WWW 2007 / Track: Security, Privacy, Reliability, and EthicsSession: Access Control and Trust on the Web688Informal Execution Semantics. To explain how procedures exe-
cute, we ﬁrst introduce an auxiliary notion: guaranteeing formulas
in a runtime environment. This means asking the runtime trust
management system to attempt to ascertain the formulas F
. Iden-
tiﬁers in F
already bound in the runtime environment are instanti-
ated to the associated values. Identiﬁers not yet bound in the run-
time environment are instantiated by the trust management system,
if possible, to values that make the formulas F
true. The runtime
environment extended with these new bindings is the result of suc-
cessfully guaranteeing F
. If the runtime trust management system
fails to establish an instance of F

the guarantee fails.

To execute a return statement, we attempt to guarantee the for-
mulas F
. If successful, we select from the resulting environment
the values of each of the return parameters x∗; these values are re-
turned to the caller. If the attempt to guarantee F
fails, execution
terminates abnormally, and the caller is informed of the failure. The
caller receives no parameter values in case of failure.

To execute a list of send branches, the runtime trust manage-
ment system selects a branch within which it can successfully guar-
antee the formulas F
. The message pattern m speciﬁed on this
branch, instantiated using the values in the resulting extended run-
time environment, is then transmitted. Execution proceeds with the
continuation1 c embedded within this send branch in the extended
environment. If the runtime trust management system fails to guar-
antee the formulas F on any send branch, then execution terminates
abnormally, and the caller is informed of the failure.

To execute a list of receive branches with identiﬁer x, the run-
time environment is consulted for the value bound to x. This value
should be a channel. When a message is received over this channel,
the message is matched against the patterns m within the receive
branches. In a successful match, the message must agree with the
runtime environment for identiﬁers in m that are already associated
with a value. Other identiﬁers in m will be bound to the values
observed in the incoming message, yielding an extended runtime
environment. If at least one receive branch has a successful match,
one such branch is selected. The formulas Y
are instantiated us-
ing the extended runtime environment, and supplied to the runtime
trust management system as additional premises. Execution pro-
ceeds with the continuation c embedded within this receive branch
in the extended environment. If no receive branch has a success-
ful match, then execution terminates abnormally, and the caller is
informed of the failure.

To execute a list of call branches, the system treats the call
branches as sends followed by receives. The system acts as if the
principal sends the message x∗ after guaranteeing the formulas F
,
then recvs the message y∗ and relies on the formulas Y
. That is,
the the runtime trust management system selects a branch, within
which it can successfully guarantee the formulas F
It calls the
associated subprotocol procedure f with the parameters x∗ instan-
tiated using the values in the resulting extended runtime environ-
ment. This procedure may return normally, in which case it sup-
plies values for the parameters y∗; execution continues with the
embedded continuation c, using the extended runtime environment.
The instances of the formulas Y
are supplied to the runtime trust
management system as additional premises during execution of c.
If the f does not return normally, then execution may continue with
a different call branch; execution proceeds in the original environ-

.

1Some readers may be unfamiliar with or scared of this term. A
continuation is simply “what remains to be done” in a computa-
tion. Notice that CPPLm contains no sequencing operation; instead,
what computation occurs after any given statement is speciﬁed di-
rectly as part of that statement, by the c at the end. Each c is that
statement’s continuation.

ment, without any extension from the abnormally terminated call
branch.

To execute a list of match branches with identiﬁer x, the runtime
environment is consulted for the value bound to x. This value is
matched against the patterns m within the match branches. In a suc-
cessful match, the value must agree with the runtime environment
for identiﬁers in m that are already associated with a value. Other
identiﬁers in m will be bound to the values contained in the value of
x, yielding an extended runtime environment. If at least one match
branch has a successful match, one such branch is selected. Execu-
tion proceeds with the continuation c embedded within this match
branch in the extended environment. If no match branch has a suc-
cessful match, then execution terminates abnormally, and the caller
is informed of the failure.

3.

INFORMAL SOLUTION

Having summarized CPPLm, we return to the problem of the pa-
per: deploying protocols on the Web. On the Web, a single server
usually runs several sessions of a protocol. The essence of the de-
ployment problem is thus determining which (if any) of many ses-
sions of a protocol should receive an incoming message. What in-
formation does a message contain that can help a dispatcher, and
how can we use it?

Our strategy is to inspect the protocol encoded in the CPPLm
program and determine whether, at each message reception, the
message’s content is sufﬁcient for uniquely identifying a session.
Besides message structure, this largely boils down to ﬁnding dis-
tinguishing values in the message that are visible at that point.

The set of distinguishing values is not ﬁxed. Many applications
may manifest such values speciﬁc to that application, such as the
user’s identity.
In all applications, however, nonces are globally
unique, and therefore distinguish the session that generated them.
In this work, we will therefore provide the most conservative anal-
ysis by treating only locally-originating nonces as distinguishing
values. Our solution, however, easily generalizes to other, includ-
ing application-speciﬁc, notions of distinction. We note where such
values can be used as we describe our analysis.

These distinguishing values are assumed to be unique and non-
forgeable, like nonces in the Dolev-Yao [2] model, and therefore
not vulnerable to duplication by attackers. This is essential to the
correctness of our analysis.

We will refer to a message that contains a distinguishing value
as dispatchable, because the destination session is identiﬁable. We
will also call a code phrase dispatchable if all messages received
within it are dispatchable.

We may be tempted to simply inspect each branch of each recv
statement and ensure that the message pattern contains an identiﬁer
bound to a distinguishing value, but this will reject programs that
should be accepted, as shown below. match statements contain
additional information that will allow more recv statements to be
considered dispatchable. This fact will complicate our analysis,
but will produce a more useful answer.2

For example, the following procedure clearly contains a recv
statement that contains a distinguishing value and therefore is dis-
patchable:

1 proc example1 (chnl, v) _
2 let n = new in

2Still more information could be extracted from the trust manage-
ment logic database. We could pursue this angle, but do not to
avoid creating dependencies on the particular trust management
logic, thereby enabling users to employ whichever one is most ap-
propriate for their setting.

WWW 2007 / Track: Security, Privacy, Reliability, and EthicsSession: Access Control and Trust on the Web689F
3
4
5

(send _ chnl n
(chnl recv n _

return _ v))

The message received on line 4 is exactly the nonce n.

However, the following procedure appears to contain a recv state-
ment that does not contain a distinguishing value and therefore is
not dispatchable:

µ → ⊤

|
|
|

x ∼ m ; µ
µ + µ′
∃x∗.µ

[TOP]
[MATCH]
[OR]
[EXISTS]

Figure 2: Constraint Language Syntax

let n = new in
(send _ chnl n
(chnl recv m _

1 proc example2 (chnl, v) _
2
3
4
5
6

return _ v)))

(m match n

The message received on line 4 is a completely new binding, m, and
therefore not identiﬁable directly as the nonce n. However, on line
5 of the program, that value is checked against n, so the program
will succeed only if m = n. Thus, we should consider this program
as being dispatchable.

This last example demonstrates a general aspect of match state-
ments: they impose constraints on messages that are received ear-
lier in the program. In example2, the match on line 5 imposes the
constraint that the message received on line 4, m, must match the
pattern n, i.e., must equal n.

The following pattern, common to commitment protocols [3],

demonstrates a more complicated constraint imposition:

1 proc commit (chnl) _
2
(chnl recv payload _
3
4
5
6

...
(chnl recv key _

(payload match {objective} key
return _ objective)))

In this protocol, one participants receives an encrypted payload
(line 2), performs some further work and communication (elided
in line 3), then receives a commitment from the other participant
in the form of a key (line 4), to the data sent earlier (line 5), which
contains the objective (line 6). In this example, the match on line
5 imposes the constraint on the message received on line 2 that
“There must exist some value key which decrypts payload”.

Another kind of constraint is introduced by branching in the lan-

guage. Consider the following contrived example:

(chnl recv prod _

1 proc example3 (chnl, left, right) _
2
3
4
5
6

return _ left
match right
return _ right))

(prod match left

In this example, the match beginning on line 3 imposes the con-
straint on the message received on line 2 that “prod must match
either left or right.”

Neither of these examples is dispatchable, as neither the mes-
sage patterns nor the constraints imply that the message contains
a distinguishing value. However, more complicated protocols with
similar constraints are dispatchable. In Sec. 5.1 we develop how to
make this judgment.
Workﬂow. A protocol engineer uses our tool to turn a CPPLm
source program into an executable that can be used to deploy their
protocol. If the protocol passes our analysis, the engineer will have
a deployable binary. If not, they see an error indicating the message
of the protocol that does not contain a distinguishing value.

Solution Overview. Our system consumes a CPPLm ﬁle, generates
all the constraints on incoming messages imposed by the rest of
the program, checks that the incoming messages all contain some
distinguishing value, then produces an executable. This executable
uses a runtime library that provides cryptographic communication
and checks for the satisfaction of the computed constraints. This
executable is combined with a server that consumes messages and
dispatches them to sessions.

The server can use a very na¨ıve dispatching algorithm. When-
ever it receives a message, it can attempt to deliver it to all sessions,
stopping when one session has accepted the message. If no session
accepts the message, then it can attempt to create a new session for
the message. Only if this ﬁnal step fails is the message rejected.

The analysis of this paper makes such a dispatching algorithm
sufﬁcient. In the absence of such an analysis, the algorithm would
be doubly erroneous: it might deliver messages to the wrong ses-
sion, i.e., one intended for session A might resume session B, caus-
ing both B to incorrectly resume and A to incorrectly starve. Sec. 5
describes the algorithm formally and justiﬁes our claim that it is
not susceptible to such errors.

4. CONSTRAINTS

The heart of this section show how constraints are generated
from CPPLm phrases (Sec. 4.2). To support this, we describe the
language of constraints (Sec. 4.1) and give their semantics. Once
we have generated constraints, we show how to annotate CPPLm
programs with them by translation to an intermediate language,
CPPLm+c, in Sec. 4.3. As a ﬁnal bookkeeping step, we present the
semantics of this annotated language in Sec. 4.4. With semantics
in hand, we then show that properties proved about translated CPPL
programs are maintained, satisfying one of our primary goals.
4.1 Constraint Language

Fig. 2 speciﬁes the syntax of the constraint language.

In this
syntax, the ; and + operators are right-associative, and + binds less
tightly than ;. The language is best explained through a description
of the informal execution semantics. This semantics depends on a
runtime environment binding identiﬁers to values, corresponding to
the runtime environment of the CPPLm program at the point where
constraint satisfaction occurs.

To check a TOP constraint of the form ⊤, nothing need be done,

as this constraint is always satisﬁed.

To check a MATCH constraint of the form x ∼ m; µ, the runtime
environment is consulted for the value bound to x. This value is
matched against the pattern m. For the match to be successful
match, the value must agree with the runtime environment for iden-
tiﬁers in m that are already associated with a value. Other values
in m will be bound to the values contained in the value of x, yield-
ing an extended runtime environment. If the match is successful,
constraint checking continues with the constraint µ in the extended
runtime environment. If µ is satisﬁed in this environment, then this
constraint is satisﬁed.

An example of a MATCH constraint is the constraint on the recv
statement on line 4 in example2 in Sec. 3: m ∼ n; ⊤. In this con-

WWW 2007 / Track: Security, Privacy, Reliability, and EthicsSession: Access Control and Trust on the Web690MATCH
s 1 = s ⊕ s

′

[x] matches m′
dom(s
|= (x ∼ m′ ; µ)

′) ⊆ ide(m′)

s 1 |= µ

OR, LEFT
|= µ

OR, RIGHT
|= µ′

|= µ + µ′

|= µ + µ′

EXISTS

[x 7→ v]∗ |= µ for some v∗

|= ∃x∗.µ

TOP

|= ⊤

Figure 3: Constraint Satisfaction

straint m is the message received on line 4, n is the pattern used in
the match statement on line 5, and the ⊤ constraint comes from the
continuation of this match, i.e., the return on line 6.

To check an OR constraint of the form µ+µ′, the two sub-constraints

are checked independently, i.e., the runtime environment is copied
in each branch. If one of the sub-constraints is satisﬁed, this con-
straint is satisﬁed and the other need not be consulted.

To check an EXISTS constraint of the form ∃x∗.µ, the runtime
environment is extended with values for x∗, if possible, that make
the constraint µ satisﬁed. If there is no assignment of the identiﬁers
x∗ to values for which µ may be satisﬁed, then this constraint is not
satisﬁed.

The formal semantics of constraint satisfaction is given in Fig. 3.

The judgments have the form:

|= µ

and the con-

where the runtime environment is represented by s
straint is represented by µ.
Runtime Implementation. The semantics does not explicitly state
how to generate values for the identiﬁers bound in EXISTS con-
straints during satisfaction checking. An implementation must solve
this problem. The obvious solution is to use uniﬁcation of identi-
ﬁers with CPPLm values and identiﬁers in match patterns. Identi-
ﬁers introduced by these constraints are initially unbound. Iden-
tiﬁers are bound by their ﬁrst comparison in a MATCH constraint.
After an identiﬁer has been bound, a failure to unify with a value
in a MATCH constraint is a failure of the EXISTS constraint that
introduced the identiﬁer.

There are some subtleties, however, due to the use of cryptog-
raphy. For example, the following constraint can be satisﬁed with
uniﬁcation:

[x 7→ (0,0)] |= ∃y.x ∼ (y, y); ⊤

The following, however, cannot:

|= ∃x, k.M ∼ {x}k; x ∼ V ; ⊤

because it refers to the contents of an encryption for which the key,
k, is unknown. We can, however, still perform some checking of
this constraint. Speciﬁcally, M can be checked to ensure that it is
long enough (in bits) to be decrypted to an x that is as long (in bits)
as the value of V .

Our compiler also optimizes some constraints at compile-time.
Informally, if the identiﬁer introduced in an EXISTS constraint does
not appear in any of the message patterns in the sub-constraint, then
the EXISTS constraint can be removed. This allows the constraint-
solver to short-circuit the uniﬁcation mechanism in many cases.

This optimization could be incorporated into the constraint gen-
eration phase of our analysis, but to do so would complicate our
analysis and shift attention from the essence of the problem.
4.2 Constraint Generation

This section discusses how to generate constraints from CPPLm

phrases.

For each recv branch, we must ﬁnd the constraints imposed on
the message by the continuation. Each code statement in the contin-
uation of the receive statement can refer to identiﬁers bound by the
message. For example, in the commit protocol (Sec. 3) the continu-
ation starting on line 3 imposes constraints on the message received
in line 2 through the use of the identiﬁer payload. Although in that
example this is the only identiﬁer bound by the pattern on line 2, in
general a receive pattern may bind any number of identiﬁers.

Therefore, our constraint generation analysis is deﬁned with re-
spect to (a) the identiﬁers bound by the message, (b) all bound iden-
tiﬁers, to decide what identiﬁers are introduced by the message, and
(c) a code statement, initially the continuation of the recv.

The phrase “bound by the message” is quite subtle. The mes-
sage binds identiﬁers in the recv branch message pattern and in
any match pattern where the variable being matched was bound by
the message. For example, in the commit protocol, the message
received on line 2 introduces payload on line 2 and objective on
line 5.

We will now present the analysis. The judgments are of the form:

,P

|= c : µ

represents the set of bound identiﬁers and P

where S
represents a
set of identiﬁers bound by the message. These judgments can be
roughly categorized into a few cases based on the code statements:

• Statements without continuations, such as return, that gener-

ate a TOP constraint.

• Statements that introduce bindings, such as let, recv, send,
and call statements that generate an EXISTS constraint for
each of the identiﬁers they bind.

• Statements that represent branching, such as recv branches,
send branches, and match branches, that introduce OR con-
straints for each branch.

Examples of each of these categories are presented in Fig. 4.
However, match statements do not ﬁt into any of these categories.
The judgments for them are shown in Fig. 5.

If the identiﬁer being matched, x, is in P

If the identiﬁer being matched is not in P

, then this match repre-
sents further use of the original message. Therefore, any identiﬁers
bound by this match must be incorporated into the P
used to an-
alyze the continuation. Furthermore, the pattern used to match the
identiﬁer must be incorporated into the constraints via a MATCH
constraint.
, then this
match is treated like any other statement that introduces bindings.
In Fig. 6 we present an example of constraint generation for lines
4 through 6 of the commit protocol example. In this derivation, we
use < i > to represent the continuation beginning on line i of the
source.
4.3 Translation

Having generated these constraints, we still need to show how
to incorporate them into an analysis that checks for the presence of
distinguishing values. We provide these constraints to the analysis
by translating CPPLm phrases into another language that contains
these constraints as annotations on recv statements.

WWW 2007 / Track: Security, Privacy, Reliability, and EthicsSession: Access Control and Trust on the Web691s
s
s
s
s
s
s
s
s
s
s
S
{payload, key, objective}, {payload, objective} |= < 6 > : ⊤

payload ∈ {payload}

{payload, key}, {payload} |= < 5 > : payload ∼ {objective} key; ⊤
{payload}, {payload} |= < 4 > : ∃key.payload ∼ {objective} key; ⊤

Figure 6: CPPLm Example Constraint Generation

x∗ : ⊤

|= return F

RETURN
,P
SEND
{y∗} = Free(S

,F )

|= send F

S ∪ {y∗},P
x m c : ∃y∗.µ

|= c : µ

. . .

,P

|= sbn : µn

SEND BRANCH
,P

|= sb0 : µ0
,P

|= (sb0 . . . sbn) : (µ0 + · · · + µn)

Figure 4: CPPLm Constraint Generation Examples

MATCH (x IN P

)

{y∗} = Free(S

, m)
S ∪ {y∗},P ∪ {y∗} |= c : µ

x ∈ P

|= x match m c : x ∼ m ; µ

MATCH (x NOT IN P
{y∗} = Free(S

)
, m)

S ∪ {y∗},P

|= c : µ

x /∈ P

|= x match m c : ∃y∗.µ

Figure 5: CPPLm Constraint Generation: Matching

We will refer to this new language as CPPLm+c. We specify the
syntax below as a modiﬁcation to CPPLm. The syntax is identical,
except that an annotation has been added to the recv branch case:
the constraint, µ, imposed on this statement by its continuation.

rb → recv m µ Y

c

The form of translation judgments is:
S ⊢ c   c′

where S
is a set of bound identiﬁers, c is a CPPLm program state-
ment, and c′ is the CPPLm+c program statement produced by the
translation and eventually run in the server.

Except for the judgment dealing with recv statements, all the
judgments are obvious and only carry along information about the
introduction of identiﬁers. Therefore, they are not included in this
short presentation. The judgment for recv statements is:

RECEIVE
S ∪ P 0 ⊢ c   c′
S ⊢ recv m Y

P 0 = Free(S

, m)

S ∪ P 0,P 0 |= c : µ

c   recv m µ Y

c′

The identiﬁers initially bound by the message pattern are used as
the initial set of identiﬁers bound by the message (P 0) in the con-
straint generation process (Sec. 4.2) that analyzes the continuation
of the recv statement. The generated constraint, µ, is used in the
resulting translated program statement.

MATCH AND RELY
s 1 = s ⊕ s

′

[x] matches m
′) ⊆ ide(m)

dom(s

;G ⊢ (x match m c rb∗) : s,u

s 1;G ⊢ c : s,u

MATCH ALTERNATIVE

;G ⊢ (x mb∗) : s,u

;G ⊢ (x match m c mb∗) : s,u

Figure 8: Semantics of match

4.4 CPPLm+c Local Semantics

In keeping with previous CPPL work [4], we give the seman-
tics of CPPLm+c procedures and code statements by describing the
strands that specify their possible behavior. Each strand is a se-
quence of transmissions and receptions that is possible for a prin-
cipal executing this CPPLm+c phrase faithfully. As mentioned in
Sec. 2, this describes the local nature of protocol execution.

Our local semantics is identical to previous work [4], except in
the RECEIVE AND RELY, RECEIVE ALTERNATIVE MATCH AND
RELY, and MATCH ALTERNATIVE cases.

The semantics of a receive statement (Fig. 7) is identical to the
earlier semantics, except that the extended runtime environment,
s 1, is checked against the µ constraint according to the constraint
satisfaction semantics in Fig. 3. (And, for technical reasons the se-
mantics of RECEIVE ALTERNATIVE must be modiﬁed for the new
syntax.)

The semantics of a match statement (Fig. 8) is very close to the
semantics of a receive statement, except: (a) there is no message
reception or transmission, and (b) we must explicitly state that the
value bound to x in the runtime environment, s
, matches the mes-
sage pattern, m. This is normally implicit in the description of the
strand unleashed by a receive statement.

The semantics described in this section is a replacement for the
local semantics of earlier work [4]. The original work also de-
scribes a global semantics relating bundles of strands. In this work,
there is no reason to modify the global semantics of that earlier
work. We elide it for brevity.
4.5 Preservation of Properties

We would like to show that properties proved about CPPL pro-

grams remain true about the translated CPPLm+c programs.

THEOREM 1. If a CPPL phrase, c, unleashes a strand s by the
earlier semantics [4], then the translation of c unleashes strand s
by the CPPLm+c semantics.

PROOF. Consider the changes made between CPPL and CPPLm+c.
The two differences are (1) the introduction of match statements
and (2) the introduction of constraint satisfaction of recv state-
ments. A CPPL program, which by deﬁnition does not include
match statements, unleashes the same strand by the CPPLm+c se-
mantics, after translation, because (1) no match statements are in-

WWW 2007 / Track: Security, Privacy, Reliability, and EthicsSession: Access Control and Trust on the Web692S
P
S
S
S
P
P
s
s
s
s
RECEIVE AND RELY
s 1 = s ⊕ s

′

s 1 |= µ

;G ⊢ (x recv m µ Y

′) ⊆ ide(m)

dom(s
s 1;G
c rb∗) : (−msg (x, m)s 1 , Y

,Y

1 ⊢ c : s,u
1) ⇒ s,u

Figure 7: Semantics of recv

RECEIVE ALTERNATIVE

;G ⊢ (x rb∗) : s,u

;G ⊢ (x recv m µ Y

c rb∗) : s,u

troduced by translation and (2) only match statements generate
constraints that may not be satisﬁed. Therefore, the strand un-
leashed by a CPPL phrase is identical to the strand unleashed the
translation of this phrase.

This is not an if and only if statement: because match statements
do not cause communication and only reject messages, it is possi-
ble for some CPPLm+c program, p, to unleash a strand s which is
also unleashed by some CPPL program, p′, such that p is not the
translation of p′.

Notice that we have not yet discussed whether our compilation
of CPPLm+c programs preserves properties, or, more formally, cor-
rectly executes the strand. We have simply shown that the transla-
tion of CPPL to CPPLm+c does not change the strands unleashed by
CPPL programs.

5. DISPATCHING

So far we have calculated the constraints imposed on incoming
messages, recorded the constraints as annotations in an extended
language, and taken a ﬁrst step towards proving correctness. We
still must describe how these constraints can be used to guarantee
that all messages received by a protocol contain distinguishing val-
ues. We must also describe the algorithm used for dispatching.

Sec. 5.1 describes the analysis that is run on CPPLm+c programs
to ensure that all received messages contain distinguishing values.
Sec. 5.2 presents the algorithm used by the dispatching server that
relies on this analysis. Sec. 5.3 proves correctness properties on
both of these.
5.1 Analyzing CPPLm+c Programs

Given a CPPLm+c program, or more generally a CPPLm+c phrase,
we must check that all received messages contain a distinguishing
value. A message may contain such a distinguishing value directly,
in a message pattern, or indirectly, in the constraints imposed on
the message by the rest of the program. The analysis to check these
conditions is fairly straight-forward, once we understand exactly
what we are checking. In particular, we are checking for visible
distinguishing values.

The notion of visibility is somewhat subtle: if a message com-
ponent contains a distinguishing value but is encrypted by an un-
known key, then the distinguishing value is not visible. Similarly, if
our language modeled hashing, then a distinguishing value would
be visible if it was hashed together with any number of visible data.
Our deﬁnition of visibility is given in Fig. 9.

The majority of the analysis is obvious, merely carrying along
information across the structure of the code phrase, and is therefore
not included in this short presentation. The judgments are of the
form:

n ⊢ c

signifying the fact that given the set of distinguishing values n
messages received in c contain a visible distinguishing value.

, all

The only interesting judgments are on one variant of let state-

ments, recv statements, and match statements.

vis : {x∗} × µ → bool

vis(n , µ) = vis(n , /0, µ)

vis : {x∗} × {x∗} × µ → bool
, µ + µ′) = vis(n ,s
, ∃x∗.µ) = vis(n ,s ∪ {x∗}, µ)

vis(n ,s
vis(n ,s

, µ) ∧ vis(n ,s

, µ′)

vis(n ,s

, ⊤) = false
, x ∼ m; µ) = vis(n ,s

vis(n ,s

, m) ∨ vis(n ,s

, µ)

vis : {x∗} × {x∗} × m → bool

vis(n ,s

, x) = x ∈ (n − s )

vis(n ,s
vis(n ,s
vis(n ,s
vis(n ,s
vis(n ,s

, (m, m′)) = vis(n ,s
, (r m)) = vis(n ,s
, (m)) = vis(n ,s
, [m]x) = vis(n ,s
, {m}x) = vis(n ,s

, m) ∨ vis(n ,s
, m)
, m)
, m) ∧ x /∈ s
, m) ∧ x /∈ s

, m′)

Figure 9: Visibility under constraints

LET (NEW)

n ∪ {x} ⊢ c

n ⊢ let x = new in c

This rule simply introduces a new distinguishing value into the set
. Recall that the new case of the let form generates a globally-
unique, i.e., locally-originating, nonce.3

MATCH (ALIASING)
x ∈ n

∪ {y} ⊢ c

n ⊢ x match y c

MATCH
x /∈ n

¬∃y.m = y

n ⊢ x match m c

n ⊢ c

These rules handle match statements. The interesting subtlety is
that pattern matching can introduce aliases for existing distinguish-
ing values. When such an alias is detected, i.e., when the pattern
is simply an identiﬁer, y, then that identiﬁer must be added to the
set. (Recall that only identiﬁers may appear on the left side of a

match, so detecting aliasing is very simple.)

RECEIVE
n ⊢ c

n ⊆ ide(m) ∨ vis(n , µ)

n ⊢ recv m µ Y

c

This is the pivotal rule. It checks that either the message pattern or
the constraint contains a visible distinguishing value, by employing
the deﬁnition of visibility given in Fig. 9.
3If a protocol author has more information about what values are
distinguishing, then custom rules similar to this one can be added
that incorporate identiﬁers bound to these values into the n set.

WWW 2007 / Track: Security, Privacy, Reliability, and EthicsSession: Access Control and Trust on the Web693s
s
s
s
s
n
n
n
There are a few subtleties we do not formalize here. First, sub-
protocols invoked by a protocol must themselves be dispatchable.
Second, these protocols must not have messages that overlap, in the
sense discussed in the conclusion. Third, the analysis as presented
will fail on protocols that start with message reception, because
no distinguishing values have been transmitted. However, we can
relax this restriction, but it requires some uninteresting technical
modiﬁcations to the analysis.
5.2 The Dispatching Algorithm

Having shown an analysis that ensures every expected incom-
ing message contains a distinguishing value, we must show how
to build a dispatching server that can correctly dispatch incoming
messages. The fundamental implication of our analysis is that only
one session will accept any given message, because each message
contains a distinguishing value. Given this, deﬁning our server is
very simple. The server simply attempts to deliver an incoming
message to all existing sessions. By the above, at most one session
will accept the message.

Before we formally present the dispatching algorithm, we must
clarify the notion of a “session”. A session, s, captures the entire
state of a protocol run: the runtime environment, the trust manage-
ment database, and the current continuation. A session may be ini-
tialized by a procedure p by creating the runtime environment con-
taining bindings for p’s arguments, initializing a trust management
database, and using the continuation embedded in p. A session is
waiting if its continuation is a recv statement, i.e., it is waiting for
an incoming message. We say that a session s evolves into a session
s′ if executing the continuation of s with the given runtime environ-
ment and trust management database reduces after some number of
steps to the session s′. If a session s evolves to a session s′ where
the continuation is a return statement, then the session s is said to
have returned. A session s that cannot evolve to any session s′ is
said to be stuck. We say that we deliver a message M to a waiting
session s when we allow s to evolve and receive message M at the
recv statement at the top of the continuation. Notice that if we de-
liver a message M to a waiting session s where M does not match
the message pattern or constraints in any of the branches of the recv
statement at the top of s’s continuation, then s is stuck.

The server obeys the following algorithm, with P representing

the CPPLm+c protocol being served.

1. Initialize sessions to {}.

2. Wait for a message, M.

3. Replicate sessions to create tmp.

4. If tmp is the empty set, then go to step 7. If not, continue.

5. Remove a session, s, from tmp.

6. Deliver message M to s.

(a) If s returns, remove s from sessions, and go to step 2.
(b) If s evolves into a waiting session s′, remove s from

sessions, add s′ to sessions and go to step 2.

(c) If s is stuck, go to step 4.

7. Initialize the protocol P to create a new session snew. Deliver

message M to snew.

(a) If snew returns, go to step 2.
(b) If snew evolves into a waiting session s′, add s′ to sessions

and go to step 2.

5.3 Correctness of Analysis and Dispatching
Our goal is not only to deploy protocols on the Web but also
to show that, in the process of doing so, we have preserved any
properties proven about them. We must therefore show that our
dispatching algorithm is “correct” in some way. Correctness is,
however, difﬁcult to deﬁne in this context.

One deﬁnition of correctness would be that if a message is deliv-
ered to a session, then that session can run to completion. One way
of stating this formally is: If a message M0 is delivered to a session
s, then if some sequence of messages M1, . . . ,Mn is subsequently
delivered to s, then session s will return.

This condition is, however, not easy to prove, and it is not always
possible to even check in an actual implementation. For example,
consider the commit protocol given in Sec. 3. As we mentioned,
it is not possible to check that some key will decrypt payload (in-
deed, cryptographic security relies on this fact). Given this, it is
difﬁcult to imagine a means of realistically implementing a checker
for the above condition for a message received on line 2.

In other words, it is difﬁcult to establish that the dispatching al-
gorithm is “right”, i.e., that it ensures progress. Absent this stronger
form of correctness, we should at least try to demonstrate the algo-
rithm does not do anything “wrong”, i.e., that it exhibits preser-
vation. In particular, it seems clearly wrong to deliver a message
meant for one session to some other session.

Our work adopts this approach, but with a practical restriction.
To understand this restriction, consider two sessions, A and B, of a
protocol that employs the empty message, e , as a keep-alive. Under
the strand-space network model, when an e message is received,
there is no reason why it should be delivered to A rather than to B.
Informally, there is no harm in sending an e message “meant” for A
to B, provided A eventually receives an e message. Pragmatically,
however, it is clear that conditions outside the pure strand space
model—such as timeouts—can cause session abortion.

Our analysis therefore forces every every message to contain a
distinguishing value. This is a property that the e message, in par-
ticular, fails to exhibit. So long as messages contain distinguishing
values that some session accepts but no other sessions can, we can
easily demonstrate that no message will be delivered incorrectly.
This ﬁnal analysis is therefore implemented by our compiler. It is
satisﬁed by a wide range of existing protocols, and also provides a
useful guideline for the creation of new ones.

To prove this form of preservation, we ﬁrst show that we have
correctly formulated a deﬁnition of visibility and that our analysis
is correct.

LEMMA 1. If vis(n ,s

of unknown identiﬁers s

, m) for some message pattern m and set

, then some identiﬁer in n

is visible.

PROOF. We proceed by structural induction over the cases of m.
Case (1) Assume that m = x. If x ∈ n
, then x is visible and is in
. If x /∈ n or x is unknown, then x is not visible or in n
. This our
base case.

Case (2) Assume that m = (m′, m′′). By induction.
Case (3) Assume that m = (r m′). By induction.
Case (4) Assume that m = (m′). By induction.
Case (5) Assume that m = [m′]x. We may proceed by induction

provided the signing key x is known.

Case (6) Assume that m = {m′}x. We may proceed by induction

provided the encrypting key x is known.

LEMMA 2. If vis(n ,s

, µ) for some constraint µ and set of un-

known identiﬁers s

, then some identiﬁer in n

is visible.

(c) If snew is stuck, reject the message and go to step 2.

PROOF. We proceed by structural induction over the cases of µ.

WWW 2007 / Track: Security, Privacy, Reliability, and EthicsSession: Access Control and Trust on the Web694n
Case (1) Assume that µ = ⊤ and vis(n ,s

, µ). This is clearly a

contradiction of our deﬁnition.

Case (2) Assume that µ = µ′ + µ′′. This OR constraint repre-
sent two branches of the program. We must ensure that all paths
through the program contain distinguishing values. Thus, each sub-
constraint must contain some identiﬁer of n

.

Case (3) Assume that µ = ∃x∗.µ′. By induction.
Case (4) Assume that µ = x ∼ m; µ′. By induction and Lemma 1.

THEOREM 2. If a CPPLm+c phrase passes the analysis, then

each message it receives contains a distinguishing value.

PROOF. We proceed by induction and cases. Clearly the only

interesting case is recv statements.

A recv statement is satisﬁed only if some distinguishing value,
i.e., a member of the set n
, n, is in the set of identiﬁers of the
message pattern, or if it is visible under the constraints, µ, of the
statement. In the ﬁrst case, the distinguishing value is clearly in
the message. In the second case, we know by Lemma 2 that the
message contains the distinguishing value.

Now that we have shown our analysis is correct, we can prove
our algorithm is correct by relying on these proofs. We do so in
two steps.

LEMMA 3. If the dispatching algorithm rejects a message M,

Figure 10: Typical Benchmark Results

then no session could accept message M.

PROOF. Suppose that some session s could have accepted mes-
sage M. If the message has been rejected, then it must have been
rejected in step 7c. This implies that snew rejected the message and
that the set tmp was empty (step 4).

Suppose that tmp was initially {s0, . . . ,sn}. For tmp to become
empty, step 5 must be executed for each session s0 through sn. At
step 6, the algorithm must have taken branch 6c, to return to step 4
and then 5. The algorithm only takes branch 6c when the session
(si) rejects the message.

Thus all sessions have rejected M, resulting in a contradiction

with the assumption that some session s exists.

LEMMA 4. If a session s accepts a message M, then no other

session s′ could have accepted message M.

PROOF. Assume that some other session s′ exists that also ac-

cepts message M.

If s accepts M, then it is waiting on some pattern p for a mes-
sage that satisﬁes constraints µ and M matches p and satisﬁes the
constraints µ.

If s′ accepts M, then it is waiting on some pattern p′ for a mes-
sage that satisﬁes constraints µ′ and M matches p′ and satisﬁes the
constraints µ′.

Recall that the code associated with s and s′ have passed the anal-
ysis. Therefore p or µ contains some visible distinguishing value n,
and p′ or µ′ contains some visible distinguishing value n′.

If M satisﬁes both patterns and constraints, then it contains both
n and n′. This is a contradiction to our assumptions about distin-
guishing values, and in particular, our Dolev-Yao [2] assumptions
about nonces, which are globally unique and non-forgeable.

Thus, s′ must not exist.

THEOREM 3. The dispatching algorithm delivers all messages
that can be delivered and does not deliver a message to session s
that should be delivered to session s′.

PROOF. By Lemmas 3 and 4.

6.

IMPLEMENTATION

We have modiﬁed the existing CPPL compiler to support the anal-

ysis described above. This compiler is implemented using OCaml [7]
and translates a CPPLm source ﬁle into OCaml. Each CPPLm proce-
dure is translated into an OCaml procedure that takes a number of
CPPLm values as arguments and returns a tuple of results.

Our implementation performs the analysis described in this pa-
per; if the analysis fails, the compiler displays an error. The error
message advises the protocol author about which line contains a
recv statement that does not contain a distinguishing value. For
example, an error message would be displayed for line 2 of the
commit protocol example from Sec. 3. This helps a protocol au-
thor identify where hand soundness proofs must occur or where the
protocol must be changed for Web deployment.

In our previous implementation, translated CPPL source ﬁles were
combined with OCaml source ﬁles that set up the environment cor-
rectly and then invoked the CPPL procedures with the proper argu-
ments. Our implementation provides a dispatching server, like a
Web server, written in OCaml that runs the CPPLm procedures on
incoming messages as described by our algorithm. Our implemen-
tation also records the values returned by each successful proto-
col run, whereas the earlier implementation prints this information
when the single protocol run completes.
Performance. We have built a benchmarking suite based on a sam-
ple of protocols from the SPORE [10] repository. Fig. 10 shows
results for two protocols which captures the trend across the suite.
The horizontal axis shows the number of concurrent clients and the
vertical axis shows the average time to session completion. The
upper lines show the outcome for the previous compiler, and the
lower lines show the outcome for our approach.

The reason for this gain is clear. Enabling deployment of CPPL
protocol speciﬁcations on stock Web servers engenders both usabil-
ity (since both deployers and clients can leverage the Web’s infras-
tructure) and scalability (owing to the Web’s statelessness). In par-
ticular, deployments can now leverage the frequent improvements

WWW 2007 / Track: Security, Privacy, Reliability, and EthicsSession: Access Control and Trust on the Web695Finally, we would like to generalize our analysis to accommodate
multiple protocols simultaneously. This would require an analysis
of all participating protocols to ensure that there are no messages
that match receive branches in multiple protocols, i.e., to ensure
that the messages do not overlap.
Acknowledgments. This material is based upon work supported
by NSF grant CNS-0627310 and under a National Science Foun-
dation Graduate Research Fellowship.

9. REFERENCES
[1] K. Bhargavan, R. Corin, C. Fournet, and A. D. Gordon.

Secure sessions for web services. In Workshop on Secure
Web Services, pages 56–66, 2004.

[2] D. Dolev and A. Yao. On the security of public-key

protocols. IEEE Transactions on Information Theory,
29:198–208, 1983.

[3] O. Goldreich. The Foundations of Cryptography. Cambridge

University Press, Cambridge, UK, 2004.

[4] J. D. Guttman, J. C. Herzog, J. D. Ramsdell, and B. T.

Sniffen. Programming cryptographic protocols. In Trust in
Global Computing, pages 116–145, 2005.

[5] J. D. Guttman, F. J. Thayer, J. A. Carlson, J. C. Herzog, J. D.

Ramsdell, and B. T. Sniffen. Trust management in strand
spaces: A rely-guarantee method. In European Symposium
on Programming, pages 325–339, 2004.

[6] C. Haack and A. Jeffrey. Pattern-Matching Spi-Calculus. In

Formal Aspects in Security and Trust, pages 55–70, 2004.

[7] X. Leroy, D. Doligez, J. Garrigue, D. R´emy, and J. Vouillon.

The Objective Caml System. INRIA,
http://caml.inria.fr/, 2000. Version 3.00.

[8] J. Matthews, R. B. Findler, P. T. Graunke, S. Krishnamurthi,
and M. Felleisen. Automatically restructuring programs for
the Web. Automated Software Engineering, 11(4):337–364,
2004.

[9] K. Onda, V. T. Vasconcelos, and M. Kubo. Language

primitives and type discipline for structured
communication-based programming. In European
Symposium on Programming, pages 122–138, 1998.

[10] Project EVA. Security protocols open repository.

http://www.lsv.ens-cachan.fr/spore/, 2007.

[11] F. J. Thayer, J. C. Herzog, and J. D. Guttman. Strand spaces:

Proving security protocols correct. Journal of Computer
Security, 7(2/3):191–230, 1999.

being made to Web server performance to handle more simultane-
ous sessions.

7. RELATED WORK

In the introduction, we alluded to a strawman solution involv-
ing uniform modiﬁcation of protocols. That approach corresponds
to past work [8] on compiling sequential interactive programs into
programs that run in Web servers. Their compiler consumes con-
sole programs that present a prompt and react to what the user types
into Web applications that present a form and resume when the
user submits a response. The compiler functions by computing and
storing the continuation at each interaction point, and encoding the
computation’s closure in a combination of hidden ﬁelds, database
records, and cookies. On response, this continuation is invoked
with the client’s response and the program continues, oblivious to
the modiﬁcation. A nonce records which continuation to resume at
each form submission.

This solution is inappropriate for CPPL programs for several rea-
sons. First, CPPL programs need not follow every send with a re-
ceive. Second, CPPL programs may involve more than two partici-
pants. A third, essential, reason why this solution is not appropriate
is that it changes the format of the messages by adding the encoded
continuations. In our environment this corresponds to changing the
protocol itself, which makes existing proofs invalid.

There is another reason why that work is inappropriate here. A
goal of that research is to ensure that continuations may be invoked
safely multiple times, e.g., that the Web browser’s Back button may
be used safely. We expressly do not wish to support this because it
would correspond to replay attacks and violate freshness assump-
tions.

One aspect of our work extends CPPL to include match state-
ments that perform pattern matching. Other languages for program-
ming cryptographic protocols also contain this functionality. Haack
and Jeffrey [6] discuss their pattern-matching system in the context
of the Spi-calculus. They also discuss the subtlety we mention in
Sec. 4.1 regarding whether identiﬁers introduced by EXISTS forms
can be used in an encrypting position in a pattern. Our work is
complementary to theirs in this aspect, as our system is based on a
strand-space semantics and this feature is not our sole contribution.

8. CONCLUSION

We have shown how a CPPLm program can be analyzed and com-
piled into a form that allows it to be used in the context of a Web
server. We have argued that the properties proved on the original
protocol are preserved, and we have presented a dispatching strat-
egy that enables multiple sessions to not interfere with one another.
We have built an implementation that can be used by protocol en-
gineers to produce efﬁcient implementations.

The approach used in this work may be applied to other prob-
lems as well. For example, there is work that produces proto-
cols that guarantee that participants implement session types [1, 9].
We could analyze the constraints of existing protocols and ensure
that they imply that messages contain the appropriate cryptographic
forms that enforce the session type property, thereby allowing this
work to be applied to existing protocols.

We would like to extend our language with regular expressions
types (to represent XML) and extend our analyses to handle them,
then apply our work to XML Web service protocols that exist in
the wild. We would also like to optimize the dispatcher design
presented here to eliminate many tests when many protocol runs
share similar constraints and message patterns, by associating the
shape of incoming messages with existing sessions.

WWW 2007 / Track: Security, Privacy, Reliability, and EthicsSession: Access Control and Trust on the Web696