Towards the Theoretical Foundation of Choreography∗

Qiu Zongyan, Zhao Xiangpeng, Cai Chao, and Yang Hongli

LMAM & Department of Informatics, School of Math., Peking University, Beijing, CHINA

zyqiu@pku.edu.cn, {zxp,caic,yhl}@math.pku.edu.cn

ABSTRACT
With the growth of interest on the web services, people
pay increasingly attention to the choreography, that is, to
describe collaborations of participants in accomplishing a
common business goal from a global viewpoint. In this pa-
per, based on a simple choreography language and a role-
oriented process language, we study some fundamental is-
sues related to choreography, especially those related to im-
plementation, including semantics, projection and natural
projection, dominant role in choices and iterations, etc. We
propose the concept of dominant role and some novel lan-
guages structures related to it. The study reveals some clues
about the language, the semantics, the speciﬁcation and the
implementation of choreography.

Categories and Subject Descriptors
H.3.5 [Info. Sys.]: Misc.—Web-based services; D.2.1 [Soft.]:
SE—Speciﬁcations; D.3.1 [Prog. Language]: Formal Def-
initions and Theory—Semantics

General Terms
Design, Languages, Theory, Veriﬁcation

Keywords
Choreography, Semantics, Implementation, Projection, Dom-
inant Role, Dominated Choice, Dominated Loop

1.

INTRODUCTION

Web services promise the interoperability of various appli-
cations running on heterogeneous platforms over the Inter-
net, and are gaining more and more attention. Web service
composition refers to the process of combining web services
to provide value-added services, which has received much
interest in supporting enterprise application integration.

The description of the single services locally from coopera-
tion of other services is called an orchestration. The de facto
standard for orchestration is BPEL [2].

On another level, we need to specify protocols among dif-
ferent services to achieve a business goal. WS-CDL [9, 8]

∗Supported by NNSF of China (No. 60573081).

Copyright is held by the International World Wide Web Conference Com-
mittee (IW3C2). Distribution of these papers is limited to classroom use,
and personal use by others.
WWW 2007, May 8–12, 2007, Banff, Alberta, Canada.
ACM 978-1-59593-654-7/07/0005.

is a W3C candidate recommendation designed for describ-
ing the collaborative observable behavior of multiple services
that interact with each other, where the behaviors are per-
formed by the participants, and the speciﬁcation written in
WS-CDL, called a choreography, provides a global view.

Extensive writing exists on the speciﬁcation of parallel
and distributive systems, for example CSP [7] and CCS [12].
However, almost all of them support intrinsically the spec-
iﬁcation from the local viewpoint. Even for the communi-
cation, the speciﬁcation is still local, as it expresses when a
process sends or receives a message from a speciﬁc channel.
Furthermore, there is not a special concept of the partici-
pants in the computation.

With the blooming of web technology, real computations
are increasingly established as a kind of processes that var-
ious computing facilities take part in, which are indepen-
dent entities and might reside in any place throughout the
world. For accomplishing the goal of the computation, they
should not only have “correct” functionalities, but also in-
teract with each other correctly. With the interaction be-
coming more complex, the problems related to specify the
interaction of the participants become harder and harder.
Moreover, it is even harder to verify the interaction locally.
This is the motivation behind the design of WS-CDL.

However, as quoted from the speciﬁcation, WS-CDL is
“not an execution business process description language or
an implementation language”. A choreography designates
a business task performed by multiple roles, but does not
give an implementation composed of a set of participants.
The speciﬁcation of the individual participants is at the level
of BPEL-like languages. For the successful development of
the web-based applications, it is urgent and important to
understand the approaches for connecting the global view
of the choreography with the local view of each participant.
The work presented here is motivated by this requirement.
It is an eﬀort to make a clear view of choreography at an
abstract level for a better understanding of what is required
by the choreography to each of the roles, and further the
choreography itself and related issues involved.

To explore the essence of choreography, we deﬁne a small
language Chor as a model of simpliﬁed WS-CDL, and a
simple process language for describing roles from a local
viewpoint, both with formal syntax and semantics. With
these models, we discuss the concept of projection, which
maps a choreography to a set of role processes, and deﬁne
the implementation of choreography based on projections.
We propose a natural projection and two structural condi-
tions related to it. Then we discuss another projection that

WWW 2007 / Track: Web ServicesSession: Orchestration and Choreography973remedies the relative ordering problem where a choreogra-
phy violates the sequential condition.

For the correct implementation of the choice structures in
a choreography, we ﬁnd that the dominant role of a choice is
a very important concept. To ensure the roles processes take
consistently the same branch in their independent version of
a choice (in the choreography), when the choice is projected,
there must be only one role – the dominant one – to make the
real choice, and the other roles simply follow the dominator’s
decision. Otherwise, the consistency cannot be guaranteed.
With this recognition, we suggest to introduce dominant
role as an explicit concept on the choreography level. We
extend Chor and the role language by some new structures,
including dominated choice, and dominated loop, with for-
mal syntax and semantics of these structures and relatives.
Furthermore, we deﬁne a projection that maps, as well as
other structures, the dominated choice and dominated loop
in Chor to the corresponding choice and loop structures for
the dominant and dominated roles in the role language. As
shown in the paper, the choreography designer can select
the dominant role for each choice or loop as they want. The
projection can generate all the necessary structures and syn-
chronizing actions, and produce a correct implementation,
i.e., the parallel composition of the resulted roles will cor-
rectly show the behavior described by the choreography.

The basic part of Chor and the process language are de-
ﬁned in Section 2 and Section 3. Section 4 is devoted to
projection and implementation, where we provide a detailed
discussion about natural projection and structural condi-
tions related to this projection. With the concept of domi-
nant role, we extend our framework in Section 5, and deal
with the implementation of choices and loops. A number of
related general issues are discussed in Section 6. Finally we
list some related work and give a conclusion.

2. THE LANGUAGE Chor

Finite roles take part in a choreography C, where each

role is associated with a number of basic local activities:

RC = {R1, . . . Rn}
locals(Ri) = {ai

1, . . . , ai

ni}

We use meta-variable ai to denote an arbitrary activity of
Ri, and use a, a1, . . . for activities of any role.

The communication from role Ri to Rj takes the form of
c[i,j], where c is a channel name. We use c, c1, . . . to rep-
resent concrete communication names in examples. We do
not care about the messages transferred in communications,
nor the variables receiving the messages.

The syntax of the choreography language Chor is given in
Fig.1 (upper part). A basic activity can be a local activity
of a role Ri, a communication, or skip which does noth-
ing. The composition structures considered here are the
sequential composition, choice, and parallel composition. A
choreography (a “program”) is simply an activity A.

We call Ri the performer of local activity ai, and call Ri
and Rj the performers of c[i,j]. We use locals(C) (locals(Ri))
to denote the set of all local activities in C (of Ri), use
comms(C) (comms(Ri)) for the set of all communication
activities in C (performed by Ri), use acts(C) (acts(Ri))
for the set of all activities appearing in C (performed by
Ri), and use α, β, . . ., possibly with subscript, to denote an
arbitrary (local or communication) activity.

Figure 1: Syntax & Semantics of Chor

A : : = BA

(basic activities)

| A; A (sequential composition)
| A(cid:117) A (choice)
| A (cid:107) A (parallel composition)

BA : : = skip

|
|
Basic:

ai
c[i,j]

Sequential:

Choice:

Parallel:

(no action)
(activity in role Ri)
(communication)

[[skip]] >= {(cid:104)(cid:105)}
[[a]] >= {(cid:104)a(cid:105)}
[[c[i,j]]] >= {(cid:104)c[i,j](cid:105)}
[[A1; A2]] >= [[A1]] =[[A2]]
[[A1 (cid:117) A2]] >= [[A1]] ∪ [[A2]]
[[A1 (cid:107) A2]] >= interlv ([[A1]], [[A2]])

2.1 A Trace Semantics of Chor

We consider the meaning of a choreography as the set of
all possible traces of its execution. A trace is a sequence of
activities of the form (cid:104)α1, α2, . . . , αn(cid:105), where n is the length,
and (cid:104)(cid:105) is the empty trace with length 0. We will use t, t1, . . .
to denote traces, and use T, T1, . . . to denote trace sets. We
use operator = for trace concatenation, and lift it to trace
sets on either or both sides:

We need a function interlv to interleave activities of two
traces and give the corresponding trace set. The deﬁnition
is routine and is omitted here. We lift interlv to trace sets:

t = T >= {t = t(cid:48) | t(cid:48) ∈ T}
T = t >= {t(cid:48) = t| t(cid:48) ∈ T}
T1 = T2 >= {t1 = t2 | t1 ∈ T1, t2 ∈ T2}
interlv (T1, T2) >= {t|∃t1 ∈ T1, t2 ∈ T2•

We also use ﬁlter operator  on traces and trace sets. The
trace(s) t S (or T  S) retains only the elements of S in t

(or T ), and keeps their orders unchanged.

such that t ∈ interlv (t1, t2)}

Deﬁnition 1. (Trace Semantics of Choreography). The
semantics of choreography C is the trace set [[C]] deﬁned by
rules in Fig.1 (lower part). Here we adopt the interleaving
semantics for parallel composition.


We assume that sequential composition operator “;” has
higher priority, while “(cid:117)” and “(cid:107)” have the same priority.
2.2 Laws and Examples

Many laws hold for choreographies in Chor. We list some
of them in Fig.2, where A, A1, A2, A3 are arbitrary activi-
ties, and = means semantical equivalence. The proofs are
straightforward, and are omitted here. Many other laws can
be found, which are out of the main focus of this paper.

In company with other laws, the Unit and Idempotent
laws can be used to simplify a choreography by removing all
unnecessary skip and replacing A(cid:117) A with A, while keeping
the semantics unaltered. Since the choice (cid:117) can always be
moved outward by the Distribution laws of (cid:117), any chore-
1 (cid:117) . . .(cid:117) A(cid:48)
ography can be transformed into the form A(cid:48)
m,
where no choice appears in each of A(cid:48)
1, . . . , A(cid:48)
m. Using the
laws in the other direction, we can transform a choreogra-
phy to a form where each (cid:117) is restricted to a minimal scope.
Thus we have following deﬁnition.

WWW 2007 / Track: Web ServicesSession: Orchestration and Choreography974Figure 2: Laws in Chor

(; assoc.)
((cid:117) assoc.)
((cid:107) assoc.)
((cid:117) sym.)
((cid:107) sym.)

Association and Symmetry:
(A1; A2); A3 = A1; (A2; A3)
(A1 (cid:117) A2)(cid:117) A3 = A1 (cid:117)(A2 (cid:117) A3)
(A1 (cid:107) A2) (cid:107) A3 = A1 (cid:107) (A2 (cid:107) A3)
A1 (cid:117) A2 = A2 (cid:117) A1
A1 (cid:107) A2 = A2 (cid:107) A1
Unit and Idempotent:
skip; A = A; skip = A
skip (cid:107) A = A
A(cid:117) A = A
Choice Distribution:
(A1 (cid:117) A2); A = (A1; A)(cid:117)(A2; A)
(;-(cid:117) distr.1)
A; (A1 (cid:117) A2) = (A; A1)(cid:117)(A; A2)
(;-(cid:117) distr.2)
(A1 (cid:117) A2) (cid:107) A = (A1 (cid:107) A)(cid:117)(A2 (cid:107) A) ((cid:107)-(cid:117) distr.)

(; unit)
((cid:107) unit)
((cid:117) idem.)

1 (cid:117) . . .(cid:117) A(cid:48)

m, with no choice in A(cid:48)

Deﬁnition 2. (Choice Normal Form). A choreography of
the form A(cid:48)
m, is
called in the Distributed Choice Normal Form. A chore-
ography in which the scope of every (cid:117) can not be limited

further is called in the Minimal Choice Normal Form.

1, . . . , A(cid:48)

Obviously, any choreography has an equivalent Distributed
Choice Normal Form, and a Minimal Choice Normal Form.
One interesting fact is, although a choreography may have
parallel structures, no deadlock can happen in its execution.

Theorem 1

(Deadlock-freeness). Suppose that ev-
ery basic activity in a choreography will terminate, then the
choreography will always terminate.

Proof. All traces in the trace set of a choreography can

be constructed using rules in Fig.1 unconditionally.

Now we present some examples.

Example 1. Here is a simple choreography in Chor:

C1 = (a1

1 (cid:107) a2

1); c1[1,2]; a2

2; c2[2,1]

The trace set of C1 is as follows:
[[C1]] = {(cid:104)a1
Here is another very simple choreography:

2, c2[1,2](cid:105),(cid:104)a2

1, c1[1,2], a2

1, a2

1, a1

1, c1[1,2], a2

2, c2[2,1](cid:105)}

C2 = (a1

1 (cid:107) a2

1); a1
2

[[C2]] = {(cid:104)a1

1, a2

1, a1

2(cid:105),(cid:104)a2

1, a1

1, a1

2(cid:105)}

We will meet this example again in Sec.4.1 etc., because it
shows some interesting features of choreographies.



3. A LANGUAGE FOR ROLES

A choreography describes the interaction among roles from
a global view. It is intended to be implemented by the coor-
dination of a set of independent processes. In order to study
the relationship between the globally described choreogra-
phy and the coordinative activities of each role, we deﬁne a
simple language for the roles here.

The role language is given in Fig.3. The only diﬀerence
from Chor is that it takes a local view on communications,
where sending actions and receiving actions represent roles’

Figure 3: Syntax & Semantics of Role Language
BP : : = skip (no action)
P : : = BP

(basics)
| P ; P (sequential)
| P (cid:117) P (choice)
| P (cid:107) P (parallel)

(cid:104)(cid:105)−→ 

Skip:

skip

Sequential:

Choice:

Parallel:

Local:

σ−→ P (cid:48)
σ−→ P (cid:48)
(cid:104)(cid:105)−→ P1

1
1; P2

P1
P1; P2
P1 (cid:117) P2
 (cid:107) 

(cid:104)(cid:105)−→ 

|
|
|

(local)
(send)
(receive)

a
c!
c?
(cid:104)a(cid:105)−→ 

a

(cid:104)(cid:105)−→ P2

; P2
P1 (cid:117) P2

(cid:104)(cid:105)−→ P2

P1
P1 (cid:107) P2

P2
P1 (cid:107) P2

1

1 (cid:107) P2

σ−→ P (cid:48)
σ−→ P (cid:48)
σ−→ P (cid:48)
σ−→ P1 (cid:107) P (cid:48)

2

2

c? ∈ fst(P1)
P1 (cid:107) P2
c! ∈ fst(P1)
P1 (cid:107) P2

c! ∈ fst(P2)
(cid:104)c(cid:105)−→ P1/c? (cid:107) P2/c!
c? ∈ fst(P2)
(cid:104)c(cid:105)−→ P1/c! (cid:107) P2/c?

local view of interactions. A sending action and a receiv-
ing action engage in a handshake when they have the same
channel name and the two roles involved are ready to per-
form them. We can deﬁne the sets locals(P ), comms(P ) and
acts(P ) too, as in Sec.2.
We deﬁne the semantics of processes as trace sets too.
The semantic rules are of the form P σ−→ P (cid:48), meaning that
process P transforms to P (cid:48) after executing activities in σ,
which is a sequence of activities (i.e. a trace). The rules
are listed in Fig.3 (lower part), where  denotes the empty
process with no command. The two rules on the lower right
are for synchronization. Function fst (for ﬁrst) is deﬁned as:

We deﬁne fst(P1 (cid:117) P2) as ∅ to force choices taking a branch
in the ﬁrst. Moreover, P/α is the process resulted from P
after executing α, as deﬁned below:

fst(α) >= {α}
fst() = fst(skip) = fst(P1 (cid:117) P2) >= ∅
fst(P1 (cid:107) P2) >= fst(P1) ∪ fst(P2)
fst(P1; P2) >= fst(P1)
α/α(cid:48) >= 
skip/α >= ⊥
(P1; P2)/α >= P1/α; P2
(P1 (cid:107) P2)/α >=&

where ⊥ denotes undeﬁned, and only the deﬁned cases are
used here. In the parallel case, when both two conditions
hold in the same time, we take them as two separate rules.
If no rule is applicable to a non-empty process, we say it is
deadlocked. A rule is introduced to represent this situation

when α = α(cid:48)
⊥ when α (cid:54)= α(cid:48)

(P1 (cid:117) P2)/α >= ⊥

P1/α (cid:107) P2
when α ∈ fst(P1)
P1 (cid:107) P2/α when α ∈ fst(P2)
⊥

otherwise

with a special symbol :

P (cid:54)=  and P is deadlocked

(cid:104)(cid:105)−→ 

P

To deﬁne the trace set of processes, we deﬁne:
=⇒ P (cid:48)(cid:48)

P σ−→ P (cid:48) P (cid:48) σ(cid:48)
=⇒ P (cid:48)(cid:48)

P σ (cid:97) σ(cid:48)

P σ−→ P (cid:48)
P σ=⇒ P (cid:48)

Now, we can have the deﬁnition:

Deﬁnition 3. (Traces of Process) If P σ=⇒ , then σ is

WWW 2007 / Track: Web ServicesSession: Orchestration and Choreography975Figure 4: The Natural Projection

if k = i
if k (cid:54)= i
if k = i

nproj(ai, k)
nproj(ai, k)

nproj(skip, k) >= skip
>= ai
>= skip
nproj(c[i,j], k) >= c[i,j]!
nproj(c[i,j], k) >= c[i,j]?
nproj(c[i,j], k) >= skip
>= nproj(A1, k); nproj(A2, k)
nproj(A1 (cid:117) A2, k) >= nproj(A1, k)(cid:117) nproj(A2, k)
nproj(A1 (cid:107) A2, k) >= nproj(A1, k) (cid:107) nproj(A2, k)

if k = j
if k (cid:54)= i ∧ k (cid:54)= j

nproj(A1;A2, k)

called a trace of P . The semantics of process P is the trace

set [[P ]]>={σ|P σ=⇒ }.


It is easy to see that all laws in Fig.2 hold still for pro-
cesses. Besides, although we adopt the same notation [[·]] for
two diﬀerent languages, it will not cause confusion.

4. PROJECTION AND IMPLEMENTATION
A choreography is a global description of a collaborative
task performed by multiple partners. We think that each
role in a choreography is a concrete entities taking part in the
task and should be implemented by a distinguishable, inde-
pendent process. A reasonable deﬁnition of implementation
is based on projection and local conformance (see Sec.6).

A projection is a procedure which takes a choreography C
with n roles and delivers n processes in the role language.
The combination of these role mimic the behavior of C. In
the simplest case, for projection proj , we want to have1:

[[proj (C, 1) (cid:107) . . . (cid:107) proj (C, n)]] = [[C]]

(1)

In a sense, processes proj (C, 1), . . . , proj (C, n) make up an
implementation of C. We will use proj (C) as a shorthand
for proj (C, 1) (cid:107) . . . (cid:107) proj (C, n).

Please note that, if the execution of the left hand side
of (1) runs into deadlock, some of its traces will end with

. Since no trace in [[C]] has  as a part, the equation will

never hold. Conversely, if we have (1), the role processes
will never deadlock (Theorem 1).

No standard projection is deﬁned in WS-CDL. We study

a simple one, and then consider the problems recognized.
4.1 Natural Projection

The natural projection (nproj ) deﬁned in Fig.4 is a simple
partition following the structure of choreographies, where
[i, j] is taken as a part of the channel name. The projection
may leave some skip and P (cid:117) P in role processes. A proce-
dure can be introduced to simplify the results. We will omit
this detail, and present the simpliﬁed results directly.

Example 2. Let us apply nproj to C1 of Exam.1:

nproj(C1, 1) = a1
nproj(C1, 2) = a2

1; c1[1,2]!; c2[2,1]?
1; c1[1,2]?; a2

2; c2[2,1]!

It is easy to see that [[nproj(C1)]] = [[C1]]. However, this is
not always the case. Consider C2 in Exam.1:
nproj(C2, 2) = a2
1
2(cid:105),(cid:104)a1
2(cid:105),(cid:104)a1
1, a1

nproj(C2, 1) = a1
1; a1
2
[[nproj(C2)]] = {(cid:104)a2

1(cid:105)}

2, a2

1, a2

1, a1

1, a1

1, a1

1We might use other similar equations, e.g. (4) in Sec.4.3.

Obviously, this is not the same as [[C2]] (see Exam.1).



Sometimes Equation (1) may fail with nproj.

In these
cases, we can blame the fault to the choreography under
consideration, or to the projection used (nproj here), or to
the semantics we choose, or even to the languages. We will
investigate the problem further on some of these issues.
4.2 Restricted Natural Choreography

The natural projection seems intuitive. Thus, from one
point of view, we can take nproj as a criterion to distinguish
the “good” choreographies from the “bad” ones, and say
that C1 in Exam.2 is good, while C2 is bad.

Deﬁnition 4. (Restricted Natural Choreography). Sup-
pose C is a choreography with n roles. We call C a restricted
natural choreography (RN choreography for short), if

[[nproj(C)]] = [[C]]

(2)

Deﬁnition 4 deﬁnes a restricted level of “well-formedness”.
If a choreography is RN, we can eﬃciently partition it into
a set of processes whose parallel composition shows the ex-
pected behavior. It is natural to ask a question: what struc-
tures make an RN choreography? We will propose some
suﬃcient conditions here.

4.2.1

Sequential Composition

The problem related to sequential composition is to keep
the relative order among the processes produced by the pro-
jection. We have seen a counterexample in Exam.2, where
the processes can not keep the relative order of their activi-
ties, and an extra trace presents.

To describe a condition for sequential compositions, we
need to deﬁne two activity sets: lead (A) includes all activ-
ities that can be executed ﬁrst in the execution of A, and
end (A) includes activities that can be the last activity of
A. These two sets can be deﬁned recursively. The follow-
ing condition guarantees that a sequential composition never
breaks Equation (2):

Condition 1. (Sequential Composition). A sequential com-

position A1; A2 is restricted natural (RN), if it satisﬁes:

∀α1 ∈ end (A1), α2 ∈ lead (A2)•

α1 and α2 have a common performer.

The concept performer is deﬁned in Sec.2.

(3)



Here are some choreographies where all sequential com-

positions presented are RN:

1 (cid:107) a2
(a1

(c1[1,3] (cid:107) a2

a1
1; a1
2

1); c[1,2]

1; c2[2,4]); c3[1,2]; a1
1
The last two example show that, when one side of “;” is a
parallel or a choice, we need to consider each of the branches
separately. We will discuss the choices further in next sub-
section.

Example 3. A simplest counterexample is C3 = a1

1; a2
1.

After projection we get

1, a2

1, a1

1(cid:105)}

nproj(C3, 2) = a2
1

nproj(C3, 1) = a1
1
[[nproj(C3)]] = {(cid:104)a1

1(cid:105),(cid:104)a2
The relative order of a1
1 is not kept. We can add a
communication to separate the two activities, and obtain an
RN choreography a1
1. Also, C2 in Exam.2 can be
modiﬁed into an RN one similarly. This remedy procedure

will be discussed further in Sec. 4.3.

1; c[1,2]; a2

1 and a2

WWW 2007 / Track: Web ServicesSession: Orchestration and Choreography976Example 4. Condition 1 has a sad consequence: we have
no way to enforce local activities of more than two roles to
terminate at the same time, when they run in diﬀerent par-
allel branches. Consider C4 = (a1
2. No matter
what and how many communications introduced, we can not
make it an RN choreography. Here is a try:

1 (cid:107) a2

1 (cid:107) a3

1); a1

C(cid:48)
4 = (a1
[[nproj(C(cid:48)

1 (cid:107) a2
1 (cid:107) a3
4)]] = [[C(cid:48)

1); c1[1,2]; c2[1,3]; a1
2
4]] ∪ {(cid:104)a1
1, a2
(cid:104)a2
1, a1

1, c1[1,2], a3
1, c1[1,2], a3

2(cid:105),
1, c2[1,3], a1
2(cid:105)}
1, c2[1,3], a1

Other arrangements will have similar results.



Some researchers proposed to add the multipartite com-

munication activities to solve this problem, e.g. [3].

4.2.2 Choice

The nproj maps a choice in a choreography to a choice
in each role process. Within the parallel composition, these
processes run independently, thus are not guaranteed to take
consistently the same branch in the run of their own version
of the choice. Inconsistent choices can result in extra traces,
or even deadlock. The simplest example showing the prob-
1(cid:105)}. After projec-
1, which has trace set {(cid:104)a1
lem is a1
1 (cid:117) skip)
tion and parallel composition, we get (a1
1(cid:105)}.
1(cid:105),(cid:104)a2
with trace set {(cid:104)(cid:105),(cid:104)a1

1 (cid:117) skip) (cid:107) (a2
1, a1

1(cid:105),(cid:104)a1

1(cid:105),(cid:104)a2

1(cid:105),(cid:104)a2

1 (cid:117) a2

1, a2

For a choice to bring no trouble, one possibility is that at
most one role process really makes a choice in its version of
the choice; for each of the other processes, all branches in
its version of the choice are the same, thus it makes no real
choice here. We have the following deﬁnition:

Condition 2. (Choice). For a choice, if we can determine
a special role, called dominant role hereafter, while for each
of the other roles involved, all branches of those roles’ version
of this choice are the same and thus can be merged together,
then this choice is an RN choice.



Now we give some examples to illustrate this condition.

Example 5. Choreography C5 includes an RN choice with

communication activities:
1; (a1

2; c[1,2] (cid:117) a1
1; (a1

3; c[1,2]); a2
C5 = a1
1
2 (cid:117) a1
nproj(C5, 1) = a1
3); c[1,2]!
nproj(C5, 2) = c[1,2]?; a2
1

R1 is the dominant role here, and the choice in R2 disap-
pears. It is easy to see that [[nproj(C5)]] = [[C5]].

Here is a negative example:

1; (a1

2; c1[1,2] (cid:117) a1
1; (a1

C6 = a1
3; c2[1,3]); a2
1
2; c1[1,2]!(cid:117) a1
nproj(C6, 1) = a1
3; c2[1,3]!)
nproj(C6, 2) = (c1[1,2]?(cid:117) skip); a2
1
nproj(C6, 3) = c2[1,3]?(cid:117) skip

Because none of the choices in the three role processes can
shrink away, we cannot have [[nproj(C6)]] = [[C6]]. Further-

more, the parallel composition may run into deadlock.

4.2.3

Structural Theory of RN Choreography

For parallel composition, we ﬁnd no extra conditions. The
interaction between parallel and sequential composition has
been studied. Now we consider the interaction between par-
allel composition and choice. Exam.5 shows some cases for
this interaction. Here are some more examples:

Example 6. Consider:
1; c1[1,2] (cid:117) a1
C7 = (a1
nproj(C7, 1) = (a1
nproj(C7, 2) = c1[1,2]? (cid:107) c2[2,1]!; a2

2; c1[1,2]) (cid:107) c2[2,1]; a2
1; c1[1,2]!(cid:117) a1

1

1

2; c1[1,2]!) (cid:107) c2[2,1]?

The dominant role of the choice is R1. No matter which
branch R1 chooses, it can always synchronize with R2. It is
not hard to see that [[nproj(C7)]] = [[C7]].

Now consider a similar example involving parallel compo-

sition of two choices with diﬀerent dominant roles:

1; c1[1,2] (cid:117) a1
C8 = (a1
nproj(C8, 1) = (a1
nproj(C8, 2) = c1[1,2]? (cid:107) (c2[2,1]!; a2

2; c1[1,2]) (cid:107) (c2[2,1]; a2
1; c1[1,2]!(cid:117) a1

2; c1[1,2]!) (cid:107) c2[2,1]?
2; c2[2,1]!)

1 (cid:117) a2

1 (cid:117) a2

2; c2[2,1])

Dominant roles of the two choices are R1 and R2, respec-
tively. No matter how R1 and R2 choose, the synchroniza-

tion will be ﬁne, and [[nproj(C8)]] = [[C8]].

Ideally, we hope to ﬁnd a set of structural conditions, that
are both suﬃcient and necessary to distinguish RN chore-
ographies from the others. However, we can only prove that
the conditions given above are suﬃcient.

Theorem 2

(Restricted Natural Choreography).

Suppose choreography C is in its Minimal Choice Normal
Form (Deﬁnition 2). If each of the sequential compositions
in C satisﬁes Condition 1 and each of the choices in C sat-
isﬁes Condition 2, then C is restricted natural.

Proof. The proof is in our report [13].

A counterexample showing the conditions are not neces-

1. It is RN but violates Condition 1.

1 (cid:117) a2

1; a2

sary is a1
4.3 Other Projections

1; a1

As pointed in Sec.4.1, we can also blame nproj for the
failure of Equation (1) in general. Taking another projec-
tion may make an equation similar to (1) hold for more
choreographies. In previous work [13], we proposed a pro-
jection to remedy the ordering of activities among diﬀerent
roles. Given a choreography C with n roles, which might
violate Condition 1 (but not Condition 2), the projection
inserts ﬁrst some communications (in either direction) into
C in the suitable positions to enforce the relative orderings
between roles, to produce a choreography C(cid:48), such that

[[nproj(C

(cid:48)

)]] acts(C) = [[C]]

(4)

Here  is the ﬁlter operation described in Sec.2. Note that

(4) is true for some non-RN choreographies. Therefore we
have an extended class of “good” choreographies.

The problem related to Condition 2 involves the consistent
choice in diﬀerent roles. To solve this problem, we need to
extend Chor. We explore the problem related to choices and
iterations in the next section.

5. AN EXTENDED FRAMEWORK

Practically, choreographies with choices violating Condi-
tion 2 are common. It is not reasonable to classify them as
non-implementable. As an example, we consider now a real
case, where a customer asks two sellers for the price and
other relevant information of some product. After receiving
two replies, the customer makes a choice based on some cri-
terion, and informs the sellers. Depending on the customer’s

WWW 2007 / Track: Web ServicesSession: Orchestration and Choreography977choice, the sellers will either continue to trade or simply go
to rest. If we made this scenario as a choreography, there
must be a choice in which all the three participants need
to make their choices in a consistent way. Thus, a choice
structure violating Condition 2 is inevitable here.

In the study, we ﬁnd that dominant role is a very impor-
tant concept. It is the key of Condition 2, where we try to
determine if there is only one role who makes a real choice.
Now we consider to introduce it explicitly into our languages.
In fact, when a designer writes a choice involving multiple
roles in a choreography, she/he has a clear idea in mind that
one of the roles is special who makes the real choice, while
the others should follow this role’s decision. Reasonably, in
the scenario above, the customer is the dominator, and the
sellers are dominated by the customer’s choice.

We will explore this idea in this section, and introduce
a dominated choice structure into Chor as a substitution of
the ordinary choice. We need also the corresponding concept
to express the communication of the dominance from one
role to other roles in the role language, and thus introduce a
guarded choice structure with communications as guards for
this. We deﬁne a new projection, an extension of nproj, to
produce correct role processes. After the study of choices,
we turn to loops. Based on the concept of dominant role, we
introduce another new structure called dominated loop. We
will extend the role language with some iteration structures,
and deﬁne the projection rules.

From the view at the end of Sec.4.1, this part of the work
is an eﬀort related to the language and projection, towards
correctness of Equation (1) in general. In the forthcoming
discussion, we will not consider problems related to sequen-
tial composition, are they are already discussed before. The
new projection proposed can deal with all the extensions.
With it, all these structures are “implementable” in a rea-
sonable sense.

5.1 Dominated Choice

Now we consider the language extension to Chor for the

reasonable implementation of choice structures.

5.1.1 Language Extensions

The ﬁrst modiﬁcation to Chor is a new choice structure

introduced to replace the ordinary one, with the form:

A : : = . . .|

i

A(cid:117) A | . . .

i

A(cid:117) A represents a choice with Ri as its dominant role. The
semantics of this choice is the same as A(cid:117) A from the global
view, i.e., the choreographic view. On the other hand, i
plays a critical role in the projection discussed below. Here
is the semantic rule for it:

[[

i

A(cid:117) A]] >= [[A1]] ∪ [[A2]]

All the laws held for the ordinary choice are true when
we replace it with the dominated choice. An important and
interesting property is:

i

A(cid:117) A]] = [[
[[

j

A(cid:117) A]]

even if i (cid:54)= j. It is not a surprise, because in choreographies,
the roles always make choice consistently. The designation
of i has no eﬀect on semantics of this level, but only on the

implementation. We can consider the designation as a direc-
tive, similar to the pragma in some programming languages,
which gives the compiler clues for compiling while having no
eﬀect on the semantics.
i(cid:117) A3), we can intro-
duce multi-branch choice structures as a simple extension.
Now we use the extended language to express the example
discussed in the beginning of this section, a scenario where
a customer wants to buy some product from two sellers.

i(cid:117) A3 = A1

Because (A1

i(cid:117) A2)

i(cid:117) (A2

Example 7. Suppose the customer is role R1, and the
two sellers are R2 and R3 respectively. Here is a choreogra-
phy that describes the protocol of their interactions:

C9 = (c1[1,2]; a2

(c5[1,2]; a2

1; c2[2,1] (cid:107) c3[1,3]; a3
2; c6[2,1] 1(cid:117) c7[1,3]; a3

1; c4[3,1]); a1
1;

2; c8[3,1])

Initially, the customer informs sellers what is wanted. The
sellers do some local work (a2
1 respectively), and then
send responses to the customer (c2[2,1] and c4[3,1]). After
some local work a1
1, the customer chooses a seller, that is de-
scribed by a dominated choice. In each branch of the choice,
the customer continues the trade with one seller.

1 and a3

Now we calculate the trace sets. To make things clear,
we use T0 to represent the trace set produced by the parallel
structure. We have
[[C9]] = T0 =(cid:104)a1

2; c6[2,1](cid:105),(cid:104)c7[1,3]; a3

1(cid:105) ={(cid:104)c5[1,2]; a2

2; c8[3,1](cid:105)}

This example will be used throughout this section.



The role language has a real extension — the guarded

choice:

P : : = . . .| c1?→P1 [] c2?→P2

As to the semantics, we need only to extend the deﬁnition of
fst and P/α, but not the semantic rules, because the guarded
choice can be reduced only with other parallel branches.
Here are the deﬁnitions:

when α = c1?
when α = c2?
otherwise

fst(c1?→P1 [] c2?→P2) >= {c1?, c2?}
(c1?→P1 [] c2?→P2)/α >=&

P1
P2
⊥

We could take a general form c1 → P1 [] c2 → P2, where
both c1 and c2 can be either send or receive. However, for
the problems considered here, current deﬁnition is enough.
On the other hand, the multi-branch guarded choice c1?→
P1 [] . . . [] cm?→Pm is a necessity. With some extension on fst
and P/α, it is easy to include this extended structure into
our language. We omit the detailed deﬁnition here.

Now we present some laws relevant to guarded choices,

where = represents semantical equivalence, as in Fig.2:

c1?→P1 [] c2?→P2 = c2?→P2 [] c1?→P1

c1?→P1; Q [] c2?→P2; Q = (c1?→P1 [] c2?→P2); Q

c?→P1 [] c?→P2 = c?; (P1 (cid:117) P2)

We assume that [] has the same priority as (cid:117), thus has
less grouping power than the sequential composition. We
will still use [[·]] for the semantics of both Chor and the role
language. It causes no confusion.

WWW 2007 / Track: Web ServicesSession: Orchestration and Choreography9785.1.2 Projection

Now we consider a projection dproj for the extended Chor,

i

which will take care of the dominant marks on choices.

Suppose

A1 (cid:117) A2 is a structure in a choreography with n
roles. For each number j (cid:54)= i, we should introduce two fresh
A1 (cid:117) A2 on
channels, namely c(cid:48)
role Rj (j (cid:54)= i) takes the form of a guarded choice:

j . The projection of

j and c(cid:48)(cid:48)

i

i

dproj(

j?→dproj(A1, j) [] c
j ?→dproj(A2, j)
(cid:48)(cid:48)
(cid:48)
For role Ri, the projection produces an ordinary choice:

A1 (cid:117) A2, j) >= c
A1 (cid:117) A2, i) >= γ1; dproj(A1, i)(cid:117) γ2; dproj(A2, i)

γ2 = (cid:107)j∈i..n∧j(cid:54)=i c(cid:48)(cid:48)
j !

γ1 = (cid:107)j∈i..n∧j(cid:54)=i c(cid:48)
j!

dproj(

where

i

As a result, when the execution of the roles arrive at their
versions of the choice structure, role Ri makes the real choice,
and notiﬁes all the other roles which branch it selects. Thus,
those roles will take the same branch in their versions of the
choice consistently.

These projection rules involve consistent selection of the
new channel names, thus can not be deﬁned separately.
However, the rules above are accurate enough, and can be
implemented straightforwardly. The rules of dproj for the
basic activities and other structures take the same form as
what for nproj (Fig.4). We do not rewrite them again.

Example 8. Now consider the customer-seller choreog-

raphy in Exam.7. Applying dproj for each role, we have:

dproj(C9, 2) = c1[1,2]?; a2

1; c2[2,1]!;
(c9[1,2]?→c5[1,2]?; a2
1; c4[3,1]!;

dproj(C9, 3) = c3[1,3]?; a3

2; c6[2,1]! [] c10[1,2]?→skip)

(c11[1,3]?→skip [] c12[1,3]?→c7[1,3]?; a3

2; c8[3,1]!)

dproj(C9, 1) = c1[1,2]?; a2

1; c2[1,2]?; a2
1;

( (c9[1,2]! (cid:107) c11[1,3]!); c5[1,2]!; c6[1,2]?
(cid:117)(c10[1,2]! (cid:107) c12[1,3]!); c7[1,3]!; c8[1,2]?)

We list the process for R1 as the last one only for making
the presentation clearer. When R1 takes the ﬁrst branch
in the choice, R2 and R3 will receive a notiﬁcation from
channels c9[1,2] and c11[1,3] respectively. Then R3 will end
immediately, while R2 going on its work further. If R1 takes
the other branch, things will be reversed.

Now we consider an interesting modiﬁcation, to see what
happens if we make R2 the dominator of the choice. We call
this modiﬁcation C(cid:48)

9, and have the following results:

dproj(C(cid:48)

dproj(C(cid:48)

9, 1) = c1[1,2]?; a2

1; c2[1,2]?; a2
1;

( c9[2,1]?→c5[1,2]!; c6[1,2]?
[] c10[2,1]?→c7[1,3]!; c8[1,2]?)

9, 3) = c3[1,3]?; a3

1; c4[3,1]!;

( c11[2,3]?→skip
[] c12[2,3]?→c7[1,3]?; a3

2; c8[3,1]!)

dproj(C(cid:48)

9, 2) = c1[1,2]?; a2

1; c2[2,1]!;

( (c9[2,1]! (cid:107) c11[2,3]!); c5[1,2]?; a2
(cid:117)(c10[2,1]! (cid:107) c12[2,3]!)→skip)

2; c6[2,1]!

Although this implementation may be thought unfair because
R2 might tend to make the choice self-beneﬁcially, the im-
plementation works perfectly.

Please notice that both dproj(C9) and dproj(C(cid:48)

9) have the
intended behavior. In any run, the role processes will per-
form a course of activities described in the choreography,
with some auxiliary synchronization. Furthermore, they will
never run into deadlock.



5.1.3 Retrospect

We list some interesting issues related to dominated choices

here:

• The communications inserted by dproj are inevitable
for obtaining a consistent implementation. This kind
of synchronization is rather tedious if written by hand.
However, they can be generated automatically as shown.
This beneﬁts choreography designers.

• The communications inserted by dproj serve only for
synchronization. They are not substantial in the sense
they do not imply any real work. After ﬁltering them

out with  acts(C), we obtain the original trace set.

Thus, what we achieve is an equation similar to (4).

• From the [[

i

j

A(cid:117) A]] = [[

A(cid:117) A]] and an equation similar
to (4), we know that with any set of the designations
of dominant roles for each choice in the choreography,
the implementation obtained will be equivalent on an
abstract level, (i.e. the choreography level).
In this
case, choreography designers can choose any role as
the dominator for a choice, thus they can choose the
most reasonable one. The projection will take care of
all details of the implementation. A formal proof of
such a theorem is an aspect of our ongoing work.

• The projection rules given are for the most general
cases. We have many opportunities to reduce the un-
necessary communications for a more eﬃcient imple-
mentation. This can be seen as optimization, and is
an interesting future work.

Thinking about the problem related to the choice struc-
A(cid:117) A
ture further, we can ﬁnd that the dominated choice
is not a necessity theoretically.
In fact, we can make an
arbitrary choreography C “implementable” by randomly se-
lecting one role as the dominator for each choice in C, and
use the technique presented above to produce the role pro-
cesses. The result will work ﬁne and is deadlock-free.

i

However, it makes a real sense for the choreography de-
signer to determine the dominant roles, because the random
selection might produce a result that is unacceptable prac-
tically. As shown in the customer-seller example, taking
one seller as the dominant role of the choice, we can also
get a consistent implementation in the role process level.
But this designation is unacceptable practically, because the
dominant seller will make the choice in favor of her/himself
generally, resulting in an unfair implementation.

Anyway, dominant role is the most important concept in
the implementation, no matter whether explicitly speciﬁed
or randomly selected.
5.2 Dominated Loop

One important weakness of the framework developed yet
is that the choreographies can only have behavior with ﬁnite
traces, because there is no iterative or recursive structure in
the languages. Now we extend Chor further to deal with

WWW 2007 / Track: Web ServicesSession: Orchestration and Choreography979this problem. With the help of the concept dominant role,
we have a clear approach already.

5.2.1 Language Extensions
People usually use ∗P to denote an abstract loop, which
causes its body P to execute zero of more times. Theoreti-
cally, ∗P is in fact a choice with inﬁnite branches
∗P = skip(cid:117) P (cid:117)(P ; P )(cid:117)(P ; P ; P )(cid:117) . . .

Thus we can apply the same technique for choices to intro-
duce loop structures into our languages. Because all roles
should go consistently on either iterating further or exiting,
we need a dominant role to make the decision and notify the
others, to enforce them going always the same way.

We introduce a new structure dominated loop into Chor,

with the syntax:

A : : = . . .| i∗ A

It means that activity A will be executed zero or more times,
and Ri is the dominant role of this loop who decides if the
next iteration is necessary.

To deﬁne the semantics of

operator (cid:104)·(cid:105)∗ on traces. For any trace t, we have:

i∗ A, we introduce the star

where  is the set of natural numbers. We lift the star
operator to trace sets:

t∗ >=5i∈{ti}

t0 >= (cid:104)(cid:105)

Now we can deﬁne the semantics of a loop:

For role Ri, we have:

Here are the semantical rules for the simple loop:

∗P

(cid:104)(cid:105)−→ 

∗ P

(cid:104)(cid:105)−→ P ;∗P

For the dominated loop, we need not to deﬁne new rules,
but only to extend the deﬁnition of fst and P/α, as what we
did for the guarded choice. Here are the relevant deﬁnitions:

fst(∗P ) >= ∅
fst(c1? []∗ c2?→P ) >= {c1?, c2?}
(c1? []∗ c2?→P )/α >=&

when α = c1?
when α = c2?


P
⊥ otherwise

We assume that ∗ has the highest priority too, and []∗ has
the same priority as (cid:117) and (cid:107), thus has less grouping power
than the sequential composition.

5.2.2 Projection

Now we consider the part of dproj related to dominated
i∗
loops. Suppose C is a choreography with n roles including
A as a part. When this dominated loop is projected into the
role language, there will be an ordinary loop in the process
corresponding to Ri, and a dominated loop in each of the
rest role processes.
For each role Rj where j (cid:54)= i, we need to introduce two
fresh channels c(cid:48)

j and c(cid:48)(cid:48)

dproj(

dproj(

j ? []∗ c
(cid:48)(cid:48)

j , with the projection rule:
j?→dproj(A, j)
(cid:48)

i∗ A, j) >= c
i∗ A, i) >= ∗(γ1; dproj(A, i)); γ2

γ2 = (cid:107)j∈i..n∧j(cid:54)=i c(cid:48)(cid:48)
j !

where we have also

γ1 = (cid:107)j∈i..n∧j(cid:54)=i c(cid:48)
j!
Let us see an example:

Example 9. Now consider an extension of the scenario
described in Exam.7. Suppose in this time, the customer
wants to buy a number of products from the two sellers:

C10 =

1∗ C9

There is a simple dominated loop, where each separate trade
is described by choreography C9. For implementation, we
project C10 to the three roles:
dproj(C10, 2) = c13? []∗ c14?→dproj(C9, 2)
dproj(C10, 3) = c15? []∗ c16?→dproj(C9, 3)
dproj(C10, 1) = ∗((c14! (cid:107) c16!); dproj(C9, 1)); (c13! (cid:107) c15!)
The results of projecting C9 have been given in Exam.8, and
are omitted here. It is easy to verify that the parallel compo-
sition of these three processes shows the intended behavior.
We can also designate a seller, e.g., R2, as the dominant
role of the loop, and also as the dominator of the choice
embedded in the loop:

(cid:48)
10 =

C

2∗ C

(cid:48)
9

In this case, we have
dproj(C(cid:48)
dproj(C(cid:48)
dproj(C(cid:48)

10, 1) = c13? []∗ c14?→dproj(C(cid:48)
10, 3) = c15? []∗ c16?→dproj(C(cid:48)
10, 2) = ∗((c14! (cid:107) c16!); dproj(C9, 2)); (c13! (cid:107) c15!)

9, 1)
9, 3)

tn+1 >= tn = t
T ∗ >=5t∈T t∗
i∗ A]] >= [[A]]

∗

[[

We assume that ∗ has the highest priority. Thus, it applies
only to the minimal structure after it. Here are some laws
for the loop structure:

i∗ A
i∗ (A2; A1); A2

i∗ A = skip(cid:117) A;
i∗ (A1; A2) = skip(cid:117) A1;
skip(cid:117) i∗ A =
A(cid:117) i∗ A =
i∗ A =

i∗ A
i∗ A
j∗ A

The last law holds even if i (cid:54)= j. Thus, the designation of
the dominant role is also a directive with no eﬀect on the
(globally-viewed) semantics of the choreography.

We need to introduce two new structures into the role lan-
guage, to express the behavior of the dominant and domi-
nated roles. The dominant role iterates on its own, while
the dominated role should continue or stop its iteration ac-
cording to the notiﬁcation from the dominator. We call the
structure for the dominated roles as dominated loop in the
role language, which is a kind of guarded command:

P : : = . . .|∗P | c1? []∗ c2?→P

The process ∗P repeats the behavior of P by zero or more
times. For the dominated loop c1? []∗ c2?→P , if a handshake
happens on c1, the loop terminates immediately; otherwise,
if a handshake happens on c2, then the loop waits for the
next handshake after the execution of P . The loop can be
seen as a kind of guarded loop proposed by Edsgar W. Di-
jsktra, with a breaking mechanism. Because it is not sym-
metric, we adopt a non-symmetric symbol []∗.

WWW 2007 / Track: Web ServicesSession: Orchestration and Choreography980Now seller R2 can sell as many products as she/he wants.
Although hard to accept, the implementation works ﬁne. 

All the discussions in Sec.5.1.3 are applicable to the
loops. Especially, we can also use ordinary loop structures
and let the projection to choose randomly a dominator for
each loop in the choreography, and make a viable imple-
mentation with the technique shown above. However, from
the practical viewpoint, taking the concept of dominant role
explicitly makes a real sense.

6. REMARKS

In this paper we present some preliminary results of an
eﬀort towards the theoretical foundation of the choreogra-
phy. Many related issues are not touched or only partially
developed. We discuss some of them in this section.

Implementation. WS-CDL document [9] deﬁnes a choreog-
raphy as a multi-participant contract from a global perspec-
tive. It does not deﬁne clearly the “correct” implementation
of a choreography, but proposes only the concept confor-
mance.
It says “each participant can then use the global
deﬁnition to build and test solutions that conform to it.
The global speciﬁcation is in turn realized by combination
of the local systems, on the basis of appropriate infrastruc-
ture support”. This leaves the deﬁnition of implementation
open, and creates confusion.

Some researchers take a global view where a choreography
is thought just a (business) process, and an implementation
is any of the processes which shows the behavior required
by the choreography. For example, N. Busi et al. [4] gave a
deﬁnition following this vein. On the other hand, we take
the role-based view or local view, and consider that a chore-
ography describes a (business) process implemented by a
set of roles. An implementation is a set of processes where
each one implements one of the roles in a clear way, and the
combination of them has the required behavior.

The fundamental dissimilitude of these two viewpoints is
whether the roles and activities described in the choreogra-
phy must have their reincarnations in any admitted imple-
mentation. The local view says that these details are really
important, but the global view says it is not the case.

We think that the deﬁnition of implementation based on
the global view is too loose. The extreme case is an im-
plementation with only one process, which executes all ac-
tivities of all roles in the choreography, and makes all the
communications as local assignments. The approach pro-
posed here takes the way of projection and local confor-
mance, where each role is a real process in any valid imple-
mentation which runs independently in parallel with other
processes corresponding to other roles. Thus, the projec-
tions is very important in the implementation, and should
be studied further. We also deﬁned and studied the concept
of local conformance in previous work [13].

Semantics. The semantics used for Chor and generally, for
choreographies, is also a topic to study. We take here all the
relative order between activities described in choreography
signiﬁcant, even if they appear in diﬀerent (and indepen-
dent) roles, thus distinguish choreographies such as

a1; a2

a2; a1

a1 (cid:107) a2

Is the distinction important in the choreography world? All
related work we read regards the relative speed of roles, but
without a discussion about its rationality. However, from
our view of point, this is questionable.

Although the semantics used here is useful in exploring
properties and problems of choreographies, it may not be
the best choice, because the intention here is to describe
collaborations between independent web services. Neglect-
ing the independency of roles, we may obtain some results
which are not important practically.

Furthermore, to ensure the relative order, we need to in-
sert many synchronizing actions (Sec.4.3) which may be
“unnecessary”, and produce a slow implementation. If we
do no care about the relative speed of diﬀerent roles, we
can get rid of Condition 1, and may obtain more eﬀective
implementations. Now we are looking for other reasonable
semantics that can reﬂect the situation better. We hope that
with the semantics, the correctness of our implementation
approach can be proved formally.

In fact, here we have a dilemma: if we allow roles to run
freely except observing the explicit synchronization written
in the choreography, the three choreographies listed above
will be semantically indistinguishable. This might bring con-
fusions to the choreography designers too.

Language. As shown in this paper, we are still in the early
stage of deﬁning a language for choreography. We propose
some novel structures for the choreography language and
the process language in this paper, based mainly on the
implementation view point. The most important concept is
dominant role. From our view, this concept must have its
position in any language designed for choreographies.

There are some other clues about the design of the lan-
guages. In our previous paper [13], we gave a simple example
which shows one weak point of the common structural ﬂow
structures for the description of choreography. Another ex-
ample is the controversial issues about the control structure
workunit of WS-CDL [3]. Aalst et al. listed some challenges
including deﬁning a “real” choreography language in their
paper [16]. It seems that lot work should be done before a
widely accepted result in this ﬁeld.

7. CONCLUSION

The rapid-developing web technology is creating an envi-
ronment where increasingly computation tasks are carried
out by multiple processes (services) residing over the Inter-
net. Due to the nature of web services, to guarantee the
correct interaction of independent, communicating services
become even more critical [14]. This is the motivation under
the development of WS-CDL [9] for specifying choreography,
i.e., the global observation of business protocol among par-
ticipants (roles). Because of these situations, a deep and
thorough understanding of the essence of choreography and
relevant problems is urgent and important.

N. Busi et al. formalized choreography and orchestration
using process algebra, with a global view on conformance [4]
(see Sec.6). J. Mendling and M. Hafner proposed a simple
projection from WS-CDL to BPEL [11] without a discus-
sion about its correctness. Another interesting reference is
the Pi4SOA project [1]. In our previous work, we deﬁned
formal models for choreography, and proposed and studied
the natural projection and Equation (1), in the context of
veriﬁcation [17] and implementation [13].

WWW 2007 / Track: Web ServicesSession: Orchestration and Choreography981As the work related to ours the most, Carbone, et al. [5]
studied a two-level paradigm for the description of commu-
nication behaviors, on the global message ﬂows and end-
point behavior levels. Three principles for well-structured
global description and a theory for projection were devel-
oped, with a condition and a framework for relating the
global description of communication-centric software to its
local correspondents. Fu et al. [6] proposed a framework for
modeling global behaviors of electronic services composed
by autonomous peers. The global protocol is speciﬁed with
B¨uchi automata. A trace semantics recording the sending
messages is given, while projection of protocol, projection
of trace, and the semantics of composed peers are deﬁned.
The Sequencing Constraints language of the SSDL protocol
framework [15] pays attentions on the description of pro-
tocols for multiparty collaboration using message-oriented
programming abstractions. Li and He [10] discussed also
the relationship between choreography and orchestration.
Compared with our work, none of these work introduced
the concept of dominant role explicitly into the languages,
nor dominated choice and dominated loop structures.

In this paper, many basic concepts related to choreogra-
phy are studied. A small language Chor for choreography
and a simple process language for the roles from local view-
points are deﬁned, both with formal syntax and semantics.
Based on them, we discuss the concept of projections, which
map a given choreography into a set of role processes. A spe-
cial mapping named natural projection is discussed in detail.
With this projection, we deﬁne a level of well-formedness,
and propose two structural conditions. We discuss also a
projection which can remedy the sequential order problem
of choreographies.

The most important contribution of this paper is recogni-
tion of the concept dominant role which is critical in the im-
plementation of any choice or iteration structures in chore-
ographies. We suggest to take dominant role as a language-
level concept, and attach it to each choice and loop struc-
tures. With this concept, choreography designers can ex-
press their desire clearer. And we can have also a clearer
model for the implementation of choreographies.

Based on the concept dominant role, we extend our lan-
guages with some novel language structures related to dom-
inant roles, including dominated choice and dominated loop
structures on both choreography and role process levels. We
propose a projection, which is an extension of the natural
projection with rules about dominated choices and domi-
nated loops. There are diﬀerent rules for the dominant role
and dominated roles. As a result, the parallel composition
of the generated role processes will be an implementation
of the choreography. We show that the selection of the
dominant role for each choice or loop has no eﬀect on the
choreography-level semantics, but only on the implementa-
tion. Thus, the choreography designer can make their se-
lection as desired, and the projection will always generate a
correct implementation, where all necessary actions to syn-
chronize the processes are generated automatically.

We discuss some additional problems related to choreog-
raphy in the paper, including the local viewpoint about the
implementation vs. the global one, the rationality of the se-
mantics, etc. A number of examples are presented in some
sections to help the readers get better understanding of the
properties of choreographies, and of the interesting phenom-
ena appeared in this ﬁeld.

8. ACKNOWLEDGMENTS

The authors would like to thank Shengchao Qin and Xue-

shan Feng for their helpful comments.

9. REFERENCES
[1] Pi4SOA. http://www.pi4soa.org/.
[2] T. Andrews, F. Curbera, H. Dholakia, et al. Business

Process Execution Language for Web Services,
version 1.1, 2003.5. http://ifr.sap.com/bpel4ws/.

[3] A. Barros, M. Dumas, and P. Oaks. A Critical

Overview of the Web Services Choreography
Description Language. www.bptrends.com, 2005.

[4] N. Busi, R. Gorrieri, C. Guidi, et al. Choreography

and orchestration conformance for system design. In
Coordination 2006, LNCS 4038. Springer, 2006.

[5] M. Carbone, K. Honda, and N. Yoshida. Structured

global programming for communication behaviour.
http://www.pi4tech.com/xwiki/bin/view/
research/papers, 2006.

[6] X. Fu, T. Bultan, and J. Su. Conversation protocols:

A formalism for speciﬁcation and veriﬁcation of
reactive electronic services. In Proceedings of CIAA
2003, LNCS 2759, pages 188–200. Springer, 2003.

[7] C. A. R. Hoare. Communicating Sequential Processes.

Prentice Hall, 1985.

[8] N. Kavantzas. Aggregating web services:

Choreography and WS-CDL. Technical report, Oracle
Corporation, 2004.

[9] N. Kavantzas, D. Burdett, G. Ritzinger, et al. Web

Services Choreography Description Language,
version 1.0, 2005. http:
//www.w3.org/TR/2005/CR-ws-cdl-10-20051109/.

[10] J. Li and J. He. Conformance validation between

choreography and orchestration. Software Eng. Inst.,
East China Normal University, manuscript, 2006.

[11] J. Mendling and M. Hafner. From inter-organizational

workﬂows to process execution: Generating BPEL
from WS-CDL. In OTM 2005, LNCS 3762. Springer,
2005.

[12] R. Milner. Communication and Concurrency. Prentice

Hall, 1989.

[13] Z. Qiu, C. Cai, X. Zhao, and H. Yang. Exploring into

the essence of choreography. Preprint 2006-63 of
Institute of Mathematics, Peking University, http:
//www.math.pku.edu.cn:8000/en/preindex.php.

[14] G. Salaun, L. Bordeaux, and M. Schaerf. Describing
and reasoning on web services using process algebra.
In 2nd Inter. Conf. on Web Services. IEEE, 2004.

[15] J. W. Simon Woodman, Savas Parastatidis.

Sequencing Constraints SSDL Protocol Framework.
http://ssdl.org.

[16] W. van der Aalst, M. Dumas, A. ter Hofstede, et al.

Life after BPEL? In WS-FM 2005, LNCS 3670.
Springer, 2005.

[17] X. Zhao, H. Yang, and Z. Qiu. Towards the formal
model and veriﬁcation of web services choreography
description language. In WS-FM 2006, LNCS 4184.
Springer, 2006.

WWW 2007 / Track: Web ServicesSession: Orchestration and Choreography982