Priv´e: Anonymous Location-Based Queries in

Distributed Mobile Systems

Gabriel Ghinita

Dept. of Computer Science

National University of

Singapore

1Panos Kalnis

1Dept. of Computer Science

1National University of

Singapore

ghinitag@comp.nus.edu.sg

1kalnis@comp.nus.edu.sg

Spiros Skiadopoulos
Dept. of Computer Science
University of Peloponnese,

Greece

spiros@uop.gr

ABSTRACT
Nowadays, mobile users with global positioning devices can
access Location Based Services (LBS) and query about points
of interest in their proximity. For such applications to suc-
ceed, privacy and conﬁdentiality are essential. Encryption
alone is not adequate; although it safeguards the system
against eavesdroppers, the queries themselves may disclose
the location and identity of the user. Recently, there have
been proposed centralized architectures based on K-anonymi-
ty, which utilize an intermediate anonymizer between the
mobile users and the LBS. However, the anonymizer must
be updated continuously with the current locations of all
users. Moreover, the complete knowledge of the entire sys-
tem poses a security threat, if the anonymizer is compro-
mised.

In this paper we address two issues: (i) We show that
existing approaches may fail to provide spatial anonymity
for some distributions of user locations and describe a novel
technique which solves this problem. (ii) We propose Priv´e,
a decentralized architecture for preserving the anonymity
of users issuing spatial queries to LBS. Mobile users self-
organize into an overlay network with good fault tolerance
and load balancing properties. Priv´e avoids the bottleneck
caused by centralized techniques both in terms of anonymi-
zation and location updates. Moreover, the system state is
distributed in numerous users, rendering Priv´e resilient to
attacks. Extensive experimental studies suggest that Priv´e
is applicable to real-life scenarios with large populations of
mobile users.

Categories and Subject Descriptors
C.2.4 [Computer-Communication Networks]: Distri-
buted Systems—Distributed Applications; H.2.7 [Database
Management]: Database Administration—Security, inte-
grity, and protection

General Terms
Design, Experimentation, Security

Keywords
Privacy, Anonymity, Spatial Databases, Peer-to-Peer

Copyright is held by the International World Wide Web Conference Com-
mittee (IW3C2). Distribution of these papers is limited to classroom use,
and personal use by others.
WWW 2007, May 8–12, 2007, Banff, Alberta, Canada.
ACM 978-1-59593-654-7/07/0005.

1.

INTRODUCTION

The increased popularity of mobile communication de-
vices with embedded positioning capabilities (e.g., GPS) has
triggered the development of location-based applications.
General Motor’s OnStar navigation system, for example,
combines the vehicle’s position with real-time information
to avoid traﬃc jams, and automatically alerts the authori-
ties in case of an accident. More applications based on the
users’ location are expected to emerge with the arrival of
the latest gadgets (e.g., iPAQ hw6515, Mio A701) which
combine the functionality of a mobile phone, PDA and GPS
receiver.

Consider the following scenario: Bob uses his GPS en-
abled mobile phone to ask the query “Find the nearest hos-
pital to my present location”. This query can be answered
by a Location-Based Service (LBS) in a public server (e.g.,
Google Maps), which is not trusted. To preserve his privacy,
Bob does not contact the LBS directly. Instead he submits
his query via an intermediate trusted server which hides his
ID (services for anonymous web surﬁng are commonly avail-
able nowadays). However, the query still contains the exact
coordinates of Bob. One may reveal sensitive data by com-
bining the location with other publicly available informa-
tion. If, for instance, Bob uses his mobile phone within his
residence, the untrustworthy LBS may infer Bob’s identity
and speculate that he suﬀers from a medical condition.

In practice, users are reluctant to access a service that may
disclose sensitive information (e.g., corporate, military), or
their political/religious aﬃliations and alternative lifestyle.
To preserve privacy in LBS, recent research focused on adapt-
ing the well established K-anonymity technique to the spa-
tial domain. K-anonymity [19, 21] has been used in sta-
tistical databases as well as for publishing census, medical
and voting registration data. A dataset is said to be K-
anonymized, if each record is indistinguishable from at least
K−1 other records with respect to certain identifying at-
tributes.
In the LBS domain, a similar idea is to employ
spatial cloaking [9, 10] to conceal user locations: instead of
reporting the exact coordinates to the LBS, an Anonymizing
Spatial Region (K-ASR) is constructed, which encloses the
locations of K−1 additional users. Ref. [13, 17] extend this
method and also address processing of anonymized queries.
Most existing approaches utilize a centralized anonymizer:
a trusted server that acts as an intermediate tier between
the users and the LBS. All users subscribe to the anonymizer
and continuously report their location while they move. Each
user sends his query to the anonymizer, which constructs the

WWW 2007 / Track: Pervasive Web and MobilityMay 8-12, 2007. Banff, Alberta, Canada371appropriate K-ASR and contacts the LBS. The LBS com-
putes the answer based on the K-ASR, instead of the exact
user location; thus, the response of the LBS is a superset of
the answer. Finally, the anonymizer ﬁlters the result from
the LBS and returns the exact answer to the user.

Our work is motivated by the following shortcomings of
existing approaches: (i) The centralized anonymizer is a
bottleneck due to handling query requests, frequent updates
of user locations and result post-processing. Moreover, the
anonymizer is a single point of failure; the system cannot
function without it. (ii) The complete knowledge of the lo-
cations and queries of all users is a serious security threat, if
the anonymizer is compromised. Even if there is no attack,
the centralized anonymizer may be subject to governmental
control, and may be banned or forced to disclose sensitive
user information (similar to the legal case of the Napster
ﬁle-sharing service). (iii) Independent of the centralized ar-
chitecture, the hierarchical partitioning method for K-ASR
construction [10, 17] fails to provide anonymity under cer-
tain conditions (see Section 3).

We propose Priv´e, a distributed architecture for anony-
mous location-based queries, which addresses the problems
of existing systems. Our contributions are:
(i) We de-
velop a superior K-ASR construction mechanism based on
the Hilbert space-ﬁlling curve, that guarantees query ano-
nymity even if the attacker knows the locations of all users.
(ii) We introduce a distributed protocol used by mobile en-
tities to self-organize into a fault-tolerant overlay network.
The structure of the network resembles a distributed B+-tree
(each mobile user corresponds to a data point), with addi-
tional annotation to support eﬃciently the Hilbert-based K-
ASR construction. In Priv´e, K-ASRs are built in a decen-
tralized fashion, therefore the bottleneck of the centralized
server is avoided. Moreover, since the state of the system is
distributed, Priv´e is resilient to attacks. (iii) We also con-
duct an extensive experimental evaluation. The results con-
ﬁrm that Priv´e achieves eﬃcient anonymization and load
balancing with low maintenance overhead, while being fault-
tolerant. Therefore, it is scalable to large numbers of mobile
users.

The rest of the paper is organized as follows: Section 2
discusses the architecture of Priv´e. Section 3 introduces
spatial K-anonymity concepts and highlights the limitations
of existing solutions. In Section 4, we introduce our Hilbert-
based K-ASR construction mechanism and in Section 5 we
describe the distributed protocol of the overlay network.
Section 6 presents the experimental evaluation of our sys-
tem. A brief survey of the related work is included in Sec-
tion 7. Finally, Section 8 concludes the paper and discusses
directions for future work.

2. SYSTEM ARCHITECTURE

Fig. 1 depicts the architecture of Priv´e. We assume a
large number of users who carry mobile devices (e.g., mo-
bile phones, PDAs) with embedded positioning capabilities
(e.g., GPS). The devices have processing power and access
the network through a wireless protocol such as WiFi, GPRS
or 3G. Moreover, each device has a unique network identity
(e.g., IP address) and can establish point-to-point commu-
nication (e.g., TCP/IP sockets) with any other device in the
system through a base station (i.e., the two devices do not
need to be within communication range of each other). For
security reasons, all communication links are encrypted.

...

Pseudonym

services

Location-Based Service

Certification

Server

C4

u2

u0

C1

u1

u3

u4

u6

u5

C2

u8

u7

C3

u9

Figure 1: Architecture of Priv´e

In addition, we assume the existence of a trusted central
Certiﬁcation Server (CS), where users are registered. Prior
to entering the system, a user u must authenticate against
the CS and obtain a certiﬁcate. Users having a certiﬁcate
are trusted by all other users. Typically, a certiﬁcate is
valid for a few hours; it can be renewed by recontacting the
CS. Apart from the certiﬁcate, the CS returns to u the IP
addresses of some users who are currently in the system. u
uses this list to identify an entry point to the distributed
network. Note that the CS does not know the locations
of the users and does not participate in the anonymization
process. Therefore the workload of the CS is low (i.e., no
location updates); moreover it does not store any sensitive
information.

Each user corresponds to a peer. Peers are grouped into
clusters, according to their location. Within each cluster,
peers elect a cluster head, and the set of heads is grouped
recursively to form a tree. To achieve load balancing, cluster
heads are rotated in a round-robin manner. By deﬁnition,
cluster heads belong to multiple levels of the tree. In Fig. 1,
for instance, there is a two-level hierarchy, where users u2,
u3, u8 are the heads of cluster C1, C2 and C3, respectively;
also, u8 is the head of the upper layer cluster C4.

Typically users ask Range or Nearest-Neighbor (NN) que-
ries with respect to their location. For example, user u1 in
Fig. 2, may ask: “Find the nearest hospital to my present
location” (the answer is h2). Such queries reveal the exact
location of u1. To achieve anonymity, Priv´e requires users
to set a degree of anonymity K (note that K is based on
individual criteria and may vary among queries). In our ex-
ample, u1 chooses K = 3. Priv´e identiﬁes an appropriate
set of three users (i.e., u1, u2 and u3) in a distributed manner
and constructs the corresponding K-ASR (i.e., the rectan-
gle which encloses the three users). Next, the transformed
query is sent to LBS by u1. In order to hide his IP address,
u1 uses a pseudonym. To obtain a pseudonym, any existing
service for anonymous web surﬁng can be used1. Note that
the pseudonym service does not know the location of any
user. Moreover, the auxiliary users inside the K-ASR col-
laborate only to hide the location, but do not know the exact
query of u1; therefore, a single point of attack is avoided.

Priv´e can collaborate with various untrustworthy spatial
databases providing LBS. The only requirement for the LBS
is to support NN queries of regions (i.e., K-ASRs) as opposed
to points. Intuitively, the nearest neighbors of a region are
all the data objects inside the region plus the NN of every

1Since each user can access his preferred pseudonym service,
that service is not a bottleneck or a single point of failure.

WWW 2007 / Track: Pervasive Web and MobilityMay 8-12, 2007. Banff, Alberta, Canada372h5

h4

u1
u1

h3
h3

u3
u3
u2

h1 h2

h1 h2

h5

h4

u1

h3

u3
u2
K-ASR

Figure 2: Example: “Find the nearest hospital”
(users are shown as black dots).

point in the perimeter of the region. In our example (Fig. 2),
the NN of the K-ASR are {h2, h3, h4}; the set is ﬁltered
by u1 to obtain the actual answer h2. The cardinality of
the NN set (thus the processing and communication cost)
depends on the K-ASR; therefore we aim to minimize the
size of the K-ASR. Query processing at the LBS [11, 13,
17] is orthogonal to our work, but outside the scope of this
paper.

3. SPATIAL K-ANONYMITY
A user u who issues a location-based query is considered
to be K-anonymous if his identity is indistinguishable from
that of K−1 other users [10]. Formally:
Deﬁnition [Spatial K-anonymity] Let H be a set of K
distinct user entities with locations enclosed in an arbitrary
spatial region K-ASR. A user u ∈ H is said to possess K-
anonymity with respect to K-ASR if the probability of dis-
tinguishing2 u among the other users in H does not exceed
1/K. We refer to K as the required degree of anonymity.

Note that: (i) The deﬁnition assumes a snapshot of user
locations. Although Priv´e supports user mobility, K-ano-
nymity is undeﬁned across multiple snapshots. (ii) Spatial
K-anonymity does not depend on the size of the K-ASR. In
the extreme case, the K-ASR can degenerate to a point, if K
users are at the same location. In general, we prefer small
K-ASRs, in order to minimize the processing cost at the
LBS and the communication cost between the LBS and the
mobile user. Nevertheless, some applications impose a lower
bound on the size of the K-ASR [17]. In such a case, the K-
ASR can be trivially enlarged to satisfy the lower bound, by
symmetrical scaling in all directions. The same procedure
can also be used to avoid having users on the perimeter of
the K-ASR.
A na¨ıve K-ASR construction algorithm would choose a
random K-ASR. However, if the K-ASR is too small it may
contain fewer than K users, whereas if it is larger than nec-
essary, it will aﬀect the query cost. Constructing the K-ASR
in the neighborhood of the querying user u (e.g., using the
K nearest neighbors of u) is also inappropriate, because u
tends to be closest to the center of the K-ASR, thus easily
identiﬁed. Moreover, we cannot pick randomly K−1 auxil-
iary users and send K independent NN queries to the LBS,
because we would disclose the exact locations of K users;
this is undesirable in any anonymization method.

2Note that, we address location anonymity; attacks based
on background knowledge (e.g. user medical history) are
outside the scope of this work

Figure 3: K-ASR Reciprocity Example, K=5
We identify the following property that is suﬃcient for
a K-ASR construction technique in order to preserve user
privacy:
Deﬁnition [K-ASR Reciprocity] Consider a user uq is-
suing a query and its associated K-ASR Aq. Aq satisﬁes the
reciprocity property iﬀ there exists a set of users AS lying
in Aq such that (i) |AS| ≥ K, (ii) uq ∈ AS and (iii) every
user u ∈ AS lies in the K-ASRs of all other users in AS.

Fig. 3 shows an example with ten users. For K=5, the K-
ASR of users u1, u3, u4, u8, u10 is area A1 an the K-ASR of
users u2, u5, u6, u7, u9 is area A2. In this example, K-ASRs
of all users satisfy the reciprocity property. For instance,
for user u1, if we set AS = {u1, u3, u4, u8, u10}, we may
easily verify that AS satisﬁes all the requirements of the
reciprocity property.

Theorem 3.1. For a given snapshot of user locations,
and regardless of the query distribution among users, a K-
ASR construction technique guarantees spatial K-anonymity
if every generated K-ASR satisﬁes the reciprocity property.
Proof. We assume the worst case scenario, where an at-
tacker knows the exact location of all users in the system
(from an outside source). The attacker intercepts a set A of
K-ASRs associated to user queries.
Consider K-ASR Aq ∈ A. The attacker attempts to infer
the user uq that constructed Aq. Since Aq satisﬁes the reci-
procity property, there exists a set of users AS (lying in Aq)
such that (i) |AS| ≥ K, (ii) uq ∈ AS and (iii) every user
u ∈ AS lies in the K-ASRs of all other users in AS.
Moreover, since every K-ASR satisﬁes the reciprocity prop-
erty, it follows that when the attacker inspects any K-ASR
that includes uq, he will observe the same set of users AS.
Therefore, for all users u in AS, the probability Pu of being
the query issuer is:

Pu = Puq =

1|AS| ≤ 1K

Hence, the K-anonymity property is satisﬁed.

In view of this property, an optimal K-ASR construction
algorithm would partition the user population into K-ASRs
that possess the reciprocity property, such that the sizes
of the resulting K-ASRs are minimized. However, optimal
K-anonymity is an NP-Hard problem [16]. A number of on-
the-ﬂy K-ASR construction techniques have been proposed,
which attempt to achieve anonymity and reduce the K-ASR
size. In the following, we brieﬂy survey these solutions and
highlight their drawbacks.
3.1 Drawbacks of Existing Approaches

The anonymization technique of Ref. [10] indexes user lo-
cations in a PR-Quad-tree. When user u issues a query, the

WWW 2007 / Track: Pervasive Web and MobilityMay 8-12, 2007. Banff, Alberta, Canada373Figure 4: Limitations of QUADASR, K=3

Quad-tree is traversed until a quadrant which contains u
and less than K−1 other users is found. The parent of that
quadrant is returned as the K-ASR. A similar idea is used
in Ref. [17]. We refer to this technique as quadASR.

There are two drawbacks of quadASR: (i) It may fail
to achieve anonymity for some user distributions. Consider
the example of Fig. 4. Each user resides in his own quad-
rant identiﬁed by its lower-left and upper-right coordinates.
When any of the users u1, u2 or u3 issues a query with de-
gree of anonymity K=3, the quadrant q2 = ((0, 2), (2, 4))
which encloses u1...3 will be returned as the K-ASR. On the
other hand, when the isolated user u4 issues a query with
K=3, the larger quadrant q1 = ((0, 0), (4, 4)) is returned.
Note that if 1 < K ≤ 3, the only reason to return quadrant
q1 is that u4 issued a query. If an attacker knows the loca-
tions of the users in the area3, he will be able to pinpoint u4
as the query origin. This vulnerability is the result of the
fact that quadASR does not satisfy the reciprocity property
(i.e. u1..3 belong to the K-ASR associated to u4, but not the
other way around). (ii) A second drawback of quadASR is
that due to the non-uniform distribution of user locations,
the number of users enclosed by a K-ASR may grow much
larger than K (as for u4 in the previous example). This cor-
responds to larger spatial extent of the K-ASR, hence higher
processing cost.

Recently, a P2P system has been proposed that performs
distributed query anonymization for location-based queries;
we refer to it as cloakP2P [7]. cloakP2P uses a technique
similar to iterative deepening [23] to construct K-ASRs. The
query source initiates a K-ASR request by contacting all
peers within a given physical radius r, which is a ﬁxed sys-
tem parameter. If the set of peers S0 found in the initial
iteration is larger than K, the nearest K of them are cho-
sen to form the K-ASR; otherwise, the process continues,
and all peers in S0 issue a request to all peers within ra-
dius r. The process stops when K or more users have been
found. Intuitively, cloakP2P determines a query K-ASR
by ﬁnding the K −1 users nearest to the query source. Un-
fortunately, this simple heuristic fails to achieve anonymity
in many cases, since the query issuer tends to be near the
center of the K-ASR. In Section 6, we show experimentally
the vulnerability of cloakP2P.

None of the existing methods satisﬁes the reciprocity prop-
erty. Next, we describe our hilbASR algorithm, which over-
comes the aforementioned drawbacks.

4. THE hilbASR ALGORITHM

Our hilbASR algorithm guarantees that the probabil-
ity of identifying the query initiator is always bounded by
1/K, even if the attacker knows the locations of all users.
hilbASR uses the Hilbert [6] ordering to group users into
3By triangulation, phone companies can estimate the loca-
tion of a user within 50-300 meters, as required by the US
authorities (E911).

(cid:25)

(cid:24)

(cid:23)

(cid:20)

(cid:26)

(cid:27)

(cid:22)

(cid:21)

(cid:20)(cid:19)

(cid:28)

(cid:20)(cid:23)

(cid:20)(cid:24)

(cid:20)(cid:20)

(cid:20)(cid:21)

(cid:20)(cid:22)

(cid:20)(cid:25)

Figure 5: Hilbert Curve (Left: 4 × 4; Right: 8 × 8).

Figure 6: HILBASR, K=3 and K=4

buckets of K. The Hilbert space-ﬁlling curve is a continu-
ous fractal which maps each region of a multi-dimensional
space to an integer. In our case, the 2D coordinates of user
locations are mapped to a 1D value. With high probabil-
ity, if two points are close in the 2D space, they will also
be close in the Hilbert transformation. Fig. 5, for instance,
shows the curve for a 4× 4 and 8× 8 space partitioning; the
granularity of the regions can be arbitrary small.
To compute the K-ASR, hilbASR employs a partition-
ing scheme that supports user mobility and varying K with
minimal overhead. Intuitively, hilbASR computes and sorts
the Hilbert values of all users. Then, the algorithm concep-
tually groups the sorted Hilbert values into K-buckets that
contain K users, except from the last one which may con-
tain up to 2·K−1 users. Let us consider a user u asking a
query with anonymity degree K. To compute the K-ASR
of u, hilbASR computes the Hilbert value H(u) of u and
ﬁnds the K-bucket that H(u) belongs to. The minimum
bounding rectangle (MBR) of all the users in the K-bucket
corresponds to the K-ASR.

For example, in Fig. 6, we illustrate the locations of ten
users and their sorted Hilbert values. To compute the 3-ASR
of user u9, hilbASR ﬁrst ﬁnds the K-bucket which H(u9)
belongs to. In our case, this consists of four users, u8, u9,
u10 and u7. Then, hilbASR returns the MBR of these users.
Thus, the 3-ASR of user u9 is area A3. Similarly, the 4-ASR
of user u5 is area A4.
Note that for a given snapshot, hilbASR returns the same
K-ASR for all users in the K-bucket. This makes the K users
of the K-bucket indistinguishable from each other. Thus, the
probability of identifying the query initiator is bounded by
1/K.

Lemma 4.1. For a snapshot of user locations, hilbASR
guarantees query source anonymity against location-based
attacks.

Proof. hilbASR satisﬁes the reciprocity property, so
from Theorem 3.1 immediately results that hilbASR guar-
antees spatial K-anonymity.

In general, techniques that use ﬁxed buckets suﬀer from
lack of ﬂexibility in accommodating queries with varying K.
Our method overcomes this limitation by avoiding to ma-
terialize the K-buckets.
Instead, it maintains a balanced

WWW 2007 / Track: Pervasive Web and MobilityMay 8-12, 2007. Banff, Alberta, Canada374Figure 7: HILBASR with Annotated B+-tree

sorting tree, which indexes the Hilbert values of user loca-
tions. Let user u initiate a query with anonymization degree
Ku. Our algorithm performs a search for H(u) in the index
and computes ranku, which corresponds to the position of
H(u) in the in-order traversal of the tree. From ranku, we
calculate the start and end positions deﬁning the K-bucket
which includes H(u), as 4:

start = ranku − (ranku mod Ku)
end =

start + Ku − 1

(1)

To compute ranku eﬃciently, we use an annotated B+-
tree (similar to the aR-tree [18]), where each tree node stores
the number of leaf nodes in each of its subtrees. Consider
the example in Fig. 7. For each internal node entry e, we
store the number of leaf entries that are rooted at e; annota-
tion counters are shown in parenthesis. Assume we want to
determine a K-ASR for entry 37, with K=6. First, we com-
pute the rank of entry 37 (Fig. 7a): we follow the path in the
tree from root to the leaf that contains 37, and at each inter-
nal node we add to the rank value the sum of all counters in
the node situated at the left of the followed pointer. At the
leaf layer, we add to the rank the local rank value of key 37
in its leaf, and obtain rank 8 (ranks start from 0). Then, we
calculate the bucket delimiters using Eq. (1), and obtain the
interval [6..11]. Next (Fig. 7b), we perform a range search to
locate the entries with ranks [6..11]. Observe that this op-
eration uses the annotation, rather that the B+-tree keys.
Sub-ranges at each level are determined by splitting the ini-
tial range based on subtree sizes; the oﬀset for the recursive
call at entry e is determined as the initial start value minus
the sum of counters of all entries in the node preceding e.
The resulting K-ASR is highlighted in the diagram.
The data structure is scalable, since the complexity of
constructing the K-ASR is O(log N + K), whereas search,
insert and delete cost is O(log N ). Therefore, hilbASR is
applicable to large numbers of mobile users who update their
position frequently and have varying requirements for the
degree of anonymity K.

5. ANONYMIZATION IN Priv´e

In this section, we introduce Priv´e, a distributed proto-
col which supports decentralized query anonymization using
the hilbASR algorithm. Priv´e mimics the functionality of
a B+-tree in a distributed setting. Each mobile user u has

4For the last (incomplete) bucket, start and end are ad-
justed accordingly

Figure 8: Distributed Index Structure, α=2

an associated index entry consisting of an ID (e.g., IP ad-
dress), and the Hilbert value H(u) of his location as index
key. A node (leaf or internal) in the B+-tree corresponds
to a cluster of users, with size bounded between α and 3α,
where α is a ﬁxed system parameter. We use the terms clus-
ter and index node interchangeably. The maximum cluster
size is 3α, instead of the usual 2α for B+-trees, to prevent
cascading splits and merges (i.e., a split followed by a user
departure), which are costly in the distributed environment.
Every user belongs to a leaf level cluster (level 0), and
the contents of each cluster are disjoint (see Fig. 8). The
users of each cluster C elect a leader called head(C). The
head (marked with an asterisk) handles all index operations
on behalf of the users in the cluster. Cluster heads are re-
cursively grouped to form a tree; therefore, they belong to
multiple levels of the tree. We denote by C i
u, the level i
cluster which includes user u. In our example, user ua is the
head of cluster C 0
a at level 0, and also the head of clusters C 1
a
and C 2
a; therefore, it belongs to every level of the tree. There
is a single cluster at the top of the hierarchy, denoted as top.
The cluster head of top is denoted by root (ua in the exam-
ple). In our protocol description, we use remote procedure
call convention to specify interactions between users. The
notation u.f unc(params) denotes the invocation of subrou-
tine f unc with parameters params at user u.

Each cluster is associated with its state information. The
state of a leaf level cluster consists of an ordered list of (IP
address, H(u)) pairs (user coordinates can be derived from
the H(u) value). The state of an upper layer cluster with
m elements consists of a list of m user addresses, separated
by m − 1 key values used to direct the search; the process
is similar to a B+-tree, with the role of memory pointers
fulﬁlled by the IP addresses of users. Each internal node
entry is annotated with a counter (depicted in parenthesis)
representing the total number of users at the subtree under
the entry. Only the head needs to know the state of the
cluster. However, in our implementation, we replicate the
state on every user within the cluster, to improve fault tol-
erance (in Section 6, we discuss the tradeoﬀ between fault
tolerance and maintenance cost). The Priv´e hierarchy has
at most logα N layers, where N is the total number of users.
Since the cluster size is bounded and a user may belong to
at most one cluster at each level, there is an upper bound
of O(α logα N ) on the membership state stored at a user.
5.1
The index supports four operations: join, departure, re-
location and K-request (i.e., a request for a K-ASR with
anonymization degree K). We establish two performance
metrics for Priv´e: (i) latency: the number of hops an in-

Index Operations

WWW 2007 / Track: Pervasive Web and MobilityMay 8-12, 2007. Banff, Alberta, Canada375Figure 9: User Join and Relocation, α=2

Figure 11: K-request, α=2, K=6

u).Relocate(u, Hu,0)
u.Relocate(relocated user,H,l)

u.RelocateMyself() /*executed by moving user*/
determine new key value Hu = Hilbert(u.x, u.y)
call head(C0
if (H in indexed key range at level l )
if (l = 0)

add relocated user to leaf user list; return
else
let n be the next hop for H
call n.Relocate(relocated user, H,l − 1)

else

call head(parent(Cl

u)).Relocate(relocated user, H,l + 1)

Figure 10: User Relocation

dex operation requires to complete. The latency is equal to
the longest tree path followed as a result of the operation.
Multiple paths may be followed in parallel during an op-
eration. (ii) communication cost: the number of messages
generated by an index operation.
Join. User join corresponds to a B+-tree insertion opera-
tion. Newly joining users authenticate at the certiﬁcation
server and receive the address of a user already inside the
system. Without loss of generality, we assume that join-
ing users know the root, since the root can be reached from
any user in O(logα N ) cost. We stress that since we require
an index structure with annotation (in order to determine
the absolute ranks of users), all joins must occur through
the root. To avoid overloading the root, we devise a load-
balancing mechanism (Section 5.2). User join has O(logα N )
complexity in terms of latency and O(logα N + α) communi-
cation cost; the second term is for updating the cluster state
in all the users of the aﬀected cluster.
Consider user uy with Hilbert value H(uy) = 46 that joins
the index of Fig. 8: uy contacts ua (at the root level) who
forwards the join request to ub and updates ub’s annotation
counter in C 2
a to 14. ub then forwards the request to uh,
whose annotation counter in C 1
b is updated to 4. Fig. 9(a)
shows the join outcome. User join may trigger a cluster
split, handled similarly to a B+-tree node split; the head
initiating the split leads one of the resulting clusters, and
appoints a random initial cluster node to lead the other.
Departure (informed). User departure is similar to a
B+-tree deletion. The eﬀect of deletion must be propagated
to root to update the annotation counters. Deletion has
O(logα N ) latency and O(logα N + α) communication cost.
If the cluster size decreases below α, the head triggers a
merge operation with the neighbor leaf-level cluster that has
fewer members (to avoid a cascaded split). The head of the
resulting cluster can be any of the initial heads, except if one
of them (e.g., ua) is also head at the higher level. If so, ua
will be chosen as leader, to minimize membership changes.
Relocation. User mobility is treated as an entry update,
which in a B+-tree translates into a deletion and an inser-

tion. Since users are likely to change location often, we opti-
mize this process by performing local reassignment of users
to nearby clusters. Due to the good locality properties of
Hilbert ordering, the number of clusters involved in reloca-
tion is likely to be small. Annotation counter updates are
only performed by aﬀected clusters; this way, updates are
not propagated all the way to the root. The upper bound on
relocation latency is O(logα N ), but in most cases relocation
only involves a few clusters, at the low layers of the index.
The pseudocode for user relocation is given in Fig. 10.

Consider user us from Fig. 8 who relocates to a new po-
sition with Hilbert value 60. He forwards the request to
ua = head(C 0
s ). ua cannot keep us within the same leaf en-
try, since the new value is outside the interval [49..55]. Since
ua = head(C 1
a), with no additional message, ua decides that
us can be relocated to C 0
f , forwards the request to uf and
updates the annotation counters of ua and uf accordingly.
Fig. 9(b) illustrates the relocation outcome.
K-request. This operation corresponds to the hilbASR
algorithm described in Section 4. Consider the example in
Fig. 11, where user um issues a K-request with K=6. The
request follows the path: um → ud → ub → ua (solid arrows
in Fig. 11(a)). The root ua determines the K-bucket (i.e.,
start = 6, end = 11) and sends a K-ASR request to ub (dot-
ted arrows in Fig. 11(a)). ub sends in parallel requests for
partial K-ASRs with ranges [6..6], [7..9] and [10..11] to ud,
ue and uh, respectively. ub, which is the head of the lowest-
layer cluster that completely covers the K-bucket (shown
hashed in Fig. 11(b)) collects the partial K-ASRs, assem-
bles the ﬁnal query K-ASR and sends it back to the query
issuer on the reverse path of the request. Note that, the clus-
ter head that covers the K-bucket sustains the highest load
among all other users involved in the query. This potential
load imbalance issue is addressed in Section 5.2. A K-request
has O(logα N )+O(logα K) latency and O(logα N )+O(K/α)
communication cost. The pseudocode for K-request is shown
in Fig. 12. Once the K-ASR is constructed, the query is-
suer (i.e., um) can send the anonymized query to the LBS
through a pseudonym service, as explained in Section 2.
5.2 Fault Tolerance and Load Balancing

Priv´e implements a soft-state based mechanism to deal

with user failures or disconnections without notiﬁcation. Each
cluster leader sends periodically (i.e., every δt seconds) a
membership update message to all cluster members. The
message contains the membership list of the current clus-
ter C and that of parent(C). Cluster members respond to
these messages; if a cluster member does not respond to
two consecutive messages, it is considered disconnected and
removed from the cluster. The change is broadcast by the
cluster head to the remaining cluster members.

WWW 2007 / Track: Pervasive Web and MobilityMay 8-12, 2007. Banff, Alberta, Canada376u.K-request() /*executed by query source*/
determine key value Hu = Hilbert(u.x, u.y)
call head(C0

u.ForwardRequest(H, count, l)

u).ForwardRequest(Hu, 0, 0)
if (l = 0) count = rankH in leaf entry
else count+ = sum of annotation counters of keys < H
if (u is root)
compute start and end using eq (1)
K-ASR = root.f indM BR(start, end, root height)
else call head(C

u ).ForwardRequest(H, count, l + 1)

l+1

u.ﬁndMBR(start,end,l)
if (l = 0) /*leaf level*/

return MBR of members with local rank in [start,end]
ﬁnd set of next hops U for range [start,end]
M BR = ∅
(cid:1) ∈ U
for u
M BR = M BR ∪ u
(cid:1)
return M BR

.ﬁndMBR(startu(cid:1) , endu(cid:1) , l − 1)

Figure 12: K-request

If a non-head cluster member u does not receive a mem-
bership update from its head for a 2δt period, it initiates a
leader election process. Alternatively, when u attempts to
initiate a operation, such as query or relocation, but cannot
contact the cluster head for two consecutive attempts, it
triggers the leader election protocol without waiting for the
timer to expire. u checks the membership it had at the last
update, and chooses as leader (i.e., new head) the user with
the smallest identiﬁer. It then sends a transfer head message
to new head, which in turn sends a membership update mes-
sage to all cluster users and also contacts head(parent(C))
to notify the change in leadership. new head will replace
the old head in all layers where the latter was leader before
disconnection.

The hierarchical structure can cause signiﬁcant diﬀerences
between the load sustained by cluster heads and ordinary
cluster members, as well as among cluster heads at diﬀerent
layers of the hierarchy. To alleviate the inherent imbalance,
we propose a cluster head rotation mechanism, where users
take turns in fulﬁlling the cluster head role. Since the pro-
motion to cluster head translates into presence at a higher
layer of the hierarchy, the rotation also ensures that users
equally share the load at diﬀerent layers.

Rotation is triggered when a node reaches a certain load
threshold, denoted by load unit.
In wireless devices, the
communication cost is dominant. It is also important from
the user’s perspective, since mobile phone operators charge
by the amount of transferred data. Therefore, in Priv´e the
load is best represented by the number of messages sent and
received by the user.

When user u reaches one load unit, it triggers a head ro-
tation in all the clusters it currently heads, starting with its
highest layer. For each node along the path to its level 0
cluster, the member with the least load is appointed as new
head. Note that, since u stores the membership state about
all clusters it belongs to at diﬀerent layers, the appointment
of a new leader can be done directly by u, without the need
for a complex protocol or additional messages. Choosing the
cluster member with the lowest load prevents the newly ap-
pointed head to start a fresh rotation soon after promotion.
Fig. 13 illustrates the rotation mechanism. For simplic-
ity, all clusters have size 2. Assume all queries originate at
user ud with K=4. After ua reaches one load unit, it hands
over the root role to ue (at layer 2) from the right-hand
subtree. Also, at layer 1, uc becomes the head and is au-
tomatically promoted to layer 2. Similarly, at layer 0, ub

Figure 13: Load Balancing Mechanism

becomes the head and is promoted to layer 1; the result is
shown in Fig. 13(b). Next, uc reaches its load unit, because
more requests pass through it (it must inject queries and col-
lect partial K-ASRs). uc triggers a rotation at level 1 and
appoints ub as cluster head (see Fig. 13(c)). Subsequently,
ub may be the next one to reach the load threshold, and start
a new rotation in the left subtree. Observe that at step (d),
the left subtree has already performed a complete rotation
round, whereas the right subtree has only performed one
change. Hence, our rotation mechanism alleviates hotspots
(an entire subtree shares the load generated by ud) and at
the same time provides a degree of fairness, not allowing a
localized hotspot to aﬀect a large partition of the index.

The granularity of load unit choice is important in prac-
tice, in order to achieve a good tradeoﬀ between load bal-
ancing and communication cost, since a rotation may incur
a number of messages as large as O(α logα N ). We further
discuss this issue in Section 6.

6. EXPERIMENTAL EVALUATION

To evaluate Priv´e, we have implemented an event-driven
packet level simulator in C++. Since we are mostly inter-
ested in the overlay-layer performance, we consider a full
mesh topology with lossless 500ms round-trip time links be-
tween any pair of users. Our workload consists of user lo-
cations and movement patterns, and is generated using the
Network-based Generator of Moving Objects [5], which mod-
els user movement on public road networks. We consider
user velocities ranging from 18 to 68km/h. We present our
results for a data set consisting of the San Francisco bay area
(Fig. 16(a)), with number of users N varying from 1000 to
10000. We vary the anonymization degree K from 10 to
160. We consider both uniform and Zipﬁan distributions of
queries over the set of users.
Anonymity Strength. In Section 4, we have proved that
hilbASR guarantees anonymity against location-based at-
tacks, under any query distribution. We illustrate this prop-
erty in comparison with cloakP2P[7] and quadASR[10].
We assume that an attacker knows (from an external source)
the locations of all users, and employs a simple strategy
which infers the query source as uc, the user who is nearest
to the center of the K-ASR. We consider a 10000 users sce-
nario in which 10000 random queries are issued. In Fig. 14
we plot the identiﬁcation success probability (i.e. of uc being
the query source), for various values of K. The dotted line
represents the value 1/ K, the ideal performance for an ano-
nymization algorithm. In the case of cloakP2P, for K=40,
the probability of uc being the query source is 10%, four
times the 1/K=2.5% maximum allowed bound. For larger
values of K, the situation gets worse, as the number of users
included in the K-ASR increases. The users are likely to
come uniformly from all directions; hence, uc is disclosed
as the query source. On the other hand, hilbASR achieves
the required anonymity degree K at all times. Due to its
poor anonymization strength, we omit cloakP2P from our
further discussion. quadASR has lower probability of iden-
tiﬁcation for this particular type of attack. However, this

WWW 2007 / Track: Pervasive Web and MobilityMay 8-12, 2007. Banff, Alberta, Canada377)
e
c
r
u
o
S
y
f
i
t
n
e
d
I
(
P

 0.2

 0.15

 0.1

 0.05

 0

1/K
HILBASR
CloakP2P
QUADASR

 20  40  60  80  100 120 140 160

K

Figure 14: Anonymity Strength

hilbASR
quadASR

Area

Area

 100K

 80K

 60K

 40K

 20K

 0

hilbASR
quadASR

 20  40  60  80 100 120 140 160

Κ

(a) Varying K, 10k users

 300K

 250K

 200K

 150K

 100K

 50K

 0

 1K 2K 3K 4K 5K 6K 7K 8K 9K 10K

(b) K=80, varying N

Ν

Figure 15: K-ASR area

does not mean that it provides stronger anonymization than
hilbASR: the ideal probability is given by the 1/K bound.
quadASR includes an excessively large number of users in
the K-ASR, yielding high query processing cost; further-
more, it is still vulnerable to attacks such as those described
in Section 3.1, while hilbASR provides anonymity guaran-
tees under all circumstances.
K-ASR Size.
In this experiment, we compare hilbASR
against quadASR in terms of spatial extent (i.e., area) of
the generated K-ASR. We consider a snapshot of user lo-
cations and generate a number of queries equal to the pop-
ulation size N . Each query is initiated by a random user.
Fig. 15(a) shows the results for varying K and 10K users.
hilbASR is better in all cases. In Fig. 15(b) we set K=80
and vary the number of users. The decrease in K-ASR size
with increasing N is explained by the higher user density in
the same dataspace (i.e., K users can be located in a smaller
region). hilbASR again outperforms quadASR in terms of
K-ASR extent. Recall that smaller K-ASR translates into
reduced execution cost at the LBS and communication cost
between the LBS and the user.
Note that quadASR has been proposed only for central-
ized anonymization. Still, the size of the resulting K-ASR
is independent of whether it is constructed in a central-
ized or distributed setting. Nevertheless, hilbASR outper-
forms quadASR in terms of both K-ASR size and anony-
mity strength (recall from Section 3.1 that quadASR may
fail for certain user distributions). The only other system
that considers anonymization in a decentralized setting is
cloakP2P, but we have shown that it fails to provide ano-
nymity by a large margin. Hence, hilbASR is the only
protocol that guarantees anonymity. Furthermore, it can
be deployed in decentralized environments, and outperforms
existing methods in terms of K-ASR size. We further investi-
gate the performance of Priv´e, which implements hilbASR
in a decentralized fashion.
Join and Departure. In a system with N users, we per-
form 0.1N random user joins, followed by 0.1N random user
departures. Fig. 16(b) shows the join latency measured as
hop count from the time a user issues a join request un-
til he receives a join response message from its leaf-level

head. We observe that the latency is lower than the theo-
retical 1 + logα N , as a user may appear in multiple levels
and can avoid sending redundant messages to himself. The
communication cost (i.e., total messages) per join and de-
parture operation (Fig. 16(c)) varies linearly with α, since
every join/departure translates into a membership update
broadcast message within one leaf-level cluster. Note the
role of α in the latency-cost tradeoﬀ: an increase of α de-
creases latency as logα N , but triggers a linear cost increase
in membership notiﬁcation. A larger α also increases the
cost of periodic cluster membership maintenance.
K-request. Fig. 16(d) and 16(e) show the K-request la-
tency and communication cost for varying α, where K=40.
Larger α decreases the latency as the height of the index
decreases. The communication cost also decreases, as fewer
leaf-level cluster heads need to be contacted to build the K-
ASR. However, α cannot grow very large from index mainte-
nance considerations. Fig. 16(f) and 16(g) show the latency
and communication cost variation with anonymization de-
gree K, α = 5. Latency is only marginally aﬀected by K
(the dominant factor in latency is logα N , since in practice
K(cid:5) N ), while the communication cost grows linearly with
K. The percentage of the user population involved in an-
swering a single K-request operation is shown in Fig. 16(h)
and 16(i). For small N values, at most 2% of all users are
needed to answer a K-request, while for larger N , less than
0.5% of the users are required.
Relocation. Priv´e addresses user mobility by using an
index update algorithm that attempts to resolve relocation
at the lower levels of the hierarchy, in order to reduce both
latency and communication cost. In our simulated scenario,
we consider 10000 users across 20 consecutive time frames,
with half of the indexed users moving at each time frame.
We consider three velocities: 68, 40 and 18km/h. Fig. 16(j)
and 16(k) show that relocation is eﬃciently handled:
for
the moderate α = 10 value, the relocation is done on aver-
age in 2.5 hops for fast-moving users and 1.5 hops for slow-
moving users. The dominant communication cost is that of
the membership change propagation; for α = 10 this cost
is roughly a quarter compared to the cost of an index dele-
tion followed by insertion for the 68km/h case, and 1/8 for
18km/h. Fig 16(l) shows the frequency of relocations com-
pleted at various levels of the hierarchy for a 6-level, α = 3,
10000 users system. Most relocations are solved at the low
levels of the hierarchy: for slow movement, 70% are solved at
the leaf level and 86% at levels 0 and 1; for fast movement,
32% of relocations are completed at the leaf level, 63% at
levels 0 and 1, and 86% at levels 0, 1 or 2.
Fault-tolerance. Starting with a system having correct
cluster membership, we fail simultaneously 10, 20 or 30%
of the nodes. We use maintenance timer values of 30 sec-
onds for refreshing cluster membership and 60 seconds for
purging a failed member. Fig. 16(m) shows the evolution of
membership state correctness over time (1 represents com-
pletely correct state). The system recovers to a correct state
within 3 purge cycles (138 sec) for 10% failure and 4 purge
cycles (197 sec) for 30% failure.
Load-balancing. We measure the load incurred by each
user for a 10000 users system, α = 5, K=80, load unit =
200 messages and a simulated time of 1 hour, during which
an average of 8 queries/user were generated. We consider
both uniform and skewed (Zipf 0.8) query source distribu-
tion. Fig. 16(n) shows the cumulative distribution function

WWW 2007 / Track: Pervasive Web and MobilityMay 8-12, 2007. Banff, Alberta, Canada378 7
 6
 5
 4
 3
 2
 1
 0

Latency

N=10000
N=1000
N=100

 5

 10
α

 15

 20

Cost

 50

 40

 30

 20

 10

 0

 14
 12
 10
 8
 6
 4
 2
 0

N=10000
N=1000
N=100

 5

 10
α

 15

 20

Latency

N=10000
N=1000
N=100

 5

 10
α

 15

 20

Cost

 35
 30
 25
 20
 15
 10
 5
 0

N=10000
N=1000
N=100

 5

 10
α

 15

 20

(a) San Francisco Bay

(b) Join Latency vs α

(c) Join/Leave Cost vs α

(d) Query Latency vs α

(e) Query Cost vs α

Latency

N=10000
N=3000
N=1000

 9
 8
 7
 6
 5
 4
 3
 2
 1
 0

Cost

N=10000
N=3000
N=1000

 45
 40
 35
 30
 25
 20
 15
 10
 5
 0

 20  40  60  80  100  120  140  160

(f) Query Latency vs K

Κ

 20  40  60  80  100 120 140 160

(g) Query Cost vs K

Κ

 20  40  60  80  100 120 140 160

(h) Percentage vs K

Κ

 20
 18
 16
 14
 12
 10
 8
 6
 4

Cost
68km/h
40km/h
18km/h

 5

 10
α

 15

 20

(k) Relocation Cost

 0.8
 0.7
 0.6
 0.5
 0.4
 0.3
 0.2
 0.1
 0

Frequency

68km/h
40km/h
18km/h

 0

 1

 2

 3

 4

 5

Level

(l) Relocation Level

Membership Correctness

10%
20%
30%

Nodes(%)

N=10000
N=3000
N=1000

 2

 1.5

 1

 0.5

 0

 1.1

 1

 0.9

 0.8

 0.7

 0.6

 1.6
 1.4
 1.2
 1
 0.8
 0.6
 0.4
 0.2
 0

 1

 0.8

 0.6

 0.4

 0.2

Nodes(%)

N=10000
N=3000
N=1000

 5

 10
α

 15

 20

 5.5
 5
 4.5
 4
 3.5
 3
 2.5
 2
 1.5
 1

Latency

68km/h
40km/h
18km/h

 5

 10
α

 15

 20

(i) Percentage vs α

(j) Relocation Latency

Load CDF

 350
 300
 250
 200
 150
 100
 50
 0

Absolute Load

Uniform
Zipf(0.8)

 0

 2K

 4K

Ν

 6K

 8K

 10K

 0

 50

 100

 150

 200

Time(sec)

 0

 0

No Rotation
Rotation-unif
Rotation-Zipf(0.8)
Ideal

 2K

 4K

Ν

 6K

 8K

 10K

(m) Failure Recovery

(n) Node Load CDF

(o) Absolute Node Load

Figure 16: Priv´e Experimental Evaluation

(CDF) of sorted user loads. The load is highly unbalanced
if no rotation is performed, with 10% of users sustaining
more than 80% of the load. With rotation, for uniform
query distribution, the load is close to the ideal one (i.e.,
diagonal line). For skewed query distribution, most of the
users share equal load, while part of the users (roughly 10%)
share a slightly higher load, as dictated by the fairness re-
quirement discussed in Section 5.2. This is illustrated better
in Fig. 16(o) which shows the absolute load of each user.

7. RELATED WORK

K-anonymity was ﬁrst discussed in relational databases
where published statistical data (e.g., census, medical) should
not be linked to speciﬁc persons. Samarati and Sweeney
[19, 21] proposed the following deﬁnition: A relation satis-
ﬁes K-anonymity if every tuple in the relation is indistin-
guishable from at least K−1 other tuples with respect to a
set of quasi-identiﬁer attributes. Quasi-identiﬁers are sets
of attributes (e.g., date of birth, gender, zip code) which
can be linked to publicly available data to uniquely iden-
tify individuals. Two techniques are used to transform a
relation to a K-anonymized one: suppression, where some
of the attributes or tuples are removed, and generalization,
which involves replacing speciﬁc values (e.g., phone num-
ber) with more general ones (e.g., only area code). Both
techniques result in information loss. Ref. [4] and Ref. [14]
discuss eﬃcient algorithms for anonymizing an entire rela-
tion while preserving as much information as possible. In
Ref. [22] the authors consider the case where each individ-

ual requires a diﬀerent degree K of anonymity, while Aggar-
wal [1] shows that anonymizing a high-dimensional relation
results to unacceptable loss of information due to the dimen-
sionality curse. Finally, Machanavajjhala et al. [15] propose
(cid:3)-diversity, an anonymization method which protects against
disclosure of sensitive attribute values.
K-anonymity has also been adopted in the LBS domain:
in Ref. [9, 10], the location of the user is concealed by con-
structing an Anonymizing Spatial Region (K-ASR) which
encloses the locations of the query source and K−1 addi-
tional users. However, their methods of K-ASR construc-
tion are ineﬃcient, and anonymization may fail for some
data distributions. Ref. [13, 17] extend further these ideas
and present a framework for the entire process of anonymi-
zation and query processing at the LBS. Nevertheless, the
aforementioned methods assume a centralized anonymizer,
which may constitute a bottleneck or a single point of at-
tack. Prior to our work, the only decentralized solution was
a P2P-based system, presented in Ref. [7]. However, that
system fails to achieve anonymity in many situations (see
Section 6).

Key and range search has been studied extensively in
distributed environments. Several structured Peer-to-Peer
systems (e.g, Chord [20]) support distributed key search
with O(log N ) complexity. The drawback of such systems is
that they cannot support eﬃciently node annotation. With-
out node annotation, the communication cost for satisfying
the reciprocity property (which guarantees K-anonymity) is
O(N ); this cost is too high for large scale systems (recall

WWW 2007 / Track: Pervasive Web and MobilityMay 8-12, 2007. Banff, Alberta, Canada379that Priv´e needs only O(logaN ) messages). Closer to our
work is the P-tree [8], which supports range queries by em-
bedding a B+-tree on top of an overlay network. No global
index is maintained; instead each node maintains its own
B+-tree-like structure. BATON [12] also addresses range
queries, by embedding a balanced tree onto an overlay net-
work. It uses additional cross-links to prevent hotspots, and
achieves O(log N ) complexity for search and maintenance.
Similar to Chord, these systems cannot support eﬃciently
node annotation.

Hierarchical clustering in distributed environments has
been an active research topic in recent years.
In Ref. [3],
a hierarchical-clustering routing protocol for wireless net-
works is presented. The NICE project [2] proposes a scal-
able application-layer multicast protocol, based on delivery
trees built on top of a hierarchically connected control topol-
ogy. Nodes participating in a multicast group are organized
into a multi-layer hierarchy of clusters with bounded size.
NICE trees obtain delays in the order of O(log N ), where
N is the size of the multicast group, and there is an up-
per bound of O(log N ) in terms of control state maintained
per node. Priv´e also uses hierarchical clustering of mobile
users, but the requirements of total ordering and annotation
impose particular challenges that have not been addressed
by existing research.

8. CONCLUSIONS

In this paper we introduced Priv´e, a distributed system
for query anonymization in LBS. In Priv´e, mobile users
who issue location-based queries organize themselves into
a hierarchical overlay network and anonymize queries in a
fully decentralized fashion. Priv´e supports our hilbASR
anonymization technique, which guarantees anonymity un-
der any user distribution. We show experimentally that our
system is eﬃcient, scalable, fault tolerant and achieves load
balancing.

LBS for mobile users are already a reality in some coun-
tries (e.g., Japan), where new mobile phones are equipped
with a positioning device, and high-speed wireless networks
are common. As such applications gain popularity, privacy
and conﬁdentiality concerns are expected to rise.
In the
future, we plan to address anonymity of continuous spatial
queries, and extend our algorithm to trajectories, as opposed
to points. We also plan to deploy Priv´e in infrastructure-
less environments, such as ad-hoc wireless networks (Wi-Fi,
Bluetooth), without point-to-point links between all users.

9. REFERENCES
[1] C. C. Aggarwal. On k-Anonymity and the Curse of
Dimensionality. In Proc. of VLDB, pages 901–909,
2005.

[2] S. Banerjee, B. Bhattacharjee, and C. Kommareddy.

Scalable application layer multicast. In Proc. of ACM
SIGCOMM, pages 205–217, 2002.

[3] S. Banerjee and S. Khuller. A Clustering Scheme for

Hierarchical Control in Wireless Networks. In Proc. of
IEEE INFOCOM, pages 1028–1037, 2001.

[4] R. Bayardo and R. Agrawal. Data Privacy through
Optimal k-Anonymization. In Proc. of ICDE, pages
217–228, 2005.

[5] T. Brinkhoﬀ. A Framework for Generating

Network-Based Moving Objects. Geoinformatica,
6(2):153–180, 2002.

[6] A. R. Butz. Alternative Algorithm for Hilbert’s

Space-Filling Curve. IEEE Trans. on Computers,
20(4):424–426, 1971.

[7] C.-Y. Chow, M. F. Mokbel, and X. Liu. A

Peer-to-Peer Spatial Cloaking Algorithm for
Anonymous Location-based Services. In In Proc. of
ACM GIS, pages 171–178, 2006.

[8] A. Crainiceanu, P. Linga, J. Gehrke, and

J. Shanmugasundaram. Querying P2P Networks using
P-trees. In Proc. of WebDB, pages 25–30, 2004.

[9] B. Gedik and L. Liu. Location Privacy in Mobile

Systems: A Personalized Anonymization Model. In
Proc. of ICDCS, pages 620–629, 2005.

[10] M. Gruteser and D. Grunwald. Anonymous Usage of

Location-Based Services Through Spatial and
Temporal Cloaking. In Proc. of USENIX MobiSys,
pages 31–42, 2003.

[11] H. Hu and D. L. Lee. Range Nearest-Neighbor Query.

IEEE TKDE, 18(1):78–91, 2006.

[12] H. V. Jagadish, B. C. Ooi, and Q. H. Vu. BATON: a

Balanced Tree Structure for P2P networks. In Proc. of
VLDB, pages 661–672, 2005.

[13] P. Kalnis, G. Ghinita, K. Mouratidis, and

D. Papadias. Preventing Location-Based Identity
Inference in Anonymous Spatial Queries. Technical
Report TRB6/06, National Univ. of Singapore, 2006.

[14] K. LeFevre, D. J. DeWitt, and R. Ramakrishnan.
Incognito: Eﬃcient Full-Domain K-Anonymity. In
Proc. of ACM SIGMOD, pages 49–60, 2005.

[15] A. Machanavajjhala, J. Gehrke, D. Kifer, and

M. Venkitasubramaniam. l-Diversity: Privacy Beyond
k-Anonymity. In Proc. of ICDE, pages 24–35, 2006.

[16] A. Meyerson and R. Williams. On the Complexity of

Optimal K-anonymity. In Proc. of ACM PODS, pages
223–228, 2004.

[17] M. F. Mokbel, C. Y. Chow, and W. G. Aref. The New

Casper: Query Processing for Location Services
without Compromising Privacy. In Proc. of VLDB,
pages 763–774, 2006.

[18] D. Papadias, P. Kalnis, J. Zhang, and Y. Tao.

Eﬃcient OLAP Operations in Spatial Data
Warehouses. In Proc. of SSTD, pages 443–459, 2001.

[19] P. Samarati. Protecting Respondents’ Identities in
Microdata Release. IEEE TKDE, 13(6):1010–1027,
2001.

[20] I. Stoica, R. Morris, D. Liben-Nowell, D. R. Karger,

M. F. Kaashoek, F. Dabek, and H. Balakrishnan.
Chord: a Scalable Peer-to-Peer Lookup Protocol for
Internet Applications. IEEE/ACM Transactions on
Networking, 11(1):17–32, 2003.

[21] L. Sweeney. k-Anonymity: A Model for Protecting

Privacy. Int. J. of Uncertainty, Fuzziness and
Knowledge-Based Systems, 10(5):557–570, 2002.

[22] Y. Tao and X. Xiao. Personalized Privacy

Preservation. In Proc. of ACM SIGMOD, pages
229–240, 2006.

[23] B. Yang and H. Garcia-Molina. Improving Search in

Peer-to-Peer Networks. In Proc. of ICDCS, pages
5–14, 2002.

WWW 2007 / Track: Pervasive Web and MobilityMay 8-12, 2007. Banff, Alberta, Canada380