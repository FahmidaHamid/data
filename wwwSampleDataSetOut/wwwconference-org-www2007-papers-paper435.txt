From SPARQL to Rules (and back) ∗

Axel Polleres

Universidad Rey Juan Carlos

Tulip´an s/n, 28933 M´ostoles, Madrid, Spain

axel@polleres.net

ABSTRACT
As the data and ontology layers of the Semantic Web stack
have achieved a certain level of maturity in standard recom-
mendations such as RDF and OWL, the current focus lies
on two related aspects. On the one hand, the deﬁnition of
a suitable query language for RDF, SPARQL, is close to
recommendation status within the W3C. The establishment
of the rules layer on top of the existing stack on the other
hand marks the next step to be taken, where languages with
their roots in Logic Programming and Deductive Databases
are receiving considerable attention. The purpose of this
paper is threefold. First, we discuss the formal semantics
of SPARQL extending recent results in several ways. Sec-
ond, we provide translations from SPARQL to Datalog with
negation as failure. Third, we propose some useful and easy
to implement extensions of SPARQL, based on this trans-
lation. As it turns out, the combination serves for direct
implementations of SPARQL on top of existing rules en-
gines as well as a basis for more general rules and query
languages on top of RDF.

Categories and Subject Descriptors
H.2.3 [Languages]: Query Languages; H.3.5 [Online In-
formation Services]: Web-based services

General Terms
Languages, Standardization

Keywords
SPARQL, Datalog, Rules

1.

INTRODUCTION

After the data and ontology layers of the Semantic Web
stack have achieved a certain level of maturity in standard
recommendations such as RDF and OWL, the query and
the rules layers seem to be the next building-blocks to be
ﬁnalized. For the ﬁrst part, SPARQL [18], W3C’s pro-
posed query language, seems to be close to recommendation,
though the Data Access working group is still struggling
∗An extended technical report of this article is available at
http://www.polleres.net/publications/.

Copyright is held by the International World Wide Web Conference Com-
mittee (IW3C2). Distribution of these papers is limited to classroom use,
and personal use by others.
WWW 2007, May 8–12, 2007, Banff, Alberta, Canada.
ACM 978-1-59593-654-7/07/0005.

with deﬁning aspects such as a formal semantics or layer-
ing on top of OWL and RDFS. As for the second part, the
RIF working group 1, who is responsible for the rules layer,
is just producing ﬁrst concrete results. Besides aspects like
business rules exchange or reactive rules, deductive rules lan-
guages on top of RDF and OWL are of special interest to
the RIF group. One such deductive rules language is Dat-
alog, which has been successfully applied in areas such as
deductive databases and thus might be viewed as a query
language itself. Let us brieﬂy recap our starting points:

Datalog and SQL. Analogies between Datalog and rela-
tional query languages such as SQL are well-known and -
studied. Both formalisms cover UCQ (unions of conjunctive
queries), where Datalog adds recursion, particularly unre-
stricted recursion involving nonmonotonic negation (aka un-
stratiﬁed negation as failure). Still, SQL is often viewed to
be more powerful in several respects. On the one hand, the
lack of recursion has been partly solved in the standard’s
1999 version [20]. On the other hand, aggregates or ex-
ternal function calls are missing in pure Datalog. However,
also developments on the Datalog side are evolving and with
recent extensions of Datalog towards Answer Set Program-
ming (ASP) – a logic programming paradigm extending and
building on top of Datalog – lots of these issues have been
solved, for instance by deﬁning a declarative semantics for
aggregates [9], external predicates [8].

The Semantic Web rules layer. Remarkably, logic pro-
gramming dialects such as Datalog with nonmonotonic nega-
tion which are covered by Answer Set Programming are of-
ten viewed as a natural basis for the Semantic Web rules
layer [7]. Current ASP systems oﬀer extensions for retriev-
ing RDF data and querying OWL knowledge bases from the
Web [8]. Particular concerns in the Semantic Web com-
munity exist with respect to adding rules including non-
monotonic negation [3] which involve a form of closed world
reasoning on top of RDF and OWL which both adopt an
open world assumption. Recent proposals for solving this
issue suggest a “safe” use of negation as failure over ﬁnite
contexts only for the Web, also called scoped negation [17].

The Semantic Web query layer – SPARQL. Since we
base our considerations in this paper on the assumption that
similar correspondences as between SQL and Datalog can be
established for SPARQL, we have to observe that SPARQL
inherits a lot from SQL, but there also remain substantial
diﬀerences: On the one hand, SPARQL does not deal with
nested queries or recursion, a detail which is indeed surpris-

1http://www.w3.org/2005/rules/wg

WWW 2007 / Track: Semantic WebSession: Query Languages and DBs787ing by the fact that SPARQL is a graph query language
on RDF where, typical recursive queries such as transitive
closure of a property might seem very useful. Likewise, ag-
gregation (such as count, average, etc.) of object values in
RDF triples which might appear useful have not yet been
included in the current standard. On the other hand, sub-
tleties like blank nodes (aka bNodes), or optional graph pat-
terns, which are similar but (as we will see) diﬀerent to outer
joins in SQL or relational algebra, are not straightforwardly
translatable to Datalog.

The goal of this paper is to shed light on the actual re-
lation between declarative rules languages such as Datalog
and SPARQL, and by this also provide valuable input for
the currently ongoing discussions on the Semantic Web rules
layer, in particular its integration with SPARQL, taking the
likely direction into account that LP style rules languages
will play a signiﬁcant role in this context.

Although the SPARQL speciﬁcation does not seem 100%
stable at the current point, just having taken a step back
from candidate recommendation to working draft, we think
that it is not too early for this exercise, as we will gain valu-
able insights and positive side eﬀects by our investigation.
More precisely, the contributions of the present work are:

• We reﬁne and extend a recent proposal to formalize the
semantics of SPARQL from P´erez et al. [16], present-
ing three variants, namely c-joining, s-joining and b-
joining semantics where the latter coincides with [16],
and can thus be considered normative. We further
discuss how aspects such compositionality, or idempo-
tency of joins are treated in these semantics.

• Based on the three semantic variants, we provide trans-
lations from a large fragment of SPARQL queries to
Datalog, which give rise to implementations of SPARQL
on top of existing engines.

• We provide some straightforward extensions of SPARQL

such as a set diﬀerence operator MINUS, and nesting
of ASK queries in FILTER expressions.

• Finally, we discuss an extension towards recursion by
allowing bNode-free-CONSTRUCT queries as part of
the query dataset, which may be viewed as a light-
weight, recursive rule language on top of of RDF.

The remainder of this paper is structured as follows:
In
Sec. 2 we ﬁrst overview SPARQL, discuss some issues in
the language (Sec. 2.1) and then deﬁne its formal semantics
(Sec. 2.2). After introducing a general form of Datalog with
negation as failure under the answer set semantics in Sec. 3,
we proceed with the translations of SPARQL to Datalog
in Sec. 4. We ﬁnally discuss the above-mentioned language
extensions in Sec. 5, before we conclude in Sec. 6.

2. RDF AND SPARQL

In examples, we will subsequently refer to the two RDF
graphs in Fig. 1 which give some information about Bob and
Alice. Such information is common in FOAF ﬁles which are
gaining popularity to describe personal data. Similarities
with existing examples in [18] are on purpose. We assume
the two RDF graphs given in TURTLE [2] notation and
accessible via the IRIs ex.org/bob and alice.org2
2For reasons of legibility and conciseness, we omit the lead-
ing ’http://’ or other schema identiﬁers in IRIs.

We assume the pairwise disjoint, inﬁnite sets I, B, L and
V ar, which denote IRIs, Blank nodes, RDF literals, and
variables respectively. In this paper, an RDF Graph is then
a ﬁnite set, of triples from I ∪ B ∪ L × I × I ∪ B ∪ L,3
dereferenceable by an IRI. A SPARQL query is a quadru-
ple Q = (V, P, DS, SM ), where V is a result form, P is a
graph pattern, DS is a dataset, and SM is a set of solution
modiﬁers. We refer to [18] for syntactical details and will
explain these in the following as far as necessary.
In this
paper, we will ignore solution modiﬁers mostly, thus we will
usually write queries as triples Q = (V, P, DS), and will use
the syntax for graph patterns introduced below.

Result Forms. Since we will, to a large extent, restrict our-
selves to SELECT queries, it is suﬃcient for our purposes to
describe result forms by sets variables. Other result forms
will be discussed in Sec. 5. For instance, let Q = (V, P, DS)
denote the query from Fig. 1, then V = {?X, ?Y }. Query
results in SPARQL are given by partial, i.e. possibly in-
complete, substitutions of variables in V by RDF terms. In
traditional relational query languages, such incompleteness
is usually expressed using null values. Using such null values
we will write solutions as tuples where the order of columns
is determined by lexicographically ordering the variables in
V . Given a set of variables V , let V denote the tuple ob-
tained from lexicographically ordering V .

The query from Fig. 1 with result form V = (?X, ?Y ) then
has solution tuples (”Bob”,
: a), (”Alice”, alice.org#me),
: c). We write substitutions in sqare brackets, so
(”Bob”,
these tuples correspond to the substitutions [?X → ”Bob”,
?Y → : a], [?X → ”Alice”, ?Y → alice.org#me], and
[?X → ”Bob”, ?Y → : c], respectively.

Graph Patterns. We follow the recursive deﬁnition of graph
patterns P from [16]:

• a tuple (s, p, o) is a graph pattern where s, o ∈ I ∪ L ∪

V ar and p ∈ I ∪ V ar.4

• if P and P ′ are graph patterns then (P AND P ′),
(P OPT P ′), (P UNION P ′), (P MINUS P ′) are graph
patterns.5

• if P is a graph pattern and i ∈ I∪V ar, then (GRAPH i P )

is a graph pattern.

• if P is a graph pattern and R is a ﬁlter expression then

(P FILTER R) is a graph pattern.

For any pattern P , we denote by vars(P ) the set of all vari-
ables occurring in P . As atomic ﬁlter expression, SPARQL
allows the unary predicates BOUND, isBLANK, isIRI, isLIT-
ERAL, binary equality predicates ’=’ for literals, and other
features such as comparison operators, data type conversion

3Following SPARQL, we are slightly more general than the
original RDF speciﬁcation in that we allow literals in subject
positions.
4We do not consider bNodes in patterns as these can be se-
mantically equivalently replaced by variables in graph pat-
terns [6].
5Note that AND and MINUS are not designated keywords in
SPARQL, but we use them here for reasons of readability
and in order to keep with the operator style deﬁnition of [16].
MINUS is syntactically not present at all, but we will suggest
a syntax extension for this particular keyword in Sec. 5.

WWW 2007 / Track: Semantic WebSession: Query Languages and DBs788# Graph: ex.org/bob
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix bob: <ex.org/bob#> .

<ex.org/bob> foaf:maker

: a.

# Graph: alice.org

@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix alice: <alice.org#> .

: a a foaf:Person ; foaf:name "Bob";

alice:me a foaf:Person ; foaf:name "Alice" ;

foaf:knows

: b.

foaf:knows

: c.

: b a foaf:Person ; foaf:nick "Alice".

: c a foaf:Person ; foaf:name "Bob" ;

<alice.org/> foaf:maker

: b

foaf:nick "Bobby".

PREFIX foaf: <http://xmlns.com/foaf/0.1/>

SELECT?Y ?X
FROM <alice.org>
FROM <ex.org/bob>
WHERE { ?Y foaf:name ?X .}

?X
”Bob”

”Bob”

?Y

: a
: c

”Alice”

alice.org#me

Figure 1: Two RDF graphs in TURTLE notation and a simple SPARQL query.

and string functions which we omit here, see [18, Sec. 11.3]
for details. Complex ﬁlter expressions can be built using the
connectives ’¬’,’∧’,’∨’.

Datasets. The dataset DS = (G, {(g1, G1), . . . (gk, Gk)}) of
a SPARQL query is deﬁned by a default graph G plus a set
of named graphs, i.e. pairs of IRIs and corresponding graphs.
Without loss of generality (there are other ways to deﬁne the
dataset such as in a SPARQL protocol query), we assume G
given as the merge of the graphs denoted by the IRIs given
in a set of FROM and FROM NAMED clauses. For instance,
the query from Fig. 1 refers to the dataset which consists
of the default graph obtained from merging alice.org ⊎
ex.org/bob plus an empty set of named graphs.

The relation between names and graphs in SPARQL is
deﬁned solely in terms of that the IRI deﬁnes a resource
which is represented by the respective graph. In this paper,
we assume that the IRIs represent indeed network-accessible
resources where the respective RDF-graphs can be retrieved
from. This view has also be taken e.g. in [17]. Particularly,
this treatment is not to be confused with so-called named
graphs in the sense of [4]. We thus identify each IRI with the
RDF graph available at this IRI and each set of IRIs with
the graph merge [13] of the respective IRIs. This allows us to
identify the dataset by a pair of sets of IRIs DS = (G, Gn)
with G = {d1, . . . , dn} and Gn = {g1, . . . , gk} denoting the
(merged) default graph and the set of named graphs, respec-
tively. Hence, the following set of clauses

FROM <ex.org/bob>
FROM NAMED <alice.org>

deﬁnes the dataset DS = ({ex.org/bob}, {alice.org}).
2.1 Assumptions and Issues

In this section we will discuss some important issues about
the current speciﬁcation, and how we will deal with them
here.

First, note that the default graph if speciﬁed by name in a
FROM clause is not counted among the named graphs auto-
matically [18, section 8, deﬁnition 1]. An unbound variable
in the GRAPH directive, means any of the named graphs in
DS, but does NOT necessarily include the default graph.

Example 1. This issue becomes obvious in the following

query with dataset DS = ({ex.org/bob}, ∅) which has an
empty solution set.

SELECT ?N WHERE {?G foaf:maker ?M .

GRAPH ?G { ?X foaf:name ?N } }

We will sometimes ﬁnd the following assumption convenient
to avoid such arguably unintuitive eﬀects:

Deﬁnition 1. (Dataset closedness assumption) Given a dataset

DS = (G, Gn), Gn implicitly contains (i) all graphs men-
tioned in G and (ii) all IRIs mentioned explicitly in the
graphs corresponding to G.

Under this assumption, the previous query has both (”Alice”)
and (”Bob”) in its solution set.

Some more remarks are in place concerning FILTER ex-
pressions. According to the SPARQL speciﬁcation “Graph
pattern matching creates bindings of variables [where] it is
possible to further restrict solutions by constraining the al-
lowable bindings of variables to RDF Terms [with FILTER
expressions].” However, it is not clearly speciﬁed how to
deal with ﬁlter constraints referring to variables which do
not appear in simple graph patterns. In this paper, for graph
patterns of the form (P FILTER R) we tacitly assume safe
ﬁlter expressions, i.e. that all variables used in a ﬁlter ex-
pression R also appear in the corresponding pattern P . This
corresponds with the notion of safety in Datalog (see Sec.3),
where the built-in predicates (which obviously correspond
to ﬁlter predicates) do not suﬃce to safe unbound variables.
Moreover, the speciﬁcation deﬁnes errors to avoid mistyped
comparisons, or evaluation of built-in functions over un-
bound values, i.e. “any potential solution that causes an
error condition in a constraint will not form part of the ﬁ-
nal results, but does not cause the query to fail.” These er-
rors propagate over the whole FILTER expression, also over
negation, as shown by the following example.

Example 2. Assuming the dataset does not contain triples

for the foaf : dummy property, the example query

SELECT ?X
WHERE { {?X a foaf:Person .

OPTIONAL { ?X foaf:dummy ?Y . } }

FILTER ( ¬(isLITERAL (?Y)) ) }

would discard any solution for ?X, since the unbound value
for ?Y causes an error in the isLITERAL expression and thus
the whole FILTER expression returns an error.

WWW 2007 / Track: Semantic WebSession: Query Languages and DBs789We will take special care for these errors, when deﬁning

the semantics of FILTER expressions later on.
2.2 Formal Semantics of SPARQL

The semantics of SPARQL is still not formally deﬁned in
its current version. This lack of formal semantics has been
tackled by a recent proposal of P´erez et al. [16]. We will
base on this proposal, but suggest three variants thereof,
namely (a) bravely joining, (b) cautiously-joining, and (c)
strictly-joining semantics. Particularly, our deﬁnitions vary
from [16] in the way we deﬁne joining unbound variables.
Moreover, we will reﬁne their notion of FILTER satisfaction
in order to deal with error propagation properly.

We denote by Tnull the union I ∪ B ∪ L ∪ {null}, where null
is a dedicated constant denoting the unknown value not ap-
pearing in any of I, B, or L, how it is commonly introduced
when deﬁning outer joins in relational algebra.

A substitution θ from V ar to Tnull is a partial function
θ : V ar → Tnull. We write substitutions in postﬁx notation:
For a triple pattern t = (s, p, o) we denote by tθ the triple
(sθ, pθ, oθ) obtained by applying the substitution to all vari-
ables in t. The domain of θ, dom(θ), is the subset of V ar
where θ is deﬁned. For a substitution θ and a set of variables
D ⊆ V ar we deﬁne the substitution θD with domain D as
follows:

xθD = xθ if x ∈ dom(θ) ∩ D

null if x ∈ D \ dom(θ)

Let θ1 and θ2 be substitutions, then θ1 ∪ θ2 is the substi-

tution obtained as follows:

x(θ1∪θ2) = 8<
:

xθ1 if xθ1 deﬁned and xθ2 undeﬁned
else: xθ1 if xθ1 deﬁned and xθ2 = null
else: xθ2 if xθ2 deﬁned
else: undeﬁned

Thus, in the union of two substitutions deﬁned values in one
take precedence over null values the other substitution. For
instance, given the substitutions θ1 = [?X → ”Alice”, ?Y →
: a, ?Z → null] and θ2 = [?U → ”Bob”, ?X → ”Alice”, ?Y →
null] we get: θ1 ∪ θ2 = [?U → ”Bob”, ?X → ”Alice”, ?Y →

: a, ?Z → null]
Now, as opposed to [16], we deﬁne three notions of com-

patibility between substitutions:

• Two substitutions θ1 and θ2 are bravely compatible (b-
compatible) when for all x ∈ dom(θ1) ∩ dom(θ2) either
xθ1 = null or xθ2 = null or xθ1 = xθ2 holds. i.e., when
θ1 ∪ θ2 is a substitution over dom(θ1) ∪ dom(θ2).

• Two substitutions θ1 and θ2 are cautiously compatible
(c-compatible) when they are b-compatible and for all
x ∈ dom(θ1) ∩ dom(θ2) it holds that xθ1 = xθ2.

• Two substitutions θ1 and θ2 are strictly compatible
(s-compatible) when they are c-compatible and for all
x ∈ dom(θ1) ∩ dom(θ2) it holds that x(θ1 ∪ θ2) 6= null.

Analogously to [16] we deﬁne join, union, diﬀerence, and
outer join between two sets of substitutions Ω1 and Ω2 over
domains D1 and D2, respectively, all except union parame-
terized by x ∈ {b,c,s}:

Ω1 ⊲⊳x Ω2 = {θ1 ∪ θ2 | θ1 ∈ Ω1, θ2 ∈ Ω2, are x-compatible}
Ω1 ∪ Ω2 = {θ | ∃θ1 ∈ Ω1 with θ = θD1∪D2
∃θ2 ∈ Ω2 with θ = θD1∪D2

or
}

1

2

Ω1 −x Ω2 = {θ ∈ Ω1 | ∀θ2 ∈ Ω2, θ and θ2 not x-compatible}
Ω1=⊲⊳x Ω2 = (Ω1 ⊲⊳x Ω2) ∪ (Ω1 −x Ω2)

The semantics of a graph pattern P over dataset DS =
(G, Gn), can now be deﬁned recursively by the evaluation
function returning sets of substitutions.

Deﬁnition 2. (Evaluation, extends [16, Def. 2] ) Let t =
(s, p, o) be a triple pattern, P, P1, P2 graph patterns, DS =
(G, Gn) a dataset, and i ∈ Gn, and v ∈ V ar, then the x-
joining evaluation [[·]]x

DS is deﬁned as follows:

DS = {θ | dom(θ) = vars(P ) and tθ ∈ G}

[[t]]x
[[P1 AND P2]]x
DS
[[P1 UNION P2]]x
[[P1 MINUS P2]]x
[[P1 OPT P2]]x
DS
[[GRAPH i P ]]x
[[GRAPH v P ]]x
[[P FILTER R]]x

DS

DS

DS ⊲⊳x [[P2]]x
DS ∪ [[P2]]x
DS −x [[P2]]x
DS =⊲⊳x [[P2]]x
(i,∅)

= [[P1]]x
DS = [[P1]]x
DS = [[P1]]x
= [[P1]]x
DS = [[P ]]x
DS = {θ∪[v → g] | g ∈ Gn, θ ∈ [[P [v → g] ]]x
DS = {θ ∈ [[P ]]x

DS | Rθ = ⊤}

DS

DS

(g,∅)}

Let R be a FILTER expression, u, v ∈ V ar, c ∈ I ∪ B ∪ L.
The valuation of R on substitution θ, written Rθ takes one
of the three values {⊤, ⊥, ε}6 and is deﬁned as follows.
Rθ = ⊤, if:

(1) R = BOUND(v) with v ∈ dom(θ) ∧ vθ 6= null;
(2) R = isBLANK(v) with v ∈ dom(θ) ∧ vθ ∈ B;
(3) R = isIRI(v) with v ∈ dom(θ) ∧ vθ ∈ I;
(4) R = isLITERAL(v) with v ∈ dom(θ) ∧ vθ ∈ L;
(5) R = (v = c) with v ∈ dom(θ) ∧ vθ = c;
(6) R = (u = v) with u, v ∈ dom(θ) ∧ uθ = vθ ∧ uθ 6= null;
(7) R = (¬R1) with R1θ = ⊥;
(8) R = (R1 ∨ R2) with R1θ = ⊤ ∨ R2θ = ⊤;
(9) R = (R1 ∧ R2) with R1θ = ⊤ ∧ R2θ = ⊤.

Rθ = ε, if:

(1) R = isBLANK(v),R = isIRI(v),R = isLITERAL(v),

or R = (v = c) with v 6∈ dom(θ) ∨ vθ = null;

(2) R = (u = v) with u 6∈ dom(θ) ∨ uθ = null

∨ v 6∈ dom(θ) ∨ vθ = null;

(3) R = (¬R1) and R1θ = ε;
(4) R = (R1 ∨ R2) and (R1θ 6= ⊤ ∧ R2θ 6= ⊤) ∧

(R1θ = ε ∨ R2θ = ε);

(5) R = (R1 ∧ R2) and R1θ = ε ∨ R2θ = ε.

Rθ = ⊥ otherwise.

We will now exemplify the three diﬀerent semantics deﬁned
above, namely bravely joining (b-joining), cautiously joining
(c-joining), and strictly-joining (s-joining) semantics. When
taking a closer look to the AND and MINUS operators, one
will realize that all three semantics take a slightly diﬀering
view only when joining null. Indeed, the AND operator be-
haves as the traditional natural join operator ⊲⊳ in relational
algebra, when no null values are involved.

Take for instance, DS = ({ex.org/bob, alice.org}, ∅) and
P = ((?X, name, ?N ame) AND (?X, knows, ?F riend)). When
viewing each solution set as a relational table with variables
denoting attribute names, we can write:

?X

: a

alice.org#me

: c

?Name
”Bob”

”Alice”

”Bob”

?X

: a

⊲⊳

alice.org#me

?Friend

: b
: c

?X

: a

=

?Name
”Bob”

alice.org#me

”Alice”

?Friend

: b
: c

Diﬀerences between the three semantics appear when join-
ing over null-bound variables, as shown in the next example.

6⊤ stands for “true”, ⊥ stands for “false” and ε stands for
errors, see [18, Sec. 11.3] and Example 2 for details.

WWW 2007 / Track: Semantic WebSession: Query Languages and DBs790Example 3. Let DS be as before and assume the follow-
ing query which might be considered a naive attempt to ask
for pairs of persons ?X1, ?X2 who share the same name and
nickname where both, name and nickname are optional:

Example 5. Let DS = ({ex.org/bob, alice.org}, ∅) and
assume a slight variant of a query from [5] which asks for
persons and some names for these persons, where preferably
the foaf : name is taken, and, if not speciﬁed, foaf : nick.

P = ( ((?X1, a, Person) OPT (?X1, name, ?N )) AND

P = ((((?X, a, Person) OPT (?X, name, ?XN AM E))

((?X2, a, Person) OPT (?X2, nick, ?N )) )

OPT (?X, nick, ?XN AM E))

Again, we consider the tabular view of the resulting join:

?X1
: a
: b
: c

alice.org#me

?N

”Bob”

null

”Bob”
”Alice”

?X2
: a
: b
: c

⊲⊳x

alice.org#me

?N
null

”Alice”
”Bobby”

null

Now, let us see what happens when we evaluate the join
⊲⊳x with respect to the diﬀerent semantics. The following
result table lists in the last column which tuples belong to
the result of b-, c- and s-join, respectively.

?X1
: a
: a
: b
: b
: b
: b
: c
: c

=

alice.org#me
alice.org#me
alice.org#me

?N

”Bob”
”Bob”

null

”Alice”
”Bobby”

null

”Bob”
”Bob”
”Alice”
”Alice”
”Alice”

X2

: a

alice.org#me

: a
: b
: c

alice.org#me

: a

alice.org#me

: a
: b

alice.org#me

b
b
b,c
b
b
b,c
b
b
b
b,c,s
b

Leaving aside the question whether the query formulation
was intuitively broken, we remark that only the s-join would
have the expected result. At the very least we might argue,
that the liberal behavior of b-joins might be considered sur-
prising in some cases. The c-joining semantics acts a bit
more cautious in between the two, treating null values as
normal values, only uniﬁable with other null values.

Compared to how joins over incomplete relations are treated

in common relational database systems, the s-joining seman-
tics might be considered the intuitive behavior. Another in-
teresting divergence (which would rather suggest to adopt
the c-joining semantics) shows up when we consider a simple
idempotent join.

Example 4. Let us consider the following single triple
dataset DS = ({(alice.org#me, a, Person)}, ∅) and the fol-
lowing simple query pattern:

P = ((?X, a, Person) UNION (?Y, a, Person))

DS = {(alice.org#me, null), (null, alice.org#me)}

Clearly, this pattern, has the solution set
[[P ]]x
under all three semantics. Surprisingly, P ′ = (P AND P )
has diﬀerent solution sets for the diﬀerent semantics. First,
[[P ′]]c
DS = ∅, since null values are
not compatible under the s-joining semantics. Finally,
[[P ′]]b

DS = {(alice.org#me, null), (null, alice.org#me),

DS = [[P ]]x

DS, but [[P ′]]s

(alice.org#me, alice.org#me)}

As shown by this example, under the reasonable assump-
tion, that the join operator is idempotent, i.e., (P ⊲⊳ P ) ≡
P , only the c-joining semantics behaves correctly.

However, the brave b-joining behavior is advocated by
the current SPARQL document, and we might also think
of examples where this obviously makes a lot of sense. Es-
pecially, when considering no explicit joins, but the implicit
joins within the OPT operator:

Only [[P ]]b
for the bNode

: b.

DS contains the expected solution (

: b, ”Alice”)

All three semantics may be considered as variations of
the original deﬁnitions in [16], for which the authors proved
complexity results and various desirable features, such as
semantics-preserving normal form transformations and com-
positionality. The following proposition shows that all these
results carry over to the normative b-joining semantics:

Proposition 1. Given a dataset DS and a pattern P
which does not contain GRAPH patterns, the solutions of
[[P ]]DS as in [16] and [[P ]]b
DS are in 1-to-1 correspondence.
Proof. Given DS and P each substitution θ obtained
DS can be reduced to a substitution θ′
by evaluation [[P ]]b
obtained from the evaluation [[P ]]DS in [16] by dropping
all mappings of the form v → null from θ. Likewise, each
substitution θ′ obtained from [[P ]]DS can be extended to a
substitution θ = θ′vars(P ) for [[P ]]b

DS.

Following the deﬁnitions from the SPARQL speciﬁcation
and [16], the b-joining semantics is the only admissible def-
inition. There are still advantages for gradually deﬁning
alternatives towards traditional treatment of joins involving
nulls. On the one hand, as we have seen in the examples
above, the brave view on joining unbound variables might
have partly surprising results, on the other hand, as we will
see, the c- and s-joining semantics allow for a more eﬃcient
implementation in terms of Datalog rules.

Let us now take a closer look on some properties of the

three deﬁned semantics.

Compositionality and Equivalences. As shown in [16],
some implementations have a non-compositional semantics,
leading to undesired eﬀects such as non-commutativity of
the join operator, etc. A semantics is called compositional if
for each P ′ sub-pattern of P the result of evaluating P ′ can
be used to evaluate P . Obviously, all three the c-, s- and
b-joining semantics deﬁned here retain this property, since
all three semantics are deﬁned recursively, and independent
of the evaluation order of the sub-patterns.

The following proposition summarizes equivalences which
hold for all three semantics, showing some interesting addi-
tions to the results of P´erez et al.

Proposition 2

(extends [16, Prop. 1]). The follow-
ing equivalences hold or do not hold in the diﬀerent seman-
tics as indicated after each law:

(1) AND, UNION are associative and commutative.
(2) (P1 AND (P2 UNION P3))

(b,c,s)

≡ ((P1 AND P2) UNION (P1 AND P3)).

(3) (P1 OPT (P2 UNION P3))

≡ ((P1 OPT P2) UNION (P1 OPT P3)).

(4) ((P1 UNION P2) OPT P3)

≡ ((P1 OPT P3) UNION (P2 OPT P3)).

(5) ((P1 UNION P2) FILTER R)

≡ ((P1 FILTER R) UNION (P2 FILTER R)).

(6) AND is idempotent, i.e. (P AND P ) ≡ P .

(b)

(b)

(b)

(b,c,s)
(c)

WWW 2007 / Track: Semantic WebSession: Query Languages and DBs791Proof Sketch.. (1-5) for the b-joining semantics are pro-
ven in [16], (1): for c-joining and s-joining follows straight
from the deﬁnitions. (2)-(4): the substitution sets [[P1]]c,s =
[[P2]]c,s = {[?X → a, ?Z → c]},
{[?X → a, ?Y → b]},
[[P3]]c,s = {[?Y → b, ?Z → c]} provide counterexamples
for c-joining and s-joining semantics for all three equiva-
lences (2)-(4).
(5): The semantics of FILTER expressions
and UNION is exactly the same for all three semantics, thus,
the result for the b-joining semantics carries over to all three
semantics.
follows from the observations in Exam-
ple 4.

(6):

Ideally, we would like to identify a subclass of programs,
where the three semantics coincide. Obviously, this is the
case for any query involving neither UNION nor OPT op-
erators. P´erez et al. [16] deﬁne a bigger class of programs,
including “well-behaving” optional patterns:

Deﬁnition 3. ([16, Def. 4] ) A UNION-free graph pattern
P is well-designed if for every occurrence of a sub-pattern
P ′ = (P1 OPT P2) of P and for every variable v occurring
in P , the following condition holds: if v occurs both in P2
and outside P ′ then it also occurs in P1.
As may be easily veriﬁed by the reader, neither Example 3
nor Example 5, which are both UNION-free, satisfy the well-
designedness condition. Since in the general case the equiv-
alences for Prop. 2 do not hold, we also need to consider
nested UNION patterns as a potential source for null bind-
ings which might aﬀect join results. We extend the notion
of well-designedness, which direclty leads us to another cor-
respondence in the subsequent proposition.

Deﬁnition 4. A graph pattern P is well-designed if the
condition from Def. 3 holds and for every occurrence of a
sub-pattern P ′ = (P1 UNION P2) of P and for every variable
v occurring in P ′, the following condition holds: if v occurs
outside P ′ then it occurs in both P1 and P2.

Proposition 3. On well-designed graph patterns the c-,

s-, and b-joining semantics coincide.

Proof Sketch.. Follows directly from the observation
that all variables which are re-used outside P ′ must be bound
to a value unequal to null in P ′ due to well-designedness, and
thus cannot generate null bindings which might carry over
to joins.

Likewise, we can identify “dangerous” variables in graph

patterns, which might cause semantic diﬀerences:

Deﬁnition 5. Let P ′ a sub-pattern of P of either the form
P ′ = (P1OPT P2) or P ′ = (P1UNION P2). Any variable v
in P ′ which violates the well-designedness-condition is called
possibly-null-binding in P .

Note that, so far we have only deﬁned the semantics in
terms of a pattern P and dataset DS, but not yet taken the
result form V of query Q = (V, P, DS) into account.

We now deﬁne solution tuples that were informally in-
troduced in Sec. 2. Recall that by V we denote the tuple
obtained from lexicographically ordering a set of variables
in V . The notion V [V ′ → null] means that, after ordering V
all variables from a subset V ′ ⊆ V are replaced by null.

Deﬁnition 6. (Solution Tuples) Let Q = (V, P, DS) be a
SPARQL query, and θ a substitution in [[P ]]x
DS, then we
call the tuple V [(V \ vars(P )) → null]θ a solution tuple of
Q with respect to the x-joining semantics.

Let us remark at this point, that as for the discussion of
intuitivity of the diﬀerent join semantics discussed in Exam-
ples 3–5, we did not yet consider combinations of diﬀerent
join semantics, e.g. using b-joins for OPT and c-joins for
AND patterns. We leave this for further work.

3. DATALOG AND ANSWER SETS

In this paper we will use a very general form of Datalog
commonly referred to as Answer Set Programming (ASP),
i.e. function-free logic programming (LP) under the answer
set semantics [1, 11]. ASP is widely proposed as a useful tool
for various problem solving tasks in e.g. Knowledge Repre-
sentation and Deductive databases. ASP extends Datalog
with useful features such as negation as failure, disjunction
in rule heads, aggregates [9], external predicates[8], etc. 7

Let P red, Const, V ar, exP r be sets of predicate, con-
stant, variable symbols, and external predicate names, re-
spectively. Note that we assume all these sets except P red
and Const (which may overlap), to be disjoint.
In ac-
cordance with common notation in LP and the notation
for external predicates from [7] we will in the following as-
sume that Const and P red comprise sets of numeric con-
stants, string constants beginning with a lower case let-
ter, or ’"’ quoted strings, and strings of the form hquoted-
stringi^^hIRIi, hquoted-stringi@hvalid-lang-tagi, V ar is the
set of string constants beginning with an upper case letter.
Given p ∈ P red an atom is deﬁned as p(t1, . . . , tn), where n
is called the arity of p and t1, . . . , tn ∈ Const ∪ V ar.

Moreover, we deﬁne a ﬁxed set of external predicates
exP r = {rdf , isBLAN K, isIRI, isLIT ERAL, =, != }
All external predicates have a ﬁxed semantics and ﬁxed
arities, distinguishing input and output terms. The atoms
isBLAN K[c](val), isIRI[c](val), isLIT ERAL[c](val) test
the input term c ∈ Const ∪ V ar (in square brackets) for
being valid string representations of Blank nodes, IRI Ref-
erences or RDF literals, returning an output value val ∈
{t, f, e}, representing truth, falsity or an error, following the
semantics deﬁned in [18, Sec. 11.3]. For the rdf predicate we
write atoms as rdf [i](s, p, o) to denote that i ∈ Const ∪ V ar
is an input term, whereas s, p, o ∈ Const ∪ V ar are output
terms which may be bound by the external predicate. The
external atom rdf [i](s, p, o) is true if (s, p, o) is an RDF triple
entailed by the RDF graph which is accessibly at IRI i. For
the moment, we consider simple RDF entailment [13] only.
Finally, we write comparison atoms ’t1 = t2’ and ’t1 != t2’
in inﬁx notation with t1, t2 ∈ Const ∪ V ar and the obvious
semantics of (lexicographic or numeric) (in)equality. Here,
for = either t1 or t2 is an output term, but at least one is
an input term, and for != both t1 and t2 are input terms.

Deﬁnition 7. Finally, a rule is of the form

h :- b1, . . . , bm, not bm+1, . . . not bn.

(1)

where h and bi (1 ≤ i ≤ n) are atoms, bk (1 ≤ k ≤ m) are
either atoms or external atoms, and not is the symbol for
negation as failure.

We use H(r) to denote the head atom h and B(r) to denote
the set of all body literals B+(r)∪B−(r) of r, where B+(r) =
{b1, . . . , bm} and B−(r) = {bm+1, . . . , bn}.

7We consider ASP, more precisely a simpliﬁed version of
ASP with so-called HEX-programs [8] here, since it is up to
date the most general extension of Datalog.

WWW 2007 / Track: Semantic WebSession: Query Languages and DBs792The notion of input and output terms in external atoms
described above denotes the binding pattern. More pre-
cisely, we assume the following condition which extends the
standard notion of safety (cf. [21]) in Datalog with negation:
Each variable appearing in a rule must appear in B+(r) in
an atom or as an output term of an external atom.

Deﬁnition 8. A (logic) program Π is deﬁned as a set of

safe rules r of the form (1).

The Herbrand base of a program Π, denoted HBΠ, is the
set of all possible ground versions of atoms and external
atoms occurring in Π obtained by replacing variables with
constants from Const, where we deﬁne for our purposes by
Const the union of the set of all constants appearing in Π
as well as the literals, IRIs, and distinct constants for each
blank node occurring in each RDF graph identiﬁed8 by one
of the IRIs in the (recursively deﬁned) set I, where I is
deﬁned by the recursive closure of all IRIs appearing in Π
and all RDF graphs identiﬁed by IRIs in I.9 As long as
we assume that the Web is ﬁnite the grounding of a rule
r, ground (r), is deﬁned by replacing each variable with the
possible elements of HBΠ, and the grounding of program Π

is ground (Π) = Sr∈Π ground (r).

An interpretation relative to Π is any subset I ⊆ HBΠ
containing only atoms. We say that I is a model of atom
a ∈ HBΠ, denoted I |= a, if a ∈ I. With every exter-
nal predicate name lg ∈ exP r with arity n we associate
an (n + 1)-ary Boolean function flg (called oracle func-
10
tion) assigning each tuple (I, t1 . . . , tn) either 0 or 1.
We say that I ⊆ HBΠ is a model of a ground external
atom a = g[t1, . . . , tm](tm+1, . . . , tn), denoted I |= a, iﬀ
flg(I, t1, . . . , tn) = 1.

The semantics we use here generalizes the answer-set se-
mantics [11]11, and is deﬁned using the FLP-reduct [9], which
is more elegant than the traditional GL-reduct [11] of stable
model semantics and ensures minimality of answer sets also
in presence of external atoms.

Let r be a ground rule. We deﬁne (i) I|=B(r) iﬀ I |= a for
all a ∈ B+(r) and I 6|= a for all a ∈ B−(r), and (ii) I |= r iﬀ
I |= H(r) whenever I |= B(r). We say that I is a model of a
program Π, denoted I |= Π, iﬀ I |= r for all r ∈ ground (Π).
The FLP-reduct [9] of Π with respect to I ⊆ HBΠ, de-
noted ΠI, is the set of all r ∈ ground (Π) such that I |= B(r).
I is an answer set of Π iﬀ I is a minimal model of ΠI.

We did not consider further extensions common to many
ASP dialects here, namely disjunctive rule heads, strong
negation [11]. We note that for non-recursive programs, i.e.
where the predicate dependency graph is acyclic, the answer
set is unique. For the pure translation which we will give in
Sec. 4 where we will produce such non-recursive programs
from SPARQL queries, we could equally take other seman-

8By “identiﬁed” we mean here that IRIs denote network
accessible resources which correspond to RDF graphs.
9We assume the number of accessible IRIs ﬁnite.
10The notion of an oracle function reﬂects the intuition that
external predicates compute (sets of) outputs for a particu-
lar input, depending on the interpretation. The dependence
on the interpretation is necessary for instance for deﬁning
the semantics of external predicates querying OWL [8] or
computing aggregate functions.
11In fact, we use slightly simpliﬁed deﬁnitions from [7] for
HEX-programs, with the sole diﬀerence that we restrict our-
selves to a ﬁxed set of external predicates.

tics such as the well-founded [10] semantics into account,
which coincides with ASP on non-recursive programs.

4. FROM SPARQL TO DATALOG

We are now ready to deﬁne a translation from SPARQL
to Datalog which can serve straightforwardly to implement
SPARQL within existing rules engines. We start with a
translation for c-joining semantics, which we will extend
thereafter towards s-joining and b-joining semantics.

Translation Πc
Q. Let Q = (V, P, DS), where DS = (G, Gn)
as deﬁned above. We translate this query to a logic program
Πc

Q deﬁned as follows.

Πc

Q ={triple(S, P, O, default) :- rdf[d](S, P, O). | d ∈ G}

∪ {triple(S, P, O, g) :- rdf[g](S, P, O).
∪ τ (V, P, default, 1)

| g ∈ Gn}

The ﬁrst two rules serve to import the relevant RDF triples
from the dataset into a 4-ary predicate triple. Under the
dataset closedness assumption (see Def. 1) we may replace
the second rule set, which imports the named graphs, by:

triple(S, P, O, G) :- rdf[G](S, P, O), HU (G), isIRI(G).

Here, the predicate HU stands for “Herbrand universe”,
where we use this name a bit sloppily, with the intention
to cover all the relevant part of C, recursively importing all
possible IRIs in order to emulate the dataset closedness as-
sumption. HU , can be computed recursively over the input
triples, i.e.

HU (X) :- triple(X, P, O, D). HU (X) :- triple(S, X, O, D).
HU (X) :- triple(S, P, X, D). HU (X) :- triple(S, P, O, X).

The remaining program τ (V, P, default, 1) represents the
actual query translation, where τ is deﬁned recursively as
shown in Fig. 2.

By LT (·) we mean the set of rules resulting from disas-
sembling complex FILTER expressions (involving ’¬’,’∧’,’∨’)
according to the rewriting deﬁned by Lloyd and Topor [15]
where we have to obey the semantics for errors, following
Deﬁnition 2. In a nutshell, the rewriting LT − rewrite(·)
proceeds as follows: Complex ﬁlters involving ¬ are trans-
formed into negation normal form. Conjunctions of ﬁlter
expressions are simply disassembled to conjunctions of body
literals, disjunctions are handled by splitting the respec-
tive rule for both alternatives in the standard way. The
resulting rules involve possibly negated atomic ﬁlter expres-
sions in the bodies. Here, BOU N D(v) is translated to v =
null, ¬BOU N D(v) to v! = null. isBLAN K(v), isIRI(v),
isLIT ERAL(v) and their negated forms are replaced by
their corresponding external atoms (see Sec. 3) isBLANK[v](t)
or isBLANK[v](f), etc., respectively.

The resulting program Πc

Q implements the c-joining se-

mantics in the following sense:

Proposition 4

(Soundness and completeness of Πc

Q).

For each atom of the form answer1(~s, default) in the unique
answer set M of Πc
Q, ~s is a solution tuple of Q with respect
to the c-joining semantics, and all solution tuples of Q are
represented by the extension of predicate answer1 in M .

Without giving a proof, we remark that the result follows
if we convince ourselves that τ (V, P, D, i) emulates exactly

WWW 2007 / Track: Semantic WebSession: Query Languages and DBs793τ (V, (s, p, o), D, i)
τ (V, (P ′ AND P ′′), D, i) = τ (vars(P ′), P ′, D, 2 ∗ i) ∪ τ (vars(P ′′), P ′′, D, 2 ∗ i + 1) ∪

= answeri(V , D) :- triple(s, p, o, D).

τ (V, (P ′ UNION P ′′), D, i) = τ (vars(P ′), P ′, D, 2 ∗ i) ∪ τ (vars(P ′′), P ′′, D, 2 ∗ i + 1) ∪

answeri(V , D) :- answer2∗i(vars(P ′), D), answer2∗i+1((vars(P ′′), D).

answeri(V [(V \ vars(P ′)) → null], D) :- answer2∗i(vars(P ′), D).
answeri(V [(V \ vars(P ′′)) → null], D) :- answer2∗i+1(vars(P ′′), D).

τ (V, (P ′ MINUS P ′′), D, i) = τ (vars(P ′), P ′, D, 2 ∗ i) ∪ τ (vars(P ′′), P ′′, D, 2 ∗ i + 1) ∪

answeri(V [(V \ vars(P ′)) → null], D) :- answer2∗i(vars(P ′), D),

answer2∗i

′(vars(P ′) ∩ vars(P ′′), D) :- answer2∗i+1(vars(P ′′), D). }

not answer2∗i

′(vars(P ′) ∩ vars(P ′′), D).

τ (V, (P ′ OPT P ′′), D, i)
τ (V, (P FILTER R), D, i) = τ (vars(P ), P, D, 2 ∗ i) ∪

= τ (V, (P ′ AND P ′′), D, i) ∪ τ (V, (P ′ MINUS P ′′), D, i)

LT (answeri(V , D) :- answer2∗i(vars(P ), D), R.)

τ (V, (GRAPH g P ), D, i) = τ (V, P, g, i) for g ∈ V ∪ I

answeri(V , D) :- answeri(V , g), isIRI(g), not g = default.

Alternate rules replacing (5)+(6):

answeri(V [(V \ vars(P ′)) → null], D) :- answer2∗i(vars(P ′), D), not answer2∗i
answer2∗i

:- answer2∗i(vars(P ′), D), answer2∗i+1(vars(P ′′), D).

′(vars(P ′), D)

′(vars(P ′), D)

(1)

(2)

(3)
(4)

(5)

(6)

(7)

(8)

(5’)
(6’)

Figure 2: Translation Πc

Q from SPARQL queries semantics to Datalog.

the recursive deﬁnition of [[P ]]x
DS. Moreover, together with
Proposition 3, we obtain soundness and completeness of ΠQ
for b-joining and s-joining semantics as well for well-designed
query patterns.

Corollary 1. For Q = (V, P, DS), if P is well-designed,
then the extension of predicate answer1 in the unique answer
set M of Πc
Q represents all and only the solution tuples for
Q with respect to the x-joining semantics, for x ∈ {b, c, s}.

Now, in order to obtain a proper translation for arbitrary
patterns, we obviously need to focus our attention on the
possibly-null-binding variables within the query pattern P .
Let vnull(P ) denote the possibly-null-binding variables in
a (sub)pattern P . We need to consider all rules in Fig. 2
which involve x-joins, i.e. the rules of the forms (2),(5) and
(6). Since rules (5) and (6) do not make this join explicit,
we will replace them by the equivalent rules (5’) and (6’)
for Πs
Q. The “extensions” to s-joining and b-joining
semantics can be achieved by rewriting the rules (2) and
(6’). The idea is to rename variables and add proper FILTER
expressions to these rules in order to realize the b-joining
and s-joining behavior for the variables in VN = vnull(P ) ∩
vars(P ′) ∩ vars(P ′′).

Q and Πb

Translation Πs
adding FILTER expressions

Q. The s-joining behavior can be achieved by

Rs = ( ^v∈VN

BOU N D(v) )

to the rule bodies of (2) and (6’). The resulting rules are
again subject to the LT -rewriting as discussed above for the
rules of the form (7). This is suﬃcient to ﬁlter out any joins
involving null values, thus achieving s-joining semantics, and
we denote the program rewritten that way as Πs

Q.

Q. Obviously, b-joining semantics is more
Translation Πb
tricky to achieve, since we now have to relax the allowed
joins in order to allow null bindings to join with any other
value. We will again achieve this result by modifying rules
(2) and (6’) where we ﬁrst do some variable renaming and
then add respective FILTER expressions to these rules.

Step 1. We rename each variable v ∈ VN in the respec-
tive rule bodies to v′ or v′′, respectively, in order to dis-
ambiguate the occurrences originally from sub-pattern P ′
or P ′′, respectively. That is, for each rule (2) or (6’), we
rewrite the body to:

answer2∗i(vars(P ′)[VN → V ′
answer2∗i+1(vars(P ′′)[VN → V ′′

N ], D),

N ], D).

Step 2. We now add the following FILTER expressions
(2) and Rb
(6′), respectively, to the resulting rule bodies

Rb
which “emulate” the relaxed b-compatibility:

Rb

(2) = Vv∈V N (

Rb

(6′) = Vv∈V N (

((v = v′) ∧ (v′ = v′′)) ∨
((v = v′) ∧ ¬BOU N D(v′′)) ∨
((v = v′′) ∧ ¬BOU N D(v′)) )
((v = v′) ∧ (v′ = v′′)) ∨
((v = v′) ∧ ¬BOU N D(v′′)) ∨
((v = v′) ∧ ¬BOU N D(v′)) )

The rewritten rules are again subject to the LT rewriting.
Note that, strictly speaking the ﬁlter expression introduced
here does not fulﬁll the assumption of safe ﬁlter expressions,
since it creates new bindings for the variable v. However,
these can safely be allowed here, since the translation only
creates valid input/output term bindings for the external
Datalog predicate ’=’. The subtle diﬀerence between Rb
(2)
and Rb
(2) preferably “carries over”
bound values from v′ or v′′ to v whereas Rb
(6′) always takes
the value of v′. The eﬀect of this becomes obvious in the
translation of Example 5 which we leave as an exercise to

(6′) lies in the fact that Rb

WWW 2007 / Track: Semantic WebSession: Query Languages and DBs794the reader. We note that the potential exponential (with
respect to |VN |) blowup of the program size by unfolding the
ﬁlter expressions into negation normal form during the LT
rewriting12 is not surprising, given the negative complexity
results in [16].

In total, we obtain a program which Πb

Q which reﬂects the
normative b-joining semantics. Consequently, we get sound
and complete query translations for all three semantics:

Corollary 2

(Soundness and completeness of Πx
Given an arbitrary graph pattern P , the extension of predi-
cate answer1 in the unique answer set M of Πx
Q represents
all and only the solution tuples for Q = (V, P, DS) with re-
spect to the x-joining semantics, for x ∈ {b, c, s}.

Q).

In the following, we will drop the superscript x in ΠQ implic-
itly refer to the normative b-joining translation/semantics.

5. POSSIBLE EXTENSIONS

As it turns out, the embedding of SPARQL in the rules
world opens a wide range of possibilities for combinations.
In this section, we will ﬁrst discuss some straightforward
extensions of SPARQL which come practically for free with
the translation to Datalog provided before. We will then
discuss the use of SPARQL itself as a simple RDF rules
language13 which allows to combine RDF fact bases with
implicitly speciﬁed further facts and discuss the semantics
thereof brieﬂy. We conclude this section with revisiting the
open issue of entailment regimes covering RDFS or OWL
semantics in SPARQL.
5.1 Additional Language Features

Set Difference. As mentioned before, set diﬀerence is not
present in the current SPARQL speciﬁcation syntactically,
though hidden, and would need to be emulated via a combi-
nation of OPTIONAL and FILTER constructs. As we deﬁned
the MINUS operator here in a completely modular fashion,
it could be added straightforwardly without aﬀecting the
semantics deﬁnition.

Nested queries. Nested queries are a distinct feature of
SQL not present in SPARQL. We suggest a simple, but
useful form of nested queries to be added: Boolean queries
QASK = (∅, PASK, DSASK)) with an empty result form (de-
noted by the keyword ASK) can be safely allowed within
FILTER expressions as an easy extension fully compatible
with our translation. Given query Q = (V, P, DS), with sub-
pattern (P1 FILTER (ASKQASK)) we can modularly trans-
late such subqueries by extending ΠQ with ΠQ′ where Q′ =
(vars(P1) ∩ vars(PASK), PASK, DSASK)). Moreover, we have
to rename predicate names answeri to answerQ′
i in ΠQ′ .
Some additional considerations are necessary in order to
combine this within arbitrary complex ﬁlter expressions, and
we probably need to impose well-designedness for variables
shared between P and PASK similar to Def. 4. We leave more
details as future work.

12Lloyd and Topor can avoid this potential exponential
blowup by introducing new auxiliary predicates. However,
we cannot do the same trick, mainly for reasons of preserv-
ing safety of external predicates as deﬁned in Sec. 3.
13Thus, the “. . . (and back)” in the title of this paper!

5.2 Result Forms and Solution Modiﬁers

We have covered only SELECT queries so far. As shown in
the previous section, we can consider ASK queries equally. A
limited form of the CONSTRUCT result form, which allows
to construct new triples could be emulated in our approach
as well. Namely, we can allow queries of the form

QC = (CONSTRUCTPC, P, DS)

where PC is a graph pattern consisting only of bNode-free
triple patterns. We can model these by adding a rule

triple(s, p, o, C) :- answer1(vars(PC), default).

(2)

to ΠQ for each triple (s, p, o) in PC. The result graph is
then naturally represented in the answer set of the program
extended that way in the extension of the predicate triple.
5.3 SPARQL as a Rules Language

As it turns out with the extensions deﬁned in the previ-
ous subsections, SPARQL itself may be viewed as an expres-
sive rules language on top of RDF. CONSTRUCT statements
have an obvious similarity with view deﬁnitions in SQL, and
thus may be seen as rules themselves.

Intuitively, in the translation of CONSTRUCT we “stored”
the new triples in a new triple outside the dataset DS. We
can imagine a similar construction in order to deﬁne the
semantics of queries over datasets mixing such CONSTRUCT
statements with RDF data in the same turtle ﬁle.

Let us assume such a mixed ﬁle containing CONSTRUCT
rules and RDF triples web-accessible at IRI g, and a query
Q = (V, P, DS), with DS = (G, Gn). The semantics of a
query over a dataset containing g may then be deﬁned by
recursively adding ΠQC to ΠQ for any CONSTRUCT query
QC in g plus the rules (2) above with their head changed to
triple(s, p, o, g). We further need to add a rule

triple(s, p, o, def ault) :- triple(s, p, o, g).

for each g ∈ G, in order not to omit any of the implicit
triples deﬁned by such “CONSTRUCT rules”. Analogously
to the considerations for nested ASK queries, we need to re-
name the answeri predicates and def ault constants in every
subprogram ΠQC deﬁned this way.

Naturally, the resulting programs possibly involve recur-
sion, and, even worse, recursion over negation as failure.
Fortunately, the general answer set semantics, which we use,
can cope with this. For some important aspects on the se-
mantics of such distributed rules and facts bases, we refer
to [17], where we also outline an alternative semantics based
on the well-founded semantics. A more in-depth investiga-
tion of the complexity and other semantic features of such
a combination is on our agenda.
5.4 Revisiting Entailment Regimes

The current SPARQL speciﬁcation does not treat en-
tailment regimes beyond RDF simple entailment. Strictly
speaking, even RDF entailment is already problematic as a
basis for SPARQL query evaluation; a simple query pattern
like P = (?X, rdf:type, rdf:Property) would have inﬁnitely
many solutions even on the empty (sic!) dataset by match-
ing the inﬁnitely many axiomatic triples in the RDF(S) se-
mantics.

Finite rule sets which approximate the RDF(S) seman-
tics in terms of positive Datalog rules [17] have been im-

WWW 2007 / Track: Semantic WebSession: Query Languages and DBs795plemented in systems like TRIPLE14 or JENA15. Similarly,
fragments and extensions of OWL [12, 3, 14] deﬁnable in
terms of Datalog rule bases have been proposed in the liter-
ature. Such rule bases can be parametrically combined with
our translations, implementing what one might call RDFS−
or OWL− entailment at least. It remains to be seen whether
the SPARQL working group will deﬁne such reduced entail-
ment regimes.

More complex issues arise when combining a nonmono-
tonic query language like SPARQL with ontologies in OWL.
An embedding of SPARQL into a nonmonotonic rules lan-
guage might provide valuable insights here, since it opens
up a whole body of work done on combinations of such lan-
guages with ontologies [7, 19].

6. CONCLUSIONS & OUTLOOK

In this paper, we presented three possible semantics for
SPARQL based on [16] which diﬀer mainly in their treat-
ment of joins and their translations to Datalog rules. We
discussed intuitive behavior of these diﬀerent joins in several
examples. As it turned out, the s-joining semantics which is
close to traditional treatment of joins over incomplete rela-
tions and the c-joining semantics are nicely embeddable into
Datalog. The b-joining semantics which reﬂects the norma-
tive behavior as described by the current SPARQL speciﬁ-
cation is most diﬃcult to translate. We also suggested some
extension of SPARQL, based on this translation. Further,
we hope to have contributed to clarifying the relationships
between the Query, Rules and Ontology layers of the Se-
mantic Web architecture with the present work.

A prototype of the presented translation has been im-
plemented on top of the dlvhex system, a ﬂexible framework
for developing extensions for the declarative Logic Program-
ming Engine DLV16. The prototype is available as a plu-
gin at http://con.fusion.at/dlvhex/. The web-page also
provides an online interface for evaluation, where the reader
can check translation results for various example queries,
which we had to omit here for space reasons. We currently
implemented the c-joining and b-joining semantics and we
plan to gradually extend the prototype towards the features
mentioned in Sec. 5, in order to query mixed RDF+SPARQL
rule and fact bases. Implementation of further extensions,
such as the integration of aggregates typical for database
query language, and recently deﬁned for recursive Datalog
programs in a declarative way compatible with the answer
set semantics [9], are on our agenda. We are currently not
aware of any other engine implementing the full semantics
deﬁned in [16].

7. ACKNOWLEDGMENTS

Special thanks go to Jos de Bruijn and Reto Krummen-
acher for discussions on earlier versions of this document,
to Bijan Parsia, Jorge P´erez, and Andy Seaborne for valu-
able email-discussions, to Roman Schindlauer for his help
on prototype implementation on top of dlvhex, and to the
anonymous reviewers for various useful comments. This
work is partially supported by the Spanish MEC under the
project TIC-2003-9001 and by the EC funded projects Trip-
Com (FP6-027324) and KnowledgeWeb (IST 507482).
14http://triple.semanticweb.org/
15http://jena.sourceforge.net/
16http://www.dlvsystem.com/

8. REFERENCES
[1] C. Baral. Knowledge Representation, Reasoning and

Declarative Problem Solving. Cambr.Univ. Press, 2003.

[2] D. Beckett. Turtle - Terse RDF Triple Language.

Tech. Report, 4 Apr. 2006.

[3] J. de Bruijn, A. Polleres, R. Lara, D. Fensel. OWL DL

vs. OWL Flight: Conceptual modeling and reasoning
for the semantic web. In Proc. WWW-2005, 2005.
[4] J. Carroll, C. Bizer, P. Hayes, P. Stickler. Named

graphs. Journal of Web Semantics, 3(4), 2005.

[5] R. Cyganiak. A relational algebra for sparql. Tech.

Report HPL-2005-170, HP Labs, Sept. 2005.
[6] J. de Bruijn, E. Franconi, S. Tessaris. Logical

reconstruction of normative RDF. OWL: Experiences
and Directions Workshop (OWLED-2005), 2005.

[7] T. Eiter, G. Ianni, A. Polleres, R. Schindlauer,

H. Tompits. Reasoning with rules and ontologies.
Reasoning Web 2006, 2006. Springer

[8] T. Eiter, G. Ianni, R. Schindlauer, H. Tompits. A

Uniform Integration of Higher-Order Reasoning and
External Evaluations in Answer Set Programming.
Int.l Joint Conf. on Art. Intelligence (IJCAI), 2005.
[9] W. Faber, N. Leone, G. Pfeifer. Recursive aggregates

in disjunctive logic programs: Semantics and
complexity. Proc. of the 9th European Conf. on Art.
Intelligence (JELIA 2004), 2004. Springer.

[10] A. V. Gelder, K. Ross, J. Schlipf. Unfounded sets and
well-founded semantics for general logic programs. 7th
ACM Symp. on Principles of Database Systems, 1988.

[11] M. Gelfond, V. Lifschitz. Classical Negation in Logic

Programs and Disjunctive Databases. New Generation
Computing, 9:365–385, 1991.

[12] B. N. Grosof, I. Horrocks, R. Volz, S. Decker.

Description logic programs: Combining logic programs
with description logics. Proc. WWW-2003, 2003.

[13] P. Hayes. RDF semantics. W3C Recommendation, 10

Feb. 2004. http://www.w3.org/TR/rdf-mt/

[14] H. J. ter Horst. Completeness, decidability and

complexity of entailment for RDF Schema and a
semantic extension involving the OWL vocabulary.
Journal of Web Semantics, 3(2), July 2005.

[15] J. W. Lloyd, R. W. Topor. Making prolog more

expressive. Journal of Logic Programming,
1(3):225–240, 1984.

[16] J. P´erez, M. Arenas, C. Gutierrez. Semantics and

complexity of SPARQL. The Semantic Web – ISWC
2006, 2006. Springer.

[17] A. Polleres, C. Feier, A. Harth. Rules with

contextually scoped negation. Proc. 3rd European
Semantic Web Conf. (ESWC2006), 2006. Springer.

[18] E. Prud’hommeaux, A. S. (ed.). SPARQL Query

Language for RDF, W3C Working Draft, 4 Oct. 2006.
http://www.w3.org/TR/rdf-sparql-query/

[19] R. Rosati. Reasoning with Rules and Ontologies.

Reasoning Web 2006, 2006. Springer.

[20] SQL-99. Information Technology - Database Language

SQL- Part 3: Call Level Interface (SQL/CLI).
Technical Report INCITS/ISO/IEC 9075-3,
INCITS/ISO/IEC, Oct. 1999. Standard speciﬁcation.
[21] J. D. Ullman. Principles of Database and Knowledge

Base Systems. Computer Science Press, 1989.

WWW 2007 / Track: Semantic WebSession: Query Languages and DBs796