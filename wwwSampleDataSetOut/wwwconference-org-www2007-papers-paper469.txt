Preference(cid:173)based Selection of

Highly Conﬁgurable Web Services

Steffen Lamparter, Anupriya Ankolekar,

Rudi Studer

Institute AIFB, University of Karlsruhe (TH)

76128 Karlsruhe, Germany

{sla,aan,rst}@aifb.uni(cid:173)karlsruhe.de

Stephan Grimm

FZI Research Center for Information
Technologies, Karlsruhe, Germany

grimm@fzi.de

ABSTRACT

A key challenge for dynamic Web service selection is that Web ser-
vices are typically highly conﬁgurable and service requesters often
have dynamic preferences on service conﬁgurations. Current ap-
proaches, such as WS-Agreement, describe Web services by enu-
merating the various possible service conﬁgurations, an ineﬃcient
approach when dealing with numerous service attributes with large
value spaces. We model Web service conﬁgurations and associated
prices and preferences more compactly using utility function poli-
cies, which also allows us to draw from multi-attribute decision the-
ory methods to develop an algorithm for optimal service selection.
In this paper, we present an OWL ontology for the speciﬁcation
of conﬁgurable Web service oﬀers and requests, and a ﬂexible and
extensible framework for optimal service selection that combines
declarative logic-based matching rules with optimization methods,
such as linear programming. Assuming additive price/preference
functions, experimental results indicate that our algorithm intro-
duces an overhead of only around 2 sec. compared to random ser-
vice selection, while giving optimal results. The overhead, as per-
centage of total time, decreases as the number of oﬀers and conﬁg-
urations increase.

Categories and Subject Descriptors: H.3.5 [Information Systems]:
On-line Information Services – Web-based services; H.3.3 [Infor-
mation Systems]: Information Storage and Retrieval – Selection
process.

General Terms: Algorithms, Languages, Economics.

Keywords: Web Services, Customisation, Preference-based Ser-
vice Selection.

1.

INTRODUCTION

Web service discovery and selection have been extensively stud-
ied in recent years. As the set of available Web services may not be
known a priori, may change frequently or service requester require-
ments and preferences may change, the problem of dynamic Web
service selection is a fundamental one. Considerable research and
industry eﬀort has focussed on the (semantic) description of Web
services, leading to standards such as WSDL [36], WSMO [9] and
OWL-S [8]. One of the key open challenges is performing dy-
namic service selection for highly conﬁgurable Web services with
dynamic user preferences. Web services are typically highly con-
ﬁgurable, with signiﬁcant service customisation possibilities and
a choice of quality-of-service (QoS) properties, e.g. delivery/re-
sponse times, naturally each with its own price. Customisation is
critical for them to be able to diﬀerentiate themselves from com-

Copyright is held by the International World Wide Web Conference Com(cid:173)
mittee (IW3C2). Distribution of these papers is limited to classroom use,
and personal use by others.
WWW 2007, May 8–12, 2007, Banff, Alberta, Canada.
ACM 978(cid:173)1(cid:173)59593(cid:173)654(cid:173)7/07/0005.

peting Web services and oﬀer a better service experience to their
customers. Service requesters themselves have certain preferences
on which service conﬁgurations they want to use and their prefer-
ences may change dynamically. Given their signiﬁcance, there is a
strong need to support customisable services. However, we lack ef-
ﬁcient methods for the representation and matching of conﬁgurable
services.

Current approaches to modelling Web service conﬁgurations and
requester preferences, such as WS-Agreement [11], enumerate the
various possible service conﬁgurations, which is ineﬃcient when
dealing with multiple service attributes and their values. For ex-
ample, a service described by ﬁve attributes, each with ﬁve possi-
ble values, already leads to 3125 diﬀerent conﬁgurations. Given
this combinatorial increase, a functional description of service at-
tributes and their associated prices or preferences would be more
appropriate.

In this paper, we model service conﬁgurations and associated
preferences compactly using utility function policies [17, 20], which
provide a declarative mechanism for eﬃciently attaching price in-
formation to attribute values. This allows us to draw from the vast
literature on eﬃcient multi-attribute decision theory methods to de-
velop an algorithm for optimal service selection.
In addition, in
order to be able to compare service attributes correctly, we need
to describe them in a way that captures their semantics. We use
ontologies to describe services attributes and their values semanti-
cally, and extend the resulting semantic representation to include
oﬀers and requests. This allows us to deﬁne appropriate attribute
value matching rules for each kind of attribute.

The contributions of this work are three-fold. First, we develop
an OWL ontology for conﬁgurable Web service oﬀers and requests
that can represent (execution-) context-dependent user preferences
for functional and non-functional (e.g. QoS) properties within a
standards-based speciﬁcation language, thus extending current se-
mantic Web service description frameworks, such as OWL-S and
WSMO. Second, we present an optimal service selection mecha-
nism in the context of this framework and demonstrate its feasibil-
ity by analysing its performance. For large numbers of highly con-
ﬁgurable oﬀers, given the assumption of additive functions, experi-
mental results indicate that the algorithm introduces an overhead of
only 2 sec. compared to random selection, while giving optimal re-
sults. This represents a 35% slowdown at 1000 oﬀers and 1600 con-
ﬁgurations per oﬀer, which only decreases as the number of conﬁg-
urations rises. Third, our framework enables ﬂexible matching by
specifying declarative logic-based matching rules rather than hard-
coding the matching algorithm as is usual. By providing a declar-
ative mechanism that integrates optimization techniques, such as
linear programming, we achieve computational tractability while
obtaining a ﬂexible system where diﬀerent optimization and match-
ing algorithms can be seamlessly plugged in.

In the following, we ﬁrst discuss the requirements for a preference-

WWW 2007 / Track: Web ServicesSession: SLAs and QoS1013Web service

Web service

1. Request Route

Publish Service

Offer

2. Service

Lookup

Service

Repository

3. Invoke Route
Planning Service

Annika

4. Receive Route

Mobifhon

Figure 1: Example for dynamic Web service binding.

based service selection framework informally through a scenario in
Section 2 and discuss the state-of-the-art with respect to these re-
quirements. We then develop an abstract model that addresses the
requirements for conﬁgurable services, preferences over conﬁgu-
rations and service selection in Section 3. To enable the exchange
of oﬀers and requests in open heterogeneous environments, the ab-
stract model is implemented in Section 4 using standard Web lan-
guages. Based on this formalization, matching and optimization
rules for service selection are presented and evaluated (Section 5).
In Section 6, we present a proof-of-concept implementation of our
optimal service selection framework within the scenario developed
in Section 2. We conclude the paper with thoughts on the feasibil-
ity of optimal service selection within current Web scenarios and
point to future work directions.

2. REQUIREMENTS ANALYSIS

Consider Annika, a mobile phone user, who is currently in the
city of Karlsruhe in Germany and wants to know the driving di-
rections to Munich as soon as possible. Annika’s mobile network
operator, Mobifhon, provides route planning services for several
countries to its customers, dynamically outsourced from third party
route planning services on the Web, as sketched in Figure 1. Thus,
the service selection takes place at Mobifhon’s end. The service se-
lection is therefore not constrained by the limited resources and par-
tial connectivity of Annika’s mobile phone, while allowing Mob-
ifhon to aggregate demands and thus procure better discounts for
services than if each customer were to transact individually. Mob-
ifhon only sends the ﬁnal route to Annika’s mobile phone. For
the sake of illustration, in the we have chosen a relatively general
scenario for identifying the requirements, but one could imagine
several simpliﬁcations, e.g. where the service repository is located
with Mobifhon.

(R1) Service Conﬁgurations: The route planning services provide
various kinds of routes (the fastest, the shortest etc.) with or with-
out highways, identifying diﬀerent kinds of attractions on the way.
They also provide services at diﬀerent levels of service quality. A
more complex route planning, for example, will cost more than a
simple route and similarly a quick response will cost more than a
slower one. The various route planning services need to be able
to describe their capabilities and conﬁgurations to Mobifhon, such
that it can choose the appropriate one at the desired QoS level.
Thus, our system must support the description of various service
conﬁgurations.

Since WSDL lacks any support for modelling QoS character-
istics of Web services, there have been several proposals to ex-
tend WSDL with concrete QoS metrics, e.g. the Web service Level
Agreement (WSLA) project [14] and Web Service Modeling Lan-
guage (WSML) [31]. By generalising beyond QoS attributes, XML
query languages, like XQuery [39], and policy languages, like WS-
Policy [38], enable the expression of constraints on arbitrary at-

tributes. However, these approaches lack appropriate support for
attaching prices and also preferences which are addressed by re-
quirement (R2).
(R2) Context-dependent Preferences: Many of Mobifhon’s cus-
tomers have diﬀerent preferences about the services they use, based
on their current context, location, activities, etc. For example, An-
nika typically prefers to travel on highways but she is currently on
vacation and wants to travel through scenic country roads, possibly
making several stops at attractions on the way. Mobifhon chooses
route planning services, taking into account the requirements and
preferences of the user as well as its own preferences, e.g. on ser-
vice characteristics such as availability, response time, supported
encryption methods etc. Annika’s preferences may also depend on
her implicit context. For example, if she has an upcoming appoint-
ment in Munich the next day, she is more likely to prefer a short
route than a long scenic route. In fact, her context-dependent pref-
erences may be predeﬁned, allowing Mobifhon to choose her pref-
erences based on her context dynamically. To enable this, we need
a way to describe requests and preferences for particular service
conﬁgurations declaratively in terms of their attributes.

Requirement (R1) and (R2) are addressed by languages such
as WS-Agreement [11] and the Web Service Oﬀering Language
(WSOL) [34], which introduce classes of services that roughly cor-
respond to what we call service conﬁgurations and attach price and
preference information to conﬁgurations. Both languages require
the enumeration of the set of possible conﬁgurations. This is clearly
ineﬃcient for Web services whose attribute space is very large or
even inﬁnite (contradiction to (R4)). For example, the charges for
route plans levied by the route planning service may decrease lin-
early with the desired response time. To cover such requirements,
we use Utility Function Policies [17] to describe preferences and
prices as a function of service attribute values, and we use declara-
tive rules to model the context-sensitive nature of the preferences.
This is similar to the approach presented in [3], where personal-
ized service selection is realized by expressing preferences declar-
atively using SQL. However, since there is no rule support, context-
dependent preferences cannot be expressed. In addition, matching
algorithms required by (R3) are not supported there.
(R3) Semantic Web Service Descriptions: One of the advantages
of using semantic description languages like OWL-S and WSMO is
that one can use logical reasoning, in particular class subsumption,
to bridge diﬀerent levels of abstraction that occur when specifying
requests and oﬀers. Thus, if Annika has speciﬁed that she wants to
know about attractions on the route, Mobifhon can identify route
planning services with information about historical sites as being
relevant. Annika may also not want to deﬁne preferences for all
attributes. She may not know which attributes are used by the ser-
vices she is interested in and even if she did, it would be too tedious.
For example, she may want to say that she generally prefers histor-
ical sites to museums without specifying which particular types of
each she prefers and by how much. The service matching algorithm
needs to match her general preference to the actual attractions in-
formation provided by individual services. By modelling attributes
as classes in a Semantic Web language, we can classify them into
attribute hierarchies. It would not be possible to rely on semantic
reasoning alone for service discovery and selection, as others [18]
have also argued, since this only results in a coarse ranking.

There have been previous eﬀorts to augment OWL-S and WSMO
with QoS extensions [15, 33]. In addition, [21, 35] propose dy-
namic binding for Web service compositions using semantic ser-
vice descriptions. However, as with the Web service description
languages, they cannot be used to describe complex functional re-
lations. Recent research [12, 26] has tried to express such relations
declaratively, without however investigating how the performance
of service selection is aﬀected by the modelling of preferences and

WWW 2007 / Track: Web ServicesSession: SLAs and QoS1014matching rules. Thus, these approaches often fail with respect to
(R4). We use a decidable fragment of the rule language SWRL
[13] to express complex functional relations declaratively, and dis-
cuss the eﬀects of modelling on the performance of selection.

(R4) Communication and Computational Eﬃciency: A lesser
requirement, yet nonetheless critical for resource-constrained en-
vironments such as mobile services, is that the chosen representa-
tion be designed for communication eﬃciency and computational
tractability. I.e., the request has to be expressed in an eﬃcient way
(e.g. by avoiding enumeration of all possible conﬁgurations) and
the selection algorithm has to be eﬃcient enough to enable run-
time selection.

Policy languages are state-of-the-art for expressing Web service
conﬁgurations. However, as already discussed, while alleviating
the problem, they cannot solve it due to the exponential size of the
attribute space. We circumvent the problem using functional repre-
sentations (as suggested in [10, 4]) by introducing Utility Function
Policies. There is a vast amount of work in economics, and par-
ticularly in operations research, addressing the computational ef-
ﬁciency of decision making algorithms. In the context of service
selection, this is investigated in [5], focusing on the complexity of
service selection with one time costs and e.g. in [40, 35] for service
compositions. Like these approaches, our work utilises eﬃcient op-
timization techniques for service selection, but also augments them
with the required service description and matching models.

Based on these requirements, in the next section we develop an
abstract model for representing and selecting conﬁgurable services.

3. ABSTRACT SELECTION MODEL

Web service selection is the problem of selecting the best oﬀer
made by a service provider given a request. In order to perform
Web service selection, one requires (i) means for communicating
service oﬀers as well as requests to the other party and (ii) an algo-
rithm for ranking the oﬀers with respect to the request. Bidding lan-
guages are a well-established means for communicating requests
and oﬀers within economic literature.

Our abstract model essentially describes a Web service, Web ser-
vice oﬀers and requests and the Web service selection problem. We
take a fairly abstract view of a Web service in our model and con-
sider it to be fully described by properties A1 . . . , Al, . . . , An. Such
properties might comprise service input and output, behavioural as-
pects of a service, QoS attributes, etc., thus covering existing Web
service description approaches as well as fulﬁlling (R1). Such a
general description of a Web service allows us to abstract from var-
ious existing Web service description frameworks, while simulta-
neously allowing us to utilise existing decision-theoretic algorithms
for multi-attribute products.

During the execution of a Web service, each attribute is assigned
a value. A set C of Web service conﬁgurations comprises all pos-
sible combinations of attribute values, i.e. C = A1 × · · · × An. For
example, considering the attributes Attractions, Highways and Re-
sponse Time a concrete conﬁguration would be a service providing
routes including highways and information about nearby attractions
within 10 seconds. A speciﬁc value of Al is denoted by ale.

A Web service contract ti j is deﬁned as a tuple (c, π), where agent
j provides a Web service with conﬁguration c to a customer i at a
price of π ∈ R. Furthermore, let T j denote the set of all contracts in-
volving provider j, and Ti the set of contracts involving customer i.
Not all possible contracts are acceptable to an agent, and thus, only
subsets T ′
i ⊆ Ti are requested or oﬀered, respectively.

j ⊆ T j and T ′

3.1 Bidding Language

For our bidding language for highly conﬁgurable Web services
(R1), we draw from bidding languages for multi-attribute products

[10, 4]. In this context, a common technique to eﬃciently encode
pricing information (R4) is the use of functions that represent the
relationship between Web service conﬁgurations and their prices
or utilities (as discussed in (R2)). This avoids the combinatorial
explosion that results from adding price markups to each conﬁgu-
ration.

D 1

(W S O). An oﬀer by a provider j is
deﬁned as a pair (C j, P j) of a set C j ⊆ C of conﬁgurations and a
function P j : C → R mapping each conﬁguration c ∈ C j to a real
number that represents the price π of invoking service conﬁguration
c. As suggested by [4], the pricing function P j(c) is described by
a base price pbase
and an additive function that aggregates pricing
functions for individual attributes:

j

P j(c) = pbase

j +

n

Xl=1

w jl p jl(al) with

n

Xl=1

w jl = 1

(1)

where p jl represents the pricing function of provider j for a partic-
ular attribute Al. The weights w jl are used to adjust the inﬂuence
of the diﬀerent attributes on the price.

Thus an oﬀer assigns an additive pricing function to a Web ser-
vice description, mapping the conﬁgurations of the oﬀer to a certain
price. Analogously, we introduce a functional form for represent-
ing Web service requests. One major diﬀerence though is that a
requester’s willingness to pay might depend on a runtime speciﬁc
context (R2). Therefore, we introduce a set K = δ1 × · · · × δn of
execution contexts, where the δi represent diﬀerent context dimen-
sions, such as current location of a mobile device, time of service
execution, history of past transactions. Any k ∈ K denotes a con-
crete execution context.

D 2

(W S R). A Web service request by
requester i is deﬁned as a pair (Ci, Fi) of a set Ci ⊆ C of accept-
: Ci × K → R that maps
able conﬁgurations and a function Fi
each conﬁguration to a real number score depending on the ex-
ecution context k. Due to payment monotonicity [10], i.e. ∀π >
π′ : (c, π) ∈ T ′
i , we interpret Fi(c, k) as the max-
imal price for which a customer is willing to carry out the trade,
i.e. T ′
i = {(c, π) ∈ Ti|π ≤ Fi(c, k)}. Fi is an additive scoring function
composed of the attribute-speciﬁc functions fil and their relative
weights wil:

i ⇒ (c, π′) ∈ T ′

Pn
Fi(c, k) = 

−∞

l=1 wil fil(ale, k)

if c ∈ Ci,
otherwise.

with

n

Xl=1

wil = 1

(2)

A conﬁguration which is not requested is scored as minus inﬁnity.

Due to the additive form of the scoring function Fi, we have
to assume mutual preferential independency [16] between the at-
tributes in the scoring function. This holds if the utility of an at-
tribute Al does not depend on the value of another attribute. For
example, the score for a certain guaranteed response time will not
change if the type of indicated attractions changes.

3.2 Selection Mechanism

Service selection in the case of conﬁgurable services involves
ﬁnding the best provider and her best oﬀer. Therefore, we have
to solve two maximization problems: ﬁrst, the best contract for
a given provider has to be identiﬁed, the so-called Multiattribute
Matching Problem (MMP) [10]. Second, based on these results, the
best provider can be chosen. Service selection often requires trade-
oﬀs between the various attributes of conﬁgurable services. For
example, it can be hard to decide between a slow route planning
service that provides a lot of detailed information about en route
attractions and a fast service that provides only imprecise route

WWW 2007 / Track: Web ServicesSession: SLAs and QoS1015information. In economic literature, multi-attribute utility theory
(e.g. [16]) uses utility functions to make such decisions, mapping
each alternative to a measure that can be used to rank the alterna-
tives. In our case, the utility of a service conﬁguration is given by
a quasi-linear function representing the diﬀerence between the re-
quester’s preference score for the conﬁguration and its price. The
MMP is thus deﬁned as follows:

D 3

(MMP). Given a request (Ci, Fi), an oﬀer (C j, P j)
and an execution context k, we solve the MMP by maximizing the
requester’s utility per service conﬁguration. The solution of the
MMP for a given requester i and provider j is referred to as ui j in
the following.

ui j = max
c∈Ci ∩C j

Fi(c, k) − P j(c)

(3)

Our assumptions of additive pricing and scoring functions al-
low us to simplify the MMP. In particular, we can decompose the
calculation into individual subproblems which can be solved inde-
pendently. The following equations (4-6) use this property to solve
Equation 3 eﬃciently by reducing the number of iterations from

O(|Ql Al|) to O(Pl |Al|). The binary decision variable xle is asso-

ciated with each attribute value and denotes whether the value is
part of the best conﬁguration. Equation 5 ensures that exactly one
attribute value is selected for each attribute. Since the following in-
teger programming formulation has a totally unimodular constraint
matrix and only integers on the constraints’ right-hand sides, the
problem can be solved eﬃciently using the simplex algorithm [28].

max

s.t.

n

Xl=1

|Al |

Xe=1

(wil fi(ale, k) − w jl p j(ale))xle − pbase

j

|Al |

Xe=1

xle = 1

for 0 < l ≤ n,

xle ∈ {0, 1}

for 0 < l ≤ n, 0 < e ≤ |Al|

(4)

(5)

(6)

In a second step, we have to ﬁnd the best provider from the set
of all oﬀers. Obviously this implies that the best contract for each
provider is known, i.e. the MMP is solved for each pair of a request
and an oﬀer. We can then determine the best provider by solving
Local Allocation Problem (LAP).

D 4

(LAP). Given a single request (Ci, Fi) and m of-
fers (C j, P j), the Local Allocation Problem can be solved by iterat-
ing over all oﬀers and determining the maximal solution for MMP.

max
j=1,...,m

ui j

(7)

Solving LAP is linear with respect to the number of oﬀers and re-
quires O(m) steps. However, there are several scenarios where LAP
is not suﬃcient for service selection. First, if we relax the require-
ment for quasi-linearity of the utility function, e.g. by allowing one
time costs, the problem will get considerably more complex.
It
can be shown by reduction of the Uncapacitated Facility Location
Problem that computing the optimal service in such scenarios is in
FPNP [5]. Second, for the problem formulation in this section, we
assume that oﬀered services are always available for all requesters
and that possible resource limitations are handled at the provider
side, e.g. by adapting the guaranteed service levels or by increasing
server capacity. LAP also needs to be extended to handle scarce
resources. This is done, e.g. in [32] using a double auction or in [7]
by means of scheduling algorithms. Third, LAP could be gener-
alized for entire service compositions such as in [40]. The tech-
niques presented later in this paper can also be applied to these new
problems, requiring only the rewrite of a single rule to change the
selection strategy.

4. ONTOLOGY(cid:173)BASED REPRESENTATION
Given the abstract selection model above, we now focus on im-
plementing this model using existing standards and tools for the
open and heterogenous Web environment. We use the Web Ontol-
ogy Language OWL [37] together with its rule extension SWRL [13]
to implement our service selection framework, which allows us
to perform sophisticated matchmaking and ranking of services by
means of logical inferencing. We build on well-known notions of
matching for Semantic Web services, such as subsumption-based
“plugin" or “exact" matches [27] and develop a ﬂexible and exten-
sible framework of declarative matching and optimization rules.

4.1 Ontology Formalism

OWL is an ontology language standardized by the World Wide
Web Consortium (W3C) [37] and is based on the description logic
(DL) formalism [2]. Due to its close connection to DL it facilitates
logical inferencing and allows to derive conclusions from an ontol-
ogy that have not been stated explicitly. We brieﬂy review some of
the modelling constructs of OWL using its abstract syntax.

The main elements of OWL are individuals, properties that relate
individuals to each other and classes that group together individu-
als which share some common characteristics. Classes as well as
properties can be put into subsumption hierarchies. Furthermore,
OWL allows for describing classes in terms of complex class con-
structors that pose restrictions on the properties of a class. For
example, the statement Class(BigCity partial restriction(connectedTo
someValuesFrom Highway)) describes the class of big cities, which are
connected to some Highway. The keyword partial means that any
big city is connected to some highway, but not any city connected
to a highway is also necessarily big, which would be achieved by
using the keyword complete instead. Subclass relationship can be
expressed by a statement like SubClassOf(BigCity InterestingCity), say-
ing that any big city is also interesting. Individuals can be related
to classes and assigned values by a statement like Individual(Munich
type(BigCity) value(locatedIn Germany) value(population 1314551)). Be-
sides introducing Munich as a big German city, this statement also
includes a data value for the city’s population, which is supported
by OWL for various datatypes such as integer or string.

An OWL ontology consists of statements like the ones above,
considered logical axioms from which an agent can draw logical
consequences. For example, given an ontology O consisting of
the above statements, it follows that Munich is an interesting city,
which is denoted by O |= InterestingCity((Munich)).

For the declarative formulation of matching directives in form
of rules, we require additional modelling primitives not provided
by OWL. We use the Semantic Web Rule Language (SWRL) [13]
which allows us to combine rule approaches with OWL. We restrict
ourselves to a fragment of SWRL called DL-safe rules1 [24], which
is more relevant for practical applications due to its tractability and
support by inference engines such as KAON22. For the notation of
rules we rely on a standard ﬁrst-order implication syntax.

4.2 Speciﬁcation of Offers and Requests

In this section we present an ontology-based modelling approach
for Web service oﬀers and requests which is in line with Deﬁni-
tion 1 and 2 of our abstract model. For the reader’s convenience
we present the most parts of our ontological model informally via
UML class diagrams, where UML classes correspond to OWL con-
cepts, UML associations to object properties, UML inheritance to
subconcept relations, UML attributes to OWL datatype properties
and UML dependencies to OWL class instantiation [6].

1DL-safety restricts the application of rules to individuals that are
explicitly mentioned in the ontology. However, this restriction does
not aﬀect the suitability of DL-safe rules in our selection scenario.
2http://kaon2.semanticweb.org/

WWW 2007 / Track: Web ServicesSession: SLAs and QoS1016Figure 2 shows a top-level view of our ontological model, which
can be split into two conceptual levels: the upper part a) captures
the elements of the abstract model introduced in Section 3, while
the lower part b) exemplarily captures certain available domain on-
tologies that are plugged in for the matchmaking of attribute values.

Web Service Description Ontology. Recalling deﬁnitions 1
and 2, oﬀers and requests specify a set C of supported conﬁgura-
tions in our abstract model, which they map to prices and scores,
respectively. This is captured in the ontological model shown in
Figure 2 a) by the classes in the two boxes for description of Web
services and policies. The classes Oﬀer and Request are introduced
as subclasses of the more general Bid, by which they are connected
to the policies used to deﬁne their pricing and scoring functions.
They represent the sets C j and Ci of conﬁgurations for a provider or
requester. Instead of relating oﬀers and requests to conﬁgurations
directly, as done in the abstract model, we introduce the interme-
diary concept Service to capture technical service-speciﬁc aspects.
Oﬀers and requests are then related to a service which in turn sup-
ports various conﬁgurations. Referring to pairs of attributes Al and
their values ale, the class Conﬁguration represents the combinations
of attribute values that a provider or customer support. This upper
part of our ontology can be seen as extensions of existing Web ser-
vice description ontologies such as OWL-S or WSMO by using
these ontologies to deﬁne the type of Attributes. For instance, by
introducing the concepts Input, Output, Result, etc. as specialisa-
tion of Attribute our ontology can be aligned to the OWL-S proﬁle.
To give an example, recall our mobile phone scenario, where our
user Annika requests route planning from Karlsruhe to Munich in
at most 30 seconds while she wants nearby castles to be indicated
along the route. For convenience, we illustrate the instantiation of
elements for service description, such as Conﬁguration, by an in-
tuitive notation of pairs of attributes and their values, while we use
OWL abstract syntax for details concerning the attribute values in
domain ontologies. Colon-separated namespace preﬁxes indicate
the origin of an entity in a domain ontology. An example of a sup-
ported conﬁguration ci for a service that Mobifhon launches as a
request based on the above parameters could look as follows.

ci

= ( ServiceType = scl : RoutePlanningService

StartPoint = geo : Karlsruhe
EndPoint = geo : Munich
Attractions = tourism : Castle
ResponseTime = 30 sec )

On the other hand, an example for a conﬁguration c j supported

by an appropriate provider could look like this.

c j

= ( ServiceType = ServiceSupportingNavigation

StartPoint = geo : Germany
EndPoint = geo : Germany
Attractions = tourism : CulturalAttraction
ResponseTime = 1 min )

equivalentClasses(ServiceSupportingNavigation intersectionOf(

scl : Service restriction(scl : supports someValuesFrom(scl : Navigation))))

Deﬁnition 1 and 2 introduce a compact functional form for ex-
pressing pricing and scoring information. This avoids introduc-
ing a separate class Price to model the tertiary relation between
Price, Conﬁguration and Oﬀer/Request explicitly. Although such
an approach would be most natural, it would result in a signiﬁ-
cant modelling overhead and does hardly scale up, as shown in our
previous work [19]. For modelling functions we introduce the no-
tion of Policies. Generally policies are declarative rules that guide
the decision making of an agent. We use a speciﬁc class of poli-
cies, called utility-function policies [17], which allow for represent-
ing trade-oﬀs between diﬀerent Web service attributes by mapping
their values to a comparable quantitative measure. Approaches on
how such policies are expressed via an ontology are discussed in

[20]. Namely there are three modelling techniques: Point Based
Functions, Piecewise Linear Functions and Pattern-based Func-
tions. To illustrate the idea, the concept Point Based Function is
introduced in more detail.

A Point Based Function can be used for discrete attributes and
is modeled by specifying sets of Points that explicitly map attribute
values ale referred to in an Attribute Value Pair to a price fil(ale) or
p jl(ale). To indicate the Attribute for which a certain Policy is ap-
plicable, the isAssignedTo-relation is introduced that points to one
of the Attributes in the Web service description. Coming back to
our example, assume Annika generally prefers cultural attractions
to sports events with the only exception that she hates museums.
We can model such a preference structure by instantiating a point-
based policy function assigned to the attribute Attractions. Map-
ping a utility of 1, 0.5 and 0 to the three alternatives results in the
following speciﬁcation of the function’s component fil for this par-
ticular attribute.

ale

fil(ale)

CultureWithoutMuseum 1

tourism : SportsEvent

0.5

tourism : Museum 0

equivalentClasses(CultureWithoutMuseum intersectionOf(

tourism : CulturalAttraction complementOf(tourism.Museum)))

The table maps alternative values for the attribute Attractions to

the utility values that specify Annika’s preferences.

Domain Ontologies for Attribute Values. The attributes
A1, . . . , An in the abstract model represent generic characteristics of
a service and can potentially originate from a given domain, de-
pending on the kinds of services to be described.
In our frame-
work, we support this by plugging in various domain ontologies –
depicted in Figure 2 b) – that describe attribute values, such as a
classiﬁcation of service types or geographic or tourism knowledge
for attributes like StartPoint or Attractions. During the matchmak-
ing process, this knowledge is, for example, used to detect that a
service supporting navigation is equivalent to a route planning ser-
vice, that Munich is in Germany, or that a castle is a historic site.

Assuming appropriate domain ontologies are available and agreed
by providers and customers, they are linked to our ontology by their
elements, such as the class InformationService or the individual
Munich, being instances of the class AttributeValue. The value for
the attribute EndPoint would be a URI like http://geo.owl#Munich
that points to a location in a geographic ontology3.

In our example, the notions of “route planning service" and “ser-
vice that supports navigation" are captured in the service classiﬁca-
tion ontology Oscl that states them to be equivalent.

Ontology( Oscl

Class(RoutePlanningService complete intersectionOf(

Service restriction(supports someValuesFrom(Navigation))))

...)

Also the values “Karlsruhe", “Munich" and “Germany" are covered
in a domain ontology, namely in the geographical ontology Ogeo,
where the two cities are stated to be located in Germany.

Ontology( Ogeo

Individual(Karlsruhe type(City) value(locatedIn Germany))
Individual(Munich type(City) value(locatedIn Germany))
...)

Moreover, the values “cultural attraction" and “castle" for the at-
tribute Attractions are related by subsumption in the ontology Otourism
that describes notions of leisure.

Ontology( Otourism

subClassOf(HistoricSite CulturalAttraction)
subClassOf(Castle HistoricSite) ...)

3Notice, that the OWL-Full language variant supports metamod-
elling, i.e. an URI can denote a class and an individual at the
same time. Although metamodelling is outside the DL formalism,
KAON2 can handle such URIs to a certain extend [22].

WWW 2007 / Track: Web ServicesSession: SLAs and QoS1017a)

Description of Web Service Offers/Requests

Service

contains

Bid

-WSDLreference:string(xsd)

defines

isValidIn

Policies

Context

Dimension

Description of Policies

has

Dimension

supports

provides

Configuration

requests

Offer

Request

PointBasedFunction

constitutedBy

next

Point

-price:double(xsd)

-score:double(xsd)

-price:float(xsd)

hasAttribute

Attribute

constitutedBy

isAssignedTo

PiecewiseLinearFunction

refersTo

AttributeValue

AttributeValuePair

hasValue

attributeValue

PatternBasedFunction

-patternIdentifier - xsd:string
-PatternParameter1 - xsd:Float
-...
-patternParameterN - xsd.Float

b)

Service

supports

Activity

Country

locatedIn

City

Navigation

MoneyTransfer

...

...

Attraction

...

CulturalAttraction

SportsEvent

...

Germany

Karlsruhe

Munich

...

supports

BankingService

RoutePlanningService

Service Classification

locatedIn

locatedIn
Geographic Knowledge

HistoricSite

Museum

...

Castle

Monument

Tourism Knowledge

Figure 2: Ontology for representing Web service oﬀers and requests

5. SERVICE SELECTION

Having shown how descriptions of conﬁgurable Web services of-
fers and requests are captured by an ontological model, we now de-
scribe how the actual selection of a service is carried out by solving
LAP using logical inferencing on the ontological elements intro-
duced above.

In order to derive a ranked list of the oﬀer instances from the
knowledge base, we formulate a query that refers to a Request in-
stance r containing preferences and to an instance k representing
the current Context. In addition, to reduce the number of oﬀers that
have to be ranked we can add mandatory conditions directly to the
query using the SPARQL FILTER element. This is exempliﬁed in
Query 8, where only services that provide a guaranteed response
time of less than 20 sec. are retrieved.

PREFIX ex: < http://example.org/ns# >
SELECT ?O , ?U WHERE {
?O ex:provides ?S . ?S ex:supports ?C . ?C ex:refersTo ?A .
?A ex:hasAttribute ex:ResponseTime ; ex:hasValue ?V .
FILTER (?V < 20) . EVALUATE mmp(r, ?O, c, ?U) .}
ORDER BY DESC(?U)

(8)

Conceptually answering such a query can be broken down into
two highly connected parts: (i) determining matches between of-
fers and requests by comparing the respective service attributes,
and (ii) ranking the various conﬁgurations provided in the oﬀer ac-
cording to the preferences in the request. In the following, we ﬁrst
discuss how matching of attribute values is realized and show how
these matching rules are applied to deﬁne variants of optimization
predicate mmp used in Query 8. Subsequently, we evaluate these
algorithms in terms of performance and discuss their applicability
for service selection.

5.1 Matching

The comparison between a requested attribute value and an of-
fered attribute value is fundamental. In the context of matchmaking
in the Semantic Web, various techniques have been proposed for
comparing the characteristics of two semantically annotated ser-
vices. The most widely used approach for descriptions based on

OWL classes is to use DL inferencing, distinguishing between sev-
eral notions of match based on subsumption or concept satisﬁabil-
ity. For two OWL classes CR and CO that represent attribute values
of a request or an oﬀer, the degrees of match proposed in [27] are:
exact if CR and CO are equivalent, plugin if CR is a subclass of CO,
subsumes if CO is a subclass of CR, intersect if the conjunction of
CR and CO is satisﬁable, and fail if the conjunction of CR and CO is
unsatisﬁable.

We support these notions of match in our framework, and also al-
low for others by including customisable matching predicates into
the service selection algorithm. In fact, since we use a declarative
formalism to describe how attribute values are matched, a user can
bring in arbitrarily complex matchmaking behaviour expressed in
rules which facilitates the adaption of the selection component to
changing service descriptions (e.g. with new attributes). Contrarily,
other approaches use hard-coded algorithms to process the results
of attribute matching that are speciﬁc to e.g. input/output matching,
as done in [27]. Since we keep attributes in Web service conﬁg-
urations rather generic, the way in which two attribute values are
compared strongly depends on the domain of interest they originate
from and on the way in which they are represented in there.

In our example, the values of the attributes ServiceType and Indi-
catedAttractions are concepts in an ontology, and thus, the formerly
described degrees of match apply to them and can be used for their
comparison. The following rule deﬁnition speciﬁes the matching
predicate for service types, requiring them to yield an exact match.

match(?P1, ?P2) ← hasAttribute(?P1, ServiceType),

hasValue(?P1, ?V1), hasAttribute(?P2, ServiceType),
hasValue(?P2, ?V2), exact(?V1, ?V2)

(9)

In our example, the scl : RoutePlanningService indeed yields an
exact match with the provided ServiceSupportingNavigation, since
Oscl entails their equivalence. The attribute ServiceType itself is
an instance of the class Attribute in the model shown in Figure 2.
Analogously, values of the attribute Attractions could be matched
using the predicate plugin(x, y) instead of exact(x, y), and again
the provided attribute value would match the requested one, since
Otourism |= subClassOf(Castle CulturalAttraction).

WWW 2007 / Track: Web ServicesSession: SLAs and QoS1018The values of the attributes StartPoint and EndPoint from the
example represent individual locations in a geographic ontology
and require a diﬀerent treatment. Here the modeller speciﬁes the
customised matching behavior for location attributes by introduc-
ing a class Location as a subclass of Attribute, of which StartPoint
and EndPoint are instances. The appropriate matching behaviour
is then captured by the following rule.

match(?P1, ?P2) ← hasAttribute(?P1, ?A1), hasValue(?P1, ?V1),

hasAttribute(?P2, ?A2), hasValue(?P2, ?V2), Location(?A1),
Location(?A2), matchLocation(?V1 , ?V2)

matchLocation(x, y) = (true

f alse

Ogeo |= locatedIn(x, y)
otherwise

(10)

(11)

The predicate matchLocation is realized as a builtin using a sep-
arate call to a description logic reasoner, just as in exact(x, y) or
plugin(x, y) before. In the example, the oﬀered value would again
match the request, since Karlsruhe and Munich are both located in
Germany according to Ogeo.

Finally, there are attributes which do require a complex match-
ing in terms of logical reasoning, but where a simple and eﬃcient
string comparison or arithmetic calculations are suﬃcient. In this
case, the modeler of a matching rule can include predeﬁned builtin
predicates deﬁned in SWRL. From our example, the QoS attribute
ResponseTime falls into this category, and is processed according
to the following rule speciﬁcation.

match(?P1, ?P2) ← hasAttribute(?P1, ?A1), hasValue(?P1, ?V1),

hasAttribute(?P2, ?A2), hasValue(?P2, ?V2), QoS Attribut(?A1 ),
QoS Attribut(?A2 ), equals(?V1, ?V2)

(12)

Also here a subclass of Attribute, namely QoSAttribute, is intro-
duced to enable the speciﬁcation of the matching behavior for all
QoS attributes, such as ResponseTime, by a single rule.

Based on deﬁnitions above, we can deﬁne a shortcut for match-

ing two arbitrary conﬁgurations as follows:

compare(?C1 , ?C2) ← ^l=1,...,n

attrCompare(Al , ?C1 , ?C2)

(13)

attrCompare(?A, ?C1 , ?C2) ← re f ersT o(?C1, ?P1), re f ersT o(?C2, ?P2),

hasAttribute(?P1, ?A), hasAttribute(?P2, ?A), match(?P1, ?P2)

(14)

5.2 Ranking

In the following, we show how the matching predicates intro-
duced in the previous section can be used within the optimization
rule mmp in order to determine the utility measure for the indi-
vidual attribute values. We deﬁne three alternative variants of the
mmp-predicate, which considerably diﬀer in their underlying as-
sumptions, applicability and performance characteristics. While
the ﬁst variant [V1] implements the ranking based on enumerating
the conﬁgurations (Equation 3), [V2] solves MMP on per attribute
basis using Equation 4-6. [V3] goes a step beyond [V2] by utilizing
the linear program formulation.

[V1] This variant implements Equation 3, where a ranking of all
oﬀers and conﬁgurations is derived by evaluating all possible con-
ﬁgurations for each oﬀer according to a request. We can model the
problem purely based on DL-safe rules using some standard SWRL
builtin functions. Rule 15 calculates the diﬀerence between score
and price of each Conﬁguration that is supported by an Oﬀer as
well as asked for in the Request. The compare-predicate deﬁned in
Rule 14 is used to match two conﬁgurations.

mmp(?R, ?O, ?K, ?U) ← provides(?O, ?S 1), supports(?S 1, ?C1),
requests(?R, ?S 2), provides(?S 2, ?C2), compare(?C1, ?C2),
price(?O, ?C1, ?P), score(?R, ?C2, ?K, ?S ), sub(?S , ?P, ?U)

(15)

Algorithm 1 Determine optimal attribute value for two policies

function F(Policy f1, Policy f2)

SELECT ?U WHERE {

f1 constitutedBy ?P1 . f2 constitutedBy ?P2 .
?P1 attributeValue ?V1 ; price ?X .
?P2 attributeValue ?V2 ; price ?Y .
?V1 match ?V2 . EVALUATE ?U := dif(?X,?Y) .

} ORDER BY DESC(?U)
return ﬁrst element of result set

all ale provided in a conﬁguration c. Attribute values are matched
by means of the matching predicate deﬁned in the previous section.
The price-relation is deﬁned analogously, but without the context-
dependency represented by the relation isValidIn.

score(?R, ?C, ?K, ?U) ← ^l=1,...,n

(re f ersT o(?C, ?AV Pl),

hasAttribute(?AV Pl, ?Al), de f ines(?R, ?Fl ), isAssignedT o(?Fl, Al),
isValidIn(?Fl , ?K), constitutedBy(?Fl, ?Pl), price(?Pl, Vl),
attributeValue(?Pl, ?AVl), match(?AV Pl, ?AVl)),
sum(?V1, . . . , ?Vn, ?U)

(16)

Advantages of this approach are that one can get a full rank-
ing of all conﬁgurations, which might be required in some appli-
cations. Furthermore, it can be modelled purely based on standard
modelling primitives provided by OWL-DL and SWRL. However,
the disadvantages are also evident. Since the approach is based on
enumerating all conﬁgurations, a ﬁnite number of conﬁgurations is
required and thus the approach is not suitable in the presence of
continuous attributes. As already discussed in Section 3, another
fundamental problem is the complexity with respect to the number
of required utility calculations.

[V2] The second variant of the mmp-predicate implements the de-
composed optimization algorithm described in Equation (4-6). In
this context we utilize the additive structure of the pricing as well
as scoring functions: the optimal value for each attribute is deter-
mined separately and the overall price/score is calculated based on
these measures. Equation 17 determines the utility of an oﬀer ac-
cording to request in a speciﬁc execution context.

mmp(?R, ?O, ?K, ?U) ← Request(?R), Oﬀer(?O)

^l=1,...,n

(deﬁnes(?R, ?Fl ), isValidIn(?Fl , ?K), isAssignedTo(?Fl , ?Al),

deﬁnes(?O, ?Pl), isAssignedTo(?Pl, ?Al), optFkt(?Fl , ?Pl, ?Ul )),
sum(?U1 , . . . , ?Un , ?U)

(17)

Since the calculation of the optimal value for a certain attribute
requires iterating over an unknown number of attribute values (in-
stances), the calculation cannot be directly expressed in SWRL. We
thus use a builtin function, called optFkt, to determine the attribute
value ale maximizing the utility fil − g jl of attribute l. Algorithm 1
shows the implementation of the builtin-predicate speciﬁcally for
Point-based Functions. In the predicate optFkt for each attribute
the requester and provider policies are queried from the knowledge
base and the attribute value leading to the maximal utility is de-
termined. A major advantage of the approach is that this query
uses the match-predicate deﬁned in the ontology. Thus, the correct
matching algorithm is used for each attribute automatically and the
implementation of the builtin is domain independent.

[V3] The third variant of the algorithm implements also the de-
composed ranking algorithm described in Equation (4-6), but with
some additional optimizations.

mmp(?R, ?O?, ?C, ?U) ← Request(?R), Oﬀer(?O),

optLP(?R, ?O, ?C, ?U)

(18)

Since pricing and scoring information are not explicitly given,
the two predicates price and score are used to calculate this infor-
mation based on the Policies deﬁned in the oﬀer or request, respec-
tively. Rule 16 calculates the score Fi(c, k) by evaluating fil(ale) for

This time we use a linear programm to calculate the optimal at-
tribute value. The calculation is encapsulated within the builtin
optLP (Algorithm 2). The builtin performs a query to get the rele-
vant utilities for the attribute values. This is done again by utilising

WWW 2007 / Track: Web ServicesSession: SLAs and QoS1019Algorithm 2 Optimization built-in using Linear Programming

function LP(Request r, Oﬀer o, Context k)

resultList := SELECT ?A, ?W, ?U WHERE {

o deﬁnes ?F1 . r deﬁnes ?F2 .
?F1 constitutedBy ?P1 ; isAssignedTo ?A .
?F2 constitutedBy ?P2 ; isValidIn k; isAssignedTo ?A .
?P1 attributeValue ?V1 ; price ?X .
?P2 attributeValue ?V2 ; price ?Y .
?V1 match ?V2 . EVALUATE ?U := dif(?X,?Y) .}

U n×maxl |Al | = ule with (l, e, ule) ∈ resultList

determine u by solving max{U T x|∀l : Pe xle = 1, x ∈ {0, 1}}

return u for given Oﬀer o and Request r

the match-predicate from the ontology. The optimization problem
is constructed and solved using a standard optimization library.4
This approach has the advantage that we can use the eﬃcient im-
plementations for solving integer linear programs provided by stan-
dard tools.

In contrast to the ﬁrst optimization algorithm, variant [V2] and
[V3] can be easily adapted to handle continuous attributes by in-
troducing appropriate builtins for optFkt and optLP. However, it is
not possible to get a ranked list enumerating all oﬀers and conﬁgu-
rations, as it is possible using the ﬁrst approach. Nevertheless, for
most applications determining the ranked list of oﬀers is suﬃcient.
In the next section we compare the diﬀerent modelling approaches

with respect to their performance in the selection process.

5.3 Performance Evaluation

Having introduced an approach for preference-based selection of
conﬁgurable Web services, the question arises how this increased
expressivity inﬂuences the performance of the selection process. In
particular, we are interested in the trade-oﬀ between performance
and optimality. Therefore, the three selection variants introduced
in Section 5.2 are compared to an algorithm that randomly selects
an oﬀer and conﬁguration. All algorithms are evaluated for vary-
ing number of oﬀers in the knowledge base and varying numbers
of conﬁgurations per oﬀer. Each of these settings is evaluated by
means of a simulation. Only settings with string matching rules
have been used. Performance evaluations of query answering with
more complex matching rules is a complementary question and has
already been elaborated in [23] for KAON2. For each setting, in-
stances of oﬀers, requests and contexts are randomly generated us-
ing a uniform distribution and stored in the knowledge base. Then
SPARQL-queries are generated according to Equation 8 (without
any FILTER condition) referring to a speciﬁc execution context
and request in the knowledge base. The time between sending the
query and receiving the result is measured. In order to avoid pos-
sible network delays the simulation is done on a single machine.
For each setting the average query time is determined based on 20
simulation runs. Using this simulation setup the following issues
are addressed:

How does the performance change when moving towards preference-
and context-aware selection strategies? How expensive is optimal-
ity? To investigate the additional time required for evaluating the
oﬀers and conﬁgurations according to preferences, we compare the
most general optimal variant [V1] with a baseline algorithm that
randomly selects an oﬀer and corresponding conﬁguration from the
knowledge base. Figure 3 shows the interrelation between the num-
ber of oﬀers in the knowledge base, the number of conﬁgurations
in an oﬀer and the resulting query time. In the ﬁrst setting (Figure
3(a)) each bid contains exactly 100 conﬁgurations. Service selec-
tion can be done in less than a second for 2000 oﬀers using the
random algorithm, while [V1] requires about 17 seconds. As de-

4For our implementation we currently use the LP solver lp_solve
5.5 (http://lpsolve.sourceforge.net/5.5/).

picted in Figures 3(b) and 3(c), the gap increases further for more
demanding settings. However, the random approach leads to a con-
siderable loss in utility for the requester. Assuming a uniform dis-
tribution of the prices and scoring values in [0,1] and a reasonable
number of oﬀers (> 50) an optimal algorithm leads to a utility of al-
most 1 while the random algorithm results only in a average utility
of 0.

Can we improve the performance of optimal selection by constrain-
ing the bidding language? How does the performance of the opti-
mal selection variants diﬀer? Variants [V2] and [V3] of the mmp-
predicate assume an additive structure of the pricing and scoring
function. As discussed above, this allows a more eﬃcient imple-
mentation.
[V2] reduces the runtime compared to [V1] from 17
to 11 seconds in the ﬁrst setting and from 477 to 41 in the sec-
ond setting (both with 2000 oﬀers). [V3] further reduces the run-
time to 5 and 13 seconds, respectively.
If we now compare this
improved performance to the random algorithm, the cost of opti-
mality is rather moderate. In particular, considering setting 3 with
1000 oﬀers and 1600 conﬁgurations per oﬀer, there is only a slow-
down by 35% when moving from random selection to [V3] (Figure
3(c)). Comparing this number to smaller settings we can observe
much greater slowdowns which, at ﬁrst glance, seems contradic-
tory. However, this observation can be explained by the fact that
for large-scale scenarios (more that 1000 conﬁgurations per oﬀer)
query answering becomes the predominant factor compared to the
optimization in [V3]. Since query answering is required for both
algorithms, variant [V3] and random selection converge.

5.4 Discussion

In this section, we presented an ﬂexible approach for assign-
ing syntactic as well as semantic matching predicates to attributes.
These predicates are automatically applied for matching attribute
values in the optimization process. In general, the results of the
performance evaluation are promising since the fastest approach
allows ranking up to 2000 oﬀers with a reasonable number of con-
ﬁgurations below 15 seconds. Considering the fact that these 2000
oﬀers all fulﬁll the mandatory conditions deﬁned in the FILTER
condition of Query 8, this can already be seen as a very large sce-
nario. Moreover, we analysed the worst-case scenario where all
oﬀers provide all possible conﬁgurations and all attributes are dis-
crete. Optimization on discrete attributes is more time consuming
compared to the continuous case because techniques like diﬀeren-
tiation are not applicable. Therefore, we expect better performance
in a real-world use case.
In our mobile scenario, only up to 20
diﬀerent route planning providers might be available, whereas the
number of possible conﬁgurations may easily exceed 1000. How-
ever, it is unlikely that all of them are oﬀered by all providers.

As a further result of our performance study, it becomes clear
that providing expressive means for modelling preferences as done
in [12, 26] is not suﬃcient without ensuring that the way they
are used allows for the implementation of eﬃcient selection algo-
rithms. Comparing the results for [V2] and [V3], we can iden-
tify the absence of the additivity assumption as the major source of
complexity (improvement from [V1] to [V2]). Using an eﬃcient
implementation for solving the optimization problem provides a
relatively minor improvement (improvement from [V2] to [V3]) in
performance. Therefore, in many cases, especially if service selec-
tion has to be done at runtime, restricting the expressiveness of the
bidding language is a viable way to considerably increase perfor-
mance. Even if preferential independency does not hold exactly,
additive functions often provide a good approximation [30]. If this
simpliﬁcation is not possible, other methods for improving the per-
formance of [V1] can be introduced, e.g. a caching mechanism for
prices and scores that reduces the number of rule evaluations [19].
A further conclusion is that in some very demanding settings, re-

WWW 2007 / Track: Web ServicesSession: SLAs and QoS1020[V1]
[V2]
[V3]
random selection

 25000

 20000

 15000

 10000

 5000

s
m
n

 

i
 

e
m

i
t
 
y
r
e
u
q

 60000

 50000

 40000

 30000

 20000

 10000

s
m
n

 

i
 

e
m

i
t
 
y
r
e
u
q

[V1]
[V2]
[V3]
random selection

 60000

 50000

 40000

 30000

 20000

 10000

s
m
n

 

i
 

e
m

i
t
 
y
r
e
u
q

[V1]
[V2]
[V3]
random selection

 0

 0

 500

 1000

 1500

 2000

number of offers in KB

 0

 0

 500

 1000

 1500

 2000

 0

 0

 400

 800

 1200

 1600

number of offers in KB

number of configurations per offer

(a) 100 conﬁgurations per oﬀer

(b) 1000 conﬁgurations per oﬀer

(c) 1000 oﬀers in KB

Figure 3: Performance of service selection.

ducing the set of relevant oﬀers is crucial. This can be realized by
adding additional mandatory conditions through FILTER expres-
sions.

6. PROTOTYPE

As a proof of concept, we implemented the algorithms presented
in this paper in a framework consisting of two components.5 The
ﬁrst is a server component that provides a repository for service of-
fers and requests that can be queried via a Web service interface and
the DL reasoner KAON2. KAON2 is chosen because it supports
the logical fragment required for our oﬀer and request descriptions,
while being optimized for large-scale query answering [23]. This
component corresponds to the service repository in Figure 1.

The second component is a client tool that facilitates the speci-
ﬁcation of Web service oﬀers and requests by providing a GUI for
specifying SPARQL-queries and utility function policies. Gener-
ally, oﬀers are transferred to the server, whereas for requests the
user decides whether they should also be stored as policies on the
server to enable further reuse (cf. (R4)) or formulated directly as a
query. The client is supplemented by a WS-BPEL engine [25] that
allows the speciﬁcation of service compositions. For example, the
second component could be used by the network operator in our
initial example to implement its application.

In order to implement dynamic binding of services, we utilise the
distinction between ports and port types in WS-BPEL. This feature
allows us to dynamically re-assign end points as long as the service
candidates have an identical interface, i.e. port type. To support
this, the client tool allows extending the process as follows: before
each dynamic service invocation, a WS-BPEL invoke-operation for
the selection service is introduced that provides the binding in-
formation for the following service. We realize the Binding by
Constraint paradigm [29] by specifying a SPARQL query (such
as Query 8) that is passed to the selection service.
In this case,
SPARQL provides a standardized language for identifying suitable
services without referring to a concrete name or identiﬁer. Parts of
the query are generated at development time of the process, while
others can be added dynamically at runtime. To illustrate this ap-
proach, Listing 1 shows an excerpt form the WS-BPEL process of
the route planning scenario introduced in Section 2. In lines 2-4 the
user’s request is received, the contained clientId is passed to the lo-
cation service, where the current country of the user is determined
(lines 8-10). Then the SPARQL query, which statically refers to re-
quest ns1:RequestOperatorX containing the providers preferences,
is extended by the context location (lines 12-15) and passed to the
selection service which is invoked in lines 18-20. After receiving
the address of the best service, the corresponding port is assigned
to the port type of the following partner link (lines 21-25) and the

5More information about the implementation can be found at
http://km.aifb.uni-karlsruhe.de/projects/kaonws/.

...
<receive name="receiveRoute" partnerLink="customer"

portType="client:Process" operation="initiate"
variable="routeRequest" createInstance="yes"/>

<assign name="Assign_Query">

<copy> <from variable="routeRequest" part="user"/>

<to variable="clientID"/>

<invoke name="LocationCheck" partnerLink="LocationServicePLT"

portType="ns1:LocationService" operation="executeQuery"
inputVariable="clientID" outputVariable="location"/>

<assign name="Assign_Query">

<copy> <from expression=’"concat(string(\"SELECT ?O , ?U WHERE {

EVALUATE mmp(ns1:RequestOperatorX, ?O,\" ),
bpws:getVariableData(’location’,’Country’),string(\",?U ) . }\"))"’/>

<to variable="requestQuery" part="queryMessage"/>

</copy>

</assign>
<invoke name="ServiceInvoke" partnerLink="SelectionServicePLT"

portType="ns1:SelectionService" operation="executeQuery"
inputVariable="requestQuery" outputVariable="responseQuery"/>

<assign name="Assign_Port">

<copy> <from variable="responseQuery" part="queryResult"/>

<to partnerLink="RoutePlanner"/>

</copy>

</assign>
<invoke name="RoutePlanningInvoke" partnerLink="RoutePlanner"
portType="ns1:RoutePlanningService" operation="requestRoute"
inputVariable="routeRequest" outputVariable="responseRoute"/>

...

Listing 1: Flexible binding in WS-BPEL

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29

route planning service is invoked by passing the original user re-
quest containing the start and end point (lines 26-28).

In case service candidates have diﬀerent interfaces, dynamic se-
lection requires complex interface mappings. [29] present an ap-
proach for dynamic binding of services using reﬂection. However,
this cannot be used directly for WS-BPEL.

7. CONCLUSION

In this paper, we have provided a formal and standards-based
representation of Web service conﬁgurations and user preferences
over these conﬁgurations meeting the requirements (R1) and (R2)
introduced in Section 2. Our approach avoids enumerating of-
fered/requested conﬁgurations and thus signiﬁcantly reduces stor-
age requirements and increases communication eﬃciency (R4). In
addition, we have presented a service selection algorithm that seam-
lessly integrates syntactic as well as semantic matching (R3) with
eﬃcient optimization techniques. In contrast to other work in this
area, we do not restrict ourselves to logical and/or similarity-based
matching approaches, but allow customisable matching predicates
that can be declaratively assigned to service attributes in a very
ﬂexible way. In order to quantify the overhead introduced by the
additional expressivity and the optimality requirement, we evalu-
ated the performance of the diﬀerent ranking algorithms, showing

WWW 2007 / Track: Web ServicesSession: SLAs and QoS1021that an algorithm that implements the linear programming formu-
lation of the optimization problem introduces only a small over-
head compared to random selection. This holds particularly for
large-scale scenarios with a high number of conﬁgurations per of-
fer. Another important ﬁnding is that the performance depends cru-
cially on the way oﬀers and request are modelled. According to our
evaluation, additive preference and price functions are required to
dynamically select services in large-scale scenarios in a computa-
tionally tractable manner (R4). Finally, as a proof of concept we
applied our framework for dynamic Web service selection in WS-
BPEL.

As future work, we plan to move from selecting single services
to service selection for an entire process. This can be realized sim-
ply by adding rules and builtin predicates implementing the more
complex optimization algorithms (e.g. [40]). In addition, we plan
to integrate behavioral matching rules as presented in [1], which
would allow deﬁning preferences over temporal properties of a ser-
vice. For example, Annika might prefer services which provide
the route information before paying. In terms of implementation,
we plan to address the problem of dynamic binding in WS-BPEL
beyond simple port re-assignments.

Acknowledgments. This research was partially supported by
the German Research Foundation (DFG) in scope of the Research
Training Group “Information Management and Market Engineer-
ing”, by the European Commission under FP6-027595 “NEON”,
FP6-507482 “KnowledgeWeb”, and FP6-507483 “DIP”, and by the
German BMBF project “SmartWeb”. The expressed content is the
view of the authors but not necessarily the view of any of the men-
tioned projects as a whole.

8. REFERENCES

[1] S. Agarwal and R. Studer. Automatic matchmaking of web services.

In 5th Int. Conf. on Web Service, Chicago,USA, 2006.

[2] F. Baader, D. Calvanese, D. McGuinness, D. Nardi, and P. F.

Patel-Schneider, editors. The Description Logic Handbook: Theory
Implemenation and Applications. Cambridge University Press, 2003.
[3] W.-T. Balke and M. Wagner. Towards personalized selection of web

services. In 12th Int. WWW Conf., Budapest, Hungary, 2003.

[4] M. Bichler and J. Kalagnanam. Conﬁgurable oﬀers and winner
determination in multi-attribute auctions. European Journal of
Operational Research, 160(2):380–394, 2005.

[5] P. A. Bonatti and P. Festa. On optimal service selection. In Proc. of

the 14th Int. WWW Conf., New York, USA, 2005.

[6] S. Brockmans, R. Volz, A. Eberhart, and P. Löﬄer. Visual modeling
of OWL DL ontologies using UML. In Proc. of the 3rd Int. Semantic
Web Conf., Hiroshima, Japan, 2004.

[7] P. Bruckner and S. Knust. Complex Scheduling. Springer, 2006.
[8] DAML Services Coalition. DAML-S: Web service description for the

semantic web. In 1st Int. Semantic Web Conf., Sardinia, Italy, 2002.

[9] R. Dumitru, U. Keller, H. Lausen, J. de Bruijn, R. Lara, M. Stollberg,

A. Polleres, C. Feier, C. Bussler, and D. Fensel:. Web service
modeling ontology. Applied Ontology, 1(1):77 – 106, 2005.

[10] Y. Engel, M. P. Wellman, and K. M. Lochner. Bid expressiveness and

clearing algorithms in multiattribute double auctions. In Proc. of the
7th ACM Conf. on e-Commerce, New York, USA, 2006.

[11] Global Grid Forum. Grid Resource Allocation Agreement Protocol.

Web Services Speciﬁcation. Available from
http://www.ogf.org/Public_Comment_Docs/Documents/
Oct-2006/WS-AgreementSpecificationDraftFinal_sp_tn_
jpver_v2.pdf, October 2006.

[12] B. Grosof and T. Poon. SweetDeal: Representing agent contracts

with exceptions using XML rules, ontologies, and process
descriptions. In 12th Int. WWW Conf., Budapest, Hungary, 2003.

[15] L. Kagal, T. Finin, and A. Joshi. Declarative Policies for Describing

Web Service Capabilities and Constraints. In W3C Workshop on
Constraints and Capabilities for Web Services, CA, USA, 2004.
[16] R. L. Keeney and H. Raiﬀa. Decisions with Multiple Objectives:

Preferences and Value Tradeoﬀs. J. Wiley, New York, 1976.

[17] J. O. Kephart and W. E. Walsh. An artiﬁcial intelligence perspective

on autonomic computing policies. In 5th IEEE Int. Workshop on
Policies for Distributed Systems and Networks, NY, USA, 2004.

[18] M. Klusch, B. Fries, M. Khalid, and K. Sycara. OWLS-MX: Hybrid
Semantic Web Service Retrieval. In 1st Int. AAAI Fall Symposium on
Agents and the Semantic Web, Arlington, USA, 2005.

[19] S. Lamparter and A. Ankolekar. Automated selection of conﬁgurable

web services. In 8. Int. Tagung Wirtschaftsinformatik, Karlsruhe,
Germany, 2007.

[20] S. Lamparter, A. Ankolekar, D. Oberle, R. Studer, and C. Weinhardt.

A policy framework for trading conﬁgurable goods and services in
open electronic markets. In 8th Int. Conf. on Electronic Commerce,
New Brunswick, Canada, 2006.

[21] D. J. Mandell and S. McIlraith. Adapting BPEL4WS for the

Semantic Web: The Bottom-Up Approach to Web Service
Interoperation. In 2nd Int. Semantic Web Conf., FL, USA, 2003.

[22] B. Motik. On the properties of metamodeling in OWL. In 4th Int.

Semantic Web Conf. (ISWC 2005), Galway, Ireland, 2005.

[23] B. Motik and U. Sattler. A comparison of reasoning techniques for

querying large description logic aboxes. In Proc. of the 13th Int.
Conf. on Logic for Programming Artiﬁcial Intelligence and
Reasoning, Phnom Penh, Cambodia, 2006.

[24] B. Motik, U. Sattler, and R. Studer. Query answering for OWL-DL
with rules. Journal of Web Semantics: Science, Services and Agents
on the WWW, 3(1):41–60, 2005.

[25] OASIS. Web Services Business Process Execution Language

(WS-BPEL). http://www.oasis-open.org/committees/tc_
home.php?wg_abbrev=wsbpel, 2007. Version 2.0.

[26] N. Oldham, K. Verma, A. Sheth, and F. Hakimpour. Semantic

WS-Agreement Partner Selection. In 15th Int. WWW Conf.,
Edinburgh, UK, 2006.

[27] M. Paolucci, T. Kawamura, T. R. Payne, and K. P. Sycara. Semantic

matching of web services capabilities. In 1st Int. Semantic Web
Conference, pages 333–347, Sardinia, Italy, 2002.

[28] C. H. Papadimitriou and K. Steiglitz. Combinatorial Optimization.

Englewood Cliﬀs, N.J.: Prentice Hall, 1982.

[29] C. Pautasso and G. Alonso. Flexible binding for reusable

composition of web services. In Proc. of the 4th Workshop on
Software Composition, Edinburgh, Scotland, 2005.

[30] S. Russel and P. Norvig. Artiﬁcial Intelligence - A Modern Approach.

Prentice Hall, 2nd edition, 2003.

[31] A. Sahai, V. Machiraju, M. Saya, A. v. Moorsel, and F. Casati.

Automated SLA monitoring for web services. In Proc. of 13th Int.
Workshop on Distributed Systems, Montreal, Canada, 2002.

[32] B. Schnizler, D. Neumann, D. Veit, and C. Weinhardt. Trading grid

services - a multi-attribute combinatorial approach. European
Journal of Operational Research, forthcoming.

[33] I. Toma, D. Foxvog, and M. C. Jaeger. Modeling QoS characteristics

in WSMO. In 1st Workshop on Middleware for Service-oriented
Computing, New York, USA, 2006.

[34] V. Tosic, K. Patel, and B. Pagurek. WSOL - web service oﬀerings

language. In CAiSE Workshop on Web Services, E-Business, and the
Semantic Web, Toronto, Canada, 2002.

[35] K. Verma, R. Akkiraju, R. Goodwin, P. Doshi, and J. Lee. On

accommodating inter service dependencies in web process ﬂow
composition. In AAAI Spring Symposium on SWS, CA, USA, 2004.

[36] W3C. Web Services Deﬁnition Language (WSDL) 1.1.

http://www.w3.org/TR/wsdl, 2001.
[37] W3C. Web Ontology Language (OWL).

http://www.w3.org/2004/OWL/, 2004.

[38] W3C. Web Services Policy Framework 1.5.

http://www.w3.org/2002/ws/policy/, July 2006.

[39] W3C. W3C XML Query (XQuery 1.0).

http://www.w3.org/XML/Query/, January 2007.

[13] I. Horrocks, P. F. Patel-Schneider, H. Boley, S. Tabet, B. Grosof, and

[40] L. Zeng, B. Benatallah, A. H. Ngu, M. Dumas, J. Kalagnanam, and

M. Dean. SWRL: A semantic web rule language combining OWL
and RuleML, 2004. W3C Submission.

[14] IBM Corporation. WSLA language speciﬁcation, version 1.0.

http://www.research.ibm.com/wsla, 2003.

H. Chang. QoS-aware middleware for web services composition.
IEEE Transactions on Software Engineering, 30(5):311–327, 2004.

WWW 2007 / Track: Web ServicesSession: SLAs and QoS1022