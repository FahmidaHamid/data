Structured Objects in OWL: Representation and Reasoning

Boris Motik

University of Oxford

Oxford, UK

Bernardo Cuenca Grau

University of Oxford

Oxford, UK

Ulrike Sattler

University of Manchester

Manchester, UK

ABSTRACT
Applications of semantic technologies often require the rep-
resentation of and reasoning with structured objects—that is,
objects composed of parts connected in complex ways. Al-
though OWL is a general and powerful language, its class de-
scriptions and axioms cannot be used to describe arbitrarily
connected structures. An OWL representation of structured
objects can thus be underconstrained, which reduces the in-
ferences that can be drawn and causes performance problems
in reasoning. To address these problems, we extend OWL
with description graphs, which allow for the description of
structured objects in a simple and precise way. To represent
conditional aspects of the domain, we also allow for SWRL-
like rules over description graphs. Based on an observation
about the nature of structured objects, we ensure decidabil-
ity of our formalism. We also present a hypertableau-based
decision procedure, which we implemented in the HermiT
reasoner. To evaluate its performance, we have extracted
description graphs from the GALEN and FMA ontologies,
classiﬁed them successfully, and even detected a modeling
error in GALEN.

Categories and Subject Descriptors
I.2.4 [KR Formalisms and Methods]: OWL

General Terms
Theory, Languages

1.

INTRODUCTION

Ontologies are nowadays used in disciplines as diverse as
biology [20], medicine[18], astronomy [4], and agriculture
[21]. A de facto standard for ontology modeling is the Web
Ontology Language (OWL),1 so most ontologies in these do-
mains were either developed from the start using OWL or
translated into OWL from other formalisms. OWL is an
expressive language capable of supporting diverse applica-
tions. Its logical underpinning is given by description logics
(DLs), which provide OWL with a clean model-theoretic se-
mantics, well-understood reasoning problems, and powerful
reasoners.

1In this paper, we focus on OWL DL—the most expressive
of the decidable languages of the OWL family.

Copyright is held by the International World Wide Web Conference Com-
mittee (IW3C2). Distribution of these papers is limited to classroom use,
and personal use by others.
WWW 2008, April 21–25, 2008, Beijing, China.
ACM 978-1-60558-085-2/08/04.

Structured objects—that is, objects composed of other,
possibly interrelated objects—pose some well-known prob-
lems to OWL and DLs [3, 1, 19]. Such objects abound, for
example, in molecular biology and the clinical sciences. Clin-
ical ontologies such as GALEN [22], the Foundation Model of
Anatomy (FMA) [18], the National Cancer Institute (NCI)
Thesaurus [7], and SNOMED CT [23] are currently being
used in large-scale applications, and they describe numer-
ous structured objects. For example, GALEN models the
heart as consisting of the left and the right ventricles, the
two atria, and the valves, all of which participate in com-
plex relationships, such as “the two ventricles of a heart are
separated by the intraventricular septum.”

OWL can be used to describe domains consisting of an
arbitrary or even inﬁnite number of objects, but it only al-
lows for axioms that can connect these objects in a certain
tree-like manner.
In other words, OWL enjoys (a variant
of) the tree model property [24]: if an OWL ontology has a
model, then it has a model with a tree-like (or forest-like)
relational structure as well. This property is responsible for
the decidability of OWL reasoning [24]; however, it prevents
suﬃciently accurate description of complex structured ob-
jects, since schema-level axioms in OWL cannot describe ar-
bitrary relational structures. Consider the previously men-
tioned diamond-shaped structure involving a heart, its right
and left ventricles, and a septum. In addition to a model
that corresponds to the structure in which the objects are
connected as expected, each schema-level description of the
heart in OWL will also have a model where one heart has
two septa, each as a part of the left and the right ventricle,
respectively. Thus, certain consequences of the diamond-
shaped structure cannot be drawn from its formulation in
OWL. For example, we cannot conclude that, if the right
ventricle has a perforated septum, the left ventricle has a
perforated septum as well.

To address this lack of expressive power, in Section 4 we
propose an extension of OWL for modeling structured ob-
jects using description graphs. Such graphs consist of ver-
tices labeled with atomic concepts and edges labeled with
atomic roles. According to our proposed model-theoretic se-
mantics, these graphs are class-level statements that specify
general patterns of connections between objects.
In addi-
tion, we allow for SWRL-like rules [8] to enable the descrip-
tion of conditional statements about graphs.

Extending DLs with axioms that can enforce arbitrary
structures easily leads to undecidability [12]. Our formalism,
however, is decidable because it can represent only struc-
tured objects whose number of parts is bounded. In prac-

555WWW 2008 / Refereed Track: Semantic / Data Web - Semantic Web IApril 21-25, 2008 · Beijing, Chinatice, structured objects are usually modeled up to a certain
level of granularity, which naturally determines this bound.
In Section 5, we present a reasoning algorithm for the case
where the OWL part is expressed in SHIQ [10]; it should,
however, be possible to extended the algorithm to SHOIQ
[9] and hence cover OWL DL. We thus obtain a powerful,
decidable, and practicable language that combines two com-
plementary formalisms: unbounded but tree-like structures
can be described using standard OWL axioms, and the nat-
urally bounded structured parts can be described using ar-
bitrarily connected description graphs and rules.

We have implemented our algorithm in the DL reasoner
HermiT [16].2 The validation of our approach is currently
diﬃcult due to the lack of test data. Thus, we have devised
an algorithm that extracts description graphs from OWL
ontologies, and have applied it to GALEN and FMA. The
resulting ontologies should be treated with caution; how-
ever, domain experts have conﬁrmed that substantial parts
of the ontologies reﬂect the actual human anatomy. Our
transformation can thus be a starting point for a more com-
prehensive remodeling using description graphs. Finally, the
ontologies are suﬃciently complex to allow us to estimate the
practicability of reasoning. We present the transformation
algorithm in Section 6.

In Section 7, we discuss the results obtained by classifying
the transformed ontologies. Our transformation allowed us
to discover a modeling error in GALEN, which we take as
indication that our formalism can indeed be useful in prac-
tice. Furthermore, classiﬁcation times for the transformed
ontologies are of similar orders of magnitude as for the orig-
inal ontologies despite the fact that our formalism adds con-
siderable expressive power to OWL.

Due to lack of space, proofs and certain technical details

are included in the accompanying technical report [13].

2. PRELIMINARIES

A SHIQ signature is a triple Σ = (NC , NR, NI ) consisting
of mutually disjoint sets of atomic concepts NC , atomic roles
NR, and individuals NI . Let S be an atomic role, A an
atomic concept, and n a nonnegative integer. SHIQ roles
and concepts are deﬁned using the following grammar:

R → S | S−
C → ⊤ | ⊥ | A | ¬C | C1 ⊔ C2 | C1 ⊓ C2 | ∀R.C | ∃R.C |

≥ n R.C | ≤ n R.C

A TBox T is a ﬁnite set of role inclusions R1 ⊑ R2, transitiv-
ity axioms Trans(R), and general concept inclusions (GCIs)
C1 ⊑ C2. An extensionally reduced ABox A is a ﬁnite set of
assertions (¬)A(a), S(a, b), a ≈ b, and a 6≈ b. A knowledge
base K is a pair (T , A). To ensure decidability of reasoning,
certain restrictions apply on the usage of roles in at-most and
at-least concepts ≤ n R.C and ≥ n R.C [10]. An interpreta-
tion I is a ﬁrst-order relational structure. The deﬁnition of
satisfaction of axioms in I can be found in [10]. I is a model
of K, written I |= K, if it satisﬁes all axioms of K. The ba-
sic inference problem for SHIQ is checking satisﬁability of
K—that is, checking whether a model of K exists.

The principles for extending DLs with rules can be found
in [12, 5, 8]. For a SHIQ signature Σ, let NV be a countably
inﬁnite set of variables disjoint from NI . A predicate is a
concept, a role, or the equality predicate ≈. Concepts have

2

http://web.comlab.ox.ac.uk/oucl/work/boris.motik/HermiT/

arity one, and roles and ≈ have arity two. An atom over Σ
has the form P (x1, . . . , xn), where P is a predicate of arity
n and xi are variables. Atoms with the equality predicate
are written as t1 ≈ t2. A rule r is an expression of the form

B1 ∧ . . . ∧ Bn → H1 ∨ . . . ∨ Hm

(1)

where n ≥ 0, m ≥ 0, and Bi and Hj are atoms. The set of
atoms {B1, . . . , Bn} is called the antecedent, and the set of
atoms {H1, . . . , Hm} is called the consequent. A program P
is a ﬁnite set of rules. A rule r is interpreted in an interpre-
tation I as a standard ﬁrst-order implication.

3. MOTIVATION

To understand the limitations of modeling structured ob-
jects in OWL, let us consider modeling the anatomy of the
heart shown in Figure 1(a). This example has been derived
by reconstructing the intention behind the axioms describ-
ing the heart in GALEN. We next consider possibilities for
a logical interpretation of the ﬁgure.

Figure 1(a) could be represented in OWL using an ABox
A. ABox assertions, however, represent concrete data; thus,
A would represent the structure of one particular heart. In
this paper, we are concerned with modeling structured ob-
jects at the schema level —that is, we want to describe the
general structure of all hearts. We should be able to in-
stantiate such a description many times. For example, if
we say that each patient has a heart, then, for each con-
crete patient, we should instantiate a diﬀerent heart, each
of the structure shown in Figure 1(a). This clearly cannot be
achieved if we describe the structure of the heart using ABox
assertions. Consequently, GALEN, SNOMED CT, and NCI
contain only schema-level axioms and no ABox assertions.

We can give a logical, schema-level interpretation to Fig-
ure 1(a) by treating vertices as concepts and arrows as par-
ticipation constraints specifying relationships between con-
cepts. For example, LeftSideOfHeart and AorticValve are
concepts and the arrow between them states that each left
side of the heart has an aortic valve as a structural com-
ponent. Participation constraints can be represented using
existential quantiﬁcation, which can be encoded in OWL us-
ing axioms of the form (2). Let K be a DL knowledge base
containing the following axioms.

LeftSideOfHeart ⊑

∃hasStructuralComponent .AorticValve

AorticValve ⊑ ∃hasAlphaConnection .LeftVentricle
LeftSideOfHeart ⊑ ∃hasSolidDivsion.LeftVentricle

(2)

(3)
(4)

Let I be an interpretation that corresponds to Figure 1(a) in
the obvious way. Clearly, I is a model of K, which justiﬁes
the formalization of Figure 1(a) by axioms (2)–(4).

Such a schema-level representation of a heart can be put
to use in many ways. We might represent knowledge about
various heart conditions; for example, if the aortic valve suf-
fers from aortic regurgitation (AR), then the left ventricle
suﬀers from left ventricular hypertrophy (LVH):

AorticValve ⊓ HasAR ⊑

∀hasAlphaConnection .HasLVH

(5)

We might expect to derive from (2)–(5) that, if the aortic
valve of the left side of the heart suﬀers from aortic regur-

556WWW 2008 / Refereed Track: Semantic / Data Web - Semantic Web IApril 21-25, 2008 · Beijing, China(a) Intended Structure

(b) Unintended Tree Structure

(c) Unintended Inﬁnite Structure

Figure 1: Diﬀerent Models of the Heart in GALEN

gitation, then the left ventricle suﬀers from hypertrophy:

LeftSideOfHeart ⊓
∃hasStructuralComponent .(AorticValve ⊓ HasAR)
⊑ ∃hasSolidDivision.HasLVH

(6)

Unfortunately, (6) does not follow from K: axioms (3) and
(4) imply the existence of two left ventricles, but no axiom
in K states that these two ventricles are necessarily the same
object. Thus, an interpretation I ′ corresponding to Figure
1(b) is also a model of K. In I ′, even if the aortic valve has
aortic regurgitation, the second left ventricle is unaﬀected.
Hence, I ′ 6|= (6), so K 6|= (6) as well.

The knowledge base K is thus underconstrained: some
models of K do not correspond to the actual structure of the
heart shown in Figure 1(a). This discrepancy can prevent
us from drawing some quite reasonable conclusions, such as
(6). Furthermore, it can also cause problems with the per-
formance of reasoning. For example, we might use axioms
(4) and (7)–(8) to describe the relationships between the left
side of the heart, the left ventricle, and the mitral valve.

LeftVentricle ⊑ ∃isBetaConnectionOf .MitralValve

(7)

MitralValve ⊑

∃isStructuralComponentOf .LeftSideOfHeart

(8)

While admitting a model corresponding to Figure 1(a), these
axioms do not state that the mitral valve in (7) is a structural
component of the “initial” left side of the heart. Hence,
the interpretation from Figure 1(c) is also a model of these
axioms. In fact, the latter model is “canonical” in the sense
that it reﬂects the least amount of information derivable
from the axioms. In order to disprove an entailment from
these axioms, an OWL reasoner will try to construct such a
“canonical” model. In practice, such models can be highly

repetitive and much larger than the intended models, which,
according to our experience, is the main reason why OWL
reasoners still cannot process ontologies such as FMA and
certain versions of GALEN.

To avoid such problems, we need to extend K with addi-
tional axioms that make all models of K correspond as much
as possible to the intended conceptualization shown in Fig-
ure 1(a). Such axioms, however, cannot be stated in OWL,
for reasons we explain next. OWL can represent unbounded
or even inﬁnite domains, which is appropriate in many cases.
For example, in the domain of people, we should not make
any assumptions about the number of people in the world.
In other words, the domain of all people does not exhibit a
natural bound on its size. Thus, we can represent the fact
that every person has exactly two parents who are persons:

Person ⊑ ≥ 2 hasParent .Person ⊓ ≤ 2 hasParent .⊤ (9)

Reasoning with such axioms is not straightforward. A model
containing one person γ must contain two parents δ1 and δ2,
each of which requires the existence of two additional parents
and so on. Eﬀectively, we obtain a model that is similar to
the one shown in Figure 1(c).

To ensure termination of the model construction outlined
in the previous paragraph, the structure of the axioms al-
lowed in OWL is restricted such that the language exhibits
(a variant of) the tree model property [24]: whenever a knowl-
edge base K has a model, it also has a model of a certain tree
shape. The relationship between the left side of the heart,
the aortic valve, and the left ventricle in Figure 1(a) is, how-
ever, triangular and cannot be represented as a tree. Hence,
if we want to ensure that the ventricles whose existence is
implied by (3) and (4) are the same in every model of K, we
must leave the conﬁnes of OWL and DLs.

Certain rule formalisms can axiomatize nontree structures.

557WWW 2008 / Refereed Track: Semantic / Data Web - Semantic Web IApril 21-25, 2008 · Beijing, ChinaFor example, the following SWRL [8] rule can be used to
make the two ventricles from Figure 1(b) the same:

LeftSideOfHeart (x)∧

hasStructuralComponent (x, y) ∧
hasAlphaConnection (y, z) ∧ LeftVentricle(z) ∧
hasSolidDivsion(x, w) ∧ LeftVentricle(w) → z ≈ w

(10)

This, however, has signiﬁcant drawbacks. From the stand-
point of modeling, such a solution is quite complex, as it
requires the modeler to anticipate which objects need to be
made the same. The fact that the two left ventricles are
the same follows from the complex interaction between ax-
ioms (2)–(4) and (10), and is thus not represented explicitly.
Clearly, such a modeling formalism is likely to be hard to
use and susceptible to modeling errors. From the standpoint
of automated reasoning, the extension of OWL with SWRL
is undecidable [8], which is a signiﬁcant impediment to the
adoption of SWRL in practice.

SWRL-like rules can, however, naturally express certain
conditional aspects of structured objects. For example, if
the septum has a ventricular septal defect, then there is a
blood ﬂow from the left to the right ventricle:

IntraventricularSeptum (x) ∧ HasVSD (x) ∧

hasLayer (y1, x) ∧ LeftVentricle (y1) ∧
hasLayer (y2, x) ∧ RightVentricle (y2) →

(11)

hasBloodFlow (y1, y2)

The variables in the antecedent of this rule are connected
in a non-tree-like way, so such a rule cannot be expressed in
OWL. If we, however, deal with arbitrarily connected struc-
tures, such as the one shown in Figure 1(a), non-tree-like
antecedents are essential for drawing the correct inferences.
Various decidable combinations of DLs and rules cannot
be used for schema modeling. For example, the DL-safe rules
[15] are syntactically restricted such that they apply only to
the explicitly named objects. Role-safe [12] and weakly safe
[17] rules also impose restrictions that prevent the applica-
tion of the rules to arbitrary elements of the domain, and
similar restrictions are also employed by various nonmono-
tonic rule extensions of OWL [6, 17, 14]. While these are
quite useful in query answering, they cannot be used to de-
rive new conclusions from the schema.

The DL SROIQ [11] and the OWL 1.1 extension of OWL
DL extend OWL with complex role inclusions of the form
R1 ◦ . . . ◦ Rn ⊑ S, restricted appropriately to ensure decid-
ability. Such axiom solve some of the problems; however,
they still cannot axiomatize arbitrary structures such as the
one in Figure 1(a) or express axioms such as (11).

4. DESCRIPTION GRAPHS

We now present an extension of OWL that addresses the

problems from Section 3.
4.1 Basic Principles

The main aspect of a description of a structured object is
the connection between the object’s parts, which can natu-
rally be represented as a graph. Hence, we introduce the no-
tion of a description graph G = (V, E, λ)—a directed graph
in which each vertex i ∈ V is labeled with a set of atomic
concepts λhii and each edge hi, ji ∈ E is labeled with a set
of atomic roles λhi, ji. For example, Figure 1(a) can be un-
derstood as a description graph that describes the heart.

Semantically, G = (V, E, λ) should be understood as a
“template” for a fragment of a model. Let I be a model
and A an atomic concept labeling some graph vertex i ∈ V .
If I contains an object γ such that γ ∈ AI , then I must also
contain an instance of G in which γ corresponds to i. For
example, if I contains an instance γ of the Heart concept,
then I must contain a relational structure corresponding to
Figure 1(a) in which γ corresponds to the top-most vertex.
As discussed in Section 3, extending DLs with constructs
that allow the description of arbitrarily connected structures
of unbounded size easily leads to undecidability. In practice,
structured objects are usually modeled up to a certain level
of granularity, which naturally determines this bound. For
example, a human body consists of a certain number of or-
gans. These organs might be decomposed into smaller parts;
however, each such decomposition is bounded, so the entire
model of human anatomy requires a bounded number of ob-
jects. Even though the number of required objects may be
large and diﬃcult to determine by hand, the fact that the
domain is bounded is intrinsic to the modeling problem. The
reasoning algorithm presented in Section 5 uses this bound
to ensure termination even on arbitrarily connected, non-
tree-like structures.

We assume that the set of atomic roles is divided into
a set of atomic tree roles NRt and a set of atomic graph
roles NRg . A graph-extended DL knowledge base is a 4-tuple
K = (T , G, P, A) where T is a DL TBox, G is a description
graph, P is a set of rules, and A is an ABox. Furthermore,
T is allowed to refer only to tree roles, G and P are allowed
to refer only to the graph roles, and A is allowed to refer to
both graph and tree roles.

For example, let K = (T , G, P, A) be a graph-extended
DL knowledge base with the following components. Let T
contain the axioms (12)–(14). Intuitively, axiom (12) says
that each person has a parent and a heart; axiom (13) en-
sures that the heart of each suﬀerer from aortic regurgitation
is an instance of HasAR; and axiom (14) says that, on each
aortic valve suﬀering from aortic regurgitation, some person
is performing a surgery on it.

Person ⊑ ∃hasParent .Person ⊓ ∃hasHeart .Heart
AR Suﬀerer ⊑ ∀hasHeart .HasAR

AorticValve ⊓ HasAR ⊑

∃performsSurgeryOn −.Person

(12)
(13)

(14)

Let G correspond to Figure 1(a), let P contain the rule
(15) that propagates the HasAR concept over the structural
components of the heart, and let A contain the assertions
Person(a) and AR Suﬀerer (a).

HasAR(x) ∧ hasStructuralComponent (x, y) →

HasAR(y)

(15)

The semantics of graph-extended KBs ensures that each
model I of K is of the form shown in Figure 2.
I con-
sists of two distinct parts. The tree backbone consists of ob-
jects (shown as large squares) connected through tree roles
(shown using thick lines), and it is constructed using the
standard DL axioms in T . As discussed in Section (3), the
number of persons is not naturally bounded so, if we want a
decidable formalism, we must employ standard DL restric-
tions. Apart from the tree backbone, I also contains ar-
bitrarily connected but naturally bounded graph instances,
such as the structure of the heart of each person. Unlike

558WWW 2008 / Refereed Track: Semantic / Data Web - Semantic Web IApril 21-25, 2008 · Beijing, Chinaof integers called vertices, ( ii) E ⊆ V × V is a set of edges,
and ( iii) λ labels each vertex i ∈ V with a set of atomic
concepts λhii ⊆ NC , and each edge hi, ji ∈ E with a set of
atomic graph roles λhi, ji ⊆ NRg . For an atomic concept A,
VA is the set of vertices that contain A in their label:

VA = {k ∈ V | A ∈ λhki}.

We now deﬁne the notion of graph-extended DL knowl-
edge bases. The deﬁnition of graph-regular rules ensures
that each such rule can become applicable only to objects
from the same instance of the description graph G, which is
required to obtain a decidable formalism.

Definition 3. A rule of the form (1) is graph-regular if
it uses only atomic concepts and graph roles and, for each
pair of variables x1 and x2 occurring in r, some antecedent
atom of r contains both x1 and x2.

A graph-extended DL knowledge base K = (T , G, P, A)
is a 4-tuple where ( i) T is DL TBox over the signature
(NC , NRt , NI ), ( ii) G is a description graph with ℓ vertices,
( iii) P is a ﬁnite set of graph-regular rules, and ( iv) A is an
extensionally-reduced ABox over (NC , NRt , NRg , NI ) that,
apart from standard assertions, can also contain graph as-
sertions of the form G(a1, . . . , aℓ) for ai ∈ NI .

Graph-regular rules can express conjunctive queries over
G, so we do not consider query answering separately. We
now formalize the semantics of description graphs.

Definition 4. An interpretation I = (△I , ·I ) interprets
a description graph G = (V, E, λ) with ℓ vertices as an ℓ-
ary relation GI ⊆ (△I )ℓ. An interpretation I satisﬁes G,
written I |= G, if all of the following conditions hold.

i-key property: for each 1 ≤ i ≤ ℓ,
∀x1, . . . , xℓ, y1, . . . , yℓ ∈ △I : hx1, . . . , xℓi ∈ GI ∧

hy1, . . . , yℓi ∈ GI ∧ xi = yi → V

xj = yj

1≤j≤ℓ

Disjointness property:
∀x1, . . . , xℓ, y1, . . . , yℓ ∈ △I : hx1, . . . , xℓi ∈ GI ∧

hy1, . . . , yℓi ∈ GI → V

xi 6= yj

1≤i<j≤n

A-start property: for each atomic conceptA with VA 6= ∅,
∀x ∈ △I : x ∈ AI →

∃x1, . . . , xℓ ∈ △I : hx1, . . . , xℓi ∈ GI ∧ W

x = xk

k∈VA

Vertex layout property: for each i ∈ V and A ∈ λhii,
∀x1, . . . , xℓ ∈ △I : hx1, . . . , xℓi ∈ GI → xi ∈ AI

Edge layout property: for each hi, ji ∈ E and R ∈ λhi, ji,
∀x1, . . . , xℓ ∈ △I : hx1, . . . , xℓi ∈ GI → hxi, xji ∈ RI

The intuition behind this deﬁnition is as follows. Each
tuple in the ℓ-ary relation GI corresponds to one instance of
the description graph G.

The i-key properties and the disjointness property en-
sure that no two instances of G can share an object, which
essentially captures the idea behind natural boundedness.
Consider the axiom B ⊑ A and a graph G consisting of
two vertices 1 and 2 such that λh1i = {A}, λh2i = {B},
and λh1, 2i = {R}. Without the i-key and the disjointness
properties, we could build a model I of G where γ1 ∈ AI ,

Figure 2: A Typical Model of K

in the case of axioms (2)–(4) and Figure 1(b), each graph
instance is necessarily of the form as speciﬁed by G in each
such model I. Note that the tree backbone of I need not be
contiguous: the bottom-most AorticValve object av can be
connected to other objects through tree roles. To summa-
rize, for a graph-extended knowledge base K, we can con-
sider only models that consist of graph instances, connected
among themselves and with other objects through tree roles.
Decidability of the formalism is now ensured by the sepa-
ration of the roles into tree and graph ones. The axioms in T
can propagate constraints across tree roles just like in stan-
dard DLs; however, we can adapt the blocking technique [10]
to ensure termination of model construction. Furthermore,
the rules in P can propagate constraints within a graph;
however, the size of the graph is naturally bounded, so this
does not cause termination problems either.

Our way of obtaining decidability is related to fusions of
abstract description systems (ADSs) [2], which allow for the
combination of diﬀerent modal and description logics. The
component ADSs can share concepts; however, the inter-
action between them through roles is restricted to ensure
decidability. Our separation of roles into graph and tree
ones is similar in spirit. Bounded structures and rules, how-
ever, cannot directly be expressed as an ADS. In addition,
we present a practical decision procedure.
4.2 Formalization

We now deﬁne of our language formally. We start by
deﬁning a signature that separates tree from graph roles.
All subsequent deﬁnitions in this paper are implicitly pa-
rameterized with such a signature.

Definition 1. A graph-extended DL signature is a 4-
tuple Σ = (NC , NRt , NRg , NI ) consisting of pair-wise dis-
joint sets of atomic concepts NC , atomic tree roles NRt ,
atomic graph roles NRg , and individuals NI .

We now deﬁne description graphs formally. We make the
technical assumption that the vertices of G are consecutive
integers, as this allows us to use vertices as indices.

Definition 2. A description graph G = (V, E, λ) is a di-
rected labeled graph where ( i) V = {1, . . . , ℓ} is a ﬁnite set

559WWW 2008 / Refereed Track: Semantic / Data Web - Semantic Web IApril 21-25, 2008 · Beijing, Chinahγ1, γ2i ∈ RI, and γ2 ∈ BI ; to ensure that BI ⊆ AI , we must
also set γ2 ∈ AI ; but then, we must instantiate G for γ2,
which clearly leads to a cyclic computation. The i-key and
the disjointness properties ensure that such a model I can-
not exist: each object occurring in a graph part of I occurs
in exactly one tuple of GI . Since this tuple is bounded in
size, each graph part of I is bounded as well, which can be
used to ensure termination of model construction.

The A-start property ensures that I contains an appro-
priate instance of G whenever I contains an instance γ of a
concept A labeling a vertex of G. If A labels more than one
vertex of G, the A-start property “guesses” the vertex of G
that γ should be matched to. Consider, for example, a graph
containing a vertex labeled with Hand and ﬁve vertices la-
beled with Finger . If some object γ is an instance of Finger ,
without further information we cannot disambiguate which
of the ﬁve ﬁngers γ stands for. Therefore, we need to make
a “guess” and examine all ﬁve possibilities independently.
Note that no other property requires guessing; hence, un-
less we label two vertices in G with the same concept A, the
semantic properties of graphs allow for deterministic reason-
ing.

Finally, the vertex and edge layout properties simply en-
sure that each instance of G indeed contains the appropriate
relational structure of G.

5. REASONING ALGORITHM

To support reasoning over graph-extended KBs, we ex-
tend the hypertableau algorithm for SHIQ from [16]. This
algorithm provides the basis for the HermiT reasoner, which
is currently the only reasoner that can classify the original
version of GALEN. Our algorithm decides satisﬁability of
K = (T , G, P, A) with T expressed in SHIQ. The algo-
rithm proceeds in two phases. In the preprocessing phase,
T and G are translated into equisatisﬁable sets of rules. In
the hypertableau phase, an attempt is made to construct a
model of A, P, and the rules from preprocessing.

The TBox T is preprocessed into a set of rules Ξ(T ) of
the form (1) exactly as it is done in [16]. Due to lack of
space, we refer the reader for details to [16, 13]. After this
transformation, ∃R.C is treated as a synonym for ≥ 1 R.C.
Translation of G into a set of rules Ξ(G) uses concepts
∃G|k, which represent objects occurring in an instance of G
at position k. Their interpretation is deﬁned as

(∃G|i)I = {s | ∃t1, . . . , tℓ : ht1, . . . , tℓi ∈ GI ∧ s = ti}.

The set Ξ(G) is computed as shown in Deﬁnition 5. It is
easy to see that Ξ(G) encodes conditions from Deﬁnition 4
in a straightforward way; hence, I |= G iﬀ I |= Ξ(G).

Definition 5. For a description graph G = (V, E, λ), the

set Ξ(G) consists of the following rules, for ℓ = |V |:

G(x1, . . . , xℓ) ∧ G(y1, . . . , yi−1, xi, yi+1, . . . , yℓ) → xj ≈ yj
for each i, j ∈ V such that j 6= i

G(x1, . . . , xℓ) ∧ G(y1, . . . , yj−1, xi, yj+1, . . . , yℓ) → ⊥

A(x) → Wk∈VA
∃G|k(x)
G(x1, . . . , xℓ) → A(xi)
G(x1, . . . , xℓ) → R(xi, xj)

for each 1 ≤ i < j ≤ ℓ
for each A such that VA 6= ∅
for each i ∈ V and A ∈ λhii
for hi, ji ∈ E and R ∈ λhi, ji

The set of rules R = Ξ(T ) ∪ Ξ(G) ∪ P produced by pre-
processing is equisatisﬁable with (T , G, P), so we check sat-

isﬁability of K by checking satisﬁability of (R, A). The hy-
pertableau algorithm, however, can be applied to any set of
rules R that is admissible according to Deﬁnition 6. It is
easy to see that Ξ(T ) ∪ Ξ(G) ∪ P is admissible.

Definition 6. A set of rules R is admissible if it can be

represented as a disjoint union of two subsets Rt and Rg.

The set Rg can contain only graph-regular rules and, for
each description graph G, it must contain all rules from the
ﬁrst two items of Deﬁnition 5.

Let denote R an atomic tree role, A an atomic concept,
and C a concept of the form ≥ n S.A or ≥ n S.¬A with S a
tree role. For each r ∈ Rt, it must be possible to separate the
variables of r into one center variable x and the set of leaf
variables {yi} such that ( i) each atom in the antecedent of
r is of the form A(x), A(yi), R(x, yi), or R(yi, x), ( ii) each
atom in the consequent is of the form A(x), A(yi), C(x),
C(yi), R(x, yi), R(yi, x), or yi ≈ yj, and ( iii) each variable
yi in the rule occurs in some binary atom in the antecedent.

Deﬁnition 7 summarizes the calculus for checking satis-
ﬁability of (R, A) for R an admissible set of rules. This
algorithm diﬀers from the one in [16] in two main points.
First, our algorithm contains the ∃G-rule that generates an
instance of G for an assertion ∃G|i(s). In spirit, the ∃G-rule
is similar to the ≥-rule that expands assertions of the form
≥ n R.C(s) by introducing fresh successors of s. Second,
our algorithm contains an appropriately modiﬁed version of
blocking [10] to ensure termination.

The idea behind blocking is the following: if two individu-
als s and s′ occur in the same concepts in an ABox A, then
s “behaves” just like s′—that is, we do not expand s any fur-
ther. To use this idea in our setting, we separate the individ-
uals in each ABox A into named, tree, and graph individuals.
The named individuals occur in the original graph-extended
knowledge base, the tree individuals are introduced by the
≥-rule, and the graph individuals are introduced by the ∃G-
rule. We use this distinction in the deﬁnition of blocking:
only tree individuals can be blocked, and the blocking indi-
vidual must also be a tree individual.

Our derivation rules generate only models of the form as
shown in Figure 2. There, the individual a is named. The
individual h1 is generated by deriving ∃hasHeart .Heart (a)
by (12) and then expanding it by the ≥-rule; hence, h1 is a
tree individual. All other individuals that correspond to the
structure of the heart (including av) are created by instan-
tiating G, so they are graph individuals. To ensure termi-
nation, we apply the ∃G-rule with the lowest priority. The
rules in R ensure that no two instances of G can share an
individual. Hence, for each tree individual t (such as h1)
that “enters” an instance of G, we can establish a bound on
the number of graph individuals occurring generated for t;
these individuals are said to be from the same graph cluster.

Definition 7. Generalized Individuals. Let T and Γ
be two disjoint countably inﬁnite sets of tree and graph sym-
bols. A generalized individual is a ﬁnite string of symbols
α0.α1. . . . .αn such that α0 ∈ NI , αi ∈ T ∪ Γ for 1 ≤ i ≤ n,
and αi−1 ∈ Γ implies αi 6∈ Γ. If αn ∈ NI , the individual is
named; if αn ∈ T, the individual is a tree individual; and if
αn ∈ Γ, the individual is a graph individual.

Successors and Predecessors. A generalized individual
x.α is a successor of x, predecessor is the inverse of succes-
sor, and descendant and ancestor are the transitive closures
of successor and predecessor, respectively.

560WWW 2008 / Refereed Track: Semantic / Data Web - Semantic Web IApril 21-25, 2008 · Beijing, ChinaGraph Cluster. Generalized individuals s and t are from
the same graph clusters if either ( i) s is either a named
individual or a graph successor of a named individual, and t
is also either a named individual or a graph successor of a
named individual, ( ii) both s and t are graph successors of
the same tree individual, or ( iii) one individual is a graph
successor of the other individual.

Generalized ABox. In the rest of this paper, we allow
ABoxes to contain generalized individuals and the assertion
⊥ which is false in all interpretations, and we take a ≈ b
(a 6≈ b) to also stand for b ≈ a (b 6≈ a).

Initial ABox. An ABox is initial if it is extensionally
reduced and nonempty and contains only named individuals.
Pairwise Anywhere Blocking. A concept is blocking-
relevant if it is of the form A, ≥ n R.A, ≥ n R.¬A, or ∃G|i,
for A an atomic concept, R a (not necessarily atomic) role,
and G a description graph. The labels of an individual and
of an individual pair in an ABox A are deﬁned as follows:

LA(s) = {C | C(s) ∈ A and C is blocking-relevant}

LA(s, t) = {R | R(s, t) ∈ A}

Let ≺ be a a transitive and irreﬂexive relation on the gen-
eralized individuals such that, if s′ is an ancestor of s, then
s′ ≺ s. By induction on ≺, we assign to each individual s
in A a status as follows:

• s is directly blocked by an individual s′ iﬀ ( i) both
s and s′ are tree individuals, ( ii) s′ is not blocked,
( iii) s′ ≺ s, ( iv) LA(s) = LA(s′) and LA(t) = LA(t′),
and ( v) LA(s, t) = LA(s′, t′) and LA(t, s) = LA(t′, s′),
for t and t′ the predecessors of s and s′, respectively.

• s is indirectly blocked iﬀ its predecessor is blocked.

• s is blocked iﬀ it is either directly or indirectly blocked.

Pruning. The ABox pruneA(s) is obtained from A by

removing all assertions that contain a descendant of s.

Merging. The ABox mergeA(s → t) is obtained from the

ABox pruneA(s) by replacing s with t in all assertions.

Clash. An ABox A contains a clash if and only if ⊥ ∈ A;

otherwise, A is clash-free.

Derivation Rules. Table 1 speciﬁes derivation rules that,
given a clash-free ABox A and a set of rules R, derive the
ABoxes hA1, . . . , Ani. In the Hyp-rule, σ is a mapping from
the set of variables NV to the individuals in A, and σ(U ) is
obtained from U by replacing each variable x with σ(x).

Rule Priority. The ∃G-rule is applicable only if no other

rule is applicable.

Derivation. A derivation for a set of admissible rules R
and an initial ABox A is a pair (T, ρ) where T is a ﬁnitely
branching tree and ρ labels the nodes of T with ABoxes such
that ( i) ρ(ǫ) = A for ǫ the root of the tree, and ( ii) for each
node t, if one or more derivation rules are applicable to ρ(t)
and R, then t has children t1, . . . , tn such that the ABoxes
hρ(t1), . . . , ρ(tn)i are the result of applying one applicable
derivation rule chosen by respecting the rule priority. A
derivation is clash-free if it has a leaf node labeled with a
clash-free ABox.

Theorem 1. For an admissible set of rules R and an ini-
tial ABox A, ( i) if (R, A) is satisﬁable, then each derivation
for R and A is clash-free, ( ii) if a clash-free derivation for
R and A exists, then (R, A) is satisﬁable, and ( iii) each
derivation for R and A is ﬁnite.

The proof is given in the technical report [13]. As a conse-
quence of the theorem, subsumption checking, concept sat-
isﬁability, and query answering are decidable as well.

6. FROM OWL AXIOMS TO GRAPHS

The evaluation of the adequacy of our approach is rather
diﬃcult due to lack of adequate test data. Furthermore, re-
modeling existing ontologies using a new modeling paradigm
may require considerable eﬀort. In order to both obtain test
data for our reasoner and make the adoption of our approach
in practice easier, we have developed an algorithm that au-
tomatically transforms a TBox T into a graph-extended
knowledge base K. For example, our algorithm can auto-
matically construct the graph shown in Figure 1(a) from
the axioms such as (2)–(4). Clearly, the knowledge base K
is only a rough approximation; however, it can be used as
a starting point for a more comprehensive remodeling of T
into a proper graph-extended KB.
6.1 The Transformation Algorithm

Our transformation of a TBox T1 into a graph-extended

KB K = (T , G, P, A) is based on two assumptions.

The ﬁrst assumption is that only some concepts and roles
from T1 are relevant for G. For example, the Heart con-
cept is clearly relevant to the description graph of human
anatomy; in contrast, the Disease concept is not relevant
because it does not represent the structure of a human body.
Similarly, the hasStructuralComponent role clearly belongs
to the graph, while the hasAge role does not.

Our second assumption is that each concept relevant to
G should be represented by one vertex in G, and that edges
in G can be decoded from axioms of the form A ⊑ ∃R.B.
Our assumption is that, by writing axioms such as (2)–(4),
modelers actually wanted to say “the aortic valve has an
alpha connection to the left ventricle, and the left side of
heart has the same left ventricle as a solid division.”

We use these two assumptions in the core part of our
algorithm, which is parameterized with a DL TBox T1, a set
of relevant concepts NCg , and a set of relevant roles NRg .
The latter set actually deﬁnes the set of graph roles, and all
other roles are considered to be tree roles. Our algorithm
ﬁrst normalizes T1 in a certain way. Then, it creates a vertex
i in V for each concept A ∈ NCg and sets λhii = {A}. Then,
it processes each axiom α ∈ T1 as follows:

• If α is of the form A ⊑ ∃R.B where {A, B} ⊆ NCg
and R ∈ NRg , then, for i and j vertices such that
λhii = {A} and λhji = {B}, the algorithm adds the
edge hi, ji to E and extends λ such that R ∈ λhi, ji.

• If α does not contain a role from NRg , the algorithm

simply copies α to the resulting TBox T .

• If α contains only roles from NRg and no existential
quantiﬁer, the algorithm translates α into a graph-
regular rule and adds it to P.

• If α is not of the above form, then either it involves a
graph and a tree role simultaneously, or it is of the form
A ⊑ ∃R.B but some of A, B, or R are not relevant for
the graph. Such an axiom either invalidates the syn-
tactic restrictions of our formalism or it does not have
a natural interpretation; hence, our algorithm simply
ignores such an axiom α.

561WWW 2008 / Refereed Track: Semantic / Data Web - Semantic Web IApril 21-25, 2008 · Beijing, ChinaTable 1: Derivation Rules of the Hypertableau Calculus

Hyp-rule

If 1. U1 ∧ ... ∧ Um → V1 ∨ ... ∨ Vn ∈ R,

2. a mapping σ : NV → NA exists such that
2.1
2.2

σ(Ui) ∈ A for each 1 ≤ i ≤ m and
σ(Vj ) 6∈ A for each 1 ≤ j ≤ n,

then A1 = A ∪ {⊥} if n = 0; or

Aj := A ∪ {σ(Vj )} for 1 ≤ j ≤ n if n > 0.

≈-rule

s ≈ t ∈ A and s 6= t

If
then A1 := mergeA(s → t) if t is a named individual

or if s is a descendant of t; or
A1 := mergeA(t → s) otherwise.

⊥-rule

≥-rule

If 1. ≥ n R.C(s) ∈ A,

2. s is not blocked in A, and
3. there are no individuals u1, . . . , un such that

{ar(R, s, ui), C(ui) | 1 ≤ i ≤ n} ∪ {ui 6≈ uj | 1 ≤ i < j ≤ n} ⊆ A,

then A1 := A ∪ {ar(R, s, ti), C(ti) | 1 ≤ i ≤ n} ∪ {ti 6≈ tj | 1 ≤ i < j ≤ n}

where t1, . . . , tn are fresh pairwise distinct tree successors of s.

∃G-rule

If 1. ∃G|i(s) ∈ A for G a description graph with ℓ vertices,

2. s is not blocked in A, and
3. there are no individuals u1, . . . , ui−1, ui+1, . . . , uℓ such that

G(u1, . . . , ui−1, s, ui+1, . . . , uℓ) ∈ A

s 6≈ s ∈ A or {A(s), ¬A(s)} ⊆ A

If
then A1 := A ∪ {⊥}.
Note: A is a generalized ABox, R is a set of admissible rules, and NA is the set of individuals occurring in A.

then A1 := A ∪ {G(t1, . . . , ti−1, s, ti+1, . . . , tℓ)} where t1, . . . , ti−1, ti+1, . . . , tℓ

are fresh pairwise distinct graph individuals from the same graph cluster as s.

Our translation cannot correctly handle axioms of the
form A ⊑ ≥ n R.B with n ≥ 2.
Intuitively, such axioms
might be handled by creating n vertices in G, labeling all
of them with B, and then connecting the vertex of A with
all the vertices of B using the role R. The situation, how-
ever, is not so simple if, in addition, we also have the ax-
iom B ⊑ ≥ m R.A. It is now not clear which vertices of the
description graph labeled with A to “reuse” to satisfy this
axiom. Therefore, we decided to ignore such axioms. This
is partly justiﬁed by the fact that GALEN and FMA—our
main sources of inspiration and test data—do not contain
≥ n R.B concepts with n ≥ 2. In human anatomy, diﬀerent
objects of the domain are naturally given diﬀerent names.
For example, instead of an axiom

Heart ⊑ ≥ 2 hasStructuralComponent .SideOfHeart ,

(16)

GALEN introduces explicit names for the left and the right
side of the heart:

Heart ⊑ ∃hasStructuralComponent .LeftSideOfHeart
(17)
Heart ⊑ ∃hasStructuralComponent .RightSideOfHeart (18)

On ontologies with at-least restrictions, our algorithm sim-
ply treats each ≥ n R.B as ∃R.B. It is natural to use num-
ber restrictions for modeling symmetric organs such as the
kidney. On such an ontology, our algorithm produces a de-
scription graph containing just one copy of the object, and
the graph can then be corrected by the modeler.

Determining the sets NCg and NRg manually is not easy.
According to our experience with GALEN and FMA, a good
strategy is to manually identify a set of roles N ′
Rg that nat-
urally belong to the graph, and then to take NRg as the clo-
sure of N ′
Rg w.r.t. the explicit role inclusions from T1. Then,
we take NCg as the set of all concepts A and B occurring in
an axiom A ⊑ ∃R.B ∈ T1 such that R ∈ NRg . Intuitively, if
A and B are connected by a role that should be included into
the graph, then it is likely that A and B should be included
into the graph as well.

This idea, however, requires some reﬁnement. For exam-

ple, GALEN contains the following axioms:

LeftVentricle ⊑ Ventricle
RightVentricle ⊑ Ventricle

(19)
(20)

Let us assume that NCg contains Ventricle, LeftVentricle ,
and RightVentricle. The core transformation then generates

a description graph G containing three diﬀerent vertices,
each labeled with one of these concepts. It is, however, coun-
terintuitive for G to contain a Ventricle vertex: no ventricle
as such exists on its own; rather, each concrete ventricle is
either the left of the right ventricle. In fact, such a descrip-
tion graph G is unsatisﬁable. Assume that an object x as
instance of LeftVentricle; due to (19), x is also an instance of
Ventricle. To satisfy the A-start property for LeftVentricle,
x must correspond to the i-th vertex of some instance of
G; similarly, to satisfy the A-start property for Ventricle, x
must also correspond to the j-th vertex of some instance of
G. Finally, because LeftVentricle and Ventricle label diﬀer-
ent vertices of G, we have i 6= j, which then invalidates the
disjointness property of Deﬁnition 4. The concept Ventricle
is thus an abstract concept:
it is not meant to be instanti-
ated directly, but only through a subclass. Such concepts
clearly do not belong into a description graph. Hence, after
computing NCg as described in the previous paragraph, our
algorithm classiﬁes the input TBox T1 using standard DL
reasoning; then, it removes from NCg all concepts that are
not leaves in the resulting classiﬁcation. Intuitively, if A is
not a leaf concept in the classiﬁcation of T1, then A is likely
to be an abstract concept, so it should not be added to G.
A pseudo-code of the algorithm is given in [13], and the

tool can be downloaded from HermiT’s Web site.
6.2 Transforming GALEN and FMA

We applied the algorithm from Section 6.1 to the original
version of GALEN; furthermore, FMA is a very large ontol-
ogy, so we have applied our algorithm to a fragment of FMA
that describes the heart. Both ontologies can be downloaded
from HermiT’s Web page. Table 2 summarizes information
about the original and the transformed ontologies.

Our transformation clearly leads to a change in the seman-
tics of the ontology, and some information is lost in the pro-
cess. Many parts of the resulting description graph, however,
correspond with the intuitive descriptions of the anatomy of
the body. For example, the graph shown in Figure 1(a) has
been extracted from the transformed ontology.

7. EVALUATION AND DISCUSSION

To evaluate our approach, we have classiﬁed the original
ontologies using HermiT, transformed them using the algo-
rithm from Section 6 into graph-extended KBs, and clas-
siﬁed the resulting KBs using the reasoning algorithm pre-

562WWW 2008 / Refereed Track: Semantic / Data Web - Semantic Web IApril 21-25, 2008 · Beijing, China2748
413

320
74
246

Translated GCIs:

Into the description graph:
Into rules over the graph:
Into the DL TBox:

Total number of concepts:
Total number of roles:
Total number of GCIs:
GCIs discarded in the transformation:
With both a tree and a graph role:
With existentials on abstract concepts:

Table 2: Information about Test Ontologies
GALEN FMA
430
38
6962 3479
328
0
328
6642 3151
680 2966
1
155
184
5807
16
1741
952
0
168
3114
325
342
667 1076

With existentials on tree roles:
With universals on tree roles:
Involving concept names only:

Vertices in the description graph:
Edges in the description graph:

sented in Section 5. We now present the performance results
and discuss the classiﬁcation results.
7.1 Performance Results

We performed the experiments using a standard laptop
with 1 GB of RAM. The classiﬁcation of the original version
of GALEN and the fragment of FMA took 129 s and 57 s, re-
spectively; furthermore, the classiﬁcation of the transformed
ontologies took 781 s and 6 s, respectively.

The increase in the classiﬁcation time for GALEN is partly
due to the fact that our implementation of the reasoning
algorithm in Section 5 is still very prototypical. In the case of
FMA, the classiﬁcation times are substantially lower because
most of the original ontology is translated into the graph, so
the generated models are much smaller.

Our performance results show that, even with a very pro-
totypical implementation, we can process complex ontolo-
gies, which we take as indication that our approach is prac-
tically feasible.
7.2 Changes in the Semantics

The transformed ontologies are more constrained than the

original ones, so we expect to obtain new entailments.

In the case of GALEN, we discovered a concept that is sat-
isﬁable in the original version of the ontology, but is unsatis-
ﬁable in the transformed ontology, which revealed a model-
ing error in GALEN. The problem occurs in the representa-
tion of the patella—a bone that is connected to certain ten-
dons through two retinacula, represented using the concepts
LateralPatellaRetinaculum and MedialPatellaRetinaculum.
GALEN describes the relationship between the patella and
the two retinacula as follows:

LateralPatellaRetinaculum ≡

∃hasOtherEndAt .Patella ⊓ (. . .)

MedialPatellaRetinaculum ≡

∃hasOtherEndAt .Patella ⊓ (. . .)

hasOtherEndAt ≡ isAtOtherEndOf −
⊤ ⊑ ≤ 1 isAtOtherEndOf

(21)

(22)

(23)
(24)

According to the axioms above, each patella is connected
to both the lateral and the medial retinacula, but due to
functionality of isAtOtherEndOf , the two must be the same
objects. Intuitively, this is an undesirable consequence, since
the two retunaculae are in reality diﬀerent objects; in other
words, isAtOtherEndOf should probably not have been de-

clared functional. Since GALEN is underconstrained, this
does not cause the inconsistency of either concept, so this
error has not been detected so far. The description graph
produced by our transformation, however, contains one node
for the patella and one for each retinaculum; furthermore,
both retinacula are connected through isAtOtherEndOf to
the same patella. Since isAtOtherEndOf
is functional, the
retinacula should be the same, which invalidates the dis-
jointness property for the graph (see Deﬁnition 4) and makes
Patella unsatisﬁable.

In the case of FMA, we did not obtain any new subsump-
tion relationships. This is due to the fact that most of the
subsumption relationships in FMA are represented explic-
itly as axioms of the form A ⊑ B where A and B are atomic
concepts. For example, the fact that the heart is an organ is
represented explicitly with the axiom Heart ⊑ Organ, and it
is not derived from the structure of the heart; clearly, such
inferences are performed in the same way on both tree-like
and nontree structures.

As explained in Section 6, our algorithm discards some ax-
ioms from the ontology. We compared the class hierarchies
of the original and the graph-extended versions of GALEN.
In total, 361 subsumption relationships were lost, such as
Femur ⊑ BodySpace (the femur is a body space), and

InteratrialSeptum ⊑ TwoAndAHalfDimensionalStructure

(the interatrial septum of the heart is a structure with two
and a half dimensions). All these entailments involve an ab-
stract concept, so their loss is not surprising since the trans-
formation algorithm discards GCIs that involve an abstract
concept and an existential on a graph role. No information
about concrete concepts has been lost, though.

In contrast, in the case of FMA we did not lose any sub-
sumption relationships. As explained before, the reason is
that the structural information in FMA largely does not in-
ﬂuence subsumption.
7.3 Discussion

Our experience with GALEN and the discussions we had
with the authors of GALEN lead us to conclude that our for-
malism represents the anatomical structures in the human
body in a way that is closer to the modelers’ intention than
the original OWL axioms.3 The fact that we found a mod-
eling error in GALEN leads us to believe that our formalism
and its semantics are based on “reasonable” assumptions.

Furthermore, capturing the semantics of abstract concepts
and axioms involving them properly is likely to be the most
important open problem. We brieﬂy discuss possibilities for
addressing it. Consider the following axiom in GALEN that
is eliminated by the transformation algorithm because both
AtrioventricularValve and Ventricle are abstract concepts:

AtrioventricularValve ⊑

∃hasAlphaConnection .Ventricle

(25)

Since both concepts in (25) are abstract, this axiom does
not say anything about the structure of the concrete ob-
jects (i.e., the objects that are likely to be included into a
description graph). Thus, one might expect the actual rela-
tionship between valves and ventricles to be described for the
concrete subclasses of AtrioventricularValve and Ventricle.
Axiom (25) can then be interpreted as a check which makes

3Thanks to Alan Rector and Sebastian Brandt.

563WWW 2008 / Refereed Track: Semantic / Data Web - Semantic Web IApril 21-25, 2008 · Beijing, Chinasure that this abstract relationship is concretized at a lower
level. Another possibility is to interpret Ventricle disjunc-
tively over its subclasses: each valve is connected to either
left or the right ventricle, but we do not know which. Cur-
rently, it is not clear which interpretation is appropriate; in
fact, the proper interpretation of abstract concepts is made
more diﬃcult by the fact that whether a concept is abstract
or concrete depends on the level of granularity.

8. CONCLUSION

We have extended OWL with description graphs, which
can be used to describe structured objects—objects consist-
ing of parts connected in a complex, arbitrary way. We also
allow for arbitrary SWRL-like rules over description graphs.
Unlike most existing combinations of DLs and rules in which
rules can be used only for query answering [12, 15, 17, 6, 14],
our rules also fully participate in schema reasoning. Based
on an observation that many structured objects exhibit a
natural bound on their size, we derived a hypertableau rea-
soning algorithm for our formalism, which we implemented
in the HermiT reasoner. To obtain suitable test data, we
extracted description graphs out of GALEN and FMA med-
ical terminologies. We successfully classiﬁed the resulting
ontologies and even detected a modeling error.

We see three open problems for future research. First,
graph-extended KBs should provide for several and not just
one description graph, as this would allow breaking up a
large graph into several more manageable parts. The main
challenge is to identify an appropriate paradigm for specify-
ing relationships between diﬀerent description graphs. Sec-
ond, an adequate semantics for modeling abstract concepts
at diﬀerent levels of granularity is needed. Third, to allow
for a wider users’ community, we would need to extend on-
tology editors such as Prot´eg´e with description graphs.

Acknowledgments
We thank Alan Rector and Sebastian Brandt for providing
us with comments from the domain experts’ perspective.

9. REFERENCES
[1] A. Artale, E. Franconi, N. Guarino, and L. Pazzi.

Part-whole relations in object-centered systems: An
overview. Data Knowledge & Engineering,
20(3):347–383, 1996.

[2] F. Baader, C. Lutz, H. Sturm, and F. Wolter. Fusions

of Description Logics and Abstract Description
Systems. Journal of Artiﬁcial Intelligence Research,
16:1–58, 2002.

[3] D. Calvanese, G. De Giacomo, and M. Lenzerini.

Structured Objects: Modeling and Reasoning. In Proc.
DOOD ’95, pages 229–246, 1995.

[4] S. Derriere, A. Richard, and A. Preite-Martinez. An

Ontology of Astronomical Object Types for the
Virtual Observatory. In Proc. of the 26th meeting of
the IAU, pages 17–18, 2006.

[5] F. M. Donini, M. Lenzerini, D. Nardi, and A. Schaerf.

AL-log: Integrating Datalog and Description Logics.
Journal of Intelligent Information Systems,
10(3):227–252, 1998.

[6] T. Eiter, T. Lukasiewicz, R. Schindlauer, and

H. Tompits. Combining Answer Set Programming

with Description Logics for the Semantic Web. In
Proc. KR 2004, pages 141–151, 2004.

[7] F. W. Hartel, S. de Coronado, R. Dionne, G. Fragoso,

and J. Golbeck. Modeling a description logic
vocabulary for cancer research. Journal of Biomedical
Informatics, 38(2):114–129, 2005.

[8] I. Horrocks and P. F. Patel-Schneider. A Proposal for
an OWL Rules Language. In Proc. WWW 2004, pages
723–731, 2004.

[9] I. Horrocks and U. Sattler. A Tableaux Decision

Procedure for SHOIQ. In Proc. IJCAI 2005, pages
448–453, 2005.

[10] I. Horrocks, U. Sattler, and S. Tobies. Practical

Reasoning for Very Expressive Description Logics.
Logic Journal of the IGPL, 8(3):239–263, 2000.

[11] O. Kutz, I. Horrocks, and U. Sattler. The Even More

Irresistible SROIQ. In Proc. KR 2006, pages 68–78,
2006.

[12] A. Y. Levy and M.-C. Rousset. Combining Horn Rules

and Description Logics in CARIN. Artiﬁcial
Intelligence, 104(1–2):165–209, 1998.

[13] B. Motik, B. Cuenca Grau, and U. Sattler.

Representation of and Reasoning with Structured
Objects in OWL. Technical report, University of
Oxford, UK, 2007. See ﬁrst author’s Web page.

[14] B. Motik and R. Rosati. A Faithful Integration of

Description Logics with Logic Programming. In Proc.
IJCAI 2007, pages 477–482, 2007.

[15] B. Motik, U. Sattler, and R. Studer. Query Answering

for OWL-DL with Rules. Journal of Web Semantics,
3(1):41–60, 2005.

[16] B. Motik, R. Shearer, and I. Horrocks. Optimized

Reasoning in Description Logics using Hypertableaux.
In Proc. CADE-21, pages 67–83, 2007.

[17] R. Rosati. DL + log: A Tight Integration of

Description Logics and Disjunctive Datalog. In Proc.
KR 2006, pages 68–78, 2006.

[18] C. Rosse and J. V. L. Mejino. A reference ontology for

biomedical informatics: the Foundational Model of
Anatomy. Journal of Biomedical Informatics,
36:478–500, 2003.

[19] J. Seidenberg and A. L. Rector. Representing

Transitive Propagation in OWL. In Proc. ER 2006,
pages 255–266, 2006.

[20] A. Sidhu, T. Dillon, E. Chang, and B. Singh Sidhu.

Protein Ontology Development using OWL. In Proc.
OWLED 2005, 2005.

[21] D. Soergel, B. Lauser, A. Liang, F. Fisseha, J. Keizer,

and S. Katz. Reengineering Thesauri for New
Applications: The AGROVOC Example. Journal of
Digital Information, 4(4), 2004.

[22] W.D. Solomon, A. Roberts, J. E. Rogers, C. J. Wroe
C.J., and A. L. Rector. Having our cake and eating it
too: How the GALEN Intermediate Representation
reconciles . . .. In Proc. AMIA, pages 819–823, 2000.

[23] K. A Spackman. SNOMED RT and SNOMEDCT.

Promise of an international clinical terminology. M.D.
Computing, 17(6):29, 2000.

[24] M. Y. Vardi. Why Is Modal Logic So Robustly

Decidable? In Proc. DIMACS Workshop, volume 31,
pages 149–184, 1996.

564WWW 2008 / Refereed Track: Semantic / Data Web - Semantic Web IApril 21-25, 2008 · Beijing, China