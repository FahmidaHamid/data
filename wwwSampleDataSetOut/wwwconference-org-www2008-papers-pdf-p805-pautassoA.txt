RESTful Web Services vs. “Big” Web Services:

Making the Right Architectural Decision

Cesare Pautasso
Faculty of Informatics
University of Lugano

via Bufﬁ 13

6900 Lugano, Switzerland

cesare.pautasso@unisi.ch

Olaf Zimmermann

IBM Zurich Research Lab

Saeumerstrasse 4
8803 Rueschlikon,

Switzerland

olz@zurich.ibm.com

Frank Leymann

Institute of Architecture of

Application Systems
University of Stuttgart
Universitätsstraße 38

70569 Stuttgart, Germany

frank.leymann@iaas.uni-

stuttgart.de

ABSTRACT
Recent technology trends in the Web Services (WS) domain in-
dicate that a solution eliminating the presumed complexity of the
WS-* standards may be in sight: advocates of REpresentational
State Transfer (REST) have come to believe that their ideas ex-
plaining why the World Wide Web works are just as applicable to
solve enterprise application integration problems and to simplify
the plumbing required to build service-oriented architectures. In
this paper we objectify the WS-* vs. REST debate by giving a
quantitative technical comparison based on architectural principles
and decisions. We show that the two approaches differ in the num-
ber of architectural decisions that must be made and in the number
of available alternatives. This discrepancy between freedom-from-
choice and freedom-of-choice explains the complexity difference
perceived. However, we also show that there are signiﬁcant dif-
ferences in the consequences of certain decisions in terms of re-
sulting development and maintenance costs. Our comparison helps
technical decision makers to assess the two integration styles and
technologies more objectively and select the one that best ﬁts their
needs: REST is well suited for basic, ad hoc integration scenarios,
WS-* is more ﬂexible and addresses advanced quality of service
requirements commonly occurring in enterprise computing.

Categories and Subject Descriptors
A.1 [General Literature]: Introductory and Survey; C.2.2 [Com-
puter Communication Networks]: Network Protocols; D.2.11
[Software Engineering]: Software Architectures; D.2.12 [Soft-
ware Engineering]: Interoperability; H.1 [Information Systems]:
Models and Principles

General Terms
Design, Standardization

Keywords
Architectural Decision Modeling, HTTP, REST, Resource Oriented
Architecture, Service Oriented Architecture, SOAP, Technology
Comparison, Web Services, WSDL, WS-* vs. REST

Copyright is held by the International World Wide Web Conference Com-
mittee (IW3C2). Distribution of these papers is limited to classroom use,
and personal use by others.
WWW 2008, April 21–25, 2008, Beijing, China.
ACM 978-1-60558-085-2/08/04.

Figure 1: Putting the WS-* vs. REST decision in the context of
application integration styles

1.

INTRODUCTION

Many different styles can be used to integrate enterprise applica-
tions (Figure 1). The choice between relying on a shared database,
using batched ﬁle transfer, calling remote procedures, or exchang-
ing asynchronous messages over a message bus is a major archi-
tectural decision, which inﬂuences the requirements for the un-
derlying middleware platform and the properties of the integrated
system [20]. The “Big”1 Web services technology stack [1, 45,
47] (SOAP, WSDL, WS-Addressing, WS-ReliableMessaging, WS-
Security, etc.) delivers interoperability for both the Remote Pro-
cedure Call (RPC) and messaging integration styles [41]. More
recently, an alternative solution has been brought forward to im-
plement remote procedure calls across the Web: so-called RESTful
Web services [12] are gaining increased attention not only because
of their usage in the Application Programming Interface (API) of
many Web 2.0 services [32], but also because of the presumed sim-
plicity of publishing and consuming a RESTful Web service [40].
Key architectural decisions in distributed system design, such as
the choice of integration style and technology, should be based on
technical arguments and a fair comparison of concrete capabilities
delivered by each alternative. Instead, the WS-* vs. REST debate
has unfortunately degenerated into biased and religious arguments
which create only confusion and expectations that cannot be ful-
ﬁlled [19].

1We follow the naming convention introduced in [33].

Application Integration StylesFile TransferShared DatabaseMessage BusRemoteProcedure CallSOAPWS*REST805WWW 2008 / Refereed Track: Web Engineering - Web Service DeploymentBeijing, ChinaIn this paper, we take a quantitative approach to compare the two
integration styles technologies based on architectural principles and
decisions. The comparison is based on our industry project and
teaching experience with both approaches. This way, the relative
complexity (or simplicity) of WS-* and RESTful Web services can
be measured in terms of 1) the number of decisions that have to be
made, 2) the number of alternatives (options) that are available, and
3) the relative cost as indicated by development effort required and
technical risk involved. As we will show, decisions may affect one
another so that, e.g., deciding to use a RESTful approach at a high
level will constrain the options for the choice of asynchronous mes-
saging middleware at a lower level. Also, in some cases, the lack
of options concerning some decisions (e.g., transactional guaran-
tees, or the reliability of the message exchange) in REST may only
apparently indicate a reduced complexity because the only choice
left is to implement a custom solution, which incurs higher devel-
opment and maintenance effort and risk.

This paper is organized as follows. First in Sections 2 and 3
we give background information on WS-* and RESTful Web ser-
vices. In Section 4, we introduce our decision-centric comparison
methodology. We then apply it by listing and comparing several
important principles (Section 5), conceptual (Section 6) and tech-
nology (Section 7) decisions involved in adopting WS-* and REST.
In Section 8, we present related work and in Section 9 we draw our
conclusions.

2. SOAP AND THE WS-* STACK

Providing seamless interoperability between heterogeneous mid-
dleware technology stacks and fostering the loose coupling of ser-
vice consumer (requestor, client) and service provider are the major
design goals of Service-Oriented Architecture (SOA) concepts and
Web services technologies.2
2.1 Concepts and Technology

On the conceptual level, a service is a software component pro-
vided through a network-accessible endpoint [16]. Service con-
sumer and provider use messages to exchange invocation request
and response information in the form of self-containing documents
that make very few assumptions about the technological capabil-
ities of the receiver. In particular, there is no notion of a remote
object reference that would require an object broker to manage a
distributed memory address space [43].

On the technology level, SOAP is an XML language deﬁning a
message architecture and message formats, hence providing a rudi-
mentary processing protocol. The SOAP document deﬁnes a top-
level XML element called envelope, which contains a header
and a body. The SOAP header is an extensible container for mes-
sage-layer infrastructure information that can be used for routing
purposes (e.g., addressing) and Quality of Service (QoS) conﬁgu-
ration (e.g., transactions, security, reliability). The body contains
the payload of the message. XML Schema is used to describe the
structure of the SOAP message, so that SOAP engines at the two
endpoints can marshall and unmarshall the message content and
route it to the appropriate implementation.

2We distinguish between concepts and technologies as follows:
there are many ways to implement SOA. For example, Message-
Oriented Middleware (MOM) and, if programming language in-
dependence is not a requirement, message-driven Enterprise Java-
Beans can be viewed as SOA implementation technologies. In this
paper, however, we concentrate on XML-based Web services as
deﬁned by W3C and OASIS [27] and restrict the discussion to the
scope of the WS-I Basic Proﬁle 1.1 [47]. For more information we
refer the reader to [1, 45, 50].

Web Services Description Language (WSDL) is an XML lan-
guage for deﬁning interfaces syntactically. A WSDL port type
contains multiple abstract operations, which are associated with
some incoming and outgoing messages. The WSDL binding
links the set of abstract operations with concrete transport proto-
cols and serialization formats. At the time of writing, the only
standardized binding uses SOAP over HTTP [21]. Vendors have
deﬁned several additional ones to support messaging protocols as
well as proprietary legacy system interfaces. Service endpoints
are addressed either on the transport level, i.e., with Universal Re-
source Identiﬁers (URIs) for SOAP/HTTP-bound endpoints, or on
the messaging level via WS-Addressing [44].

By default, there is no notion of state. The interaction with state-
ful Web services is covered by the WS-Resource Framework [28],
which handles the management of stateful resources behind a Web
service interface. The WS-* technology stack covers also many
other QoS features required to ensure the interoperability of ad-
vanced middleware systems [45]. Given the modularity and com-
posability of the approach, this has led to a fairly large set of WS-*
speciﬁcations.
2.2 Strengths

In spite of their perceived complexity, the SOAP message format
and the WSDL interface deﬁnition language have gained widespread
adoption as the gateway technologies capable of delivering interop-
erability between heterogeneous middleware systems.

One advantage of WS-* is protocol transparency and indepen-
dence. Using SOAP, the same message in the same format can be
transported across a variety of middleware systems, which may rely
on HTTP, but also on many other transports. The transport proto-
col may change along the way. Being declared as SOAP headers,
QoS aspects such as encryption and reliable transfer can be made
independent from the transports used along the path ("end-to-end
QoS").

Using WSDL to describe a service interface helps to abstract
from the underlying communication protocol and serialization de-
tails as well as from the service implementation platform (operating
system and programming language). WSDL contracts provide a
machine-processable description of the syntax and structure of the
corresponding request and response messages and deﬁne a ﬂexible
evolution path for the service. As business and technology require-
ments change, the same abstract service interface can be bound
to different transport protocols and messaging endpoints. In par-
ticular, WSDL can model service interfaces for systems based on
synchronous and asynchronous interaction patterns. This kind of
ﬂexibility becomes fundamental when building gateways for pre-
existing legacy systems, which may not always use Web-friendly
protocols.

Furthermore, mature SOAP engines and WSDL tools [2, 11] ef-
fectively hide the perceived complexity from the application pro-
grammer and integrator. According to our personal project experi-
ence [54], it is not required to study the speciﬁcations to be able to
develop interoperable services, assuming that the selected runtimes
and tools adhere to the WS-I Basic Proﬁle [47]. Test clients can be
generated from the WSDL contracts automatically.
2.3 Weaknesses

Paradoxically, the power delivered by current WS-* tooling that
make it so easy to turn existing software components into Web ser-
vices can also be misused [35]. Thus, it is important to avoid leak-
age across abstraction levels. Interoperability problems can occur
when, for instance, native data types and language constructs of the
service implementation are present in its interface. This weakness

806WWW 2008 / Refereed Track: Web Engineering - Web Service DeploymentBeijing, Chinacan be mitigated by stating and enforcing certain design and coding
guidelines such as contract-ﬁrst development.

Given the expressivity of the WS-* stack of standards, early
implementations have been plagued by interoperability problems.
Apart from misinterpretations later clariﬁed by WS-I, these can
be partly blamed on the impedance mismatch between XML and
existing (object-oriented) programming languages. For instance,
the translation between the XML on the wire and the correspond-
ing memory data structures has been problematic and is the main
source of performance inefﬁciencies [15]. Taking Java as an ex-
ample, several attempts were necessary (Apache SOAP to JAX-
RPC 1.0 and 1.1 to JAX-WS and JAX-B) to produce a stable Web
service marshalling layer [25]. Furthermore, XML Schema is a
very rich language, making it difﬁcult to identify the right con-
struct to express a data model in a way that is fully supported by
all SOAP/WSDL implementations. This problem can be avoided
with proﬁling, identifying a subset of XML Schema types such as
sequences which is “good enough” for most integration scenarios
and known to be interoperable.

3. REST

REpresentational State Transfer (REST) was originally introduc-
ed as an architectural style for building large-scale distributed hy-
permedia systems. This architectural style is a rather abstract entity,
whose principles have been used to explain the excellent scalability
of the HTTP 1.0 protocol and have also constrained the design of
its following version, HTTP 1.1. Thus, the term REST very often
is used in conjunction with HTTP.

In this section we outline the main characteristics of REST fo-
cusing on the current interpretation used to deﬁne “RESTful” Web
services. For more information we refer the reader to [12, 14, 33].
3.1 Technology Principles

The REST architectural style is based on four principles:
Resource identiﬁcation through URI. A RESTful Web service
exposes a set of resources which identify the targets of the interac-
tion with its clients. Resources are identiﬁed by URIs [5], which
provide a global addressing space for resource and service discov-
ery.

Uniform interface. Resources are manipulated using a ﬁxed set
of four create, read, update, delete operations: PUT, GET, POST,
and DELETE. PUT creates a new resource, which can be then de-
leted using DELETE. GET retrieves the current state of a resource
in some representation. POST transfers a new state onto a resource.
Self-descriptive messages. Resources are decoupled from their
representation so that their content can be accessed in a variety of
formats (e.g., HTML, XML, plain text, PDF, JPEG, etc.). Meta-
data about the resource is available and used, for example, to con-
trol caching, detect transmission errors, negotiate the appropriate
representation format, and perform authentication or access con-
trol.

Stateful interactions through hyperlinks. Every interaction with
a resource is stateless, i.e., request messages are self-contained.
Stateful interactions are based on the concept of explicit state trans-
fer. Several techniques exist to exchange state, e.g., URI rewriting,
cookies, and hidden form ﬁelds. State can be embedded in response
messages to point to valid future states of the interaction.
3.2 Strengths

RESTful Web services are perceived to be simple because REST
leverages existing well-known W3C/IETF standards (HTTP, XML,
URI, MIME) and the necessary infrastructure has already become
pervasive. HTTP clients and servers are available for all major

programming languages and operating system/hardware platforms,
and the default HTTP port 80 is commonly left open by default in
most ﬁrewall conﬁgurations.

Such lightweight infrastructure, where services can be built with
minimal tooling, is inexpensive to acquire and thus has a very low
barrier for adoption. The effort required to build a client to a REST-
ful service is very small as developers can begin testing such ser-
vices from an ordinary Web browser, without having to develop
custom client-side software. Deploying a RESTful Web service is
very similar to building a dynamic Web site.

Furthermore, thanks to URIs and hyperlinks, REST has shown
that it is possible to discover Web resources without an approach
based on compulsory registration to a (centralized) repository.

On the operational side, it is known how to scale a stateless
RESTful Web service to serve a very large number of clients, thanks
to the support for caching, clustering and load balancing built into
REST. Due to the possibility of choosing lightweight message for-
mats, e.g., the JavaScript Object Notation (JSON [10]) or, in the ex-
treme, even plain text for very simple data types, REST also gives
more leeway to optimize the performance of a Web service.
3.3 Weaknesses

There is some confusion regarding the commonly accepted best
practices for building RESTful Web services. Hi-REST recommen-
dations have been established informally, but are not always fully
followed by so-called Lo-REST implementations: Hi-REST, advo-
cates using all of the 4 verbs (GET, POST, PUT, DELETE)3; rec-
ommends the use of (so-called) “nice” URIs; and suggests the use
of Plain Old XML (POX) for formatting the content of messages4.
Lo-REST, on the other hand, focuses on the minimum common
denominator. Thus, only 2 verbs (GET for idempotent requests,
and POST for everything else) are used. This is due to the fact
that proxies and ﬁrewalls may not always allow HTTP connections
that use any other verb. Also, POST and GET are the only two
verbs that can be used in the method attribute of an XHTML
form5. These restrictions have led to a series of workarounds,
where the “real” verb is sent using either a special HTTP header
(X-HTTP-Method-Override) or – like with Ruby on Rails
– a hidden form ﬁeld (−method). As with most non-standard
workarounds, these may not be understood by all Web servers,
and require additional development and testing effort. Regarding
the message payload format, Lo-REST simply enforces the use of
MIME-Types, but does not restrict the data to be in a particular
format.

Another limitation makes it impossible to strictly follow the GET
vs. POST rule. For idempotent requests having large amounts of
input data (more than 4 KB in most current implementations) it is
not possible to encode such data in the resource URI, as the server
will reject such “malformed” URIs6 – or in the worst case it will
crash, exposing the service to buffer overﬂow attacks. The size of
the request notwithstanding, it may also be challenging to encode
complex data structures into a URI as there is no commonly ac-
cepted marshalling mechanism. Inherently, the POST method does
not suffer from such limitations.

3The latest version of HTTP 1.1. actually includes 8 verbs: GET,
POST, PUT, DELETE, HEAD, TRACE, OPTIONS, CONNECT.
4At the time writing, it was debated which ﬂavor of XML or which
alternative serialization formats (e.g., JSON, YAML, etc.) guaran-
tees the best interoperability.
5The XForms standard also allows PUT, but not yet DELETE.
6HTTP Code 414 - Request-URI too long.

807WWW 2008 / Refereed Track: Web Engineering - Web Service DeploymentBeijing, China4. COMPARISON METHOD

Architectural decisions [39] are the key metaphor in our com-
parison method. Architectural decisions capture the main design
issues and the rationale behind a chosen technical solution; they
can informally be deﬁned as conscious design decisions concern-
ing a software system as a whole or affecting one or more of its core
components and determining the non-functional characteristics and
quality factors of the system [52]. For each architectural decision,
one or more architecture alternatives (AAs) enumerate the design
options.

In our earlier work, we proposed a structured, proactive approach
to architectural decision modeling [52], which extends today’s prac-
tices of rather informal, retrospective decision capturing for docu-
mentation purposes. When reviewing the SOAP vs. REST debate,
it becomes clear that many of the issues discussed and arguments
brought forward qualify as recurring architectural decisions that
can be modeled.
4.1 Preparation of Decision Models

Architectural decision models have several use cases, for exam-
ple decision support and governance during architecture design;
they can also be used to facilitate technical quality assurance re-
views [53]. In the context of this work, we used them as a metric
for the REST vs. WS-* technology comparison. We took the fol-
lowing steps:

1. Screening of reference information and positioning papers as
well as online resources such as blog entries of proponents
of the two integration styles, identifying candidate decisions
and alternatives along the way.

2. Development of several sample integration scenarios, record-
ing the architectural decisions and development steps required
when using REST and WS-*.

3. Creation of one decision model for each of the two integra-

tion styles from the results of Steps 1 and 2.

4. Comparison of the models created in Step 3, leading to a re-
view cycle to solicit additional input to make sure that both
models actually address the same design issues and are com-
plete enough for the following assessment step.

5. Walk through the now completed decision models to deter-
mine relative complexity and cost (as indicated by required
development effort and technical risk) assessments.

6. Measure and compare 1) number of decisions, 2) number of

options per decision and 3) cost assessment per option.

4.2 Comparison Levels

The two decision models we prepared are organized into four

levels of abstraction:

1. Comparison of architectural principles. The intent of an
architectural style such as REST is communicated through
its deﬁning principles [3]. These principles determine how
the architectural style addresses its requirements and design
goals.
In our comparison models, principles and require-
ments such as protocol layering, dealing with heterogeneity,
and loose coupling are investigated.
A comparison of these principles comprises the ﬁrst step in
our comparison (Table 1). This is the level of abstraction
and detail on which most existing comparisons of the two
styles reside. Principles such as dealing with heterogeneity

and loose coupling are typically deﬁned informally; hence,
an assessment solely based on these criteria only is bound
to be subjective and incomplete. Therefore, we added three
more steps.

2. Comparison of conceptual decisions. Next, we investigate
conceptual decisions required when following one of the two
respective styles (Table 2): we compare how service contract
design is supported and discuss the similarities and differ-
ences between the methodologies for publishing a service.

3. Comparison of technology decisions. We then reﬁne the con-
ceptual decisions and compare how the two integration styles
can be technically realized (Table 3).

4. Vendor asset-level comparison. On this level, concrete im-
plementations tools can be evaluated in the light of the pre-
viously discussed decisions. For instance, we surveyed how
contemporary Web browsers and Web servers implement the
HTTP speciﬁcation, and which SOAP engines and WSDL
tools exist. Due to space limitations, we could not include
these parts of the decision models in this paper.

5. COMPARISON OF PRINCIPLES

We start by comparing how REST and WS-* comply with the

architectural principles introduced in the previous section.
5.1 Protocol Layering

The ﬁrst architectural principle clariﬁes whether the Web is used
as a publishing medium for delivering application services to clients
or as a messaging medium for application integration – in other
words, whether HTTP is considered as an application or as a trans-
port protocol.

In the context of REST, the Web is seen as the universal medium
for publishing globally accessible information. Applications be-
come part of the Web by using URIs to identify the provided re-
sources, data, and services and by leveraging the full semantics of
the four HTTP verbs (GET, POST, PUT, and DELETE) to expose
operations on such resources.

Instead, from the perspective of SOAP/WS-*, the Web is seen as
the universal transport medium for messages, which are exchanged
between Web services endpoints of published applications. Thus,
applications gain the ability to remotely interact through the Web
but remain “outside” of the Web. In other words, the HTTP pro-
tocol is used as a tunneling protocol to enable remote communica-
tion through ﬁrewalls, but it is not used to convey the semantics of
the service interaction. This can be seen from the way WS-* uses
URIs to address messaging endpoints, which typically remain the
same for all operations of a service, whereas REST URIs identify
resources of the application domain.

In WS-*, both request and response messages are exchanged us-
ing only one HTTP verb (POST), the only one which allows to
transfer XML payloads in both directions. This way, the selection
of the operation to be performed by the service is no longer done at
the HTTP level, but is pushed into the SOAP message7.
5.2 Dealing with Heterogeneity

The Web is a rather uniform client/server environment, where all
components (e.g., browsers, Web servers, proxies, clients) speak
the same protocol: HTTP. Heterogeneity is more related to the
competition between different browser vendors that would lead, for
7Unless the SOAP-Action HTTP header is employed, which is
controversial and discouraged by the WS-I Basic Proﬁle.

808WWW 2008 / Refereed Track: Web Engineering - Web Service DeploymentBeijing, Chinayes
X

Architectural Principle and Aspects REST WS-*
Protocol Layering
yes
HTTP as application-level protocol
X
HTTP as transport-level protocol
Dealing with Heterogeneity
yes
Browser Wars
X
Enterprise Computing Middleware
Loose Coupling, aspects covered
Time/Availability
Location (Dynamic Late Binding)
Service Evolution:

yes
X

yes, 3

X
X

Uniform Interface
XML Extensibility

Total Principles Supported

yes, 2
(X)
X
X
3

X
3

Table 1: Principles Comparison Summary

instance, to different renderings of HTML pages or incompatible
JavaScript libraries. Still, all browsers support the same HTTP pro-
tocol and can process a large variety of standard document types.

SOAP and WS-* originate from a more complex and heteroge-
neous domain, the one of enterprise computing. This domain can
be characterized as a collection of heterogeneous, autonomous, dis-
tributed software systems [7]. In organizations having a long his-
tory, which may even predate the advent of the Web, these software
systems are implemented in many different kinds of technologies.
Examples are legacy COBOL programs running on mainframes
that require screen-scraping, transaction processing over Message
Queuing (MQ)-based reliable data feeds, and distributed object-
oriented programs adhering to the Common Object Request Broker
Architecture (CORBA).

From these examples, it can be seen that the heterogeneity ad-
dressed by WS-* standardization efforts goes beyond the synchro-
nous client/server protocols used in speciﬁc RPC middleware prod-
ucts, but extends to delivering the interoperability needed to build
the plumbing for SOAs integrating technically diverse enterprise
applications.
5.3 Deﬁning Loose Coupling

Both WS-* and REST foster the development of loosely coupled
distributed systems, albeit according to different deﬁnitions of this
rather overloaded term. There are many aspects to loose coupling:
time/availability, location transparency, and service evolution are
important dimensions.

A very important aspect of loose coupling concerns the abil-
ity for service consumers to interact with a service provider even
when the latter is not available (the time/availability aspect of loose
coupling). Thus, in such kind of loosely coupled system, clients
are not affected when services suffer from temporary downtime.
When WS-* is used to implement message-based (as opposed to
RPC-based) SOAs, the underlying message bus makes it possi-
ble to achieve such degree of loose coupling as messages can be
transferred using persistent, reliable queues. Since RESTful Web
services exclusively focus on RPC-like, synchronous interactions,
this technology cannot hide such failure scenarios. In other words,
when an HTTP server is down, its clients will be affected as their
HTTP requests fail; they have to handle such connection timeout
failures themselves.

Synchronous interactions can nevertheless show a form of loose
coupling, when clients discover the actual location of service pro-
viders at runtime. This location aspect of loose coupling (dynamic

late binding) is supported by most WS-* toolkits thanks to the stan-
dardization of service registry lookup APIs. In REST, a form of
location transparency can be achieved by DNS address translation,
requiring to additional efforts to properly conﬁgure the networking
infrastructure.

When it comes to managing the evolution of a Web service, loose
coupling implies the ability to make modiﬁcations to a Web service
without affecting its clients. In case of RESTful Web services, it
is clear that the uniform “4 verbs” GET, POST, PUT, DELETE are
the same for all services and never change. Freezing the basic pro-
tocol allows for complete decoupling of clients from servers, as no
change on the server will ever break a client, as such change sim-
ply does not happen. At ﬁrst glance, RESTful Web services might
appear to be “more” loosely coupled, as each WS-* service inter-
face publishes a different set of operations and such interface may
change over time. However, independent of whether the set of op-
erations is ﬁxed or not, another important part of a service interface
deﬁnition is the message parameter data model, which speciﬁes the
format (i.e., the syntax, structure, and in some cases also the se-
mantics) of the message payloads for each operation. In this case,
both WS-* and RESTful POX/HTTP services share the same loose
coupling properties of XML [9]. As opposed to a binary protocol,
the usage of SOAP or POX messages can give the ability to slightly
modify a service interface in non-breaking ways [42].

In summary, as shown in Table 1, both styles support all three
principles, albeit with different deﬁnitions and interpretations of
the aspects involved. Therefore, it is too early to reach a conclusion
and we need to continue with our comparison at the conceptual and
technology levels.

6. CONCEPTUAL COMPARISON

Table 2 summarizes our conceptual comparison. From a con-
ceptual point of view, WS-* and REST support a different set of
integration styles as it was discussed in Section 1.

WS-* and REST take a different approach to the deﬁnition of the
Web service interfaces. In this section, we therefore concentrate
on the most important architectural decisions that have to be made
when following the respective contract design methodologies.

The importance of having a well-deﬁned, machine processable
interface description has been understood for a long time [6, 24].
Two different practices have emerged in the WS-* community. Contract-
ﬁrst prescribes to begin the development of a service from the spec-
iﬁcation of its interface, whereas Contract-last takes a bottom-up
approach, where an existing service implementation is published
with an automatically generated contract.

REST constrains the interface of a resource to its generic uniform
interface with predeﬁned operations. Thus, apparently no decision
has to be made concerning what are the available operations (i.e.,
contract-less development). Designers are advised to concentrate
their effort on deﬁning the exposed resources. However, it is still
necessary to: 1) assess whether all four verbs are applicable to each
resource exposed by the RESTful Web service8 and 2) establish the
exact semantics of applying each verb on the resource.

Comparing the complexity of Web service interface design, we
can conclude that REST appears to be simpler as it completely
constrains the set of operations. However, the designer is still re-
quired to enumerate the set of resources (or the set of operations,
for WSDL-based services) to be provided by a Web service. These
are two different kinds of artifacts; however, a non-negligible de-
sign effort is still required in both cases.

8For which resource/verb combination should “405 Method Not
Allowed“ be returned to the client?

809WWW 2008 / Refereed Track: Web Engineering - Web Service DeploymentBeijing, ChinaArchitectural Decision and AAs
Integration Style
Shared Database
File Transfer
Remote Procedure Call
Messaging
Contract Design
Contract-ﬁrst
Contract-last
Contract-less
Resource Identiﬁcation
Do-it-yourself
URI Design
“Nice” URI scheme
No URI scheme
Resource Interaction Semantics
Lo-REST (POST, GET only)
Hi-REST (4 verbs)
Resource Relationships
Do-it-yourself
Data Representation/Modeling
XML Schema
Do-it-yourself
Message Exchange Patterns
Request-Response
One-Way
Service Operations Enumeration
By functional domain
By non-functional properties and QoS
By organizational criterion (versioning)
Total Number of Decisions, AAs

REST WS-*
1 AA
2 AAs

X

1 AA

X
1 AA
X
2 AA
X
X

2 AAs

X
X
1 AA
X
1 AA
(X)a
X
1 AA
X

n/a

8, 10

X
X

2 AAs

X
X

n/a

n/a

n/a

n/a

1 AA
X

2 AAs

X
X

X
X
X

≥3 AAs

5, ≥10

aOptional

Table 2: Conceptual Comparison Summary

Although the methodology used to design a RESTful Web ser-
vice is rather similar to the one used to design a WSDL-based Web
service, it requires architects and developers to make decisions that
deal with different abstractions. To help with the comparison we
outline these decisions in the following. RESTful Web service de-
sign entails making these decisions (Table 2):

1. Resource Identiﬁcation: What are the resource abstractions
(e.g., a book catalog, a purchase order, a bank account) ex-
posing an application as a Web service?

2. URI Design: Each resource should be addressed using a “nice”
URI scheme [34]. Properties of such URIs include: durabil-
ity [4], predictability, conciseness, reiﬁcation (prefer nouns
to verbs), readability, consistency, and abstraction from im-
plementation details [26].

3. Resource Interaction Semantics: Decide which of the four
verbs are applicable to a resource. For example, should it be
allowed to POST on a resource representing a bank account?
In general, this decision can be constrained by distinguishing
whether accessing a resource is a read-only operation free
of side-effects – and thus GET should be used, or instead
accessing a resource involves modifying its state – thus one
of the PUT, POST, DELETE verbs should be used.

4. Resource Relationships: Resources should be connected by
linking them into several kinds of relationships (e.g., own-
ership, reference, or containment). This is useful to incre-
mentally discover the interface of a RESTful Web service by
traversing hyperlinks between each of its resource represen-
tations. Likewise, the content of a resource can be revealed
gradually, allowing interested clients to follow links to drill-
down for more details. Also, relationships may be used to
represent correct state transitions. Thus clients can correctly
interact with a stateful resource as they navigate to the next
states listed in the current state’s representation.

5. Data Representations: The content-type of a resource must
be chosen among a set of standard formats. If an XML-based
representation is chosen, it is not mandatory to constrain the
content using a schema.

The design process behind a WS-* Web service centers upon the
deﬁnition of its interface using the WSDL language, which requires
to make the following decisions (Table 2):

1. Data Modeling: Structure the content of the XML messages

exchanged by the service using XML Schema data types.

2. Message Exchange Patterns: Determine whether each oper-
ation uses a synchronous or an asynchronous interaction pat-
tern – an outgoing message is only required for synchronous
message exchange.

3. Service Operations Enumeration: Deﬁne the set of actions
exposed by the service interface. A WSDL port type can con-
tain more than one operation; the service modeler can group
related operations by functional area (business domain), by
nonfunctional properties such as security requirements (e.g.,
authorization proﬁle), or by organizational factors such as
change frequency or version management patterns. The ra-
tionale behind these grouping criteria is to achieve high co-
hesion between the service operations so that as few clients
as possible break when the service interface evolves.

The design of the interface of WS-* Web services is a very im-
portant decision, as each service is characterized by a speciﬁc set of
operations, listed in its WSDL description. The port type for each
service must be designed carefully, so that it describes the service
functionality in an understandable way; no pre-deﬁned semantics
for its operations is available. In this regard, many extensions for
annotating service descriptions with additional semantics metadata
have been proposed (e.g., SA-WSDL, or WSDL/S). However, no
standard has been agreed upon yet.

There is a tradeoff between modularity/reusability and perfor-
mance [8]. It is still a challenge to design a reusable Web service
interface, which requires a minimal number of interactions to ac-
complish a certain goal with all of its potential clients [37].

As summarized in Table 2, eight conceptual architectural deci-
sions with only ten alternatives are required for REST. For ﬁve de-
cisions, only one alternative exists. This freedom from choice leads
to substantial design and development efforts for decisions with a
single do-it-yourself alternative. Rather surprisingly, the number of
decisions is lower for WS-* (ﬁve). However, there are many more
alternatives for these decisions (more than ten). Hence, WS-* pro-
vides freedom-of-choice within rather strict conceptual boundaries
established by the speciﬁcations. Moreover, the alternatives are
easier to implement due to the standardization of the concepts and
the available tool support.

810WWW 2008 / Refereed Track: Web Engineering - Web Service DeploymentBeijing, ChinaREST
1 AA
X
(X)b

≥6 AAs

X
X
X
X
X
X
1 AA
X

3 AAs
X
(X)c
Xd
X
1 AA
(X)

X
1 AA
X

1 AA

X

2 AAs

X
X

1 AAs

X
many
X

10, ≥17

Architectural Decision and AAs
Transport Protocol
HTTP
waka [13]
TCP
SMTP
JMS
MQ
BEEP
IIOP
Payload Format
XML (SOAP)
XML (POX)
XML (RSS)
JSON [10]
YAML
MIME
Service Identiﬁcation
URI
WS-Addressing
Service Description
Textual Documentation
XML Schema
WSDL
WADL [18]
Reliability
HTTPR [38]e
WS-Reliability
WS-ReliableMessaging
Native
Do-it-yourself
Security
HTTPS
WS-Security
Transactions
WS-AT, WS-BA
WS-CAF
Do-it-yourself
Service Composition
WS-BPEL
Mashups
Do-it-yourself
Service Discovery
UDDI
Do-it-yourself
Implementation Technology
. . .
Total Number of Decisions, AAs

aLimited to only the verb POST
bStill under development
cOptional
dWSDL 2.0
eNot standard

WS-*
≥7 AAs

Xa

X
X
X
X
X
X
1 AA
X

2 AA
X
X

2 AAs

X
X

4 AAs
(X)
X
X
X
X

2 AAs

X
X

3 AAs

X
X
X

2 AAs

X

X

2 AAs

X
X
many
X

10, ≥25

Table 3: Technology Comparison Summary

7. TECHNOLOGY COMPARISON

Table 3 summarizes the third step of our REST vs. WS-* com-
parison. Unlike in the conceptual comparison, the number of deci-
sions required is the same (ten). However, again WS-* offers more
alternatives. For REST, ﬁve decisions offer only one alternative.
7.1 Transport Protocol

The Web is deﬁned by its protocol: HTTP, thus when choosing
to build a RESTful Web service, there is no choice but to build
services that communicate using HTTP9. Thus, given the lack of
options, no decision is necessary when it comes to choosing the
communication protocol.

One of the properties of WS-*, instead, is its transport inde-
pendence, which allows SOAP messages to be exchanged using a
variety of transport protocols. The WSDL binding element is used
to select an appropriate transport protocol (HTTP being one pos-
sibility) to bind the operation messages. The corresponding QoS,
security, and transactional policies also have to be deﬁned. Table 3
shows a few examples of available transport protocols. With this
approach, messages in a standardized format can be transported
using the most suitable protocol [46]. On the one hand, both syn-
chronous (e.g., HTTP) and asynchronous protocols (e.g., JMS) are
available, making SOAP suitable for the implementation of both
request-response and one-way message exchange patterns. On the
other hand, this creates the need for devising mechanisms such as
SOAP headers, delivering certain QoS properties at the message
level. For example, since a SOAP message could be routed both
over secure and non-secure communication channels, it has been
suggested that the message itself should be protected in order to
guarantee certain end-to-end security properties of the communi-
cation.
7.2 Payload Format

For WS-* Web services, a single standardized message format
exists: SOAP. On the other hand, RESTful Web services currently
do not use a single format for representing resources. Instead they
rely on the ﬂexibility provided by the content negotiation features
of REST to choose between a variety of MIME document types –
which may also include SOAP itself10. This can complicate and
hinder the interoperability of a RESTful Web service, as – for ex-
ample – clients expecting JSON [10] data will not be able to parse
a XML payload. Also, a RESTful Web service capable of serving
resources in multiple representation formats requires more mainte-
nance effort. However, in our experience the beneﬁt of preferring
JSON over XML can outweigh the extra effort and the lack of in-
teroperability with a signiﬁcant overhead reduction.
7.3 Service Identiﬁcation

RESTful Web services leverage the URI standard as the nam-
ing mechanism to address resources. The advantage of URIs is
that they encapsulate all information required to identify and lo-
cate a resource on a global addressing space without the need for
a centralized registry. Furthermore, URIs can be bookmarked, ex-
changed via hyperlinks and, given their readability, even printed on
billboards for advertising [26].

WS-* initially lacked a standard addressing mechanism and also
relied on URIs for identiﬁcation of messaging end-points and WSDL
service interface descriptions. More recently, WS-Addressing [44]
was introduced to represent addressing information through the
deﬁnition of “end-point references”. This standard language aug-

9The waka [13] protocol being still under development
10IETF RFC 3902, application/soap+xml.

811WWW 2008 / Refereed Track: Web Engineering - Web Service DeploymentBeijing, Chinaments the information stored in URIs with additional metadata, but
lacks the conciseness and readability properties that ensured the
success of URIs.
7.4 Service Description

Whereas WS-* Web services rely on a standard, machine-process-
able, strongly-typed XML interface description language (WSDL),
RESTful Web services have adoped a more human-oriented ap-
proach based on informal, textual descriptions, giving developers
extensive documentation of the API of the provided service [32].

As a consequence, WSDL tools can automatically generate client
stub code for most programming languages, masking the complex-
ity of remotely interacting with a service. For RESTful Web ser-
vices, developers have to manually write the code to assemble the
resource URIs and correctly encode/decode the exchanged resource
representations. Having good documentation greatly helps to re-
duce the amount of trial and error involved in the process, but is
no substitute for using a compiler of a “real” interface description
language. To address this shortcoming, the Web Application De-
scription Language (WADL [18]) was recently proposed. Also the
latest WSDL version 2.0 could be applied to describe RESTful Web
services, thanks to its more ﬁne-grained control over the HTTP
binding and the possibility of supporting non-SOAP message en-
codings.

In general, having an interface description language to specify
service contracts is not only beneﬁcial for simplifying repetitive
development tasks, but also helps to catch incompatibilities caused
by changes of service interfaces early in the development process.
Thanks to the strong typing features of WSDL, clients will break at
compile time. This would also beneﬁt RESTful Web services, in-
sofar changes to the URI naming scheme11 and resource represen-
tations are concerned, since due to the uniform interface principle
the actual set of operations applicable to a resource never changes
(as already discussed).
7.5 Reliability, Security, Transactions

The WS-* stack contains a set of optional speciﬁcations covering
the QoS properties of messages exchanged. These help to guaran-
tee a certain quality level in the communication, in a way which is
independent of the underlying transport protocol and which can be
handled automatically by the WS-* middleware. In terms of the ef-
fort involved, developers may declare the desired security/reliable
messaging/transactional policies associated with a Web service in-
terface and reuse the corresponding WS-* standard implementation
to deliver them. While the WS-* speciﬁcations related to QoS in-
deed are complex, they should be considered as optional technol-
ogy choices addressing advanced requirements in enterprise com-
puting scenarios.

For simpler scenarios, the basic guarantees of protocols such
as HTTP (best effort) and HTTPS (point-to-point SSL security)
are shared by both REST and WS-* styles. A reliable extension
to HTTP (HTTPR [38]) was proposed, but did not complete the
standardization process. No framework for distributed transactions
comparable to WS-* has been proposed in conjunction with REST.
7.6 Service Composition

Fostering service reuse by means of service composition is one
of the central tenets of SOA. The standardization of the invoca-
tion path to a Web service has greatly facilitated their reuse and
composition, as opposed to the traditionally fragmented markets
for software components (e.g., where EJBs can not be easily mixed
with .NET assemblies). This has also led to the emergence of a
11HTTP redirection can only work up to a certain point.

large number of languages and tools speciﬁcally targeting the com-
position of WS-* services out of already existing ones (e.g., WS-
BPEL [29], JOpera [31], or XL [15]).

Given their lack of formally described interfaces and the pos-
sibility of not always using XML messages, RESTful Web ser-
vices are cumbersome to compose using the WSDL-based invo-
cation abstractions provided by WS-BPEL [30]. The composition
of RESTful Web services is the main focus of so-called Web 2.0
Mashups, which are seen as a welcome improvement over screen-
scraping the information to be composed out of traditional HTML
Web sites [48].
7.7 Service Discovery

Do-it-yourself build-time lookup is a common choice for both
RESTful and for WS-* Web services. Many successful large-scale
industry deployments of Web services use groupware or Web por-
tals supported by databases as their service repositories [54].

WS-* offers Universal Description, Discovery, and Integration
(UDDI) registries as an additional technology option. While this
technology has been mature and stable for several years now, it
has failed to reach widespread acceptance in the industry. Several
proprietary WSDL-based registry and repository products exist.
7.8 Implementation Technology

A fairly large number of application server platform options ex-
ists both for hosting RESTful and WS-* Web services implemented
in any programming language. Likewise, client-side library sup-
port for consuming RESTful and WS-* Web services is also avail-
able in most programming languages and operating systems. Due
to space limitations we cannot present a complete survey compar-
ing all available implementation technologies. However, it is worth
mentioning that most existing WS-* Web services tools are cur-
rently being extended to also provide support for REST.

8. RELATED WORK

SOAP vs. REST has been an ongoing discussion for some time
on the blogosphere and has also recently gained attention in the aca-
demic community. None of the existing work employs a structured
and detailed comparison method based on architectural decisions.
For example, the ECOWS 2005 keynote [17] focused on the rec-
onciliation of WS-* with REST, whereas [55] gives a comparison
of the two approaches from the point of view of their application
to workﬂow systems. A good discussion on whether the Web (and
in particular RESTful Web services) can fulﬁll the requirements of
enterprise computing can be found in a recent W3C workshop [23].
A comparison of RESTful Web services and so-called “Big Web
Services” is also found in Chapter 10 of [33]. In it, a critical look
to the WS-* stack is given in terms of how it does not ﬁt with
the “resource-oriented” paradigm of the Web. The chapter also at-
tempts to show how simpler RESTful techniques can be used to
replace the corresponding WS-* technologies. The distinction be-
tween “resource-oriented” and “service-oriented” architectures was
ﬁrst introduced by [36]. Unfortunately, the book does not provide
a clear deﬁnition of the terms services and resources, and its tech-
nology comparison is not based on measurable, objective criteria
such as software quality attributes, design and development effort,
technical risk, and QoS characteristics.

Even if HTTP is a synchronous protocol, the comparison pre-
sented in [22] argues that RESTful calls are asynchronous from an
application layer perspective. Thus, REST can be seen as favorable
solution for simple integration scenarios. Additional architectural
concerns such as the URL design and payload format are not dis-
cussed.

812WWW 2008 / Refereed Track: Web Engineering - Web Service DeploymentBeijing, ChinaIn [51] we applied architectural decision modeling concepts to
another complex design issue in SOA, that of designing transac-
tional workﬂows. We touched upon the transport protocol selec-
tion decision, but did not investigate it in detail. The paper focused
on the rationale behind architectural decision modeling and the us-
age of decision models as a design method; it did not serve as a
technology comparison metric as in this paper.

A framework for the comparison of pre-Web services middle-
ware infrastructures (i.e., CORBA vs. J2EE vs. COM+) has been
introduced in [49], with the goal of supporting the choice of the
most suitable framework given certain application requirements.

9. CONCLUSION

In this paper we used architectural principles and decisions as
a comparison method to illustrate the conceptual and technologi-
cal differences between RESTful Web services and WSDL/SOAP-
based “Big” Web services. On the principle level, the two ap-
proaches have similar quantitative characteristics. On the concep-
tual level, less architectural decisions must be made when deciding
for WS-* Web services, but more alternatives are available. On
the technology level, the same number of decisions must be made,
but less alternatives have to be considered when building RESTful
Web services. Thus, the perceived simplicity of REST now can
be understood from a quantitative perspective – choosing REST
removes the need for making a series of further architectural de-
cisions related to the various layers of the WS-* stack and makes
such complexity appear as superﬂuous. Still, if advanced function-
ality as delivered by WS-* is needed, it will be no simple matter
to extend a RESTful Web service to support it in an interoperable
manner. Furthermore, according to our experience several of the
decisions that are very easy to make for RESTful services lead to
signiﬁcant development efforts and technical risk, for example the
design of the exact speciﬁcation of the resources and their URI ad-
dressing scheme.

From our comparison it can also be seen that the two styles
are rather similar, as long as the same subset of technology deci-
sions is compared, for example when ignoring the more advanced
features of the WS-* stack and only comparing POX/HTTP and
SOAP/HTTP. It could even be argued that these two approaches
are two technology-level variants of the same conceptual design.

Assuming that the enterprise-level features of WS-* (transac-
tions, reliability, message-level security) are not required, the key
decision drivers at present are degree of ﬂexibility and control,
but also development efforts and technical risk (in implementa-
tion design, development, and maintenance), degree of open source
and vendor tool support, and programming interface convenience.
REST scores better with respect to ﬂexibility and control, but re-
quires a lot of low-level coding; WS-* provides better tool support
and programming interface convenience, but introduces a depen-
dency on vendors and open source projects. The main conclusion
from this comparison is to use RESTful services for tactical, ad hoc
integration over the Web (à la Mashup) and to prefer WS-* Web
services in professional enterprise application integration scenar-
ios with a longer lifespan and advanced QoS requirements.
Acknowledgements
The authors would like to thank Domenico Bianculli, Christopher
Ferris, Joachim Hagger, Jana Koehler, Noah Mendelsohn, David
Nüscheler, James Snell, Stefan Tramm, and Tammo van Lessen for
their invaluable input and support. This work is partially supported
by the EU-IST-FP7-215605 (RESERVOIR) project.

10. REFERENCES
[1] G. Alonso, F. Casati, H. Kuno, and V. Machiraju. Web

Services: Concepts, Architectures, Applications. Springer,
2004.

[2] Apache. Axis2. http://ws.apache.org/axis2/.
[3] L. Bass, P. Clements, and R. Kazman. Software Architecture

in Practice. Addison Wesley, 2003.

[4] T. Berners-Lee. Cool URIs don’t change, 1998. http:
//www.w3.org/Provider/Style/URI.html.
[5] T. Berners-Lee, R. Fielding, and L. Masinter. Uniform

Resource Identiﬁer (URI): generic syntax. IETF RFC 3986,
January 2005.

[6] A. Birrell and B. J. Nelson. Implementing remote procedure

calls. ACM Transactions on Computer Systems (TOCS),
2:39–59, February 1984.

[7] C. Bussler. B2B Integration. Springer, June 2003.
[8] W. R. Cook and J. Barﬁeld. Web services versus distributed

objects: A case study of performance and interface design. In
Proc. of the IEEE International Conference on Web Services
(ICWS2006), Chicago, USA, September 2006.

[9] F. P. Coyle. XML, Web Services, and the Data Revolution.

Addison-Wesley, May 2002.

[10] D. Crockford. JSON: The fat-free alternative to XML. In

Proc. of XML 2006, Boston, USA, December 2006.
http://www.json.org/fatfree.html.

[11] Eclipse. Web Tools Platform (WTP) Project.

http://www.eclipse.org/webtools/.

[12] R. Fielding. Architectural Styles and The Design of
Network-based Software Architectures. PhD thesis,
University of California, Irvine, 2000.

[13] R. Fielding. waka: A replacement for HTTP. In

APACHECON US, November 2002.
http://www.apache.org/~fielding/waka/.

[14] R. Fielding. A little REST and Relaxation. The International

Conference on Java Technology (JAZOON07), Zurich,
Switzerland, June 2007.
http://www.parleys.com/display/PARLEYS/
A\%20little\%20REST\%20and\%20Relaxation.

[15] D. Florescu, A. Gruenhagen, and D. Kossmann. XL: An

XML programming language for Web service speciﬁcation
and composition. In Proc. of the 11th International World
Wide Web Conference (WWW2002), Honululu, Hawaii,
USA, May 2002.

[16] K. Gottschalk, S. Graham, H. Kreger, and J. Snell.

Introduction to web services architecture. IBM Systems
Journal, 41(2):170–177, 2002.

[17] H. Haas. Reconciling Web services and REST services
(Keynote Address). In Proc. of the 3rd IEEE European
Conference on Web Services (ECOWS 2005), Växjö,
Sweden, November 2005.

[18] M. J. Hadley. Web Application Description Language
(WADL), 2006. http://wadl.dev.java.net/.

[19] D. Hansson. Keynote. In Canada on Rails, January 2006.
[20] G. Hohpe. Enterprise Integration Patterns. Addison-Wesley,

October 2003.

[21] IETF. HTTP, 1999.

http://www.ietf.org/rfc/rfc2616.

[22] E. Landre and H. Wesenberg. Rest versus soap: as

architectural style for web services. In 5th International
OOPSLA Workshop on SOA & Web services Best Practices,
2007.

813WWW 2008 / Refereed Track: Web Engineering - Web Service DeploymentBeijing, China[23] K. Laskey, P. L. Hègaret, and E. Newcomer, editors.

Workshop on Web of Services for Enterprise Computing.
W3C, February 2007. http:
//www.w3.org/2007/01/wos-ec-program.html.

[24] B. Meyer. Applying "design by contract". IEEE Computer,

25(10):40–51, October 1992.

[25] R. Monson-Haefel. J2EE Web Services. A-W., 2003.
[26] J. Nielsen. URI as UI, March 1999. http:

//www.useit.com/alertbox/990321.html.

[27] OASIS. Organization for the Advancement of Structured

Information Standards.
http://www.oasis-open.org/.

[28] OASIS. Web Services Resources Framework (WSRF 1.2),

April 2006. http:
//www.oasis-open.org/committees/wsrf/.

[29] OASIS. Web Services Business Process Execution Language,

April 2007. http://docs.oasis-open.org/
wsbpel/2.0/wsbpel-v2.0.pdf.

[30] H. Overdick. Towards resource-oriented bpel. In 2nd

ECOWS Workshop on Emerging Web Services Technology,
November 2007.

[31] C. Pautasso and G. Alonso. The JOpera visual composition

language. Journal of Visual Languages and Computing
(JVLC), 16(1-2):119–152, 2005.

[32] Programmable Web. API Dashboard, 2007.

http://www.programmableweb.com/apis.

[33] L. Richardson and S. Ruby. RESTful Web Services. O’Reilly,

May 2007.

[34] P. Seebach. Making URLs accessible, June 2001.

http://www.ibm.com/developerworks/
library/us-cranky8.html.

[35] R. Sessions. Fuzzy boundaries: Objects, components, and

web services. ACM Queue, 2(9), December/January
2004-2005.

[36] J. Snell. Resource-oriented vs. activity-oriented Web

services. IBM developerWorks, October 2004.
http://www-128.ibm.com/developerworks/
webservices/library/ws-restvsoap/.

[37] T. Takase and K. Tajima. Efﬁcient Web services message
exchange by SOAP bundling framework. In Proc. of 11th
IEEE International EDOC Conference (EDOC 2007),
October 2007.

[38] S. Todd, F. Parr, and M. Conner. A Primer for HTTPR, July

2001. http://www.ibm.com/developerworks/
webservices/library/ws-phtt/.

[39] J. Tyree and A. Akerman. Architecture decisions:

Demystifying architecture. IEEE Software, 22(2):19–27,
2005.

[40] S. Vinoski. Serendipitous reuse. IEEE Internet Computing,

12(1):84–87, 2008.

[41] S. Vinoski. Putting the "Web" into Web services: Interaction
models, part 1: Current practice. IEEE Internet Computing,
6(3):89–91, May-June 2002.

[42] S. Vinoski. Putting the "Web" into Web services: Interaction
models, part 2. IEEE Internet Computing, 6(4):90–92, July
2002.

[43] W. Vogels. Web services are not distributed objects. IEEE

Internet Computing, 7(6):59–66, Nov-Dec 2003.

[44] W3C. Web Services Addressing, May 2006.

http://www.w3.org/2002/ws/addr/.

[45] S. Weerawarana, F. Curbera, F. Leymann, T. Storey, and

D. Ferguson. Web Services Platform Architecture. Prentice
Hall, March 2005.

[46] C. Werner, C. Buschmann, T. Jaecker, and S. Fischer.

Enhanced transport bindings for efﬁcient SOAP messaging.
In Proc. of the 3rd IEEE International Conference on Web
Services (ICWS’05), Orlando, FL, USA, July 2005.

[47] WS-I. Web Services Interoperability.

http://www.ws-i.org.

[48] J. Yu, B. Benatallah, R. Saint-Paul, F. Casati, F. Daniel, and

M. Matera. A Framework for Rapid Integration of
Presentation Components. In Proc. of the 16th International
World Wide Web Conference. Banff, Canada, May 2007.
[49] A. Zarras. A comparison for middleware infrastructures.
Journal of Object Technology, 3(5):103–123, May-June
2004.

[50] O. Zimmerman, M. Tomlinson, and S. Peuser. Perspectives

on Web Services: Applying SOAP, WSDL, and UDDI to
Real-World Projects. Springer, September 2003.

[51] O. Zimmermann, J. Grundler, S. Tai, and F. Leymann.
Architectural decisions and patterns for transactional
worlﬂows in SOA. In Proc. of the 5th International
Conference on Service-Oriented Computing, Vienna,
Austria, 2007.

[52] O. Zimmermann, T. Gschwind, J. Kuester, F. Leymann, and

N. Schuster. Reusable architectural decision models for
enterprise application development. In Quality of Software
Architecture (QoSA) 2007, Boston, USA, July 2007.

[53] O. Zimmermann, J. Koehler, and F. Leymann. Architectural
decision models as micro-methodology for service-oriented
analysis and design. In SEMSOA Workshop, Hannover,
Germany, May 2007.

[54] O. Zimmermann, M. Milinski, M. Craes, and F. Oellermann.

Second generation web services-oriented architecture in
production in the ﬁnance industry. In OOPSLA Conference
Companion, 2004.

[55] M. zur Muehlen, J. V. Nickerson, and K. D. Swenson.

Developing Web services choreography standards - the case
of REST vs. SOAP. Decision Support Systems, 40(1):9–29,
July 2005.

814WWW 2008 / Refereed Track: Web Engineering - Web Service DeploymentBeijing, China