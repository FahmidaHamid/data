SewNet - A Framework for Creating Services Utilizing

Telecom Functionality

Sumit Mittal, Dipanjan Chakraborty, Sunil Goyal, and Sougata Mukherjea

sumittal@in.ibm.com, cdipanjan@in.ibm.com, gsunil@in.ibm.com,

IBM India Research Laboratory

New Delhi, India - 110 070
smukherj@in.ibm.com

ABSTRACT
With Telecom market reaching saturation in many geogra-
phies and revenues from voice calls decreasing, Telecom op-
erators are trying to identify new sources of revenue. For
this purpose, these operators can take advantage of their
core functionalities like Location, Call Control, etc. by ex-
posing them as services to be composed by developers with
third party o(cid:11)erings available over the Web. To hide the
complexity of underlying Telecom protocols from applica-
tion developers, the operators are steadily adopting Service
Oriented Architecture (SOA) and reference standards like
Parlay-X and IMS. However, a number of challenges still re-
main in rapid utilization of Telecom functionalities for cre-
ating new applications - existence of multiple protocols, dif-
ferent classes of developers, and the need to coordinate and
manage usage of these functionalities.
In this paper, we
present SewNet, a framework for creating applications ex-
ploiting Telecom functionality exposed over a (converged)
IP network. More speci(cid:12)cally, SewNet a) provides an ab-
straction model for encapsulating invocation, coordination
and enrichment of the Telecom functionalities, b) renders
a service creation environment on top of this model, and c)
caters to various di(cid:11)erent categories of developers. With the
help of two use-case scenarios, we demonstrate how SewNet
can create services utilizing rich Telecom functionality.

Categories and Subject Descriptors
C.2.m [Computer-Communication Networks]: Miscel-
laneous; D.2.6 [Software Engineering]: Programming En-
vironments

General Terms
Design, Languages

Keywords
Service Composition, Telecom, Web 2.0, Abstraction Model

1.

INTRODUCTION

The Telecom business model is evolving. With the market
reaching saturation and revenues from voice calls decreasing
rapidly, Telecom operators are aggressively looking at newer
Copyright is held by the International World Wide Web Conference Com-
mittee (IW3C2). Distribution of these papers is limited to classroom use,
and personal use by others.
WWW 2008, April 21–25, 2008, Beijing, China.
ACM 978-1-60558-085-2/08/04.

sources of revenue. This includes partnerships with third-
party providers to o(cid:11)er alternate services such as gaming
applications, news, ringtones, etc.
In recent years, how-
ever, these services are facing strong competition from simi-
lar technologies and applications provided by Internet Con-
tent providers. These applications can be accessed through
a browser-enabled phone, while paying only for the connec-
tivity charges, and thereby adversely a(cid:11)ect revenues from
the paid-for-services hosted on the Telecom operator portal.
Examples of such services range from VoIP and telephony
conferencing services to various content services (maps, ring-
tones, etc.). An increasing number of mobile users are now
using browser-enabled phones to access these services, by-
passing the Telecom portal. For example, it has been esti-
mated that 60% of the mobile content tra(cid:14)c in US and 90%
in Europe is o(cid:11)-portal [10].

Telecom operators, however, have an edge over Internet
service providers in terms of their still unmatched core func-
tionalities of Location, Presence, Call Control, etc., char-
acterized further by carrier-grade Quality-of-Service (QoS)
and high availability. Therefore, a potential channel for the
operators to increase their revenue is to o(cid:11)er these func-
tionalities as services to developers for creating new inno-
vative applications. These developers can belong to not
only the select partners of the Telecom operator, but also
those involved in creating a variety of long{tail applica-
tions [18]. Moreover, with the underlying IP and telephony
networks converging, developers can compose these func-
tionalities with third party services available on the IP net-
work. For example, Location and Presence information from
Telecom can be clubbed with Google Maps to provide new
workforce management solutions for mobile settings [15].

To support the basic operations such as voice and SMS,
many of the building blocks of a Telecom infrastructure -
location registries (HLR/VLR), accounting and billing ser-
vices, etc. - are already in place. However, these are not easy
to utilize in new applications because they are not exposed
using standardized frameworks and component models. To-
wards this, Telecom operators are steadily adopting Service-
Oriented Architecture (SOA) that would let developers ac-
cess these services without knowledge of the underlying plat-
form implementation. Web services, as an instantiation of
SOA, have received much interest in the community due to
their potential in facilitating seamless business-to-business
or enterprise application integration [22]. The Parlay con-
sortium has de(cid:12)ned a standard, called Parlay-X [8], that
exposes Web service interface for core Telecom functionali-

875WWW 2008 / Refereed Track: XML and Web Data - XML IIApril 21-25, 2008 · Beijing, Chinaties. On similar lines, IP Multimedia Subsystem (IMS) [4]
provides a reference framework to expose these functionali-
ties as services to Web-engineered systems using SIP [19].

Although e(cid:11)orts like Parlay-X and IMS are a step in the
right direction, rapid development of applications that uti-
lize Telecom functionality still faces a number of challenges
in a realistic setting. Firstly, one needs to provide interfaces
that shield the application developer from di(cid:11)erent Telecom
protocols (Parlay-X, SIP, etc.), including the legacy ones.
Secondly, one needs to package the Telecom functionalities
so that they can be readily used in di(cid:11)erent programming
styles (Java, HTML/JavaScript, etc.) other than pure Web
service based composition (like BPEL). Finally, one also
needs to encapsulate the invocation of Telecom functional-
ity with various coordination rules, for example, those that
correspond to managing the usage of a service, including
monitoring, metering and access control.

In this paper, we present SewNet, a framework that ad-
dresses the above challenges to enable rapid composition of
Telecom services. Our main contributions in SewNet can be
summarized as:

(cid:15) We propose the Telecom Service Reference, Encapsu-
lation and Coordination (T-Rec) ‘Proxy’ model. This
enables developers to seamlessly incorporate Telecom
functionality and apply various coordination rules.

(cid:15) We design a service composition environment based on

the T-Rec model, and implement a prototype.

(cid:15) We demonstrate how SewNet can be used by di(cid:11)er-
ent categories of developers, including Java, BPEL and
HTML/JavaScript programmers.

It is important to note that although we focus on Tele-
com in this paper, the T-Rec proxy model is generic and
applicable to third-party services available on the Web.

The rest of this paper is organized as follows. In Section 2,
we motivate the reader towards challenges and issues in com-
posing Telecom functionality in di(cid:11)erent applications. We
then propose and describe our T-Rec model in Section 3, fol-
lowed by SewNet’s architecture in Section 4, and implemen-
tation in Section 5. Section 6 illustrates the use of SewNet
for two use-case scenarios, while Section 7 provides a discus-
sion of related work. We conclude in Section 8.

2. PROBLEM ILLUSTRATION AND

MOTIVATION

We illustrate the problem with respect to the component-
oriented diagram of a service that utilizes Telecom function-
ality, as shown in Figure 1. In general, such an application
can be broken into two major blocks. Firstly, there are Tele-
com blocks (represented as red rectangular boxes in the (cid:12)g-
ure) that invoke a Telecom network functionality (for exam-
ple, invoking the location service or capabilities like SMS,
Third Party Call Control). The others are non-Telecom
blocks, where the developers can embed various constructs
(depicted by green hexagonal boxes in the (cid:12)gure). For ex-
ample, in a workforce management solution, these blocks
can contain logic for scheduling agents on the basis of Lo-
cation and Presence information provided by Telecom oper-
ator. Alternatively, these blocks can be UI constructs, for
instance those enabled by various Ajax-based platforms. Fi-
nally, the non-Telecom blocks can also be invocation points

Receive SMS

Location

3rd Party 
service

Send SMS

Start

App Logic

Presence

End

App Logic

UI Construct

Figure 1: Model of a Telecom Service

for orchestration with third party services available over the
Web. Also, as the (cid:12)gure shows, to bind these Telecom and
non-Telecom blocks, speci(cid:12)cation of complex control and
data (cid:13)ows is also required during the service design.

We believe that for application development utilizing Tele-
com blocks composed with the non-Telecom ones, the follow-
ing challenges need to be addressed:

Firstly, functionality available within a Telecom operator
is, in general, exposed using multiple protocols. For exam-
ple, Presence related information can be accessed via the SIP
protocol, and Messaging capabilities using SMPP protocol.
As a step towards hiding protocol heterogeneity and com-
plexity, the Parlay consortium has come up with the Parlay
[9] and the subsequent Parlay-X standards [8]. Parlay-X
exposes a Web Services interface for several Telecom func-
tionalities. However, it does not cover the whole gamut of
functionalities that can be o(cid:11)ered by the Telecom operator,
especially those requiring session control. Further, some
of the Telecom functionality can also be exposed through
legacy protocols. Therefore, we need an abstraction model
that provides interfaces shielding the application developer
from the underlying protocols. This model should also allow
seamless switching between di(cid:11)erent protocols, for example,
when moving from legacy interfaces to the Parlay-X ones.

Secondly, developers who want to utilize Telecom func-
tionality in their application can belong to di(cid:11)erent cate-
gories [18]. More speci(cid:12)cally, composite applications mod-
eled in Figure 1 can be written in Java, BPEL, HTML/JavaScript,
etc. Although editors corresponding to the various program-
ming styles provide the developer with constructs for the
non-Telecom blocks, they still require the Telecom function-
alities packaged in a format suitable for incorporation. For
example, in the case of Java applications, a developer needs
a Java interface to invoke these functionalities (while a Java-
based programming environment lets her code much of the
non-Telecom blocks). Similarly, developers require a WSDL
interface for a BPEL-based composition, JavaScript for a
HTML/JavaScript based composition, etc. Therefore, the
abstraction model (outlined above) for core Telecom func-
tionalities needs also to be broad to cover a range of pro-
gramming styles.

Thirdly, even though interfaces like WSDL (for Parlay-
X) and SIP have tools to generate \clients" for invoking the
corresponding functionalities, in real life, however, there is
e(cid:11)ort required to integrate these clients within the applica-
tion. For example, code needs to be written to incorporate
the client in the application code, while taking care of ter-
tiary library dependencies for this client. It would help the
developer immensely if the abstraction model pre-generates
the clients corresponding to di(cid:11)erent programming styles,
and packages them in a structured manner. Having a well-
de(cid:12)ned structured format would enable any application de-

876WWW 2008 / Refereed Track: XML and Web Data - XML IIApril 21-25, 2008 · Beijing, ChinaComposed Service

Java/ 
JavaScript/
BPEL

Telecom 
Block

Reference

Encapsulation

Coordination

Parlay-X/ 
SIP/ 
Legacy 
Protocols


	

 






T-Rec Proxy

Figure 2: T-Rec ‘Proxy’ Model

velopment environment (with some extensions to interpret
this structure) to integrate these clients seamlessly.

Finally, when Telecom functionality gets used in an appli-
cation, Telecom operator as well as the application developer
want to coordinate its usage. For instance, one needs mech-
anisms for embedding logic for charging, specifying access
control policies, etc. Furthermore, with recent trends sug-
gested by Web 2.0, application developers should be able
to contribute, implicitly or explicitly, to the enrichment and
re(cid:12)nement of the exposed Telecom functionality (and its us-
age). Therefore, the abstraction model needs to be rich
enough to enable all of this.

A number of operators are already moving in the direction
of making their core functionalities available for application
development. For example, British Telecom has released
a Software Development Kit [11] that enables its network
services to be utilized in Web mash-ups. However, what is
missing is an abstraction model which is broad, structured
and rich, as motivated above. We propose such a model
next, and thereafter describe a service creation framework
on top of this model.

3. T-REC MODEL

Figure 2 represents the basic concept of our Telecom Ser-

vice Reference, Encapsulation and Coordination (T-Rec) ‘Proxy’
model.
In essence, once an application has been broken
down into Telecom and non-Telecom blocks, this model is
used to realize the Telecom blocks, considering the program-
ming style, while also enabling mechanisms for coordination
and enrichment. In practice, these proxies would be created
by a Telecom operator and made available to application
developers over the Web (or a converged IP network).
3.1 T-Rec Structure

Our rich, structured T-Rec Proxies consist of the following

elements:

(cid:15) Proxy Representation. Contains signatures of the meth-
ods (APIs) exposed by the proxy along with a tex-
tual description of the service it represents. The APIs
are designed to hide protocol speci(cid:12)c details and ab-
stract the Telecom functionality to the programming
language level. As discussed before, APIs correspond-
ing to multiple styles (Java, BPEL, JavaScript) should
be created to support di(cid:11)erent environments.

(cid:15) Implementation. This module connects to the Telecom
service using the underlying protocol, and is available
in di(cid:11)erent formats. For example, the implementation
could be in the form of a .jar (cid:12)le for a Java proxy, a .js
(cid:12)le for JavaScript, or could be encapsulated by visual
constructs, such as widgets, and used inside HTML
pages.

(cid:15) Con(cid:12)guration File. Proxies come with a default set-
ting but can be further con(cid:12)gured by developers. This
includes assigning default values for some of the pa-
rameters in an API, specifying the access control list,
etc. Such settings could also be functionality speci(cid:12)c,
for instance, restricting the size of SMS messages.

(cid:15) Metadata. To enable easy look up, keywords and tags
related to the proxy functionality are associated with
it. New tags can be added to the proxies if required;
for example when a developer utilizes a proxy in a way
that was not originally foreseen by its creator.

(cid:15) Utility Snippets. The proxies are populated with mul-
tiple code snippets on top of the basic functionality.
For example, a ‘Presence’ proxy may have a program
fragment that parses the returned response (usually an
XML document) for di(cid:11)erent attributes. These utili-
ties can be suggested, in an appropriate manner, to
developers who wish to use the proxy.

(cid:15) Unit Test Code. Proxies contain codes that let di(cid:11)er-
ent APIs supported in the proxy be tested in isolation.
These are very helpful during testing and debugging.

(cid:15) Link to Blogs. Each proxy is linked to a blog entry
where developers can log their experience of using the
proxy. If multiple proxies are suggested during a look
up, analyzing the blog entries can help the developers
choose the most appropriate one for their task.

3.2 T-Rec Beneﬁts

Intuitively, a T-Rec proxy acts as a ‘wrapper’ for Telecom
functionality, including its underlying protocol. Using this
wrapper, the proxy creator can provide several bene(cid:12)ts to
application developers.
3.2.1 Encapsulation
APIs de(cid:12)ned in a proxy can hide protocol speci(cid:12)c details
from the developer. For example,
interfaces in Parlay-X
throw exceptions with error codes that require knowledge of
Parlay-X for interpretation. As an instance, an application
developer using Parlay-X would need to know that the error
code SVC0004 stands for invalid addresses in a message. Us-
ing the proxy model, we can encapsulate these error codes
with higher level exceptions, such as throwing InvalidAd-
dressException whenever error code SVC0004 is returned.
Moreover, using proxies, similar APIs can be exposed across
di(cid:11)erent protocols. For example, various APIs in the Lo-
cation proxy can have similar signatures for Parlay-X and
SIP-Presence based implementations1.
3.2.2 Coordination
When Telecom proxies get used in an application, Telecom
operator as well as the developer can manage and meter its
usage. For instance, whenever the proxy corresponding to
Location information gets invoked within an application, the
Telecom operator can authenticate the developer and also
charge some amount.
In this case, proxies are con(cid:12)gured
to collect the relevant information, for example developerId,
from the developer and send to the operator. Similarly, the

1In SIP, location information is obtained by subscribing for
the presence information, and parsing the returned docu-
ment. We can wrap this under a getLocation() interface.

877WWW 2008 / Refereed Track: XML and Web Data - XML IIApril 21-25, 2008 · Beijing, China
)
s
(
o
i

 

d
u
t
S
n
o
i
t
i
s
o
p
m
o
C

PJQRSUTSVS!W

QW

a
v
a
J

S[

]V<^)R\

QW

``!abc

dbef

jf

`k

L
M
T
H

 
/
 
t
p
i
r
c
S
a
v
a
J

PJQR!S<TS!VSW

QW

S[

])VU^R\

QW

``!a

b)c

d)bef

jf

`k

UML, 
BPEL, 

…

Web

e
r
o
C

t
e
N
w
e
S

 


	



Call Forwarding

Messaging

Call Control

Location

VoIP

Payment




&)'
.)/

&)*+

! "
(!01

#
2!3465

&'

78
DE
BC

9:<;=)>)=:)?@

H
DIJILK

;?l
o!K

=m=
qLDr

=n;=>)=
tu

:?@
vwD)x

y>)=)8
~u

}L;w=>)=
KL
M

GF

:?@

8
D)

<;w=>)=:)?@
G)!N

Figure 3: SewNet Architecture

developer can con(cid:12)gure the Location proxy to cache the lo-
cation information locally within itself, and avoid connecting
to the operator’s infrastructure at each invocation.

The proxy model also provides an easy mechanism to in-
corporate various business contracts between the operator
and the developer. For example, implementation module in
a proxy can be extended to make the proxy display adver-
tisements on behalf of the operator, whenever it is invoked.
In this case, logic can be such that the proxy picks what to
advertise on a real{time basis.
3.2.3 Collaboration and Reuse
Using the proxy model, developers can collaborate, share
and contribute towards enriching Telecom functionality. For
instance, user of the Location proxy in an application can
publish a utility to parse the output of this service. This
utility can be re-used by other developers while incorporat-
ing this proxy in their applications. Similarly, the proxies
can be con(cid:12)gured to provide updates to a developer about
new entries on the blog, utilities published recently and bug
(cid:12)xes, etc. In the case of bug (cid:12)xes, logic can be embedded in
the proxy to automatically download the latest implemen-
tation modules.

4. SEWNET DETAILS

In this section, we present SewNet, a framework that uti-
lizes the rich, structured T-Rec proxy model to enable seam-
less weaving of Telecom functionality with application logic
and other constructs required to develop a service.
4.1 SewNet Architecture

As Figure 3 shows, SewNet has two main architectural

components - SewNet Core and Composition Studio(s).
4.1.1 SewNet Core
SewNet Core forms the backbone architecture that ex-
poses Telecom functionality to developers through simple,
intuitive interfaces for lookup and select while allowing for
developer participation and feedback through publishing and
blogging.

Telecom Repository consists of proxies for di(cid:11)erent
functionalities exposed by the Telecom operator. These prox-
ies are available in various implementation styles, for ex-
ample, Java proxies to be used inside Java applications,
JavaScript proxies to run on a Web browser, etc. As men-

tioned earlier, each proxy hides the underlying protocol (Parlay-
X, SIP, etc.) and o(cid:11)ers a rich set of APIs to facilitate inte-
gration with the application being developed.

Metadata Manager helps the Telecom Repository or-
ganize and maintain relevant metadata (keywords and tags,
textual description, etc.) associated to a proxy and the APIs
it o(cid:11)ers. This information is used to suggest proxies on a
look up.

Blog Manager organizes and stores free-form textual
comments associated to a proxy and its APIs. These inputs
are presented to the developer while browsing and selecting
proxies from the Telecom repository.

Analytics Manager maintains qualitative information
about proxies, including a rating and ranking of each proxy.
We envision this manager containing tools to analyze blogs
by di(cid:11)erent developers, collect usage statistics, etc. and
making such information available to application developers.
Publish Manager de(cid:12)nes the interface to publish new
proxies as well as new artifacts associated to an existing
proxy; published items become available to other developers.
4.1.2 Composition Studio(s)
Developers wishing to use Telecom proxies exposed by
SewNet need to integrate their development environments
(or composition studios) with SewNet Core. These studios
range from programming platforms (e.g. Eclipse environ-
ment) to model driven tools (such as those containing UML
editors for service design and representation) to work(cid:13)ow
editors allowing services to be composed in a language like
BPEL. For integration with SewNet Core, a studio needs
extensions along three dimensions. Firstly, its service de-
sign (or programming) editor should provide the ability to
identify the Telecom blocks from the non-Telecom blocks.
Secondly, it should o(cid:11)er Lookup, Publish and Blogging in-
terfaces for proxies provided by SewNet core. Thirdly, once
proxies have been selected for di(cid:11)erent Telecom blocks, a
Code Generator module should traverse the structured for-
mat of each proxy to seamlessly integrate it with rest of the
application code2. It is interesting to note that a particular
composition studio may use one or more di(cid:11)erent types of
proxies. For example, while creating a JSP page, developers
can incorporate Java as well as JavaScript proxies.
4.2 Composing Telecom Services using SewNet
Once a composition studio has been integrated with SewNet

Core, the following steps illustrate the process that applica-
tion developers follow to compose Telecom services:

1. Service Design: Developer designs the service using
drag-and-drop or other mechanisms supported on the
design editor. In this step, Component services, Logic
blocks, Control (cid:13)ow (sequencing, fork, join), etc. are
de(cid:12)ned by the developer (c.f. Figure 1).

2. Proxy Lookup: For each Telecom block, developer ob-
tains a set of matching proxies from repository, based
on keywords, input-output, or both.

3. Proxy Selection: From candidate proxies suggested by
SewNet, the developer selects those that best (cid:12)t the
requirement. Proxy selection is based on suitability

2In practice, a Composition Studio would already have some
code generation capabilities. In this case, we just need to
extend these capabilities to incorporate the proxy model.

878WWW 2008 / Refereed Track: XML and Web Data - XML IIApril 21-25, 2008 · Beijing, China

$
%
&
(
%
,
-
A
F
G
M
N
F
O
X
Y
Z
\
Y
_
g
h
i
X
Y
Z
\
Y
_
g
h
i
l
A
p
s
F
G
E
F
G
O
z
l
{
|
A
M


M
E
u
E
u
C
p
F

F
O
{
}
A

r
K
F

C

N

K
F
O
Service Design

Proxy Look up, Select





	










Transformation







The code produced depends on the programming lan-
guage. For example, while for Java, it creates a class
with an invoke method that internally calls the proxy
API, for BPEL, it generates an invoke statement. Fur-
ther, Code Generator also analyzes the method signa-
ture of each API to understand the exceptions being
thrown and organizes appropriate exception-handling
blocks around it. Finally, Unit Test codes available
with each proxy are included in the code generated.

Figure 4: Code Generation

5.

IMPLEMENTATION

(for e.g.
metadata (QoS parameters like reputation, etc.).

reading more about each proxy) and other

4. Proxy Con(cid:12)guration: Developer optionally associates
various service coordination rules with each proxy. For
example, she speci(cid:12)es the time-period after which cached
location information is to be refreshed by the Location
proxy.

5. Code Generation: Outputs code for the designed ser-
vice (BPEL, Java, JavaScript inside HTML, etc.). This
step is described in more detail in the next subsection.

6. Incorporate Other Constructs: Developer incorporates
appropriate application logic, UI elements, etc.
to
complete the service. At this point, developer also
takes care of data-(cid:13)ow between di(cid:11)erent constructs.

4.3 Code Generation

From a developer’s view, once a service has been designed
and relevant proxies for the Telecom blocks selected, she ex-
pects the composition environment to generate a skeleton
code that not only captures the service (cid:13)ow, but also in-
tegrates code for the selected proxies. Further, this code
should provide her the extension points to include applica-
tion logic and other constructs for the non-Telecom blocks.
We divide this process of ‘Code Generation’ into three steps:

1. Capture Service Design: Service design is captured in
a structured document, that we call processDoc. Fur-
ther, for each Telecom block, processDoc stores infor-
mation about the proxy that was selected, and the API
that was chosen under this proxy. It should be noted
that the structure of processDoc and the information
it stores is dependent on the programming style of the
application. More speci(cid:12)cally, it should be able to rep-
resent each programming construct of that style.

2. Generate Process Skeleton: This step takes process-
Doc and transforms it to a concrete, fully-compiled
code. For this purpose, Code Generator parses pro-
cessDoc and converts each element into the correspond-
ing programming construct. While parsing this doc-
ument, it creates place holders for the non-Telecom
blocks and adds comments to aid the developer when
she examines the generated code. For the Telecom
blocks, it populates the proxy code, as described next.

3. Populate Telecom Proxy Code: In this step, the Code
Generator imports the relevant implementations of the
proxies from the Telecom Repository and generates the
code necessary to invoke the selected API in the proxy.

In this section, we describe an implementation of SewNet,
including various Telecom proxies, a composition studio to
develop services using these proxies, and generation of code
in two di(cid:11)erent programming styles - Java and BPEL.
5.1 Telecom Repository

In our current implementation, we have built T-Rec prox-
ies corresponding to SMS, Location and Presence functional-
ity and are in the process of creating a proxy for Third-party
Call Control (3PCC). While SMS, Location and 3PCC are
designed on top of Telecom Web Services Server3 (TWSS),
Presence proxy is developed on SIP interfaces exposed by
WebSphere Presence Server (WPS)4. TWSS is an o(cid:11)ering
from IBM that enables Telecom operators to provide devel-
opers with controlled, reliable access to network capabilities
such as Location, SMS and Call Control through standards-
based Parlay-X Web Services. On the other hand, WPS is
an application that collects, manages, and distributes real-
time presence information to applications and users based
on the SIP protocol.

Proxies for each functionality were created in three pro-
gramming styles - Java, WSDL and JavaScript. As noted
earlier, each proxy has an implementation module that con-
nects to the service through the underlying protocol, a ser-
vice representation object (including metadata about the
proxy), a module to test the proxy in isolation and (cid:12)nally
a set of attached utilities. All proxies are available through
a repository implemented on top of DB2 5. This repository
provides various interfaces for integration with a composi-
tion studio - proxy lookup and import, publishing of new
proxies and utilities, blogs indexed per proxy per API, etc.
We are currently in the process of including the capability
to analyze blogs and feedback received for di(cid:11)erent proxies.
For SMS and Location, BPEL proxies were created by us-
ing the WSDL interfaces de(cid:12)ned by Parlay-X, these provide
su(cid:14)cient information for invoking the corresponding func-
tionality from a BPEL work(cid:13)ow. On the other hand, Java
proxies were implemented by generating Java clients from
these WSDL descriptions (using standard IBM tools) and
wrapping inside our proxy structure. For Presence proxy
based on SIP, we used the JAIN SIP standard and rendered
the interfaces in Java for publish, subscribe (with noti(cid:12)ca-
tion handling), etc. This implementation was also exposed
as a Web service, using which a WSDL interface was ob-
tained for the BPEL proxy.

For Parlay-X based functionality (SMS and Location),
JavaScript proxies can be created by including standard
SOAP over HTTP calls from within a JavaScript code frag-

3http://www-306.ibm.com/software/pervasive/serviceserver/
4www.ibm.com/software/pervasive/presenceserver/
5www.ibm.com/db2

879WWW 2008 / Refereed Track: XML and Web Data - XML IIApril 21-25, 2008 · Beijing, China 












 "!

#$



#



Location

LogicBlock2





Start

ReceiveSms

SmsType

Join

End















LogicBlock1

Presence

LogicBlock3



 

	



Figure 6: Proxy Look Up and Publish

Figure 5: SewNet Composition Studio

ment. However, for SIP based proxies like Presence, the
above procedure does not work since SIP messages are ex-
changed over TCP/UDP. To create a JavaScript proxy in
this case, we (cid:12)rst implemented a servlet (to be hosted on the
operator’s infrastructure) that talks to the Presence Server
using SIP (over UDP) messages.
In turn, the Presence
JavaScript proxy interacts with this servlet to fetch presence-
related information while shielding the developer from speci(cid:12)cs
of SIP protocol.

Apart from proxies, our repository contains a Telecom
Constructs Library (TCL) to o(cid:11)er developers with ready-to-
use constructs that can be utilized in a variety of Telecom
applications. For example, this library consists of data-type
de(cid:12)nitions based on the TeleManagement Forum’s Shared
Information/Data (SID) model6 for the Telecom industry.
TCL also contains de(cid:12)nitions of various exceptions related
to the Telecom domain, such as NetworkBusyException, Un-
knownEndPointException, etc. These exceptions encapsu-
late various protocol speci(cid:12)c error codes, like those de(cid:12)ned
in the Parlay-X standard (c.f. Section 3.2.1).
5.2 Composition Studio

Figure 5 gives a snapshot of a prototype Composition Stu-
dio for SewNet along with an annotation of its di(cid:11)erent com-
ponents. The Constructs palette o(cid:11)ers constructs to help
build services, for example, those for specifying start and
end blocks, di(cid:11)erentiating a Telecom block from application
logic block, a condition statement, a join, etc. On the other
hand, Telecom palette exposes proxies for accessing func-
tionalities of the Telecom network, and currently supports
SMS, Location and Presence. The Design Canvas lets the
developers design their services through simple drag-and-
drop of various constructs and Telecom functionality. The
Properties View displays attributes attached to di(cid:11)erent
components of a service design. Once the service has been
completely designed and the proxies chosen, developer can
generate code by invoking the Code Generator. Currently,
code can be generated in Java and BPEL.

The Composition Studio provides service developers the

6http://www.tmforum.org/browse.aspx?catID=1684

facility to look up existing proxies and also publish new ones.
The proxy look up and publish interfaces are shown in Fig-
ure 6. The look up is enabled by SewNet’s Metadata Man-
ager and can be invoked using simple keywords. The results
(cid:12)rst display a brief description of the suggested proxies fol-
lowing which the developer can ask for more details for the
ones that match her requirements. At this point, developers
can also check blogs to bene(cid:12)t from other users’ experience.
The publish interface, on the other hand, provides an easy
mechanism for developers (operators in the case of Telecom
functionality) to package their services as a proxy, and pub-
lish the same in the repository. These proxies can be looked
up and reused by others, thereby fostering a collaborative
environment.

To guide the developers in their composition process, Com-
position Studio also includes a set of application templates.
These templates range from being simple applications uti-
lizing core Telecom functionality to workforce management
solutions and other such services making extensive use of Lo-
cation and Presence information. Developers using SewNet
have the option of starting with these templates, and re-
(cid:12)ning them in the design canvas as per their requirement.
Code Generator can then output code for these.

The entire Composition Studio is implemented as a plug-
in to the Eclipse platform7. Eclipse is an open source meta
IDE built using Java and can be used for building other
IDEs. By becoming part of the Eclipse framework, this stu-
dio becomes immediately available to the large community
of Eclipse users. Moreover, the plugin based approach allows
tapping into various existing and future components being
added to the Eclipse platform. For example, generated Java
code is directly editable using plug-ins included in Eclipse.
5.3 Service Coordination

As discussed before, developers can coordinate various as-
pects of their usage of Telecom functionality through the
proxy model. The current implementation of these proxies
helps developers coordinate their execution (in the devel-
oped application) with respect to testing, billing and con(cid:12)g-
uring various application speci(cid:12)c requirements.
5.3.1 Testing and Debugging
A major challenge for developers in Telecom domain is to
perform the tasks of testing and debugging without going
‘live’ on the network. Towards this, SewNet provides an im-
plementation of proxies for a Telecom simulator8. This sim-
ulator mocks the basic operations of SMS, Call Control, etc.

7http://www.eclipse.org
8http://www.openapisolutions.com/

880WWW 2008 / Refereed Track: XML and Web Data - XML IIApril 21-25, 2008 · Beijing, China

	



	





	















%





	





based on a back-end network emulator and can be used to
simulate various Telecom settings and con(cid:12)gurations. Such
‘simulator’ proxies can be used by developers for correctness
and functionality testing, and debugging, before moving on
to ‘real’ network proxies.
In this case, developers do not
need to change their service design, albeit just switch to the
corresponding proxies for real network.
5.3.2 Billing
Telecom operators spend a signi(cid:12)cant amount of time pro-
visioning a new service and connecting it to their billing sys-
tem. In SewNet, we have exposed the Charging functional-
ity of the Telecom operator (on top of the de(cid:12)ned Parlay-X
interfaces) using the T-Rec proxy model, and made it avail-
able through the repository. A well encapsulated proxy for
billing helps the operator in populating charging rules cor-
responding to a proxy user. Furthermore, billing proxy can
also be o(cid:11)ered to a developer who can utilize it to charge
users of her application. The charging models supported by
the Billing proxy are of various types; for instance, charging
could be based on a contract basis or a per usage basis.
5.3.3 Proxy Conﬁguration
SewNet proxies include a set of con(cid:12)gurable attributes to
suit a variety of applications. For example, in SMS the de-
veloper can restrict the size of message sent by a user. For
Location, the developer can con(cid:12)gure the period of time for
which the location information is cached within the proxy.
Similarly, default handlers are de(cid:12)ned for exceptions thrown
by di(cid:11)erent interfaces. For instance, on encountering a Net-
workBusyException, the default rule can be to wait for a cer-
tain amount of time before retrying. These attributes can
be utilized and con(cid:12)gured by the proxy user at any stage of
the service development process to suit her requirements.
5.4 Code Generation

SewNet’s Composition Studio allows the developers to
output the service code in two di(cid:11)erent programming styles
- Java and BPEL. In each of these cases, the service de-
sign is captured using a processDoc (described earlier in
Section 4.3) based on the BPEL Schema. BPEL is an XML-
based programming language to describe high level business
processes and has many constructs to capture service de-
sign, including invocation, fault handling, correlation, and
support for conditional logic.
5.4.1 Java
Service design captured in processDoc is converted into
a Java project that can be imported inside the Eclipse pro-
gramming environment. For this purpose, we (cid:12)rst make a
skeleton of an Eclipse project including creation of a pack-
age structure and the metadata (cid:12)les .project and .classpath.
A Java class is generated for each of the Telecom and non-
Telecom blocks occurring in processDoc, while a main class
is created to capture the (cid:13)ow of the service. During pop-
ulation of the main class, constructs from the processDoc
(invoke, switch, etc.) are transformed to the correspond-
ing ones in Java. While for the classes generated for non-
Telecom blocks, the developer is expected to embed her ap-
plication logic, for the Telecom blocks, SewNet populates
the classes with code for invoking the chosen proxy. For
this purpose, we (cid:12)rst import the underlying implementa-
tion jars from the repository, add the corresponding import

statements in the Java class9, add statements to instantiate
the underlying proxy object, and capture the output of API
chosen by the developer. Further, we parse the API invoked
to import the data-types corresponding to input and output
variables, and to add try-catch blocks for handling the ex-
ceptions that can be possibly thrown. In general, the code
produced is well-formatted and documented to smoothen
the task of ordinary Java programmers.

While the code generated acts as a template for the com-
posite service, it needs to be examined and modi(cid:12)ed by the
developer to ensure that the data (cid:13)ow between component
services (input-output type matching, ordering of parame-
ters, etc.) is handled properly. Further, it should be noted
that since we are using a processDoc based on BPEL schema
to capture service design, the code that can be outputted in
Java is restricted to those constructs that can be represented
using BPEL structure. We are currently investigating exten-
sions to this schema that would enable a richer Java code.

5.4.2 BPEL
In this case, we assume the Telecom blocks to be re-
alized by Web services and BPEL becomes the ‘glue’ to
bind these Web services into a cohesive business solution.
From the service design in processDoc, we (cid:12)rst generate
the WSDL description that provides the name and interface
for the composite service and describes the port types and
partner link types for stitching together the di(cid:11)erent blocks
(components) in this service. The next step is the genera-
tion of a concrete BPEL structure that captures the invo-
cation of di(cid:11)erent components in the manner as described
by the processDoc i.e., the control-(cid:13)ow of the service. Fur-
ther, we populate the Telecom blocks using speci(cid:12)c details
from the corresponding WSDL descriptions. For example,
we introduce variables that capture the input and output
of each of these blocks. Similarly, we automatically import
the schemas containing de(cid:12)nitions of the various used data-
types. For the non-Telecom blocks, the developer has the
option of either wrapping them as Web services or utilize
extensions to BPEL supporting inline Java code. Finally,
similar to the case of code generation in Java, the developer
needs to edit this template BPEL work(cid:13)ow (for data-(cid:13)ow,
etc.) before it is actually deployed.

6. DEMONSTRATION

We now illustrate how SewNet can be used for rapidly de-
veloping new Telecom applications. We demonstrate com-
position of two services. While the (cid:12)rst one involves utilizing
core Telecom functionality glued together by rich application
logic, the second service is a mashup of Telecom functional-
ity and a third party service.
6.1 Composing a ‘Live’ Yellow-Pages Service
Telecom operators with their de(cid:12)ned presence and loca-
tion frameworks can enable a ‘dynamic, real-time’ Yellow-
Pages service. In essence, this service would provide matches
in response to a customer request seeking ‘nearby’, ‘avail-
able’ vendors (such as tourist looking for a cab) by using
Telecom network to determine the availability and location
of the subscribed vendors. Business Finder [17] is an exam-
ple of such a Yellow-Pages service.

9entries are added to the .classpath meta(cid:12)le also

881WWW 2008 / Refereed Track: XML and Web Data - XML IIApril 21-25, 2008 · Beijing, ChinaLoc

Presence

Matchmake

Start

RecvSms

Parse

Condition

Feedback

Join

SendSms

End

UpdateAvailability

Availability

Figure 7: Yellow Pages Design

Figure 7 illustrates the design of this service on SewNet’s
Composition Studio. The service receives request messages
via the ‘receive SMS’ functionality, and proceeds to parse
the content of these messages. The incoming requests can
be categorized into three types. The (cid:12)rst type corresponds
to a customer’s request for a nearby, available vendor. For
this, the service determines the current location and pres-
ence information of the subscribed vendors and formulates
its response based on its internal match-making logic. The
second type of request is a feedback from a customer while
the third type is from a vendor asking to update her avail-
ability status. Finally, ‘send SMS’ is used to return the
response to the requester. Once the service has been de-
signed, the developer proceeds to look up appropriate prox-
ies for each of the Telecom blocks. In this case, proxies are
selected for SMS, Location and Presence functionalities.

From the service design, code can be generated either in
Java or as a composite BPEL. Figure 8 presents a snap-shot
of the code generated in Java for the designed Yellow-Pages
service. As the code structure in the left panel of the (cid:12)gure
shows, a class is created for each of the Telecom and non-
Telecom blocks. While the classes for SMS, Availability
and Location are populated with code to invoke the under-
lying proxy, classes for Parse, Matchmake, Feedback and Up-
dateAvailability correspond to the application blocks, and
act as place-holders for the service developer to incorporate
her application speci(cid:12)c logic. YellowPages.java is the main
class that coordinates the control (cid:13)ow of the service. This
class has the code to call each proxy and application logic
block using the invoke keyword. It also contains the trans-
formation for constructs like switch, fork, join, etc. used by
the developer in designing the service. Finally, as shown,
the code also includes the Telecom constructs library (c.f.
Section 5.1) and a unit test code for each Telecom proxy.

The right section of Figure 8 presents the code generated
to handle invocation of the Location proxy, including the
block to instantiate the proxy object, import statements to
de(cid:12)ne the used data-types, and handler blocks for the ex-
ceptions thrown. In this example, we have also incorporated
calls to the Billing service (for monetizing the usage of Lo-
cation proxy). As outlined earlier, the code produced can be
easily imported as a project and enhanced inside the Eclipse
development environment.

Figure 8: Code for Yellow Pages

6.2 Creating a Mashup Application

SewNet proxies can also be used to compose mashups in-
volving Telecom functionality and third party services. An
example is demonstrated in Figure 9 that combines the Lo-
cation proxy in JavaScript format along with the popular
Google Maps service. This simple mashup receives updates
on the location information and displays it on Google Maps.
Note that this currently has no application logic component.
However, the same can be incorporated to develop a variety
of di(cid:11)erent solutions, such as a mobile workforce manage-
ment system [15]10.

We are in the process of extending an existing mashup
editor, called QEDWiki [3], to enable seamless incorpora-
tion of SewNet JavaScript proxies in the mashups designed.
More speci(cid:12)cally, this editor needs to add statements to im-
port the implementation (locationProxy.js (cid:12)le that con-
tains getLocation() function), include JavaScript code to
invoke the proxy (call getLocation() that internally sub-
scribes callback() to receive location updates), de(cid:12)ne vari-
ables to capture the invocation output, etc. All this shall be
automatically done through interpretation of the JavaScript
proxy structure.

7. DISCUSSION AND RELATED WORK

In this section, we put SewNet under the perspective of
various current and past e(cid:11)orts towards service composition.
While some of these pertain to Web applications in general,
others are more speci(cid:12)c to the Telecom domain.

Composition using Web Services. The literature on
Web service composition is extensive. Triana [20] aims to fa-
cilitate Web service composition by providing a higher level
of abstraction and guiding developers in creating composed

10A mashup based on SewNet proxies will be demonstrated in
the Conference on IP Multimedia Subsystems Architecture
and Applications (IMSAA-2007).

882WWW 2008 / Refereed Track: XML and Web Data - XML IIApril 21-25, 2008 · Beijing, Chinaprovides high level Web service interfaces via its service de-
livery platform that hide low level Telecom protocol speci(cid:12)c
constraints and allow creation of Managed network mashups.
However, both these lack a structured and rich format like
our T-Rec proxy model.

Telecom Standards and Platforms. The (cid:12)rst wave
of e(cid:11)orts along exposing core Telecom functionality primar-
ily focused on creation of open standards and APIs. For
example, Session Initiation Protocol (SIP) is an open stan-
dard being widely adopted across service providers to create
Voice-over-IP services. Many Telecom operators are now
moving towards implementing the IMS framework [4] to ex-
pose their core functionalities (voice service, SMS service,
Call control) using SIP. JSR-289 [6] has been proposed by
Sun and Ericsson to enhance existing SIP Servlet speci(cid:12)-
cation and support development of composed applications
involving both HTTP and SIP servlets. E(cid:11)orts are being
undertaken to come up with platforms that support con-
current execution environments for di(cid:11)erent standard-based
protocols (e.g. SOAP, SIP over HTTP) and business logic
written in several languages (Java, BPEL, etc.). For exam-
ple, the IBM WebSphere Application Server product suite11
implements a converged SIP and SOAP servlet container,
while enabling tailored message processing and policy en-
forcement for these protocols. Alcatel is also exploring the
option of SOA/REST APIs on top of its Telecom Applica-
tion Server [1]. From SewNet’s perspective, the proxy model
can encapsulate di(cid:11)erent standards, while the implementa-
tion module can be based on available platforms.

Telecom Device Functionality. A generic model of
Telecom services is described in [18], where apart from core
Telecom network functionality and third party o(cid:11)erings, ser-
vices also make use of device functionality and information
such as calendar, user pro(cid:12)le and location (e.g.
cell site
information). Currently, there are a plethora of end-user
devices in a Telecom environment, ranging from basic (of-
fering only the capabilities of messaging and voice) to sophis-
ticated, state-of-the-art devices like iPhone12. There are ef-
forts to promote an open mobile phone software stack that
abstracts hardware di(cid:11)erences and o(cid:11)er a uniform set of
APIs for accessing many of the functions of a mobile phone
(calendaring, date, etc.). JSR 248 speci(cid:12)cation, contributed
signi(cid:12)cantly by Sun Microsystems, is a step towards that
direction. To compose richer Telecom applications within
SewNet, we can wrap the device functionality using the
proxy model and make them available to a developer dur-
ing the composition process. In this case, such ‘device-side’
proxies will not only ease the access to device functional-
ity, but also shield the developer from the heterogeneity of
the underlying device itself. We wish to investigate device
proxies based on JSR 248 in the near future.

Web 2.0 and SewNet. The phrase Web 2.0 refers to a
perceived business revolution in the Web community caused
by the movement to Internet as a platform. In essence, Web
2.0 changes the way in which businesses interact with its
customers, by advocating the following core principles: a)
provide power to the developers by o(cid:11)ering rich, intuitive,
and interactive interfaces for services based on Ajax or sim-
ilar frameworks; b) create an architecture of participation
that encourages consumers to add value to a service as they

11www.ibm.com/software/webservers/appserv/was/
12http://www.apple.com/iphone/

Figure 9: Mashup Code Fragment

services. The paper presents a case study that investigates
how this environment can be used in a Telecom setting. Syn-
thy [14] demonstrates composition of a workforce manage-
ment application enabled over a Telecom network, where
core functionalities like Location are exposed as semantically
annotated Web services and orchestrated using AI planning
techniques. The Meteor-S [23] framework looks at a number
of aspects related to composition of Web services, including
capture of semantic requirements of the process and choos-
ing components under given constraints. Zeng et al. [24] pro-
pose a method for choosing component services during Web
service composition based on a generic QoS model (based
on price, duration, reliability, etc.) and established linear
programming techniques. As noted earlier, in a Telecom
environment, we need a broader model than pure Web ser-
vices to cover di(cid:11)erent protocols.
In any case, SewNet’s
T-Rec proxy model is rich enough to apply many of these
techniques. For example, each proxy can be annotated with
QoS guarantees regarding its reliability, response time, etc.,
using which developers can estimate the QoS parameters of
their composed services according to [16].

Tools for Mashup Applications. One of the most com-
monly used terms for Web 2.0 applications is a \mashup" -
an application that combines content from more than one
source into an integrated experience. Content is picked up
from multiple servers (data sources) using technologies like
Ajax and REST, and composed (or rendered) in the same
user interface (UI), typically a browser. There are several
tools that aid in the creation of such mashup user interfaces.
Examples are QEDWiki [3], Yahoo Pipes [12], Aqualogic [2],
and PrestoStudio [5]. These tools cater to a class of ap-
plication developers who prefer \drag-and-drop" operations
to create their own mashups. Most of these tools are not
Telecom speci(cid:12)c and can bene(cid:12)t by incorporating SewNet’s
proxies. Web21C [11] from British Telecom allows develop-
ers to integrate core Telecom functionality with other Web
services into a single application, while allowing application
speci(cid:12)c logic to bind the component services. Like our work,
Web21C hides the complexity of Parlay-X or SIP by expos-
ing these Telecom functions as higher level APIs. Similarly,
Connected Services Framework Sandbox [7] from Microsoft

883WWW 2008 / Refereed Track: XML and Web Data - XML IIApril 21-25, 2008 · Beijing, Chinause it; and c) harness collective intelligence by facilitating
collaboration and sharing among users through communi-
ties and social networks. We argue that SewNet, based on
T-Rec proxies, incorporates these core Web 2.0 principles.

With several providers and community developers con-
tributing towards development of services and its associated
artifacts, it is important to help a developer with e(cid:11)ective
tools for inferencing and recommendation. While there has
been a lot of work in the domain of inferencing and collabo-
rative (cid:12)ltering [13, 21], SewNet opens up a new environment
for applying current work as well as identifying interesting
problems, for instance, those related to selection and recom-
mendation of utility snippets for a proxy.

8. CONCLUSIONS AND FUTURE WORK
With Telecom market reaching saturation, Telecom op-
erators can take advantage of their core functionalities like
Location, Call Control, etc. These can be exposed as ser-
vices and used by developers to compose rich, innovative
applications. We believe that although operators are mak-
ing e(cid:11)orts in this direction, a number of challenges still need
to be addressed - existence of multiple protocols, di(cid:11)erent
categories of developers, and the need to coordinate the us-
age of these functionalities.
In this paper, we presented
SewNet, a framework for creating applications exploiting
Telecom functionality exposed over a converged IP network.
We (cid:12)rst provided an abstraction model, called the T-Rec
‘Proxy’ model, for encapsulating invocation, coordination
and enrichment of the Telecom functionalities, and there-
after rendered a service creation architecture based on this
model. We also demonstrated the e(cid:11)ectiveness of SewNet
for di(cid:11)erent categories of developers with the help of two
use-case scenarios.

In the future, we wish to integrate SewNet with other de-
velopment studios, including various mash-up environments
and UML-based model driven composition tools. We also
want to create proxies for some popular third party services
available over the Web. Finally, we plan to encapsulate de-
vice capability under our proxy model and include the same
in our service composition framework.

9. ACKNOWLEDGMENTS

We would like to acknowledge Himanshu Agrawal for de-
veloping SewNet’s composition studio, and our colleagues in
IBM Haifa Research Lab for helping us re(cid:12)ne our ideas.

10. REFERENCES
[1] Alcatel Open Service Delivery Solution.
http://www.eurescom.de/Parlay-OSA-
products/Alcatel/Alcatel open service delivery solution.pdf.

[2] BEA AquaLogic Family of Tools.

http://www.bea.com/framework.jsp?CNT
=index.htm&FP=/content/products/aqualogic/.

[3] IBM QEDWiki.

http://services.alphaworks.ibm.com/qedwiki/.
[4] IP Multimedia Subsystem (IMS) Architecture.

http://www.dataconnection.com/sbc/imsarch.htm.

[5] JackBe PrestoStudio.

http://www.jackbe.com/Papers/JackBe-
StudioOverview.pdf.

[6] JSR 289. http://jcp.org/en/jsr/detail?id=289.

[7] Microsoft Connected Services Framework Sandbox.

http://www.microsoft.com/serviceproviders/solutions/
connectedservicesframework.mspx.

[8] Open Service Access (OSA); Parlay X Web Services;

Part 1: Common. 3GPP TS 29.199-01.

[9] Parlay API Speci(cid:12)cation. http://www.parlay.org.

[10] Telco Web 2.0 Mashups: A New Blueprint for Service

Creation.
http://www.networkmashups.com/docs/ssi 0507.pdf.

[11] Web 21c sdk. http://web21c.bt.com/.
[12] Yahoo Pipes. http://pipes.yahoo.com/pipes/.
[13] G. Adomavicius, R. Sankaranarayanan, S. Sen, and

A. Tuzhilin. Incorporating Contextual Information in
Recommender Systems using a Multidimensional
Approach. In proceedings of ACM Transactions on
Information Systems, volume 23, pages 103{145, 2005.

[14] V. Agarwal, K. Dasgupta, N. Karnik, A. Kumar,

A. Kundu, S. Mittal, and B. Srivastava. A Service
Creation Environment based on End to End
Composition of Web Services. In Proceedings of the
14th International World Wide Conference, May 2005.

[15] N. Banerjee, K. Dasgupta, and S. Mukherjea.

Providing Middleware Support for the Control and
Co-ordination of Telecom Mashups. In proceedings of
MNCNA Workshop, Middleware Conference, Nov’ 07.

[16] J. Cardoso, A. Sheth, J. Miller, J. Arnold, and

K. Kochut. Quality of Service for Work(cid:13)ows and Web
Service Processes. Journal of Web Semantics,
1:281{308, 2004.

[17] D. Chakraborty, K. Dasgupta, S. Mittal, A. Misra,

A. Gupta, E. Newmark, and C. L. Oberle.
BusinessFinder: Harnessing Presence to enable Live
Yellow Pages for Small, Medium and Micro Mobile
Businesses. In proceedings of IEEE Communications
Magazine, Issue on \New Directions in Networking
Technologies in Emerging Economies", January 2007.

[18] D. Chakraborty, S. Goyal, S. Mittal, and

S. Mukherjea. On the Changing Face of Service
Composition in Telecom. In proceedings of MNCNA
Workshop, Middleware Conference, November 2007.

[19] J. Rosenberg, H. Schulzrinne et al. SIP: Session

Initiation Protocol.
http://www.rfc-editor.org/rfc/rfc3261.txt, 2002.
[20] S. Majithia, M. Shields, I. Taylor, and I. Wang.

Triana: a Graphical Web Service Composition and
Execution Toolkit. In proceedings of IEEE
International Conference on Web Services, 2004.

[21] J. Martineau, A. Java, P. Kolari, T. W. Finin,
A. Joshi, and J. May(cid:12)eld. BlogVox: Learning
Sentiment Classi(cid:12)ers. In proceedings of AAAI
Conference, 2007.

[22] S. Staab et al. Web services: Been there, done that?

IEEE Intelligent Systems, pages 72{85, Jan-Feb 2003.

[23] K. Sivashanmugam, J. Miller, A. Sheth, and

K. Verma. Framework for Semantic Web Process
Composition. In Special Issue of the International
Journal of Electronic Commerce (IJEC), 2004.

[24] L. Zeng, B. Benatallah, M. Dumas, J. Kalagnanam,

and Q. Z. Sheng. Quality Driven Web Services
Composition. In proceedings of World Wide Web
Conference, 2003.

884WWW 2008 / Refereed Track: XML and Web Data - XML IIApril 21-25, 2008 · Beijing, China