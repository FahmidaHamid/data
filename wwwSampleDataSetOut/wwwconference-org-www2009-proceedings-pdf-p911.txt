Why is the Web Loosely Coupled?

A Multi-Faceted Metric for Service Design

Cesare Pautasso

Faculty of Informatics University of Lugano

6900 Lugano, Switzerland

cesare.pautasso@unisi.ch

Erik Wilde

School of Information

UC Berkeley

dret@berkeley.edu

ABSTRACT
Loose coupling is often quoted as a desirable property of
systems architectures. One of the main goals of building
systems using Web technologies is to achieve loose coupling.
However, given the lack of a widely accepted deﬁnition of
this term, it becomes hard to use coupling as a criterion to
evaluate alternative Web technology choices, as all options
may exhibit, and claim to provide, some kind of “loose” cou-
pling eﬀects. This paper presents a systematic study of the
degree of coupling found in service-oriented systems based
on a multi-faceted approach. Thanks to the metric intro-
duced in this paper, coupling is no longer a one-dimensional
concept with loose coupling found somewhere in between
tight coupling and no coupling. The paper shows how the
metric can be applied to real-world examples in order to
support and improve the design process of service-oriented
systems.

Categories and Subject Descriptors
D.2.2 [Software Engineering]: Design Tools and Tech-
niques—Decision Tables; D.2.8 [Software Engineering]:
Metrics—Software Science; H.3.5 [Information Storage
and Retrieval]: Online Information Services—Web-Based
Services

General Terms
Design, Measurement

Keywords
Loose Coupling, Tight Coupling, Web Services, SOA, REST,
WS-*, RPC, HTTP

1.

INTRODUCTION

One of the deﬁning properties of Web services and service-
oriented architectures is their “loose coupling” [20]. Loose
coupling has a positive connotation as it implies that ser-
vices share only a small set of assumptions and therefore
the impact of change is limited, and services can evolve in-
dependently [18]. A loosely coupled service-oriented system
is thus easy and cheap to evolve and has the potential to
grow as rapidly and scale as easily as the Web. Beyond
this point, however, there is little agreement upon what the

Copyright is held by the International World Wide Web Conference Com-
mittee (IW3C2). Distribution of these papers is limited to classroom use,
and personal use by others.
WWW2009, April 20–24, 2009, Madrid, Spain.
ACM 978-1-60558-487-4/09/04.

term “loose coupling” actually means in the context of spe-
ciﬁc Web technologies (e.g., [3, 9, 27, 19]).

Taking the ongoing SOAP vs. REST debate [31] as an
example, the argument of being “more” or “less” loosely cou-
pled has been brought forward by each side. For exam-
ple, giving an explicit description of a service interface in a
WSDL document can be regarded as loose coupling, because
it enables the interoperability of clients with services imple-
mented in any programming language. However, it can also
be regarded as tight coupling, because changes made to the
WSDL may break clients that are built using code automat-
ically generated from an earlier version of the service de-
scription. Given the lack of a clear deﬁnition of the concept
of coupling, as we are going to discuss, diﬀerent interpreta-
tions are possible. Each side is therefore, in its own view,
correct in labeling the other as the one fostering a “tightly
coupled” approach to the design of service-oriented systems.
This paper explores how to apply the concept of coupling
to the design of service-oriented systems in greater detail,
deﬁnes what it means to do so, and uses this deﬁnition in a
way which leads to a better understanding of the diﬀerent
semantics people refer to when they mention loose and tight
coupling. Our goal is to make explicit the various semantics
that are often implicitly associated with the term, so that
alternative interpretations become clear, and Web service
technologies can be evaluated and compared in terms of the
multi-faceted coupling metric we introduce in this paper.

Through a systematic study, we have collected 12 facets
which can be associated with coupling related to speciﬁc
aspects of Web technologies. This paper gives a deﬁnition
of each facet, and discusses their relationships and interde-
pendencies based on concrete examples. We also apply our
multi-faceted deﬁnition to evaluate the coupling of existing
Web technologies and Web services frameworks (remote pro-
cedure calls over HTTP [2, 13] vs. the RESTful usage of the
HTTP protocol [12, 14] vs. a WS-* compliant enterprise-
service bus [6]). We present our ﬁndings indicating that
whereas current technologies can be considered loosely cou-
pled as far as they provide platform independent solutions,
they achieve a diﬀerent degree of coupling according to all of
the other facets. In particular, no technology per-se provides
loose coupling in terms of all the facets. Also, we show that
the degree of coupling of a service-oriented system does not
fully depend on the choice of the underlying Web services
platform. As far as certain facets are concerned (i.e., granu-
larity and evolution), loose coupling is not inﬂuenced by the
choice, e.g., between REST or WS-* but instead depends on
the outcome of more speciﬁc design decisions.

WWW 2009 MADRID!Track: Web Engineering / Session: Web Architecture Aspect911This paper is organized as follows. We ﬁrst introduce
some related work (Section 2) and discuss the origins of the
term (Section 3) to motivate the need for a better deﬁnition
of loose coupling. Section 4 enumerates twelve facets of cou-
pling giving concrete examples on how they aﬀect Web tech-
nologies. Section 5 evaluates our multi-faceted deﬁnition to
measure the coupling of concrete technology examples. Sec-
tion 6 concludes the paper.
2. RELATED WORK

Most authors recognize that the “notion of designing ser-
vices to be loosely coupled is the most important, the most
far reaching, and the least understood service characteris-
tic” [27, p. 75]. Loose Coupling has been named the “secret
sauce of service-orientation” [3, Chapter 5]. Also, the “need
for loose coupling” is somewhat self-evident and the “notion
of loose coupling is a fundamental underpinning of SOA” [41,
p. 10]. However when it comes to deﬁning precisely what
characteristics of coupling are the most signiﬁcant for the
design of service-oriented systems, only a limited consensus
emerges from the literature.

Zimmermann et al.

[47, p. 157] use loose coupling im-
plicitly as a synonym of ﬂexibility by means of information
hiding: “a client application is not tightly coupled with a
server, but coded against an abstract service description”.
This deﬁnition resonates with the following:

“the phrase loosely coupled describes enter-
prise services’ characteristic of interacting in well-
deﬁned ways without needing to know each other’s
inner workings. This means that the service’s
functionality can change without aﬀecting the
services that use it, as long as the behavior de-
scribed in its interface remains the same–that is,
as long as it continues providing the functionality
it provides.” [44, p. 111]

Delivering loose coupling by means of contracted inter-
faces is also recommended by Bloomberg and Schmelzer [3,
p. 90]. This view is related to the “forgiving nature of
the Web”, which enables browsers to work together with
Web servers developed by diﬀerent vendors. A similar def-
inition of interface coupling is provided by Newcomer and
Lomow [27]. The same authors also mention the importance
of reusing service interfaces (so they are not coupled to a sin-
gle business process) as well as the danger of coupling clients
and services to a speciﬁc platform (i.e., to avoid vendor lock-
in). Platform coupling is also mentioned by Weerawarana
et al. [41]. However, the authors stress that “a message-
based approach fosters loose coupling” and “Web service
technology is built on the concept of [ asynchronous ] mes-
saging”. Hence, Web service technology is loosely coupled,
as opposed to distributed object middleware platforms based
on synchronous interactions. The tightly coupled nature of
RPC-style Web services is discussed by Hohpe [18], where
message-oriented middleware is presented as the loosely cou-
pled solution to enterprise application integration problems.
Kaye [20, Chapter 10] discusses the implications of tight
vs. loose coupling on the following aspects: interaction, mes-
saging style, message paths, technology mix, data types,
syntactic deﬁnition, bindings, semantic adaptation, software
objective, and consequences. Krafzig et al. [23, Chapter 3]
also take a multi-level approach to describe coupling in dis-
tributed systems. These are: physical level (whether services

are directly or indirectly connected), platform (i.e., OS and
programming language) dependency or independency, com-
munications style (synchronous vs. asynchronous), type sys-
tem (strongly typed interfaces vs. weakly typed payloads),
interaction patterns (chatty distributed objects vs. message
bus), process control (centralized vs. distributed), and dis-
covery (static binding vs. dynamic binding).

Whereas the classiﬁcations developed by Kaye and Krafzig
are related to the multi-faceted deﬁnition we are going to
present in this paper, we have revisited their classiﬁcations
in the context of the SOAP vs. REST debate, entirely fo-
cusing on service design issues (i.e., the technical questions
regarding loose vs. tight coupling), while the other classiﬁ-
cations also include considerations that are more related to
the implementation, deployment, and management aspects
of services.
3. ORIGINS

In computer science, the notion of coupling predates the
emergence of service-oriented computing. Some early us-
age examples can be found in distributed systems and soft-
ware engineering design principles. In distributed systems,
loosely coupled architectures are distinguished from “closely
coupled” [36] ones based on whether two processes may com-
municate through some form of shared memory (close) or
may only rely on message passing (loose). In practice, loose
coupling in terms of space, time, and synchronization has
been associated the properties of distributed systems de-
signed according to the publish/subscribe paradigm [10]. In
software engineering, the basic design principle of modular-
ity implies the decomposition of a software architecture into
modules characterized by high cohesion and low coupling [39,
45, 26]. Thus, coupling “measures the interdependencies of
two modules” [15, 5] and it can be understood that a low
degree of coupling is beneﬁcial to aid the understanding and
support the evolution of a system [25].

Even though the term “loose coupling” is often associ-
ated with software architectures (and was introduced into
computer science as early as 1974 [35]), its origins can be
traced back even earlier, leading to research on organiza-
tional structures as early as 1967 [37]:

“The concept [ of loose coupling ] has a rare

[ . . .

combination of face validity, metaphorical salience,
and cutting-edge mysticism, all of which encour-
age researchers to adopt the concept but do not
help them to examine its underlying structure,
themes, and implications.
] Because the
concept has been underspeciﬁed, its use has gen-
erated controversy. Researchers who oppose the
concept on the basis of its imprecision have watched
as more and more researchers adopt it. Researchers
who advocate the concept on the basis of its face
validity have watched it become unrecognizable.
Researchers who are in the middle have often
used the concept hesitantly, convinced that it ﬁts
the phenomena they study, but uncertain about
its meaning.” [29]

By applying this quote from organization research to the
context of service-oriented systems, it is easy to realize how
marketing buzzwords sweep through the IT industry and
gain acceptance thanks to the positive impression they de-
liver and thanks to their imprecise deﬁnition, and thus their

WWW 2009 MADRID!Track: Web Engineering / Session: Web Architecture Aspect912ability to be quoted in many diﬀerent contexts. The prob-
lems which may cause tight coupling or which could be
avoided by implementing loose coupling are the same in or-
ganizations and IT system architectures: the tension be-
tween the eﬃciency and safety of an internally determinate
and completely rational structure, vs. the necessity to ﬁt
into an open world of uncertainty and conﬂicting concepts.
Introducing tight coupling in complex systems may also af-
fect their reliability, making accidents more prone to happen,
because local failures are more likely to propagate [34]. In
case of loose coupling, the following quote is relevant to illus-
trate how it can ﬁt well with the design of service-oriented
systems:

“A ﬁnal advantage of coupling imagery is that
it suggests the idea of building blocks that can be
grafted onto an organization or severed with rel-
atively little disturbance to either the blocks or
the organization. [ . . . ] Thus, the coupling im-
agery gives researchers access to one of the more
powerful ways of talking about complexity now
available.” [42]

“Loose coupling” often is being perceived as referring to
any intermediary state on a linear scale going from “no cou-
pling” to “tight coupling”, with “loose coupling” being any-
where in between these two extremes. This conceptualiza-
tion looks at coupling as a one-dimensional concept. Or-
ten and Weick [29] argue that the linear view of coupling
is too constrained, and suggest to follow a two-dimensional
approach.

responsive

non-responsive

tightly coupled
non-coupled

non-distinctive

loosely coupled

decoupled
distinctive

Figure 1: Two-Dimensional View of Coupling in Or-
ganizational Studies

The two-dimensional deﬁnition shown in Figure 1 has
been developed within the context of organizational stud-
ies. But even for the goal of achieving loose coupling in the
context of service-oriented systems design, this model can
be useful to understand that a multi-dimensional approach
to deﬁne the concept can lead to improved understanding.
If the IT landscape for which services are being designed
has distinctive components, then it is not realistic to look at
If, however, for organi-
tight coupling as the ultimate goal.
zational, contractual, political, or legal reasons, it is possible
to remove distinctiveness, it is possible to design and de-
ploy a tightly coupled system. In the two-dimensional view
of coupling, the question is how to achieve responsiveness
(i.e., the ability for all business-level goals to be achieved by
having services interact) given the design goals and/or the
constraints of the environment.

1

Even with this two-dimensional view of coupling, however,
it is still not completely clear what these two orthogonal
axes (responsiveness, distinctiveness) refer to in the context
of service-oriented systems design. Nowadays it is, for exam-
ple, well-accepted that distinctiveness in terms of the phys-

1

With the exception being the introduction of a technology
layer which introduces homogeneity, which is the traditional
middleware approach.

ical network infrastructure is mostly irrelevant — the Inter-
net provides a protocol stack which makes it unnecessary to
deal with network protocol issues that were serious issues
when computer networks were still dominated by vendor-
speciﬁc protocol suites. This begs the question what kind
of properties one should look for when evaluating a given
technology according to the model shown in Figure 1. The
next Section thus introduces a number of facets which we
have identiﬁed as being important properties for deciding
how a given service-oriented design should be evaluated to
measure its coupling properties.

4. COUPLING FACETS

This section introduces a framework which can serve as a
tool for analyzing the kind of coupling implied by a given
technology choice during the design of a service-oriented
system. From the previous discussion, it is clear that cou-
pling is a complex concept that requires to explore a multi-
dimensional space. To do so, we look at various facets to
which the term can be applied. We prefer the term facets
over dimensions to emphasize that not all facets are com-
pletely independent. While enumerating the following facets
(summarized in Table 1), we have attempted to achieve a
high degree of independence between them, but we do not
claim that they are fully orthogonal.

The facets cover all relevant design aspects that help to
understand which kind of coupling can be found in a system.
Our method for identifying relevant facets is based on the
principle that a facet should be included if there is a concrete
scenario where the facet can help to better understand how
a system design or a technology might be perceived as being
tightly or loosely coupled.
4.1 Discovery

Discovery is one of the facets which can be approached
in diﬀerent ways. In closed environments, it is possible to
deﬁne and implement policies for compulsory registration
of service descriptions and interfaces, making it possible for
clients to discover them (e.g., using UDDI registries [7]).
The Web, however, has no central registry beyond the DNS
(which is not Web-speciﬁc, but a core part of the Internet
protocol suite). Some attempts were made to have “Web
site registries” (similar to Yahoo! or the Open Directory
Project) but such centralized registry-based approaches were
overwhelmed by the Web’s rate of growth, and the lack of
a universally accepted scheme for classifying Web resources.
Nowadays, clients perform discovery on the Web through
search engines. Search engines do not necessarily require the
registration of new Web pages, as they can rely on crawlers
following hyperlinks to discover them.

RESTful Web services are usually not described or reg-
istered in any standardized or centralized way. The idea is
that a RESTful Web service can be discovered by decentral-
ized referral (i.e., by exchanging a hyperlink pointing to it)
and does not need a description in terms of its operations,
and that the representations that the service accepts and
produces are exposed through HTTP, and are documented
as media types. Thus, discovery for a RESTful Web service
means interacting with it, and the only possible “registry”
might be sets of URI templates [16], describing how its re-
sources are addressed through URIs.

In the case of SOAP and WS-*, no equivalent “loosely
coupled” mechanism is available to describe relationships

WWW 2009 MADRID!Track: Web Engineering / Session: Web Architecture Aspect913Facet
Discovery
Identiﬁcation
Binding
Platform
Interaction
Interface Orientation Horizontal

Tight Coupling Loose Coupling
Registration
Context-based
Early
Dependent
Synchronous

4.1
4.2
4.3
4.4
4.5
4.6
4.7 Model
4.8
4.9
4.10 Evolution
4.11 Generated Code
4.12 Conversation

Granularity
State

Referral
Global
Late
Independent
Asynchronous
Vertical
Self-Describing Messages
Coarse
Stateless
Compatible
None/Dynamic
Reﬂective

Shared Model
Fine
Shared, Stateful
Breaking
Static
Explicit

Table 1: Coupling Facets Summary

between services that can be exploited for the purposes of
discovery. It is worth noting that the global UDDI business
registries were discontinued in January 2006. After 5 years
of operation they had accumulated less than 50’000 service
registrations (a small number when compared to the size
of the Web), showing that the “tightly coupled” assumption
of expecting all service providers to manually register them-
selves was not practical. However, UDDI continues to thrive
within the boundaries of the corporate ﬁrewall, showing that
a tightly coupled solution can work in a local environment.
Discovery also requires a common model (see Section 4.7),
because discovery implies that services (and registries) share
some model of what to discover, and how to discover it. For
example, keyword search (i.e., indexed phrases) is the largest
common denominator on the Web: it is a free text model.
It also is a weak model because it does not ensure that re-
sults actually match a given API, as shown, for example,
by the work on the Woogle free-text search engine for Web
services [8].
4.2

Identiﬁcation

Identiﬁcation (often also referred to as naming) is one of
the most important design considerations in order to connect
systems with the real world, and systems with systems. Sys-
tems usually perform tasks applied to objects found outside
of the systems themselves. Identiﬁcation is about making
the association between the representations within the sys-
tems, and these external entities (and of course also for the
entities only existing within systems). The challenges re-
lated to identiﬁcation include designing namespaces, assign-
ing identities, and providing identity-related services, such
as discovery lookups, bindings, or comparisons [21].

Tightly coupled approaches to identiﬁcation mostly rely
on centralized services, where there is a single entity assign-
ing and managing identities. In that case, identity is mostly
tied to the context within which services are cooperating
with that central entity. As soon as identiﬁers are moved
outside of that context, services lose the ability to meaning-
fully handle these identiﬁers; they become opaque with no
clearly deﬁned rules how to interpret and resolve them. Ide-
ally, identiﬁers in tightly coupled scenarios always should be
augmented with additional context information when they
leave the original context. In practice, however, this rarely
happens and the problem of resolving identiﬁers due to a
loss of context is a frequently occurring problem [38].

Loose coupling is based on an identity concept which does
not couple identiﬁcation to context. In the context of REST,

identiﬁcation is done using a Uniform Resource Identiﬁer
(URI) [1]. URIs can use various identiﬁcation schemes,
with the most frequently used one on the Web being the
http scheme. Services are free to use whatever identiﬁcation
scheme they like, the important aspect being that agreeing
on URIs as the common way of identiﬁcation makes it eas-
ier to use globally unique identiﬁers without relying on a
centralized authority. If applications insist on using opaque
local identiﬁers, these can be folded into URIs using the tag
scheme [22]. However, this would re-create the problem of
these URIs needing a proper context for interpretation that
is typical for tightly coupled identiﬁcation.
4.3 Binding

Closely related to discovery and identiﬁcation, binding
refers to the process of resolving symbolic names into iden-
tiﬁers used at a lower abstraction level. For example, a
DNS name can be bound to one of the corresponding IP
addresses using a DNS lookup (a form of discovery).
In
service-oriented systems, binding can be applied in diﬀerent
ways [30]. Abstract service interfaces referred to by clients
need to be bound to a concrete network endpoint and trans-
port protocol used by the service provider. Likewise, the
partner links of a BPEL process need to be bound to com-
patible WSDL port types.

A tightly coupled binding is one that is hard to change,
e.g., when it is resolved early, a long time before the re-
sult of the lookup is actually needed. Thus, compile-time or
deployment-time binding are considered to establish a tight
coupling between the bound entities, as it will not be possi-
ble to change the binding during the rest of the lifecycle of
the system.

Dynamic binding instead happens at run-time, and partic-
ularly at the latest possible time (e.g., right before a service
invocation). This is a form of loose coupling, because the
binding is established only when it becomes necessary. Per-
forming a lookup before every service invocation, however,
can impose a signiﬁcant overhead and establishes a tight
coupling between the clients and the resolver. Not only the
resolver becomes a scalability bottleneck, but if the resolver
would become unavailable, all client lookups will fail and
clients will be unable to perform any service invocation.
4.4 Platform

Platform coupling concerns the requirements for all ser-
vices to be based on a homogeneous middleware infrastruc-
ture.
If two services need to communicate, they must be

WWW 2009 MADRID!Track: Web Engineering / Session: Web Architecture Aspect914Service Client

Horizontal Interface

Vertical Interface

Client-Side

Logic

Vertical Interface

Service API 
Implementation

Service 

Implementation

Service Client

Service 

Implementation

Service Protocol

Logic

Service 

Implementation

1. Horizontal Interface

2. Vertical Interface (protocol used directly)

3. Vertical Interface (internal horizontal separation)

Figure 2: Interface Orientation

built using a compatible platform and programming lan-
guage.
Interaction between services built using diﬀerent,
heterogeneous platforms (e.g., CORBA, DCOM, .NET, J2EE)
is not easy to achieve, as complex and expensive bridging so-
lutions are required [28]. A service is thus tightly coupled
to a speciﬁc technology platform if this limits the possibility
of outsourcing the management of the service to an external
provider as well as the ability of clients built on a diﬀerent
platform to use the service.

Standardization helps to decouple services thanks to the

interoperability it provides between diﬀerent platforms. Thus,
the beneﬁt of the Web services stack of standards is to enable
such interoperability and make the underlying technology
platform irrelevant when it comes to connecting services. In
this sense, loose coupling means that services that still need
to be deployed on a speciﬁc platform (by a speciﬁc vendor)
are nevertheless able to exchange messages with each other
no matter which middleware platform and programming lan-
guage is chosen.

4.5

Interaction

The interaction facet is about whether two services need
to be available at the same time in order to successfully
interact. Tight coupling is implied by synchronous interac-
tions, which require both parties to be available at the same
time in order to communicate. Loose coupling is typically
associated with asynchronous interactions, where a success-
ful interaction can happen even if one of the involved parties
is not available at the same time.

In service-oriented systems, the interaction facet of loose
coupling plays a major role in order to enable the communi-
cations of subsystems that are provided as a service by a dif-
ferent organization than the one consuming them. Thanks
to the properties of asynchronous message-based communi-
cations, it becomes possible to remove the time dependencies
between both ends of the communication.

For example, when it comes to performing maintenance
tasks on the services, as these do not always need to be
available to immediately handle client requests, the service
providers do not need to schedule outages taking into ac-
count the needs of their clients. On the other hand, a service
that is published using a synchronous communications pro-
tocol requires a bigger investment to avoid outages in the
provider infrastructure, as client request messages will be
lost if the service supposed to process them becomes (even
temporarily) unavailable.

HTTP is typically perceived as a synchronous communi-
cations protocol: when a Web server is not available, Web
browsers stop working. However, in more complex setups,
thanks to HTTP caches, proxies and reverse proxies, it be-
comes possible to service HTTP requests even if the main

back-end system is down. Also, the HTTP protocol can be
used to interact with non-blocking RESTful Web services,
which do not immediately respond to requests. Instead, to-
gether with a 202 (Accepted) status code, they provide a
URI from which to download the response at a later point in
time. However, as it can be seen from this example, this is
only a non-blocking synchronous interaction. The client does
not have to remain connected to the server while it waits for
a response, but when the request is sent, the server must be
available to receive it.
4.6

Interface Orientation

Interfaces to services can be designed with two alternative
orientations: horizontal or vertical. Horizontal interfaces (or
APIs) are local interfaces from a higher-level component to
a lower-level component. APIs for remote operations still
allow the higher-level component to only interact with a
local component (the API), since the component providing
the horizontal interface acts as a stub, hiding the distributed
nature of the interaction.

Vertical interfaces (or protocols) instead deﬁne the rules
that are necessary to communicate with a remote component
found on the same abstraction level. A protocol still needs a
communications mechanism which provides the foundation
on top of which the protocol is supposed be executed, but
the protocol itself provides a vertical separation between two
services.

Horizontal interfaces assume that there is a lower-level
component which provides the functionality, and this com-
ponent typically either sits on top of another horizontal in-
terface (as in a layered architectural style), or directly im-
plements a vertical interface. A typical example for this is
the well-known socket API, which provides a local library
for establishing inter-process communications.

Designing services based on horizontal interfaces mostly
results in tight coupling, because the component providing
the interface must be a more homogenous component, adher-
ing to both the horizontal interface it implements, and the
way in which the functionality is implemented, such as using
a protocol to communicate with a remote service provider
2
Designing services based on vertical interfaces
(Figure 2.1).
typically results in loose coupling, because this approach is
based on the minimal set of deﬁnitions that are necessary to
interact — the protocol deﬁnition.

Vertical interfaces are better for heterogeneity, because
they do not make any assumption about how the local ab-
2

As a historical footnote it is interesting to mention that
the Internet protocol stack only speciﬁes vertical interfaces
(protocols), whereas the ISO/OSI protocol architecture [46],
the major Internet contender in the 80s, speciﬁed protocols
as well as standardized horizontal interfaces (APIs) for all
its layers.

WWW 2009 MADRID!Track: Web Engineering / Session: Web Architecture Aspect915straction (the horizontal interface between the protocol im-
plementation and the service user) is designed (Figure 2.2
shows the basic model, Figure 2.3 shows an internal sepa-
ration of the client-side code). Horizontal interfaces often
lead to homogenous environments, where all integrated ser-
vices depend on the same middleware APIs (which hide the
proprietary protocols). A typical example for a protocol
is TCP, which implements inter-process communications on
the Internet, and is the protocol most often used through
the socket API mentioned earlier. To communicate with a
peer over the Internet, only TCP is required; sockets are a
popular choice for using TCP, but are an entirely local issue.
4.7 Model

This facet is about whether the design assumes that there
is a common application-level data model that is shared
among services within a problem domain.
If this is the
case, then messages are simply treated as a serialization of
that model, which is only used to transfer a model instance
from one service to the other through some communications
medium. This approach often uses generated code for mar-
shaling and unmarshaling, because the model instance in
essence is the shared information, and all services use the
same method for mapping models to the wire format.

This shared model design introduces tight coupling, be-
cause there is a strong conceptual connection between all
services sharing the same data model. This coupling often
is not only tight in principle, it also is tight in practice, be-
cause services are built with a particular method or tool for
marshaling and unmarshaling. Services wishing to use a dif-
ferent method or tool have a hard time doing so, because
the representation on the wire has not been designed for in-
teroperability and reuse in diﬀerent contexts, but instead is
just a serialization of the shared model.

Loose coupling does not assume that there is a shared
model, instead messages being exchanged are self-contained
and are designed to be processed as documents in a stan-
dardized representation format. Thus messages can be pro-
cessed with any toolset for that format [43]. Loosely coupled
services can use a diﬀerent internal model (adapted to their
local requirements) as long as they solve the problem of map-
ping the standard document format to their internal models.
While this additional step of mapping document structures
to an internal model might be regarded as overhead that is
not required in the tightly coupled scenario, it is essential
for loose coupling, because it allows cooperation between
services as long as there is a suﬃcient shared understanding
to deﬁne a mapping between the external canonical message
format and the internal models of each service.
4.8 Granularity

Granularity of services interfaces is about the design trade-
oﬀ between the number of interactions that are required to
provide certain functionality to service a large client com-
munity, and the complexity of the data parameters (or op-
eration signatures) to be exchanged within each interaction.
In API design, a typical goal is to minimize the number of
interactions [17]. In service design, this is even more so, due
to the high latency involved in a service invocation.

By using more coarse-grained interfaces (i.e., fewer inter-
actions required), services can exploit the extensibility of
well-designed message formats, and service evolution (Sec-
tion 4.10) can be based on message extensibility, rather than
an extension of the set of possible service interactions.

Fine-granular interfaces are tightly coupled because changes

in a service introduce or remove operations. The main ad-
vantage of ﬁne-granular interfaces usually is eﬃciency, be-
cause it is possible to pick speciﬁc interactions having the
exact signature required by a subset of the clients, for which
the overhead of exchanging unnecessary data can be re-
duced.
4.9 State

Depending on the scale of a service landscape, state man-
agement can become one of the central problems in eﬃcient
service design. Stateful services are based on the assumption
that a service keeps state of an ongoing interaction, leading
to problems for services with many clients, high throughput,
and long-running transactions. The alternative is to choose
a stateless service design, which keeps state in the messages
that are passed back and forth between cooperating services.
Loose coupling for state management means stateless ser-
vices. As an example, the acronym REST itself stands for
Representational State Transfer and highlights that state-
less interactions are one of the key properties of the Web.
Mechanisms for session management (e.g., cookies [24] or
URI rewriting) are nevertheless also available. However,
shared state (i.e., state that is kept by two or more inter-
acting services) always implies tight coupling, because there
must be associated mechanisms of establishing and recov-
ering stateful sessions, comparing states, resolving inconsis-
tencies, implementing time-out mechanisms, and performing
distributed garbage collection. The management overhead
of shared state is substantial, so it should only be employed
when required, i.e., to reduce the size of message payloads.
4.10 Evolution

This facet concerns how services can evolve over time,
and how that aﬀects their clients. From the point of view
of the service provider, compatibility among versions can be
seen in two directions: Backward compatibility allows older
clients to keep functioning when using a service that has
been upgraded to a new version. Forward compatibility al-
lows newer clients to use an old version of a service, even
though they have been developed against a newer version
of the service. Evolution becomes particularly important in
connection with the discovery facet, because the compati-
bility of clients and services should be taken into account
during the lookup. Also, in case of late binding, run-time
errors may be produced if clients are bound to evolved (and
potentially incompatible) services.

Tight coupling for this facet is implied by an exact match
of versions, so that neither forward or backward compatibil-
ity are supported. A loosely coupled design instead attempts
to provide as much forward and backward compatibility as
possible, even if there are limits to how many changes an in-
terface can withstand without breaking clients. Loose cou-
pling therefore needs to combine rules about how to handle
diﬀering version numbers, and what rules to apply in the
event of diﬀering version numbers.

3

3

Interestingly, one of the core speciﬁcations of the Web,
XML itself, at the time of writing is undergoing a controver-
sial update. The proposed 5th edition of XML 1.0 [4] would
not change the version number of XML, but introduce new
features. This way, the loose coupling of XML-based services
would be compromised, because some documents conform-
ing to the 5th edition could not be processed using older
XML processors.
It is still unclear whether the proposed

WWW 2009 MADRID!Track: Web Engineering / Session: Web Architecture Aspect916Common design patterns for this facet are mustUnder-
stand and mustIgnore, so that the service has a mechanism
to communicate to its clients how to deal with new proto-
col constructs. However, mustUnderstand also introduces
the risk of fragmentation, because older clients cannot use
services whose new features are ﬂagged with mustUnder-
stand — this mechanism therefore has to be used with care.
mustIgnore, on the other hand, helps to provide a forward
compatible evolution path, as it refers to the convention of
ignoring unknown protocol elements (e.g., Web browsers do
not break if they encounter unknown HTML tags, which are
simply ignored).

Another important design aspect related to service evo-
lution are well-deﬁned rules about extensibility. Extension
points of a service interface must be well thought out and
should be clearly marked, so that clients know where to ex-
pect changes and extensions. The patterns mentioned above
can then be used to learn what to do when such extensions
are encountered.
4.11 Generated Code

For suﬃciently precise interface descriptions of models
(Section 4.7), it is possible to automatically generate code
for handling key communications functions. Code genera-
tion only works if the communication requirements are com-
pletely speciﬁed in machine-readable form, and if evolution
(see Section 4.10) of the system happens in well-deﬁned,
predictable ways.

Code generation takes a service description and turns it
into code representing the service at the time the code was
generated. This produces tight coupling between the gen-
erated code and the description. If the description changes,
the code of the automatically generated stubs may no longer
work. Moreover, code generation introduces a dependency
on the corresponding run-time environment. Also if this
changes, the code may have to be regenerated.

A loosely coupled design does not use static code genera-
tion. Instead, it uses declarative mechanisms to model core
concepts of the system design (e.g., content types on the
Web), methods to communicate using these concepts (i.e.,
content negotiation), and then leaves it to the participating
systems to either hardcode assumptions about the system
environment, or to provide dynamic extension mechanisms.
For example, most Web browsers feature an extension
mechanism for MIME content types, because media types
appear at a faster rate than Web browsers are updated. On
the other hand, most Web browsers do not have a well-
designed extension mechanism for URI schemes, because
new schemes do not appear very often. So with respect
to the code generation facet, browsers provide a good foun-
dation for loose coupling on the media type level, but much
less so on the URI scheme level.
4.12 Conversation

Most service invocations span multiple basic interactions,
forming conversations. Services may provide functionality
that requires clients interacting with them to follow a certain
path, which prescribes to follow a set of partially ordered
message exchanges.

A tightly coupled design aims at augmenting the service
description with metadata constraining all possible interac-
tion sequences to the correct ones. Whereas this enables to

5th edition will be ﬁnalized in this form.

statically check that a client correctly interacts with a ser-
vice, it also restricts its future evolution, because the client
makes many assumptions on how to interact with the ser-
vice. Speciﬁcation languages for orchestration such as the
Business Process Execution Language (BPEL) or choreog-
raphy such as the Web Services Choreography Description
Language (WS-CDL) can be used to augment service inter-
face contracts with a static description of possible correct
conversational interactions.

Enabling clients to discover at runtime how to correctly
interact with a service is a loosely coupled design practice
for enforcing guarantees about the conversation. This can
be achieved with a reﬂective inspection mechanism, enabling
clients during the invocation of a service, to inquire with the
service itself about what are the possible future steps of the
interaction, and to dynamically pick among them the next
interaction.

This approach is followed by RESTful Web services, which
use hyperlinks as the mechanism to steer clients participat-
ing in loosely coupled conversations. In a very simple sce-
nario, a RESTful multistage process for ﬁlling out forms on
the Web controls the conversation by replying to each form
submission with a new form and a URI where to submit that
new form. Clients can correctly follow this long interaction
without any prior knowledge of the corresponding process.
Also, no description of how the process is designed must be
provided in advance by the service. By simply inspecting the
representations of the service’s resources, clients are able to
follow the required conversation pattern of the service. Hy-
perlinks thus create the ties which hold together the various
resource URIs which are accessed while interacting with the
service. Since these ties are established at run-time, no tight
coupling is established between services.

5. EVALUATION

In this section we aim at moving from a qualitative de-
scription of these facets to a quantitative evaluation, ad-
dressing the problem of how to use the twelve facets to
analyze the properties of three representative Web services
technologies: RESTful HTTP, RPC over HTTP, and WS-*
based messaging on a so-called enterprise service bus (ESB [6]).
A similar analysis can be conducted over the design of con-
crete service-oriented systems.

Table 2 and Figure 3 summarize our ﬁndings, listing for
each technology the corresponding coupling characteristics
and visualizing the implied degree of coupling. For all tech-
nologies we immediately see that all are operating system
and programming language independent, making them loosely
coupled according to the Platform facet. Whereas this was
not necessarily true for traditional vendor-speciﬁc middle-
ware platforms, thanks to the WS-* standardization eﬀorts
and the pervasive support for the HTTP protocol, nowa-
days loose coupling in terms of platform independence can
be safely assumed for all Web services technologies.

In the ﬁrst two columns we compare a RESTful usage of
the HTTP protocol against its use for implementing Remote
Procedure Calls (RPC) across the Web. This is an impor-
tant comparison, as it helps to highlight the diﬀerences be-
tween true RESTful Web service APIs, and RPC-based Web
services provided using, for example, SOAP over HTTP, or
XML-RPC. Concerning the discovery (Decentralized), iden-
tiﬁcation (Global), and binding (Dynamic) facets, we do not
observe any diﬀerence due to the properties of the HTTP

WWW 2009 MADRID!Track: Web Engineering / Session: Web Architecture Aspect917RESTful HTTP

RPC over HTTP

WS-*/ESB

Degree of Coupling

Tight Coupling

Design-Specific Coupling

Loose Coupling

Coupling Facet

Discovery

Discovery

Discovery

Conversation

Identification

Conversation

Identification

Conversation

Identification

Generated
Code

Evolution

Binding

Generated
Code

Binding

Generated
Code

Binding

Platform

Evolution

Platform

Evolution

Platform

State

Interaction

State

Interaction

State

Interaction

Granularity

Interface
Orientation

Model

(a) RESTful HTTP

Granularity

Interface
Orientation

Model

(b) RPC over HTTP

Granularity

Interface
Orientation

Model

(c) WS-*/ESB

Figure 3: Measuring the degree of coupling implied by diﬀerent Web services technologies

Discovery
Identiﬁcation
Binding
Platform
Interaction
Interface Orientation Vertical

RESTful HTTP
Referral
Global
Late
Independent
Asynchronous

4.1
4.2
4.3
4.4
4.5
4.6
4.7 Model
4.8
4.9
4.10 Evolution
4.11 Generated Code
4.12 Conversation

Granularity
State

RPC over HTTP
Referral
Global
Early/Late
Independent
Synchronous
Horizontal
Shared Model
Fine/Coarse
Stateless/Shared, Stateful
Compatible/Breaking
Static
Explicit

WS-*/ESB
Registration
Context-based
Late
Independent
Asynchronous
Horizontal
Self-D. Messages/Shared Model
Fine/Coarse
Stateless
Compatible/Breaking
Static
Explicit

Self-Describing Messages
Fine/Coarse
Stateless
Compatible/Breaking
None/Dynamic
Reﬂective

Table 2: Web Services Technology Evaluation Summary

protocol. However, when it comes to the interaction facet,
some diﬀerences become apparent. RPC interactions are by
deﬁnition synchronous. RESTful interactions are instead
asynchronous, since services interact indirectly by updating
(with POST, PUT, or DELETE) the state of resources, which
can be later accessed by other services (with GET) [33]. Inter-
face orientation is vertical in REST, which only relies on the
protocol and resource representations, whereas RPC is often
based on the stub mechanism where the client of a remote
service accessed via RPC calls a local interface which then
handles the fact that the service is implemented remotely.
The two technologies also diﬀer in terms of the model facet,
where RPC follows a shared model approach, where all ser-
vices must agree beforehand on the syntax and the semantics
of the exchanged messages, while REST promotes a “Self-
Describing Representations” solution. RESTful interactions
are also stateless, while RPC oﬀers both options, as interact-
ing services may establish a session by sharing state among
them, but also may be designed to avoid such tight cou-
pling. RPC is also based on generated code stubs, while
REST does not require them as it follows a more dynamic
approach based on plugin extensibility. Also regarding con-
versations, REST promotes a dynamic, reﬂective approach,

while RPC-based Web services make the interaction con-
straints explicit at design-time.

It is worth noting that not all the facets are bound by
the properties of a given technology. For example, the gran-
ularity, state, and evolution facets depend on the concrete
design choice of a given service-oriented system architecture,
and are not constrained by the choice of the REST vs. RPC
styles. In other words, it is possible to design tightly cou-
pled RESTful Web services, which can be “chatty” in their
interactions, if their interfaces expose a large number of ﬁne-
grained resources. The same can be said about RPC-based
services, which can either publish many ﬁne-grained opera-
tions, or a few coarse-grained ones, depending on the cho-
sen design strategy. Also in terms of the evolution facet, a
service design needs to be evaluated at a more speciﬁc level.
For example, XML technology can support a loosely coupled
evolution facet only if it is used with additional guidelines
for versioning and the enforcement of mustUnderstand rules.
We have chosen to include in our evaluation the WS-*/ESB
technology (which is not Web/HTTP centric), because the
enterprise service bus family of middleware products is widely
perceived to be the foundation for loosely coupled SOA im-
plementations. Thus, it is interesting to apply our multi-

WWW 2009 MADRID!Track: Web Engineering / Session: Web Architecture Aspect918faceted deﬁnition also to measure the coupling implied by
this technology. We observe that ESB provides loose cou-
pling according to four facets: binding (Dynamic), interac-
tion (Asynchronous), state (Stateless) and platform (Inde-
pendent). However, the technology uses context-based iden-
tiﬁcation (a tightly coupled solution) and requires central-
ized service registration to support service discovery. Also,
interactions based on multiple message exchanges are explic-
itly modeled using workﬂow and conversation models. The
development process of services connected by an ESB relies
on code generation techniques (thus, an ESB presents an
horizontal interface orientation). Therefore, according to all
of these other ﬁve facets, this kind of middleware technology
does not help to achieve loose coupling. Similar to the other
two alternatives, the choice of using an ESB does not con-
strain the evolution and granularity facets. Additionally, it
is also possible to choose between a shared model design, or
to leverage the ESB mediation capabilities to foster a more
loosely coupled design based on self-describing messages.

In more quantitative terms, the table counts the number
of facets for which a technology results in loose or tight cou-
pling. We also distinguish facets for which the degree of
coupling does not depend on the chosen technology but may
vary depending on more speciﬁc design decisions.

Coupling
Loose
Tight
Design-Speciﬁc

REST RPC WS-*/ESB
4
5
3

10
0
2

3
4
5

Only in the best case (assuming that all design-speciﬁc
facets follow loosely coupled options) we can conclude that
using RESTful HTTP would provide a system architecture
featuring loose coupling according to all facets. Choosing
RPC over HTTP, instead, would not result in a completely
loosely coupled system, due to the 4 facets (interaction,
model, generated code, and conversation) which only present
a tightly coupled approach. This alternative also requires

RESTful HTTP

RPC over HTTP

WS-*/ESB

Discovery

Conversation

Identification

Generated
Code

Binding

Evolution

Platform

State

Interaction

Granularity

Interface
Orientation

Model

Figure 4: Comparing the degree of coupling implied
by diﬀerent Web services technologies

more eﬀort to achieve a loosely coupled system, as up to
5 facets are design-speciﬁc and are unconstrained by the
technology choice. This number is smaller in case of the
WS-*/ESB alternative, where only 3 facets are design-speciﬁc.
A more detailed, facet-by-facet comparison is visualized with
the radar chart of Figure 4. It is interesting to notice that the
curve indicating the degree of coupling implied by RESTful
HTTP is strictly bounded by both of the other curves. If we
do not consider the discovery and identiﬁcation facets, the
same holds between the RPC and the ESB curves. Thus, our
multi-faceted metric can be used to establish a partial or-
dering between diﬀerent Web services technologies in terms
of their degree of coupling.
6. CONCLUSIONS

SOAP-based Web services and the REST architectural
style have been and still are the topic of many debates.
Many of these debates are heated, often missing the point
that the more prescriptive style of the SOAP approach and
the more descriptive style of the REST approach have their
roots in diﬀerent scenarios, the former assuming closed worlds
and contractual relationships, whereas the latter caters to
an open world with ad-hoc interactions [40]. So far, only
few attempts have been made to compare both approaches
as objectively as possible [31]. “Loose coupling” and “tight
coupling” are frequently used terms in such debates, given
the positive connotation of the former and the negative im-
plications of the latter. Reduced coupling is beneﬁcial be-
cause interdependencies typically make complex IT applica-
tion systems brittle and slow to adapt to changes [32].

In terms of the goals which should be accomplished when
designing service systems, WS-* and REST can be described
by integration vs. cooperation (Fiedler et al. [11] make a sim-
ilar distinction for database systems). Both goals (as well
as “loose” and ‘tight” coupling) are not good or bad per-se.
They are the result of a strategic decision on how to de-
sign and implement IT architectures, and there can be valid
business objectives for both of these goals. These business
objectives should be the input for a decision how to design
a system, for example putting a higher emphasis of perfor-
mance optimization (usually easier with tight coupling) or
agility (usually easier with loose coupling).

The twelve facets described in this paper make it easier to
understand which approach is more appropriate for a given
problem, and for which facet of the system design a loose
or tight coupling approach should be preferred. In the end,
as we have shown in our evaluation, very few systems are
loosely or tightly coupled according to all facets. Instead,
they use a mix of both depending on the business objectives
and the constraints of the chosen Web technologies. Our
multi-faceted metric thus also deﬁnes a set of choices that
need to be made, giving system designers a more structured
approach for making better design decisions and comparing
alternative Web services technology options.
Acknowledgements
The authors would like to thank Domenico Bianculli for his
constructive feedback. This work is partially supported by
the EU-IST-FP7-215605 (RESERVOIR) project.
7. REFERENCES
[1] Tim Berners-Lee, Roy Thomas Fielding, and Larry
Masinter. Uniform Resource Identiﬁer (URI): Generic
Syntax. Internet RFC 3986, January 2005.

WWW 2009 MADRID!Track: Web Engineering / Session: Web Architecture Aspect919[2] Andrew Birrell and Bruce Jay Nelson. Implementing
Remote Procedure Calls. ACM Transactions on Computer
Systems (TOCS), 2:39–59, February 1984.

[3] Jason Bloomberg and Ronald Schmelzer, editors.

Service Orient or Be Doomed! John Wiley & Sons, New
York, NY, March 2006.

[4] Tim Bray, Jean Paoli, C. Michael Sperberg-McQueen,
Eve Maler, and Fran¸cois Yergeau. Extensible Markup
Language (XML) 1.0 (Fifth Edition). World Wide Web
Consortium, Recommendation REC-xml-20081126,
November 2008.

[5] Lionel C. Briand, John W. Daly, and J¨urgen K. W¨ust.

A Uniﬁed Framework for Coupling Measurement in
Object-Oriented Systems. IEEE Transactions on Software
Engineering, 25(1):91–121, January 1999.

[6] David Chappell. Enterprise Service Bus. O’Reilly, 2004.
[7] Luc Clement, Andrew Hately, Claus von Riegen, and

Tony Rogers. UDDI Version 3.0.2. Organization for the
Advancement of Structured Information Standards, UDDI
Spec Technical Committee Draft, October 2004.

[8] Xin Dong, Alon Y. Halevy, Jayant Madhavan, Ema

Nemes, and Jun Zhang. Similarity Search for Web
Services. In Proceedings of the 30th International
Conference on Very Large Data Bases, pages 372–383,
Toronto, Canada, September 2004.

[9] Thomas Erl. Service-Oriented Architecture: Concepts,

Technology, and Design. Prentice Hall, 2005.

[10] Patrick Th. Eugster, Pascal A. Felber, Rachid

Guerraoui, and Anne-Marie Kermarrec. The many
faces of publish/subscribe. ACM Computing Surveys,
35(2):114–131, 2003.

[11] Gunar Fiedler, Thomas Raak, and Bernhard

Thalheim. Database Collaboration Instead of Integration.
In Sven Hartmann and Markus Stumptner, editors,
Proceedings of the 2nd Asia-Paciﬁc Conference on
Conceptual Modelling, pages 49–58, Newcastle, Australia,
January 2005.

[12] Roy Thomas Fielding. Architectural Styles and the Design

of Network-based Software Architectures. PhD thesis,
University of California, Irvine, Irvine, California, 2000.

[13] Roy Thomas Fielding, Jim Gettys, Jeffrey C. Mogul,

Henrik Frystyk Nielsen, Larry Masinter, Paul J.
Leach, and Tim Berners-Lee. Hypertext Transfer
Protocol — HTTP/1.1. Internet RFC 2616, June 1999.

[14] Roy Thomas Fielding and Richard N. Taylor.

Principled Design of the Modern Web Architecture. ACM
Transactions on Internet Technology, 2(2):115–150, May
2002.

[15] Carlo Ghezzi, Mehdi Jazayeri, and Dino Mandrioli.

Fundamentals of Software Engineering. Prentice Hall, 2003.

[16] Joe Gregorio. URI Template. Internet Draft

draft-gregorio-uritemplate-03, March 2008.

[17] Michi Henning. API Design Matters. ACM Queue,

5(4):24–36, May 2007.

[18] Gregor Hohpe. Enterprise Integration Patterns.

Addison-Wesley, October 2003.

[19] Nicolai M. Josuttis. SOA In Practice. O’Reilly, August

2007.

[20] Doug Kaye. Loosely Coupled: The Missing Pieces of Web

Services. RDS Press, August 2003.

[21] Tim Kindberg. Ubiquitous and contextual identiﬁer

resolution for the real-world wide web. Technical Report 95,
HP Labs, 2001.

[22] Tim Kindberg and Sandro Hawke. The ’tag’ URI

Scheme. Internet RFC 4151, October 2005.

[23] Dirk Krafzig, Karl Banke, and Dirk Slama. Enterprise

SOA: Service-Oriented Architecture Best Practices (The
Coad Series). Prentice Hall, 2004.

[24] David M. Kristol and Lou Montulli. HTTP State
Management Mechanism. Internet RFC 2965, October
2000.

[25] Michele Lanza and Radu Marinescu. Object-Oriented

Metrics in Practice. Springer, 2006.

[26] G. J. Myers. Composite/Structured Design. Van Nostrand

Reinhold, 1978.

[27] Eric Newcomer and Greg Lomow. Understanding SOA

with Web services. Addison-Wesley, 2005.

[28] Johann Oberleitner, Thomas Gschwind, and Mehdi
Jazayeri. The Vienna Component Framework enabling
composition across component models. In ICSE ’03: Proc.
of the 25th International Conference on Software
Engineering, pages 25–35, 2003.

[29] J. Douglas Orton and Karl E. Weick. Loosely Coupled
Systems: A Reconceptualization. Academy of Management
Review, 15(2):203–223, April 1990.

[30] Cesare Pautasso and Gustavo Alonso. Flexible Binding
for Reusable Composition of Web Services. In Proc. of the
4th Workshop on Software Composition (SC 2005),
Edinburgh, Scotland, April 2005.

[31] Cesare Pautasso, Olaf Zimmermann, and Frank

Leymann. RESTful Web Services vs. ”Big” Web Services:
Making the Right Architectural Decision. In Proceedings of
the 17th International World Wide Web Conference, pages
805–814, Beijing, China, April 2008. ACM Press.

[32] Cynthia Rettig. The Trouble with Enterprise Software.

MIT Sloan Management Review, 49(1):21–27, 2007.

[33] Leonard Richardson and Sam Ruby. RESTful Web

Services. O’Reilly, May 2007.

[34] Jos A. Rijpma. Complexity, Tight-Coupling and

Reliability: Connecting Normal Accidents Theory and High
Reliability Theory. Journal of Contingencies and Crisis
Management, 5(1), March 1997.

[35] Wayne P. Stevens, Glenford J. Myers, and Larry L.
Constantine. Structured Design. IBM Systems Journal,
13(2):115–139, 1974.

[36] Andrew S. Tanenbaum. Distributed Operating Systems.
Prentice-Hall, Englewood Cliﬀs, New Jersey, September
1994.

[37] James D. Thompson. Organizations in Action: Social
Science Bases of Administrative Theory. McGraw-Hill,
New York, NY, June 1967.

[38] Manolis Tzagarakis, Nikos Karousos, Dimitris

Christodoulakis, and Siegfried Reich. Naming as a
Fundamental Concept of Open Hypermedia Systems. In
Proceedings of the 11th ACM Conference on Hypertext and
Hypermedia, pages 103–112, San Antonio, Texas, May
2000. ACM Press.

[39] Steve Vinoski. Old Measures for New Services. IEEE

Internet Computing, 9(6):72–74, November 2005.

[40] Steve Vinoski. Serendipitous Reuse. IEEE Internet

Computing, 12(1):84–87, January 2008.

[41] Sanjiva Weerawarana, Francisco Curbera, Frank
Leymann, Tony Storey, and Donald Ferguson. Web
Services Platform Architecture. Prentice Hall, March 2005.

[42] Karl E. Weick. Educational Organizations as Loosely

Coupled Systems. Administrative Science Quarterly,
21(1):1–19, March 1976.

[43] Erik Wilde and Robert J. Glushko. Document Design

Matters. Communications of the ACM, 51(10):43–49,
October 2008.

[44] Dan Woods and Thomas Mattern. Enterprise SOA:
Designing IT for Business Innovation. O’Reilly, 2006.
[45] E. Yourdon and L. Constantine. Structural Design.

Prentice Hall, 1979.

[46] Hubert Zimmermann. OSI Reference Model — The ISO
Model of Architecture for Open Systems Interconnection.
IEEE Transactions on Communications, 28(4):425–432,
April 1980.

[47] Olaf Zimmermann, Mark Tomlinson, and Stefan

Peuser. Perspectives on Web Services: Applying SOAP,
WSDL, and UDDI to Real-World Projects. Springer,
September 2003.

WWW 2009 MADRID!Track: Web Engineering / Session: Web Architecture Aspect920