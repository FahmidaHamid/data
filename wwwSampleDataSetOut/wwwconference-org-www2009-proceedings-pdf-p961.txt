Characterizing Insecure JavaScript Practices on the Web

Chuan Yue

Department of Computer Science
The College of William and Mary

Williamsburg, VA 23187, USA

cyue@cs.wm.edu

Haining Wang

Department of Computer Science
The College of William and Mary

Williamsburg, VA 23187, USA

hnw@cs.wm.edu

ABSTRACT
JavaScript is an interpreted programming language most
often used for enhancing webpage interactivity and func-
tionality. It has powerful capabilities to interact with web-
page documents and browser windows, however, it has also
opened the door for many browser-based security attacks.
Insecure engineering practices of using JavaScript may not
directly lead to security breaches, but they can create new
attack vectors and greatly increase the risks of browser-
based attacks. In this paper, we present the ﬁrst measure-
ment study on insecure practices of using JavaScript on the
Web. Our focus is on the insecure practices of JavaScript in-
clusion and dynamic generation, and we examine their sever-
ity and nature on 6,805 unique websites. Our measurement
results reveal that insecure JavaScript practices are common
at various websites: (1) at least 66.4% of the measured web-
sites manifest the insecure practices of including JavaScript
ﬁles from external domains into the top-level documents of
their webpages; (2) over 44.4% of the measured websites
use the dangerous eval() function to dynamically generate
and execute JavaScript code on their webpages; and (3) in
JavaScript dynamic generation, using the document.write()
method and the innerHTML property is much more popular
than using the relatively secure technique of creating script
elements via DOM methods. Our analysis indicates that
safe alternatives to these insecure practices exist in common
cases and ought to be adopted by website developers and
administrators for reducing potential security risks.

Categories and Subject Descriptors
H.3.5 [Information Storage and Retrieval]: Online In-
formation Services—Web-based services; I.7.2 [Document
and Text Processing]: Document Preparation—Script-
ing languages; K.6.5 [Management of Computing and
Information Systems]: Security and Protection—Unau-
thorized access

General Terms
Experimentation, Languages, Measurement, Security

Keywords
JavaScript, execution-based measurement, security, same ori-
gin policy, AST tree matching, Web engineering
Copyright is held by the International World Wide Web Conference Com-
mittee (IW3C2). Distribution of these papers is limited to classroom use,
and personal use by others.
WWW 2009, April 20–24, 2009, Madrid, Spain.
ACM 978-1-60558-487-4/09/04.

1.

INTRODUCTION

Security is an important aspect of Web engineering, and
it should be taken into serious consideration in the develop-
ment of high quality Web-based systems [5, 15, 19, 21, 23].
In many cases, however, security does not receive suﬃcient
attention due to the complexity of Web-based systems, the
ad hoc processes of system development, and even the fact
that many designers or developers lack security knowledge
on Web development techniques. It is not a surprise there-
fore, that website security breaches are common [7] and Web
applications are more susceptible to malicious attacks than
traditional computer applications [27].

Browser-based attacks have posed serious threats to the
Web in recent years. Exploiting the vulnerabilities in Web
browsers [6, 25] or Web applications [11, 14], attackers may
directly harm a Web browser’s host machine and user through
various attacks such as drive-by download [20, 24, 28], cross-
site scripting [10, 37], cross-site request forgery [2, 46], and
Web privacy attacks [4, 12]. Attackers may even use browsers
to indirectly launch large-scale distributed attacks against
Web servers [17] or propagate Internet worms [18].

Most of these browser-based attacks are closely tied with
JavaScript, which is an interpreted programming language
most often used for client-side scripting. JavaScript code
embedded or included in HTML pages runs locally in a user’s
Web browser, and it is mainly used by websites to enhance
the interactivity and functionality of their webpages. How-
ever, because JavaScript is equipped with a powerful and
diverse set of capabilities in Web browsers [9], it has also
become the weapon of choice for attackers.

Modern Web browsers impose two restrictions to enforce
JavaScript security: the sandbox mechanism and the same-
origin policy. The former limits JavaScript to execute only
in a certain environment without risking damage to the rest
of the system, while the latter prevents JavaScript in a doc-
ument of one origin from interacting with another document
of a diﬀerent origin [9, 45]. Unfortunately, most JavaScript-
related security vulnerabilities are still the breaches of either
of these two restrictions [40]. Some of these vulnerabilities
are due to Web browser ﬂaws, but the majority of them
have been attributed to the ﬂaws and insecure practices of
websites [46, 48].

A great deal of attention has been paid to the JavaScript-
related security vulnerabilities such as cross-site scripting [10,
29, 38, 46, 48] that could directly lead to security breaches.
However, little attention has been given to websites’ inse-
cure practices of using JavaScript on their webpages. Sim-
ilar to websites’ other insecure practices such as using the

WWW 2009 MADRID!Track: Web Engineering / Session: Client Side Web Engineering961customers’ social security numbers as their login IDs [8],
insecure JavaScript practices may not necessarily result in
direct security breaches, but they could deﬁnitely cultivate
the creation of new attack vectors.

In this paper, we present the ﬁrst measurement study on
insecure practices of using JavaScript at diﬀerent websites.
We mainly focus on two types of insecure practices: inse-
cure JavaScript inclusion and insecure JavaScript dynamic
generation. We deﬁne the former as the practices of us-
ing the src attribute of a <script> tag to directly or in-
directly include a JavaScript ﬁle from an external domain
into the top-level document of a webpage. A top-level doc-
ument is the document loaded from the URL displayed in
a Web browser’s address bar. By “directly”, we mean that
the <script> tag belongs to the top-level document, and
by “indirectly”, we mean that the <script> tag belongs to a
sub-level frame or iframe document whose origin is the same
as that of the top-level document. We deﬁne the latter as
the practices of using dangerous techniques such as the eval()
function to dynamically generate new scripts. Both types of
insecure practices create new vectors for attackers to inject
malicious JavaScript code into webpages and launch attacks
such as cross-site scripting and cross-site request forgery.

The primary objective of our work is to examine the sever-
ity and nature of these two types of insecure JavaScript
practices on the Web. To achieve this goal, we devised an
execution-based measurement approach. More speciﬁcally,
we instrumented the Mozilla Firefox 2 Web browser and vis-
ited the homepages of 6,805 popular websites in 15 diﬀerent
categories. The instrumented Firefox non-intrusively moni-
tors the JavaScript inclusion and dynamic generation activ-
ities on those webpages, and it precisely records important
information for oﬄine analysis.

Our measurement results reveal that insecure JavaScript
inclusion and dynamic generation practices are widely preva-
lent among websites. At least 66.4% of the measured web-
sites have the insecure practices of including scripts from
external domains into the top-level documents of their home-
pages. Over 74.9% of the measured websites use one or more
types of JavaScript dynamic generation techniques, and in-
secure practices are quite common. For example, eval() func-
tion calls exist at 44.4% of the measured websites. Using the
document.write() method and the innerHTML property is
much more popular than using the relatively secure method
of creating JavaScript elements via DOM (Document Ob-
ject Model) methods. Our results also show that around
94.9% of the measured websites register various event han-
dlers on their homepages, implying that the captured inse-
cure JavaScript practices in inclusion and dynamic genera-
tion are likely conservative estimates.

The main contribution of our paper is threefold. First,
we introduce a browser instrumentation framework that en-
ables us to capture essential JavaScript execution behav-
ior on webpages. Not only can this framework measure
the insecure JavaScript practices, it can also examine other
JavaScript execution characteristics such as function call
patterns and code (de)obfuscation activities. Second, we
present a classiﬁcation method to analyze and classify dif-
ferent types of dynamically generated JavaScript code. By
extracting the AST (abstract syntax tree) trees of scripts
and performing AST signature creation and matching, our
classiﬁcation method can eﬀectively assist us in understand-
ing the structural information of the hundreds of thousands

of dynamically generated scripts. Third, our measurement
study sheds light on the insecure JavaScript practices and
especially reveals the severity of insecure JavaScript inclu-
sion and dynamic generation practices on the Web. Our
in-depth analysis further indicates that safe alternatives to
these insecure practices do exist in common cases. We there-
fore suggest website developers and administrators pay se-
rious attention to these insecure engineering practices and
use safe alternatives to avoid them.

The rest of the paper is structured as follows. Section 2
explains why the two types of JavaScript practices are in-
secure. Section 3 introduces our measurement and analy-
sis methodologies. Section 4 describes the data set of this
study. Section 5 presents and analyzes our measurement re-
sults. Section 6 reviews related work, and ﬁnally, Section 7
concludes the paper.

2. MOTIVATION

In the same-origin policy, the origin of a document is de-
ﬁned using the protocol, domain name, and port of the URL
from which the document is loaded. It is important to re-
alize that this policy does not limit the origin of a script
itself. Although JavaScript code cannot access another doc-
ument loaded from a diﬀerent origin, it can fully access the
document in which it is embedded or included even when
the code has a diﬀerent origin than the document [9]. In-
cluding scripts from an external domain into the top-level
document of a webpage is very dangerous because it grants
the scripts the maximum permissions allowed to control the
webpage and the browser window. Therefore, if the author
of a script ﬁle or the administrator of a script hosting site
is insincere or irresponsible, insecure JavaScript inclusion
practices could lead to serious security and privacy breaches.
Moreover, script hosting sites could become attractive tar-
gets of attacks, especially when their JavaScript ﬁles are
included by multiple websites. To lower the potential risks,
websites should avoid external JavaScript inclusion by using
internal JavaScript ﬁles from the same sites when possible.
Otherwise if external inclusion is really inevitable, for exam-
ple some advertising sites or traﬃc analysis sites may neces-
sitate it [22], external included scripts should be retrieved
using HTTPS connections and should be restricted within a
sub-level HTML frame or iframe document whose origin is
diﬀerent from that of the top-level document.

The eval() function takes a string parameter and evalu-
ates it as JavaScript code. This function is dangerous be-
cause it executes the passed script code with the privileges
of the function’s caller [39]. Therefore, attackers may en-
deavor to inject malicious code into the evaluated string
in order to take advantage of this capability. Meanwhile,
since scripts are dynamically generated and evaluated, it
is very challenging to eﬀectively ﬁlter out maliciously in-
jected code [13, 25, 32]. Eval() should be avoided 1 if at
all possible, and its safe alternatives should be used [35,
39]. Other JavaScript dynamic generation techniques such
as using the document.write() function and the innerHTML
property also pose similar security risks, as discussed in Sec-
tion 5.

Once attackers have successfully exploited these insecure
practices and injected their malicious JavaScript code, they
can easily launch severe attacks such as cross-site scripting

1Searching “eval is evil” on the Web for many discussions.

WWW 2009 MADRID!Track: Web Engineering / Session: Client Side Web Engineering962Web Browser(cid:13)

Offline Analysis Toolkit(cid:13)

Web(cid:13)
Pages(cid:13)

Instrumented(cid:13)

Content Module(cid:13)

Instrumented(cid:13)
DOM Module(cid:13)

Instrumented(cid:13)
SpiderMonkey(cid:13)

JavaScript(cid:13)

Engine(cid:13)

Trace(cid:13)
Files(cid:13)

JavaScript Code Classification Tools(cid:13)

AST Tree(cid:13)
Extraction(cid:13)

=(cid:13)

AST Signature(cid:13)
Creation and(cid:13)

AST(cid:13)

Signature(cid:13)

a(cid:13)

+(cid:13)

Matching(cid:13)

Categorization(cid:13)

b(cid:13)

c(cid:13)

Other Tools(cid:13)

Figure 1: Overview of the Instrumentation Frame-
work and Analysis Toolkit.

and cross-site request forgery. These attacks can be used to
conduct many malicious activities such as account hijack-
ing, user behavior tracking, denial of service attacking, and
website defacing. Therefore, insecure engineering practices
of using JavaScript should be thoroughly investigated, their
risks should be highlighted to Web developers, and safe al-
ternatives should be used to avoid them.

3. METHODOLOGY

We devised an execution-based measurement approach to
study the insecure JavaScript practices on the Web. Our
strategy is to ﬁrst use an instrumented Web browser to ob-
tain actual JavaScript execution trace information on diﬀer-
ent webpages, and then use oﬄine analysis to characterize
and understand various JavaScript practices. An alternative
approach is to simply perform static analysis on webpages.
However, this approach suﬀers from the problem of unde-
cidability and is unable to precisely determine which scripts
will be generated and executed. In contrast, our approach al-
lows us to eﬀectively capture the dynamics of webpages and
JavaScript code in their real runtime environments. Fig-
ure 1 gives an overview of our instrumentation framework
and analysis toolkit.

3.1 Instrumentation Framework

To achieve an accurate and eﬃcient measurement, we em-
ployed the source code instrumentation technique and in-
strumented the most popular open source Web browser—
Mozilla Firefox. Our instrumentation method is similar to
program tracing, which is a well-known approach for mon-
itoring program behavior and measuring program perfor-
mance. We followed a few rules suggested in [1] to minimize
instrumentation overhead. More speciﬁcally, we attempted
to insert less instrumentation code and place the code only
at necessary points with low execution frequency.

We mainly instrumented three modules of Firefox 2 source
code: the JavaScript engine, the content module, and the
DOM module. Firefox uses SpiderMonkey as its JavaScript
engine [47]. SpiderMonkey JavaScript engine is written in
C programming language and is a relatively independent
module in Firefox. The major interface between Spider-
Monkey and other modules in Firefox is the SpiderMonkey
JSAPI [41]. JSAPI facilitates other modules in Firefox to
use the core JavaScript data types and functions of Spider-
Monkey, and it also allows other modules to expose some of
their objects and functions to JavaScript code.

Inside the SpiderMonkey, our instrumented code written
in C consists of three parts. First, eight trace logging func-
tions were integrated into the JSAPI interface. These func-
tions facilitate the trace collection in a consistent manner,

recording various information such as script text, function
calls, and event handler registrations. Second, we added
code to the byte-code interpreter of SpiderMonkey so that
we can record the execution information of any global scripts
and function scripts. Third, we instrumented the object sys-
tem implementation of SpiderMonkey to monitor the calls
to the eval() function and collect both the calling context
information and the evaluated content information.

The trace ﬁles generated in the above instrumentation
points enable us to analyze the practices of JavaScript in-
clusion and the practices of JavaScript dynamic generation
using eval(). We also needed to monitor the practices of
other JavaScript dynamic generation techniques. Originally
we attempted to fulﬁll this task by still instrumenting in-
side the SpiderMonkey and monitoring the engine’s native
callbacks to the content and DOM modules. However, we
found that this approach induces high overhead and could
only record partial information. Therefore, we decided to di-
rectly instrument the content module and the DOM module
of Firefox.

In the content module of Firefox, we integrated C++ code
to measure the other three types of JavaScript dynamic gen-
eration techniques. We instrumented the document.write()
method 2 and the method for setting the innerHTML prop-
erty of an HTML element to track their invocations. Both
techniques can be used to add new content to an HTML doc-
ument, and the added content may contain new JavaScript
code. We also added code to monitor the method for re-
placing, inserting or appending a new DOM element, which
could be created by using DOM methods such as docu-
ment.createElement() and document.createTextNode(). Our
instrumentation code can identify the script type of elements
and record their source and text information. Other tech-
niques such as the insertAdjacentHTML() method or the
outerHTML property are supported in the Internet Explorer
Web browser only, and we cannot measure them in Firefox.
In the DOM module and the content module, we added
C++ code to measure various event handler registration
techniques supported in Firefox. Event handlers can be
triggered by user interaction or timer events. We collected
event handler registration information to show that further
JavaScript inclusion and execution could happen and our
captured insecure practices are likely conservative estimates.
Event handler registration and other aspects of information
described above are written into a set of six diﬀerent trace
ﬁles to assist our oﬄine analysis.

Since many internal user interface components of Firefox
also heavily use JavaScript, special care is needed to en-
sure that the above instrumentation code only records the
JavaScript execution activities of a visited webpage. Our
code checks the JSPrincipals [43] information of an object or
script to guarantee this requirement. We also ensured that
our instrumentation code only monitors and records essen-
tial information and does not change the execution logic of
Firefox and SpiderMonkey.

3.2 Analysis Toolkit

We took an oﬄine analysis approach so that we can suf-
ﬁciently analyze the trace information without interfering
with the actual measurement process. We developed an of-
ﬂine analysis toolkit that consists of a set of tools written in
approximately 5,000 lines of Java code, 200 lines of C code,

2In this paper, it includes the document.writeln() method.

WWW 2009 MADRID!Track: Web Engineering / Session: Client Side Web Engineering963Initialize an empty AST signature set S;
for each AST tree in the XML ﬁles do

thisSig=the top N level structure of the AST tree;
if thisSig matches an existing signature in S then

Record the information of this matching;

SigCreateMatch (XMLﬁles, N )
1.
2.
3.
4.
5.
6.
7.
8.
endif
9. endfor
10. return the result set S;

S = S ∪ {thisSig};

else

Figure 2: High-level AST Signature Creation and
Matching Procedure.

500 lines of Linux shell script code, and 300 lines of Matlab
script code. About half of the tools are used for classifying
dynamically generated JavaScript code, and the others are
used for processing trace records and calculating statistical
information. The detailed description of the JavaScript code
classiﬁcation tools is as follows.

The motivation for developing these classiﬁcation tools is
to automate the challenging task of understanding a large
number of dynamically generated JavaScript code. To achieve
this goal, we explored the concepts in software engineering
and developed an AST (abstract syntax tree)-based classi-
ﬁcation method. As illustrated in Figure 1, the key idea
is to ﬁrst extract the AST trees of scripts, then create and
match AST signatures, and ﬁnally merge signatures into dif-
ferent categories. We devised such an AST-based approach
in that ASTs have been demonstrated eﬀective in program
understanding [3, 30].

The AST tree extraction tool is a standalone C program
that embeds the SpiderMonkey 1.7 [47]. This is the same
version of the SpiderMonkey as used in our instrumented
Firefox 2 Web browser. Therefore, our extraction tool can
create a token stream and parse the stream into a syntax
tree for a script in the same manner as in the instrumented
Firefox. The tool ﬁnally constructs the essential structure
of a syntax tree as an AST tree and writes the tree into an
XML ﬁle to facilitate further comparison.

We applied top-down tree matching techniques to perform
AST signature creation and matching, and the high-level
procedure is illustrated in Figure 2. First, an empty AST
signature set S is initialized. Next, for each AST tree in
the XML ﬁles, its top N level structure is used to generate
an AST signature, denoted as thisSig. Then, top-down tree
comparisons are made to seek a match between the thisSig
and an existing signature in the set S.
If a match exists,
this procedure keeps a record of the related information,
otherwise, the thisSig is added to the set S as a new AST
signature. Finally, this procedure returns the signature set
S as its output.

To be accurate and representative, an AST signature keeps
the name and type information of an operator node, but it
only keeps the type information of an operand. Top-down
tree matching techniques can capture the key structural dif-
ferences between trees, and they have been used in several
Web-related projects [26, 33, 34]. The comparison algorithm
used in line 4 of this procedure is adapted from the STM
(simple tree matching) algorithm presented in [31]. STM
is an eﬃcient top-down tree distance comparison algorithm,
and our adaptation is to only compare the top N levels of

Table 1: Category Breakdown by Top-Level Do-
main.

Category
arts
business
computers
games
health
home
news
recreation
reference
regional
science
shopping
society
sports
world
Total
Uniq-Total

com org
417
16
430
7
29
432
13
428
107
277
28
415
412
24
19
409
17
116
23
292
96
209
479
2
84
302
13
403
15
199
493
5220
4727
445

gov
0
10
1
0
41
22
6
12
11
21
68
0
34
0
1
227
170

net
27
4
21
43
8
14
12
19
4
6
8
2
11
21
23
223
212

edu
1
0
1
0
33
2
3
0
192
3
47
0
3
0
0
285
276

cc
39
49
15
14
30
18
43
40
158
152
64
17
58
62
262
1021
950

other Total
500
500
500
500
500
500
500
500
500
500
500
500
500
500
500
7500
6805

0
0
1
2
4
1
0
1
2
3
8
0
8
1
0
31
25

trees. As shown in Section 5, such an adaptation is eﬀective
in striking a good balance between retaining the accuracy
and reducing the total number of signatures.

The AST signature categorization tool was developed to
further merge AST signatures into diﬀerent categories. We
deﬁned categories according to diﬀerent types of JavaScript
expressions and statements such as arithmetic expressions
and assignment statements. Such a categorization can help
us to understand the use purposes of JavaScript code from
a programming language perspective. This tool is especially
useful for analyzing dynamically generated scripts, most of
which have speciﬁc use purposes in terms of programming
language functionality as revealed in our analysis.

4. DATA SET

To obtain a representative data set, we followed a similar
method as used in [16] and selected top websites listed by
Alexa.com [36]. We chose 15 categories and then top 500
sites from each of these categories. Table 1 gives the break-
down of 15 categories by DNS top-level domain (TLD). Since
some sites appear in multiple categories, the total number
of unique sites is 6,805 in our study. This number is over
ﬁve times larger than that in [16], and we also only visited
the homepages of those sites so that we can have a con-
sistent measurement. Meanwhile, measuring the insecure
JavaScript practices on homepages is suﬃcient to illustrate
the severity of the problem. Table 1 shows that the majority
of the 6,805 sites come from the .com TLD and the country
code (denoted as the cc) TLD. The former contributes 4,727
unique sites and the latter contributes 950 unique sites.

The execution of JavaScript on a webpage can be roughly
divided into two phases: the document loading and pars-
ing phase and the event-driven phase [9]. When the docu-
ment loading and parsing phase ends, the event-driven phase
starts and event handlers can be asynchronously executed
in response to various user interaction and timer events. In
our study, we developed a browser extension to automati-
cally visit each of the 6,805 webpages using our instrumented
Firefox Web browser. On each page, our browser exten-
sion waits for the end of the document loading and parsing
phase and then stays in the event-driven phase for 10 sec-
onds. Our browser extension has no intention to trigger the
execution of any speciﬁc event-handlers on a page. This is
because the event handlers registered on diﬀerent webpages
are very diverse, and it is diﬃcult to trigger their executions

WWW 2009 MADRID!Track: Web Engineering / Session: Client Side Web Engineering964Pages with any JS

Total

Pages with

DJS

Table 2: JavaScript Presence by Category and Top
Level Domain.
Category/
TLD
arts
business
computers
games
health
home
news
recreation
reference
regional
science
shopping
society
sports
world
com
org
gov
net
edu
cc
other
All

embedded JS included JS
437(87.4%)
483(96.6%)
484(96.8%)
380(76.0%)
473(94.6%)
482(96.4%)
374(74.8%)
465(93.0%)
471(94.2%)
375(75.0%)
473(94.6%)
471(94.2%)
330(66.0%)
451(90.2%)
467(93.4%)
389(77.8%)
479(95.8%)
471(94.2%)
430(86.0%)
475(95.0%)
477(95.4%)
389(77.8%)
467(93.4%)
477(95.4%)
286(57.2%)
443(88.6%)
455(91.0%)
401(80.2%)
457(91.4%)
479(95.8%)
274(54.8%)
405(81.0%)
421(84.2%)
393(78.6%)
486(97.2%)
487(97.4%)
329(65.8%)
441(88.2%)
435(87.0%)
456(91.2%)
482(96.4%)
492(98.4%)
481(96.2%)
377(75.4%)
438(87.6%)
4551(96.3%) 4504(95.3%) 4629(97.9%) 3838(81.2%)
247(55.5%)
401(90.1%)
150(88.2%)
75(44.1%)
153(72.2%)
194(91.5%)
122(44.2%)
239(86.6%)
863(90.8%)
654(68.8%)
23(92.0%)

491(98.2%)
492(98.4%)
484(96.8%)
488(97.6%)
481(96.2%)
487(97.4%)
483(96.6%)
487(97.4%)
476(95.2%)
492(98.4%)
449(89.8%)
493(98.6%)
466(93.2%)
496(99.2%)
489(97.8%)

422(94.8%)
160(94.1%)
204(96.2%)
250(90.6%)
902(94.9%)
24(96.0%)

378(84.9%)
137(80.6%)
189(89.2%)
223(80.8%)
817(86.0%)
22(88.0%)

6421(94.4%) 6270(92.1%) 6591(96.9%) 5098(74.9%)

9(36.0%)

in a consistent manner. Therefore, the JavaScript execu-
tion data set collected in our measurement study covers the
whole document loading and parsing phase and 10 seconds
of the event-driven phase for each of the 6,805 homepages.
The data set was collected in the second week of July 2008.

5. RESULTS AND ANALYSIS

We present and analyze our measurement results in this
section. We ﬁrst brieﬂy present the results on JavaScript
presence. Then, we detail the results on the insecure prac-
tices of JavaScript inclusion and dynamic generation. Fi-
nally, we give a short summary of the results on event han-
dler registrations.

5.1 Overall JavaScript Presence

Table 2 lists the results of overall JavaScript presence
for the 6,805 measured homepages. We use JS to repre-
sent any JavaScript code, and we use DJS to represent the
JavaScript code that is dynamically generated by using one
of the four dynamic generation techniques measured in our
instrumented Firefox Web browser. The embedded JS indi-
cates that the executed JavaScript code is embedded within
an HTML document, and the included JS indicates that the
executed JavaScript code is included from a separate ﬁle.

Overall, JavaScript execution has been widely observed on
6,591(96.9%) homepages. Both the JS embedding and JS in-
clusion are very common, and they are practiced on 6,421
and 6,270 pages, respectively. The percentage of webpages
containing JavaScript execution within a category ranges
from 89.8% for science to 99.2% for sports, and the percent-
age of webpages containing JavaScript execution within a
TLD ranges from 90.6% for .edu to 97.9% for .com. JavaScript
dynamic generation is also very popular, and there are 5,098
(74.9%) sites containing DJS on their homepages. For the
DJS presence within a category, the lowest percentage is
54.8% for science, and the highest percentage is 91.2% for
sports. For the DJS presence within a TLD, the highest
percentage is 81.2% for .com, and the lowest percentage is
36.0% for other domains such as .mil and .info.

i

s
n
a
m
o
d
 
n
o
s
u
c
n
i
 
e

i

l

l
i
f
 
t
p
i
r
c
S
a
v
a
J
 
f
o
 
n
o
i
t
c
a
r
F

1

0.9

0.8

0.7

0.6

0.5

0.4

0.3

0.2

0.1

0
0
10

1
10

The outdegree value

2
10

Figure 3: Cumulative distribution of the 4,517
JavaScript ﬁle inclusion domains in terms of their
outdegree values.

5.2 Insecure JavaScript Inclusion

Among all the 6,270 webpages with the included JS, we
identify and analyze insecure practices of JavaScript inclu-
sion. Note that we deﬁned the insecure JavaScript inclusion
as the practices of using the src attribute of a <script>
tag to directly or indirectly include a JavaScript ﬁle from an
external domain into the top-level document of a webpage.
Keeping JavaScript code separate from HTML markups is
actually a good engineering practice, advocated especially in
the unobtrusive JavaScript programming paradigm [9, 49].
Therefore, there is no need to analyze the good practices
of including JavaScript ﬁles from the same host or domain,
and we only focus on the insecure inclusion practices.

5.2.1 Results and analysis

To our surprise, insecure JavaScript inclusion is very preva-
lent. Around 66.4% (4,517 out of 6,805) of websites directly
or indirectly include JavaScript ﬁles from external domains
into the top-level documents of their homepages. Note that
our analysis tool applies a conservative standard to compare
the domain name of a JavaScript ﬁle and that of its includ-
ing homepage. Two domain names are regarded as diﬀerent
only if, after discarding their top-level domain names (e.g.,
.com) and the leading name “www” (if existing), they do
not have any common sub-domain name3. Therefore, this
66.4% result is basically an objective estimate of the severity
of insecure JavaScript inclusion practices.

After further analyzing the domain name relationship be-
tween JavaScript ﬁle inclusion sites and JavaScript ﬁle host-
ing sites, we found that those 4,517 sites include JavaScript
ﬁles from a diverse set of 1,985 external domains. We can
use a directed graph to characterize the domain name re-
lationship between these sites. Diﬀerent vertices represent
diﬀerent domain names, and a direct edge from vertex A to
vertex B means that the homepage in domain A includes
at least one JavaScript ﬁle from domain B. Therefore, 4,517
vertices have a greater than zero outdegree value, and 1,985
vertices have a greater than zero indegree value.

Figure 3 illustrates the CDF (cumulative distribution func-
tion) of the 4,517 JavaScript ﬁle inclusion domains in terms
of their outdegree values. We can see that approximately

3For example, two domain names www.d1sub2.d1sub1.d1tld
and d2sub3.d2sub2.d2sub1.d2tld are regarded as diﬀerent
only if the intersection of the two sets {d1sub2, d1sub1}
and {d2sub3, d2sub2, d2sub1} is empty.

WWW 2009 MADRID!Track: Web Engineering / Session: Client Side Web Engineering9651

0.9

0.8

0.7

0.6

0.5

0.4

0.3

0.2

0.1

i

s
n
a
m
o
d
 
g
n
i
t
s
o
h
 
e

l
i
f
 
t
p
i
r
c
S
a
v
a
J
 
f
o
 
n
o
i
t
c
a
r
F

0
0
10

1
10

2
10

3
10

4
10

The indegree value

Figure 4: Cumulative distribution of the 1,985
JavaScript ﬁle hosting domains in terms of their in-
degree values.

43.6% of the 4,517 sites include JavaScript ﬁles from at least
three external domains. While the mean value of outdegree
is 3.1, the maximum value of outdegree reaches 24. These
results indicate that not only 66.4% of measured sites are at
the risk of having their homepages under the control of the
included JavaScript code, but many of them also face higher
risks from multiple sources.

From a diﬀerent perspective, Figure 4 depicts the CDF of
the 1,985 JavaScript ﬁle hosting domains in terms of their
indegree values. We can observe two interesting phenom-
ena. On the one hand, JavaScript ﬁles in approximately
60.6% of the hosting domains are only included by one of
our visited homepages. On the other hand, JavaScript ﬁles
in approximately 7.7% of the hosting domains are included
by at least 10 of our visited homepages, and JavaScript ﬁles
in 14 sites are even included by at least 100 of our visited
homepages. The mean value of indegree is 7.2, but the max-
imum value of indegree reaches a very high value of 2,606.
After inspecting those 14 high-proﬁle JavaScript ﬁle hosting
domains and many other low-proﬁle domains, we found that
a few of them are popular traﬃc analysis service sites and
advertising servers. However, most of them are the kind of
“hidden” sites that provide nothing on their root URLs but
just point to some stored JavaScript ﬁles using URL paths.
Understanding the properties of those sites is beyond the
scope of this paper, but what we need to emphasize is that
external JavaScript ﬁle hosting sites, especially those high-
proﬁle ones, create new vectors for large-scale browser-based
attacks. Even a single compromised JavaScript ﬁle could di-
rectly cause security breaches on thousands of websites.

Among the 4,517 sites that include JavaScript ﬁles from
external domains, we also observed that 125 sites only use
the HTTPS protocol to retrieve JavaScript ﬁles and 138 sites
use both the HTTP protocol and the HTTPS protocol to re-
trieve diﬀerent JavaScript ﬁles. In total, there are 263 sites
using HTTPS to include scripts from 72 JavaScript ﬁle host-
ing sites. These observations imply that some JavaScript
ﬁle hosting sites do provide the secure transmission service
for accessing their hosted JavaScript ﬁles, and some of our
measured sites do use this service. However, this secure
JavaScript transmission service is not popular. Only 3.6%
(72 out of 1,985) of the JavaScript ﬁle hosting sites pro-
vide the service, and only 5.8% (263 out of 4,517) of the
JavaScript ﬁle inclusion sites use the service. Also note that
HTTPS protects data in transit, but it does not guarantee
that a JavaScript ﬁle is uncompromised in a hosting site.

In contrast to these 4,517 sites, we did ﬁnd that there are
324 other sites, in which an external included JavaScript ﬁle
is always restricted within a sub-level HTML frame or iframe
document whose origin is diﬀerent from that of the top-level
document. This observation implies that some sites do limit
the control of external included JavaScript code within sub-
level documents and provide a protection to the top-level
documents of their homepages. However, such a relatively
secure practice is exclusively followed by only 324 measured
sites, and those 4,517 sites still use a very insecure way to
include external JavaScript ﬁles.

5.2.2 Safe alternatives to insecure inclusion

Our results show that insecure JavaScript inclusion is widely

practiced by the majority (66.4%) of our measured sites.
Our in-depth analysis on the domain name relationship be-
tween JavaScript ﬁle inclusion sites and hosting sites fur-
ther reveals the severity and nature of those insecure prac-
tices. Although HTTPS and sub-level documents are used
by a small portion of sites to enhance the security of ex-
ternal JavaScript ﬁle inclusion, we believe that the major-
ity of measured JavaScript ﬁle inclusion sites and hosting
sites have not paid suﬃcient attention to the potential risks
of insecure JavaScript inclusion. For JavaScript ﬁle inclu-
sion sites, we suggest them (1) avoid external JavaScript
inclusion by using internal JavaScript ﬁles from the same
sites, if at all possible; (2) restrict the permission of ex-
ternal included scripts by placing them within a sub-level
HTML frame or iframe document whose origin is diﬀerent
from that of the top-level document, if external inclusion is
really inevitable; and (3) retrieve external JavaScript ﬁles
using HTTPS connections, if the HTTPS service is avail-
able. The third suggestion needs a hosting site to provide
the HTTPS service for accessing its JavaScript ﬁles, but the
ﬁrst two suggestions can be easily adopted by JavaScript ﬁle
inclusion sites.

5.3 Insecure JavaScript Dynamic Generation
Since 74.9% of measured sites (5,098 out of 6,805) contain
DJS scripts on their homepages, we now characterize all
the DJS scripts based on their generation techniques and
analyze insecure practices.

5.3.1 DJS presence by category and TLD

Table 3 lists the overall DJS presence by category and
TLD for the four diﬀerent DJS generation techniques. We
can see that the eval() function and the document.write()
method are widely used on 44.4% and 64.6% of webpages,
respectively. In contrast, the innerHTML property and the
DOM methods (i.e., replacing, inserting or appending a new
created script element) are only used on 13.7% and 11.7%
of webpages, respectively.
It is also interesting to notice
that the categories with the highest DJS presence values
are news and sports for all the four generation techniques.
The TLDs with the highest DJS presence values are .com,
.net, and country code domains. These results indicate that
JavaScript dynamic generation is more likely to be used on
those sites that have more dynamic contents.

5.3.2 DJS instance summary

We now examine the generated DJS instances on each
webpage. A DJS instance is identiﬁed in diﬀerent ways for
diﬀerent generation techniques. For the eval() function, the

WWW 2009 MADRID!Track: Web Engineering / Session: Client Side Web Engineering9661

0.8

0.6

0.4

0.2

0
 
0
10

1

0.8

0.6

0.4

0.2

S
J
D
d
e

 

t

a
r
e
n
e
g
−
a
v
e

l

 

h

t
i

w
 
s
e
g
a
p

 
f

o

 

n
o

i
t
c
a
r
F

S
J
D
d
e

 

t

a
r
e
n
e
g
−
L
M
T
H
r
e
n
n

i
 

h

t
i

w
 
s
e
g
a
p

 
f

o

 

n
o

i
t
c
a
r
F

innerHTML-
generated
76(15.2%)
73(14.6%)
55(11.0%)
58(11.6%)
35(7.0%)
57(11.4%)

eval-
generated
258(51.6%)
253(50.6%)
205(41.0%)
203(40.6%)
190(38.0%)
240(48.0%)
314(62.8%)
229(45.8%)
144(28.8%)
258(51.6%)
137(27.4%)
245(49.0%)
163(32.6%)
322(64.4%)
212(42.4%)

Table 3: DJS Presence by Category and Top-Level
Domain.
Category/
TLD
arts
business
computers
games
health
home
news
recreation
reference
regional
science
shopping
society
sports
world
com
org
gov
net
edu
cc
other
All

write-
generated
403(80.6%)
295(59.0%)
307(61.4%)
327(65.4%)
276(55.2%)
357(71.4%)
412(82.4%)
310(62.0%)
214(42.8%)
337(67.4%)
234(46.8%)
307(61.4%)
283(56.6%)
424(84.8%)
341(68.2%)
2359(49.9%) 3359(71.1%)
195(43.8%)
50(29.4%)
135(63.7%)
92(33.3%)
558(58.7%)
7(28.0%)
3024(44.4%) 4396(64.6%)

DOM-
generated
83(16.6%)
56(11.2%)
55(11.0%)
57(11.4%)
34(6.8%)
73(14.6%)
161(32.2%) 110(22.0%)
57(11.4%)
22(4.4%)
58(11.6%)
35(7.0%)
38(7.6%)
42(8.4%)
95(19.0%)
55(11.0%)
724(15.3%) 656(13.9%)
22(4.9%)
9(5.3%)
21(9.9%)
7(2.5%)
79(8.3%)
0(0.0%)
934(13.7%) 794(11.7%)

67(13.4%)
44(8.8%)
97(19.4%)
39(7.8%)
37(7.4%)
42(8.4%)
114(22.8%)
92(18.4%)

25(5.6%)
9(5.3%)
26(12.3%)
17(6.2%)
130(13.7%)
3(12.0%)

109(24.5%)
32(18.8%)
77(36.3%)
50(18.1%)
393(41.4%)
4(16.0%)

whole evaluated string content is regarded as a DJS instance.
Within the written content of the document.write() method
and the value of the innerHTML property, a DJS instance
can be identiﬁed from three sources: (1) between a pair
of <script> and </script> tags; (2) in an event handler
speciﬁed as the value of an HTML attribute such as onclick
or onmouseover; and (3) in a URL that uses the special
javascript:protocol speciﬁer [9]. For the DOM methods,
each new script element is identiﬁed as a DJS instance.

Table 4 gives a summary of DJS instances for both the
document loading and parsing phase, denoted as the pre-
onload phase, and the event-driven phase, denoted as the
post-onload phase. The two numbers in each table cell rep-
resent the data for the pre-onload and post-onload phases,
respectively. The data in the second row of the table gives
the total number of DJS instances identiﬁed in the two ex-
ecution phases for the four diﬀerent techniques. The data
in the third row of the table gives the total number of web-
pages on which those DJS instances are identiﬁed. The IPP
in the last three rows of the table stands for the “Instance
Per Page”.

Table 4:
onload/Post-onload Phases.
Summary

eval-

DJS Instance Summary for Pre-

total number
of DJS instances
total number
of pages
mean value
of IPP
maximum value
of IPP
standard deviation
of IPP

write-
generated generated
67446/
519
4385/
63
15.4/
8.2
1053/
160
41.6/
20.9

194676/
22632
2986/
363
65.2/
62.3
2543/
6350
174.4/
367.2

innerHTML-

DOM-
generated generated
1370/
557
680/
260
2.0/
2.1
13/
25
1.7/
2.7

28717/
6626
844/
187
34.0/
35.4
5001/
1403
184.3/
134.1

It is evident that the eval() function generates the largest
number of DJS instances in both phases (194,676 in the
pre-onload phase and 22,632 in the post-onload phase). The
mean value of IPP for eval-generated DJS instances is 65.2

 

1

 

S
J
D
d
e

 

t

a
r
e
n
e
g
−
e

t
i
r

w
h

 

t
i

w
 
s
e
g
a
p

 
f

o

 

n
o

i
t
c
a
r
F

0.8

0.6

0.4

0.2

pre−onload
post−onload

pre−onload
post−onload

1
10

2
10

3
10

IPP for eval−generated DJS instances

4
10

0
 
0
10

1
10

2
10

3
10

4
10

IPP for write−generated DJS instances

(a)

(b)

 

1

 

S
J
D
d
e

 

t

a
r
e
n
e
g
−
M
O
D
h

 

t
i

w
 
s
e
g
a
p

 
f

o

 

n
o

i
t
c
a
r
F

0.8

0.6

0.4

0.2

pre−onload
post−onload

pre−onload
post−onload

1
10

2
10

0
 
0
10

1
10

2
10

3
10

4
10

0
 
0
10

IPP for innerHTML−generated DJS instances

(c)

IPP for DOM−generated DJS instances

(d)

Figure 5: Cumulative distribution of the webpages
in terms of IPP (Instance Per Page) for (a) eval-
generated, (b) write-generated, (c) innerHTML-
generated, and (d) DOM-generated DJS instances.

in the pre-onload phase and 62.3 in the post-onload phase.
The maximum value of IPP for eval-generated DJS instances
reaches 2,543 in the pre-onload phase and 6,350 in the post-
onload phase. These numbers indicate that eval() may be
misused or abused. The document.write() method also gen-
erates a large number of DJS instances in the pre-onload
phase, but it only generates 519 DJS instances on 63 pages
in the post-onload phase. Calling document.write() in post-
onload phase is usually not desirable because it will over-
write the current document with the written content.
In
both phases, the innerHTML property also generates a large
number of DJS instances, while DOM methods generate
much fewer DJS instances.

For the four JavaScript dynamic generation techniques,
Figures 5(a) to 5(d) further illustrate the cumulative distri-
bution of the webpages in terms of IPP. In each of these four
ﬁgures, the “o” curve is for the pre-onload phase and the “∗”
curve is for the post-onload phase. Note that the total num-
ber of pages is diﬀerent for the two phases (as shown in the
third row of Table 4), and we present the two curves together
for ease of comparison. We can see that the indication of
misuse or abuse is especially evident for the eval() function.
While the majority (about 60%) of webpages have 10 or less
eval-generated DJS instances, nearly 17% and 11% of web-
pages have 100 or more eval-generated DJS instances for the
pre-onload phase and the post-onload phase, respectively.

5.3.3 Structural analysis of eval-generated DJS

The prevalence of DJS on various categories of webpages
and the high IPP values motivate us to further understand
the use purposes of the large number of DJS instances. Using
our JavaScript code classiﬁcation tools, we now uncover the
use purposes of eval-generated DJS instances in terms of
programming language functionality.

From the total 217,308 (both the pre-onload phase and the
post-onload phase) eval-generated DJS instances, 217,308

WWW 2009 MADRID!Track: Web Engineering / Session: Client Side Web Engineering967s
e
e
r
t
 

T
S
A

 
f
o
 
n
o
i
t
c
a
r
F

1

0.9

0.8

0.7

0.6

0.5

0.4

0.3

0.2

0.1

0

0

The DJS instances in these 14 categories all have speciﬁc use
purposes in terms of programming language functionality.
Only 1.2% of the DJS instances have mixed programming
language functionalities, and they are classiﬁed into the last
category of mixed statements. The generated DJS instances
in the last 15 categories are either various expressions (from
simple expression to other expression) or various statements
(from variable declarations to mixed statements). In general,
a JavaScript expression is used only to produce a value, while
a JavaScript statement normally has side eﬀects and is often
used to accomplish some tasks.

2

4

6

8

10

12

14

16

18

20

The Height of an Abstract Syntax Tree

5.3.4 Safe alternatives to eval()

Figure 6: Cumulative distribution of the AST trees
in terms of the height of an AST tree.

AST trees are extracted by our AST tree extraction tool.
The maximum height of these AST trees is 19. Figure 6
shows the cumulative distribution of the AST trees in terms
of the height of an AST tree. Nearly 90% of AST trees
have a height less than or equal to 4. Therefore, we selected
N = 4 as the input parameter (Figure 2) and used the top-
four level structure of AST trees to create and match AST
signatures. A total number of 647 AST signatures are cre-
ated and matched from the 217,308 AST trees. These 647
AST signatures capture the essential structural information
of the 217,308 AST trees, and they greatly facilitate our
further analysis. Using more levels of AST tree structure is
unnecessary because lower-level AST tree nodes only contain
less important structural information.

Finally, AST signatures with the same programming lan-
guage functionality are merged into the same category by
using our AST signature categorization tool. For example,
two AST signatures representing two types of function calls
with diﬀerent number or type of parameters are merged into
the same function calls category. Table 5 lists the ﬁnal 17
categories of DJS instances classiﬁed from the 647 AST sig-
natures, and in turn from the 217,308 DJS instances.

Table 5: The 17 categories of eval-generated DJS
instances.

Category

Number of

parse error
empty content
simple expression
12(0.4%)
arithmetic expression
79(2.6%)
relational expression
159(5.3%)
logical expression
265(8.8%)
object/array literal
126(4.2%)
other expression
98(3.2%)
variable declarations
function declarations
1157(38.3%)
assignment statements 1289(42.6%)
527(17.4%)
function calls
561(18.6%)
method calls
29(1.0%)
object/array creations
conditional statements
181(6.0%)
1075(35.5%)
try-catch statements
mixed statements
910(30.1%)

Presence
Average
in Pages DJS instances DJS length
1175.5
20(0.7%)
124(4.1%)
0.0
13.9
67.9
31.7
75.8
623.0
18.5
586.0
13380.7
51.9
368.9
75.9
41.3
519.1
51.7
6884.1

111(0.05%)
291(0.13%)
1209(40.0%) 134251(61.8%)
158(0.1%)
3246(1.5%)
3249(1.5%)
4798(2.2%)
5789(2.7%)
411(0.2%)
1929(0.9%)
42015(19.3%)
2733(1.3%)
2062(0.9%)
212(0.1%)
9371(4.3%)
4127(1.9%)
2555(1.2%)

We can see that 0.05% of the DJS instances have parse
error when AST trees are extracted, and 0.13% of the DJS
instances have empty content. The majority (around 98.6%)
of the eval-generated DJS instances are classiﬁed into the 14
categories from simple expression to try-catch statements.

To further understand whether using eval() is necessary
in these diﬀerent categories, we randomly sampled and in-
spected both the content and the calling context of 700 DJS
instances. We sampled 200 DJS instances from the simple
expression category and 200 DJS instances from the assign-
ment statements category. These two categories have the
largest numbers of DJS instances, accounting for 61.8% and
19.3%, respectively, of all the eval-generated DJS instances.
The remaining 300 DJS instances are sampled from the other
15 categories, with each of them contributing 20 instances.
In at least 70% of the sampled cases, the eval() function is
misused or abused while safe alternatives can be easily iden-
tiﬁed. Here we illustrate three representative sampled cases.
The ﬁrst one is: this.homePos = eval(“0” + this.dirType +
this.dim), in which a string simple expression “0-500” is gen-
erated. Indeed, such a kind of string concatenation directly
generates a string value, and using eval() is redundant. The
second one is: var ﬀ nav=eval(“nav ”+tt[i][1]), in which a
variable name “nav 20912” is dynamically accessed. A safe
alternative is using the JavaScript window object to directly
access the variable: var ﬀ nav=window[“nav ”+tt[i][1]]. The
third one is: var responses = eval(o.responseText), in which
the response content of an XMLHttpRequest [50] is directly
evaluated. This practice is used in many of our sampled
cases to convert a responseText into a JSON object. How-
ever, since malicious JavaScript code could be injected into
the responseText, it would be better to use a JSON parser
rather than the eval() function to perform such a transfor-
mation [42]. The other 30% of the sampled cases usually
have complex calling context, so we do not further identify
their safe alternatives.

We suggest that eval() should be avoided if at all possible.
In addition to the safe alternatives exempliﬁed above, DOM
methods can be generally used to generate and execute var-
ious JavaScript statements.

5.3.5 Structural analysis of other types of DJS

As mentioned before, the DJS instances generated by the
document.write method() and the innerHTML property are
identiﬁed from three diﬀerent sources. We use jscode to
present a DJS instance identiﬁed between a pair of <script>
and </script> tags, use eventhandler to represent a DJS in-
stance identiﬁed in an event handler, and use jsprotocol to
represent a DJS instance identiﬁed in a javascript:protocol
URL. The DJS instances generated by the DOM methods
are speciﬁed in either the src attribute or the text attribute
of a script element. Table 6 gives the structural analysis re-
sults of the DJS instances generated by these three dynamic
generation techniques. The main usage of each type of DJS
instance is summarized in the last column of the Table 6.

WWW 2009 MADRID!Track: Web Engineering / Session: Client Side Web Engineering968Table 6: Structural analysis of DJS instances gener-
ated by the document.write() method, innerHTML
property, and DOM methods.

Technique
and Type

Presence Number of Avg. Main usage
in Pages DJS instances length

jscode

write

eventhandler

jsprotocol

jscode

innerHTML

eventhandler

DOM

jsprotocol

src
text

4000
1773
501
120
747
336
779
33

26125
38650
3190
503

31267
3573
1866

61

77 JS inclusion
function call
39
45
function call
262 JS inclusion
function call
60
function call
33
-
JS inclusion

623 assignment

5.3.6 Safe alternatives to jscode generation via doc-

ument.write() and innerHTML

For the eventhandler and jsprotocol DJS instances gener-
ated by document.write() and innerHTML, their usages are
relatively safe. When new content is added to a document,
event handlers are directly speciﬁed on various elements of
the newly-added content to respond to various events. The
javascript:protocol scripts are often used on links to ex-
ecute some statements without loading a new document.

What we emphasize is that generating jscode using doc-
ument.write() and innerHTML is not desirable. For docu-
ment.write(), the generated jscode is immediately executed.
Multiple document.write() calls can be used to construct
a jscode, and document.write() calls can be nested. All
these factors make the ﬁltering of write-generated malicious
JavaScript code a very challenging task [32]. However, our
results show that 26,125 instances of write-generated jscode
are identiﬁed on a large number of 4,000 homepages. For in-
nerHTML, the generated jscode is recognized by a browser,
but it is not necessarily executed. For example, Firefox does
not directly execute a jscode generated by innerHMTL. In
Internet Explorer, the defer attribute and some tricks need
to be used to execute an innerHTML-generated jscode, but
this practice is also not recommended due to potential script-
injection attacks [44]. Fortunately, only 503 instances of this
practice are identiﬁed on 120 pages as shown in Table 6.

The best practice is to use DOM methods to dynamically
generate JavaScript code. Using DOM methods (such as cre-
ateElement() and createTextNode()) to create JavaScript el-
ements explicitly declares that the new elements are scripts.
This practice can enable potential Web content protection
mechanisms such as those presented in [13, 25, 32] to accu-
rately deﬁne security policies and weed out potential mali-
cious JavaScript code. Unfortunately, only 1,927(1,866 plus
61) instances of this practice are identiﬁed.

Our results show that the main usage of jscode generated
by document.write() and innerHTML is for including other
JavaScript ﬁles (denoted as JS inclusion in Table 6).
In-
deed, by specifying the src attribute of a script element,
DOM methods ﬁt well for such a usage. By specifying the
text attribute of a script element, DOM methods can also
be used to generate and execute various statements such as
assignment statements or function calls, thus safely replac-
ing the relatively insecure practices of jscode generation via
document.write() and innerHTML.

5.4 Event Handler Registration

Our measurement results show that event handler regis-
trations occurred on 6,451(94.9%) pages in the pre-onload
phase, with an average of 108.2 registrations per page and a

maximum of 5,074 registrations per page. Event handler reg-
istration occurred on 1,767(26.0%) pages in the post-onload
phase, with an average of 61.4 registrations per page and a
maximum of 2,229 registrations per page. These results in-
clude majority event types (e.g., event attributes of HTML
tags, timer events, and XMLHttpRequest events) and event
registration techniques supported in Firefox. The execution
of event handlers may trigger further JavaScript inclusion
and dynamic generation, implying that our captured inse-
cure JavaScript practices are likely conservative estimates.

6. RELATED WORK

To the best of our knowledge, there is no directly related
work on characterizing the insecure practices of JavaScript
inclusion and dynamic generation. Therefore, we only brieﬂy
review some JavaScript related measurement studies. Krish-
namurthy and Wills [16] measured the homepages of 1,158
unique sites selected from Alexa.com [36] to study the con-
tent delivery tradeoﬀs in Web access. The focus of their
study is on the performance impact of extraneous content,
and their results show that JavaScript is often used on pop-
ular webpages to retrieve extraneous content such as images
and advertisements.

In the investigation of malware, several execution-based
measurement studies [20, 24, 28] have been conducted to
identify malicious webpages that contain code (in many cases,
JavaScript code) for exploiting Web browser vulnerabilities
and installing malware.
Instead of targeting at malicious
sites, our focus in this work is on legitimate websites’ inse-
cure JavaScript practices.

7. CONCLUSION

In this paper, we presented the ﬁrst measurement study
on insecure practices of using JavaScript on the Web. We
focused on investigating the severity and nature of insecure
JavaScript inclusion and dynamic generation. Through an
instrumented Mozilla Firefox 2 Web browser, we visited the
homepages of 6,805 popular websites in 15 diﬀerent cate-
gories. We found that at least 66.4% of the measured web-
sites have the insecure practices of including JavaScript ﬁles
from external domains into the top-level documents of their
homepages. Our in-depth analysis on the domain name rela-
tionship between JavaScript ﬁle inclusion sites and hosting
sites further reveals the severity and nature of those inse-
cure practices. Our measurement results on JavaScript dy-
namic generation show that the “evil” function eval() was
called on 44.4% of the measured homepages, and the doc-
ument.write() method and the innerHTML property were
also used to generate JavaScript code. Our AST-based struc-
tural analysis on various DJS instances further uncovers
their usages with respect to programming language function-
ality. Our analysis indicates that in common cases, safe al-
ternatives do exist for both the insecure JavaScript inclusion
and insecure JavaScript dynamic generation. Since Web-
based attacks have become more common and damaging in
recent years, we suggest website developers and adminis-
trators pay serious attention to these insecure JavaScript
practices and use safe alternatives to avoid them. In the fu-
ture, we will measure insecure JavaScript practices on more
speciﬁc types of websites and webpages. We will also inves-
tigate whether other insecure JavaScript practices exist on
the Web.

WWW 2009 MADRID!Track: Web Engineering / Session: Client Side Web Engineering9698. ACKNOWLEDGMENTS

The authors thank anonymous reviewers for their valu-
able comments and suggestions. This work was partially
supported by NSF grants CNS-0627339 and CNS-0627340.

9. REFERENCES
[1] T. Ball and J. R. Larus. Optimally proﬁling and tracing

programs. ACM Trans. Program. Lang. Syst.,
16(4):1319–1360, 1994.

[2] A. Barth, C. Jackson, and J. C. Mitchell. Robust defenses

for cross-site request forgery. In Proc. of the CCS, pages
75–88, 2008.

[3] I. D. Baxter, A. Yahin, L. Moura, M. Sant’Anna, and

L. Bier. Clone detection using abstract syntax trees. In
Proc. of the ICSM, pages 368–377, 1998.

[4] A. Bortz, D. Boneh, and P. Nandy. Exposing private

information by timing web applications. In Proc. of the
WWW, pages 621–628, 2007.

[5] S. Ceri, P. Fraternali, A. Bongio, M. Brambilla, S. Comai,

and M. Matera. Designing Data-Intensive Web
Applications. Morgan Kaufmann, ISBN 1-55860-843-5,
2002.

[6] S. Chen, J. Meseguer, R. Sasse, H. J. Wang, and Y.-M.

Wang. A systematic approach to uncover security ﬂaws in
gui logic. In Proc. of the S&P, pages 71–85, 2007.
[7] W. S. (Editor). Web Engineering: Principles And

Techniques. IGI Publishing, ISBN 1-591-40433-9, 2005.

[8] L. Falk, A. Prakash, and K. Borders. Analyzing websites

for user-visible security design ﬂaws. In Proceedings of
SOUPS, pages 117–126, 2008.

[9] D. Flanagan. JavaScript: The Deﬁnitive Guide. O’Reilly

Media, ISBN 0-596-10199-6, 2006.

[10] S. Fogie, J. Grossman, R. Hansen, A. Rager, and P. D.
Petkov. XSS Exploits: Cross Site Scripting Attacks and
Defense. Syngress, ISBN 1-597-49154-3, 2007.

[11] Y.-W. Huang, F. Yu, C. Hang, C.-H. Tsai, D.-T. Lee, and

S.-Y. Kuo. Securing web application code by static analysis
and runtime protection. In Proc. of the WWW, pages
40–52, 2004.

[12] C. Jackson, A. Bortz, D. Boneh, and J. C. Mitchell.

Protecting browser state from web privacy attacks. In Proc.
of the WWW, pages 737–744, 2006.

[13] T. Jim, N. Swamy, and M. Hicks. Defeating script injection

attacks with browser-enforced embedded policies. In Proc.
of the WWW, pages 601–610, 2007.

[14] S. Kals, E. Kirda, C. Kruegel, and N. Jovanovic. Secubat: a

web vulnerability scanner. In Proc. of the WWW, pages
247–256, 2006.

[15] G. Kappel, B. Proll, S. Reich, and W. R. (Eds.). Web

Engineering: The Discipline of Systematic Development of
Web Applications. John Wiley & Sons, ISBN
0-470-01554-3, 2006.

[22] T. Oda, G. Wurster, P. V. Oorschot, and A. Somayaji.

Soma: Mutual approval for included content in web pages.
In Proc. of the CCS, pages 89–98, 2008.

[23] T. A. Powell, D. L. Jones, and D. C. Cutts. Web Site

Engineering: Beyond Web Page Design. Prentice Hall,
ISBN: 0-13650-920-7, 1998.

[24] N. Provos, P. Mavrommatis, M. A. Rajab, and F. Monrose.

All your iframes point to us. In Proc. of the USENIX
Security Symposium, 2008.

[25] C. Reis, J. Dunagan, H. J. Wang, O. Dubrovsky, and

S. Esmeir. Browsershield: vulnerability-driven ﬁltering of
dynamic html. In Proc. of the OSDI, pages 61–74, 2006.

[26] D. C. Reis, P. B. Golgher, A. S. Silva, and A. F. Laender.

Automatic web news extraction using tree edit distance. In
Proc. of the WWW, pages 502–511, 2004.

[27] G. Rossi, O. Pastor, D. Schwabe, and L. O. (Eds.). Web

Engineering: Modelling and Implementing Web
Applications. Springer, ISBN: 1-84628-922-X, 2007.

[28] Y.-M. Wang, D. Beck, X. Jiang, R. Roussev, C. Verbowski,

S. Chen, and S. T. King. Automated web patrol with
strider honeymonkeys: Finding web sites that exploit
browser vulnerabilities. In Proc. of the NDSS, 2006.

[29] G. Wassermann and Z. Su. Static detection of cross-site

scripting vulnerabilities. In Proc. of the ICSE, pages
171–180, 2008.

[30] C. A. Welty. Augmenting abstract syntax trees for program

understanding. In Proc. of the ASE, pages 126–133, 1997.

[31] W. Yang. Identifying syntactic diﬀerences between two

programs. Softw. Pract. Exper., 21(7):739–755, 1991.

[32] D. Yu, A. Chander, N. Islam, and I. Serikov. Javascript

instrumentation for browser security. In Proc. of the POPL,
pages 237–249, 2007.

[33] C. Yue, M. Xie, and H. Wang. Automatic cookie usage

setting with cookiepicker. In Proc. of the DSN, pages
460–470, 2007.

[34] Y. Zhai and B. Liu. Web data extraction based on partial
tree alignment. In Proc. of the WWW, pages 76–85, 2005.

[35] 24 ways: Don’t be eval().

http://24ways.org/2005/dont-be-eval.

[36] Alexa Top Sites.

http://www.alexa.com/browse?CategoryID=1.

[37] CERT Advisory CA-2000-02 Malicious HTML Tags

Embedded in Client Web Requests.
http://www.cert.org/advisories/CA-2000-02.html.

[38] Cross-site scripting.

http://en.wikipedia.org/wiki/Cross-site scripting.

[39] eval - MDC. http://developer.mozilla.org/en/

Core JavaScript 1.5 Reference/Global Functions/eval.

[40] JavaScript. http://en.wikipedia.org/wiki/JavaScript.
[41] JSAPI reference - MDC.

http://developer.mozilla.org/en/JSAPI Reference.
[42] JSON in JavaScript. http://www.json.org/js.html.
[43] JSPrincipals - MDC.

[16] B. Krishnamurthy and C. E. Wills. Cat and mouse: content

http://developer.mozilla.org/en/JSPrincipals.

delivery tradeoﬀs in web access. In Proc. of the WWW,
pages 337–346, 2006.

[17] V. T. Lam, S. Antonatos, P. Akritidis, and K. G.

Anagnostakis. Puppetnets: misusing web browsers as a
distributed attack infrastructure. In Proc. of the CCS,
pages 221–234, 2006.

[18] B. Livshits and W. Cui. Spectator: detection and

containment of javascript worms. In Proc. of the USENIX
Annual Technical Conference, pages 335–348, 2008.

[19] E. Mendes and N. M. (Eds.). Web Engineering. Springer,

ISBN 3-540-28196-7, 2005.

[20] A. Moshchuk, T. Bragin, S. D. Gribble, and H. M. Levy. A
crawler-based study of spyware in the web. In Proc. of the
NDSS, 2006.

[21] S. Murugesan and Y. D. (Eds.). Web Engineering :

Managing Diversity and Complexity of Web Application
Development. Springer, ISBN 3-540-42130-0, 2001.

[44] MSDN: innerHTML property. http://msdn.microsoft .com

/en-us/library/ms533897(VS.85).aspx.

[45] Same origin policy.

http://en.wikipedia.org/wiki/Same origin policy.

[46] SANS Top-20 2007 Security Risks (2007 Annual Update).

http://www.sans.org/top20/2007/.

[47] SpiderMonkey (JavaScript-C) Engine.

http://www.mozilla.org/js/spidermonkey/.

[48] Symantec Internet security threat report volume XIII:

April, 2008. http://www.symantec.com/
business/theme.jsp?themeid=threatreport.

[49] Unobtrusive Javascript. http://www.onlinetools.org/

articles/unobtrusivejavascript/.

[50] XMLHttpRequest.

http://www.w3.org/TR/XMLHttpRequest/.

WWW 2009 MADRID!Track: Web Engineering / Session: Client Side Web Engineering970