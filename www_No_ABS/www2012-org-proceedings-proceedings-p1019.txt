Link prediction is the task of inferring links in a graph Gt+1 based on the observation of a graph Gt.
It may be that t + 1 follows t in time, or it may be that t + 1 represents some other evolution or manipulation of the graph such as including additional links from experiments that are di cult or expensive to conduct.
Link prediction stated in this manner is a binary classi cation problem in which links that form construct the positive class and links that do not form construct the negative class.
Link analysis, more loosely de- ned, is the problem of identifying evolutionary processes or growth mechanisms in a network that are responsible for the formation of new relationships between nodes.
We formally de ne a new technique for performing both link prediction and link analysis based on a restrictive representation of the local topological embedding of the source Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
and target vertices.
This idea is a generalization and extension of the triangle counting approach for multi-relational prediction in [6].
It also draws on concepts from literature on graphlets as introduced in [19] and to a lesser degree from motif analysis as discussed in [17].
Many existing link prediction models compress a selection of simple information in theoretically or empirically guided ways.
By contrast the VCP approach preserves as much topological information as possible about the embedding of the source and target vertices.
It also extends naturally to multi-relational networks and can thereby encode a variety of additional information such as edge directionality.
It can encode continuous quantities such as edge weights by binning into relational categories, such as high activity and low activity.
Information about the nature of relationships is maintained as structures are identi ed within the network.
We proceed with a formal exploration of VCP, discuss its relationship to isomorphism classes, provide algorithms that formally describe VCP computations, and demonstrate the potential of VCP in link prediction and analysis as well as feasibility in terms of computational time.
Fast forms of the algorithms listed within this paper are all implemented in C++ and integrated into the LPmade [14] link prediction software and are thus freely available on MLOSS.
Formally, a vertex collocation pro le (VCP), written as VCPn,r i,j , is a vector describing the relationship between two vertices, vi and vj, in terms of their common membership in all possible subgraphs of n vertices over r relations.
A VCP element, VCPn,r i,j (x) is de ned as a distinct embedding of vi and vj within a particular isomorphism class of n vertices and is represented by a uniquely addressable cell in the VCP vector.
Figure 1 illustrates the  rst 16 elements of VCP3,2 s,t , where the two relations correspond to edge directionality.
In general, we can encode the connectivity in any multi-relational network of r relations with 2r di erent types of connections.
We use 2r instead of 2r 1 because structural holes are often as important as links [5], and we consider the lack of relation as itself a type of connection.
Undi-rected single-relational networks exhibit two types of connections: existent and nonexistent.
Directed single-relational networks are similar to undirected bi-relational networks and have four types of connections: nonexistent, outward, inward, and bidirectional.
The cardinality of VCPn,r depends upon the number of vertices n and the number of types of relationship r in the set of relations R. The space grows exponentially in the number

 s s s s t t t t


 s s s s t t t t


 s s s s t t t t


 s s s s t t t t



 Figure 1: Elements of VCP3,2 identical except with the presence of et,s.
s,t .
16 through 31 are r



 n























 Table 1: Number of enumerated subgraphs composing VCP for values of n and r.
of vertices with the base as the cardinality of the power set of relations.
The formula for the number of subgraphs is written in intuitive form in Equation 1.
The multiplier accounts for the number of possible collocation structures disregarding any links between the source and the target.
The multiplicand is the number of di erent ways two vertices with the same embedding can appear based on the di erent link possibilities between them.
(2r)(cid:16) n(n 1) 2  1(cid:17)   2r 1 (1) We can manipulate these to achieve the simpler formula below.
n(n 1)r
  1
 (2) Table 1 illustrates the number of subgraphs respecting vertex identity that compose the VCP given di erent values of n and r.
The number of subgraphs grows at such a rate as to make the sheer size of output unmanageable for large values of n and r. The rate of growth of VCPs is much slower due to superlinear increases in the isomorphisms with increasing n, but nonetheless VCP cardinality also grows quickly.
Fortunately, the most important information is typically located close to the source and target vertices, and many networks have few types of relationships.
When the number of relationship types is high, relationships can be compressed or discarded in various ways albeit with a loss of information.
Isomorphic subgraphs are closely related to VCP elements.
In Figure 2, it is impossible to distinguish subgraph 1 from


 s s s s t t t t


 s s s s t t t t


 s s s s t t t t


 s s s s t t t t


 s s s s t t t t


 s s s s t t t t


 s s s s t t t t


 s s s s t t t t



























 Figure 2: Subgraphs that form VCP4,1 ping of isomorphic subgraphs to VCP elements.
s,t and the map-subgraph 2, and the prevalence of the frequency of each during counting will depend upon implementation details of the counting algorithm that determine the order in which the vertices are selected.
These subgraphs map to the same VCP element, VCP4,1 s,t (1), and the count of that element is the sum of the counts of the isomorphic subgraphs.
Isomorphisms that require a mapping between vs and vt, for instance subgraph 1 and subgraph 8 in Figure 2, do not share the same VCP element even though they reside within the same isomorphism class.
VCP elements ignore isomor-phisms that require mapping vs to vt because VCP describes the local embedding of these two explicitly identi ed vertices.
In undirected graphs, elements such as VCP4,1 s,t (1) and
 s,t (3) together supply information regarding symmetry or asymmetry in the density of the embedding of vs and vt.
The distinction in directed networks is more obvious and relates to the potential signi cance of the di erence in the local topologies of the source of a new link and its target.
Figure 2 shows all the subgraphs pertinent to VCP4,1 and their corresponding mappings to elements.
Counting the number of elements in VCPn,r is related to the complex problem of counting the number of isomorphism classes in graphs of n vertices.
In VCP3,r, each enumerated subgraph maps uniquely to a VCP element.
vs and vt are  xed, and there is only one permutation of the remaining vertex.
In VCP4,r, there are two mappable vertices and the number of VCP4,r elements is described as: 26r 2 + 24r 2 (3) The derivation of a general formula for |VCPn,r| for all n and r is extremely combinatorially involved and its discussion is beyond the scope of this paper.
We have instead provided software that computes VCP cardinalities and subgraph-to-element mappings for 3 < n < 8 and 1 < r < 8.
For practical purposes, Table 2 shows the cardinality of all VCPs with fewer than a million elements.
We de ne a VCP addressing scheme similar to the isomor-phism certi cate addressing scheme in [12].
The subgraphs from which the elements are derived are indexed by assign-i,j .
r



 n














 --




---

--------ing powers of 2r to edges in the adjacency matrix in increasing lexicographical order starting with e1,3 and ending with en 1,n.
vs and vt are de ned as v1 and v2 respectively, and e1,2 is the edge of highest value.
The value of each edge is multiplied by the index of the lexicographically ordered power set, P(R), corresponding to the ordered set of R relations on the edge.
Figures 1 and 2 demonstrate the indexing scheme for two di erent values of n and r. For any selection of vertices vs, vt, v3, ..., vn, this addressing scheme will map the resulting multi-relational subgraph to an index that exists within a set of indices of isomorphic structures.
We de ne the unique address of a VCP element as the subgraph representative with the lowest index within the corresponding isomorphism class.
This addressing scheme provides a unique address for all elements in all VCPs.
The addresses for elements in VCP4,1 are provided in Figure
 error-prone and di cult especially as the number of sub-graphs increases, we have provided a program that outputs the mapping from all subgraph indices to their corresponding element addresses for all VCPs.
Directed networks with r relations can be treated similarly to undirected networks with 2r relations with one major caveat.
The subgraph-to-element mapping di ers with directed networks.
Taking ex i,j momentarily as notation for an edge of relation x and 2x as relation x in the opposite i,j   ex direction, ex j,i in undirected multi-relational networks, i,j   e2x but ex j,i in directed networks.
In the context of larger subgraphs, this causes more isomorphic equivalences and decreases the cardinality of the VCP by comparison to its undirected pseudo-equivalent, a fact demonstrated in Figure 3.
For instance, VCP4,2 contains 1088 elements whereas the directed variant of VCP4,1 contains only 1056 elements.
s s
 t t    
 s s t t

 Figure 3: Subgraphs from undirected VCP4,2 and directed VCP4,1.
The directed subgraphs both map to directed VCP4,1(221), but the undirected subgraphs map to two di erent VCP4,2 elements.
Algorithm 1 VCP3,r Input: network G = (V, E), relations R, i : vi   V , j : vj   V i,j i,j [ ]   V CP 3,|R| i,j  i,k    (P(R), ei,k)  j,k    (P(R), ej,k)     22|R| i,j + 2|R| j,k +  i,k
 [ ] + 1 Output: V CP 3,|R|





 7: end for

  i,k    (P(R), ei,k)     22|R| i,j + 2|R| j,k +  i,k


 [ ] + 1 12: end for

  j,k    (P(R), ej,k)     22|R| i,j + 2|R| j,k +  i,k


 [ ] + 1 17: end for



 21: end for
 [ ]   V CP 3,|R| [ ]   V CP 3,|R| [ ]   V CP 3,|R| i,j [ ] + 1 i,j i,j i,j i,j i,j i,j Therefore, the algorithms in Section 3 and the procedures described by all provided code work with only minor adjustments, which are essentially related to the subgraph-to-element mapping.
We include software to construct the mapping for VCP4,1 where there are actually two relations corresponding to directionality.
In fact, Algorithms 1 and 2 serve as reference algorithms and not as optimized or even asymptotically optimal approaches for VCP element counting.
implementations of the na ve VCP4,1 algorithm fail to return within a reasonable time for networks with even thousands of nodes.
Fortunately, it is possible to design much faster approaches, and we implemented these approaches and provide them as a set of C++  les.
We also present a more innovative algorithm, Algorithm 3 for counting VCP4,1 that corresponds to the approach in the code for that VCP.
Algorithm 1 demonstrates how to calculate VCP3,r for the set of r relations in R.  (P(R), ex,y) refers to a procedure to determine the index of the multi-relational edge ex,y in P(R), the lexicographically ordered power set of relations.
This procedure can derive power set indices e ciently by setting individual bits in the index according to the presence of the relation corresponding to that bit and indexing the bits by the natural order of the relations themselves.
This na ve algorithm  rst determines the contribution of any edge types between vi and vj, the  xed source and tar-Input: network G = (V, E), i : vi   V , j : vj   V , subgraph-element mapping M for l : vl 6= vi   vl 6= vj   l > k do       + 2       + 1 Output: V CP 4,1 i,j 1: for k : vk 6= vi   vk 6= vj do


















 21: end for
 i,j     0 if ei,k   E then end if if ei,l   E then end if if ej,k   E then end if if ej,l   E then end if if ek,l   E then end if
       + 16       + 4       + 8 get vertices for the link.
Then it counts subgraphs with a third vertex connected to both vi and vj, subgraphs only connected to vi, subgraphs only connected to vj, and both.
  represents the identity of an edge within P(R) and   represents the index of the subgraph.
Because no isomorphisms exist with only one mappable vertex, the algorithm directly increments the VCP elements corresponding to the underlying subgraph index as contrasted to Algorithm 2 wherein the subgraph index must be mapped to an element address.
A na ve implementation iterates through each vertex in the network and determines the corresponding subgraph index by summing the edge contributions.
For one free vertex, this approach has complexity O (cid:16)|V | log (cid:16) |E| |V |(cid:17)(cid:17) per edge |V |(cid:17)(cid:17) neighbor search time for output assuming O (cid:16)log (cid:16) |E| the average case.
This complexity is probably feasible for small networks, but may require an unacceptably long time for large networks.
It is simple to improve upon this approach by considering only the vertices that are neighbors, denoted by  (vx) of vi, vj, both, or neither and performing set operations.
VCP3,1 i,j (0) is populated by subtracting | (vi)    (vj)| from |V |   2.
VCP3,1 i,j (2) are populated by computing set di erences | (vi)    (vj)| and | (vj) (vi)| respectively.
VCPi,j is computed as the intersection | (vi)    (vj)|.
These operations can be performed quickly especially in graphs in which adjacencies are represented as ordered lists of neighbors.
This implementation has average-case complexity O (cid:16) |E| |V |(cid:17) per edge output.
i,j (1) and VCP3,1 i,j (M ( ))   V CP 4,1 i,j (M ( )) + 1 end for
 yielding a complexity of O (cid:16)|V |2 log (cid:16) |E| Algorithm 2 iterates through every pair of free vertices, |V |(cid:17)(cid:17) from (cid:0)|V | 2 2 (cid:1) pairs of free vertices.
This requires trillions of operations even for small networks.
It is possible to reduce this time greatly by restricting consideration to known neighbors as described in the discussion of Algorithm 1, but na ve implementations of this optimization involve many expensive operations in hashes or balanced search trees.
Algorithm 3 instead uses a minimal number of set operations implemented as merge operations on ordered lists.
Figure 4 provides an illustration of the sets mentioned in the following explanation.
First, the number of connected pairs and unconnected pairs is computed once for the entire network, and these values are represented as  G and  G respectively.
We must also track the connected pairs and unconnected pairs internal to the vertices in our consideration for the prediction output to di erentiate VCP4,1(0) from VCP4,1(10).
We start by constructing a set of potential  third position  vertices,  3, as  (vi)    (vj).
For each member of  3, we construct two disjoint sets of  fourth position  vertices,  4 containing vertices reachable by our current member of  3 but not contained within  3, and  4a constructed from  3 excluding the current member of  3.
In  4, we count new connections and gaps in the con gu-ration, and we increment the counter for the corresponding subgraph.
For  4a, we do not count connections and gaps since con gurations using those set members are counted when they serve as members of  3, or  third position  vertices.
Likewise, we only count subgraphs with two members from  3 when the member from  4a compares lower.
This avoids multi-counting.
After considering the con g-urations from all members of  4 and  4a, we account for structures with isolates by contributing |V |   2   | 3|   | 4| to V CP 4,1 i,j (M ( 1)).
We also account for multi-counting of VCP4,1(0) due to duplicate consideration of gaps by subtracting the same quantity from V CP 4,1 i,j (M (0)).
Finally, we compute VCP4,1(0) and VCP4,1(10) using our computations of vertices and gaps in the vertices we have encountered in the single  3 and multiple  4 sets and subtract their contributions from the contributions from the entire network.
It is possible to perform the entire procedure using a few relatively inexpensive merge operations in ordered vectors or lists and entirely avoiding hashes or balanced trees.
This exposition mostly describes the procedure to quickly compute VCP4,1 albeit omitting minor implementation details.
We refer more interested readers to the code itself.
It is trivial to extend VCP algorithms to networks more complex than those on which we obtained our results.
This includes any form of edge feature such as directionality, weight, temporality, di erent relation types, or any information describing edges or vertex pairs that either exists categorically or can be quantized.
One amenable network representation associates an ordered set of bits with each edge.
Each bit corresponds to the presence of a particular relation or some Boolean descriptor for a pair of vertices.
The determination of the existence of an edge for single-relational data instead becomes an evaluation of the edge as the binary-coded integral value of the ordered set of bits.
This is one conceivable implementation for  (P(R), ex,y) in Algorithm 1, which replaces the constant values for all   updates in Algorithms 2 and 3.
For most values of r, this Input: network G = (V, E), i : vi   V , j : vj   V , subgraph-element mapping M count of connected pairs  G, count of unconnected pairs  G Output: V CP 4,1 i,j  1   0 if ei,k   E   ek,i   E then  2    1 if ei,l   E   el,i   E then end if if ej,l   E   el,j   E then end if if ek,l   E   el,k   E then else       + 1 else       + 1 else       + 1  2    2 + 8       + 1  2    2 + 2       + 1  1    1 + 1       + 1  2    2 + 16       + 1 end if  4    (vk)    3       + | 4| for l : vl    4 do 1:     2 2:     0 3:     0



















































 56: end for





 i,j end for     | 3| + | 4|

  2    2 + 16       + 1 else       + 1 end if
  2    2 + 2 else       + 1 end if
 i,j (M ( 2))   V CP 4,1 i,j (M ( 2)) + 1 end for for l : vl    3   l > k do  2    1 if ei,l   E   el,i   E then end if if ej,l   E   el,j   E then  2    2 + 8 end if if ek,l   E   el,k   E then i,j (M ( 2))   V CP 4,1 i,j (M ( 2)) + 1 i,j (M ( 1))   V CP 4,1 i,j (M (0))   V CP 4,1 i,j (M ( 1)) + |V |   2     i,j (M (0)) + |V |   2     i,j (M (16))   V CP 4,1 i,j (M (0))   V CP 4,1 i,j (M (16)) +  G   (  +  ) i,j (M (0))+ G ( + ( )) (2|V | )



 s t Figure 4: A depiction of the sets considered within Algorithm 3.
can be implemented as a constant-time operation equivalent to retrieving the value of a variable, so the asymptotic cost of populating the VCP vector is una ected.
Excepting the additional costs of writing output and of allocating and deal-locating the storage necessary to hold the additional multi-relational structural elements, which is inexpensively proportional to 2r, the computational complexity of the multi-relational extension is no greater than for single-relational networks.
First, we illustrate how VCP can serve as a powerful link analysis and modeling tool.
Then we perform a standard comparison of the link prediction e cacy of VCP and a selection of other methods.
Timing results are rarely provided in link prediction work despite vast di erences in the running time and feasibility of methods.
For this reason and because we believe many might suspect that a completely theoretically aligned implementation of VCP is computationally unachievable, we also provide comparative timing results.
We present results for several di erent data sets to demonstrate the performance of the techniques under comparison for di erent families of networks.
Though all of these data sets contain information with which to generate edge weights, we are interested in providing purely structural comparison here, so all quantitative results are presented based on networks constructed without edge weights.
calls is a stream of 262 million cellular phone calls from a major cellular phone service provider.
We construct directed networks from the calls by creating a node vi for each caller and a directed link ei,j from vi to vj if and only if vi calls vj.
sms is a stream of 84 million text messages from the same source as calls and constructed in the same manner.
These two data sets are not publicly available.
condmat-collab is a stream of 19,464 multi-agent events representing condensed matter physics collaborations from
 collaborations by creating a node for each author in the event and an undirected link connecting each pair of authors.
For all experiments involving condmat, we use the years 1995 to 1999 for constructing training data and the year 2000 for testing.
dblp-cite is a citation network based on the DBLP computer science bibliography.
Each researcher is a node vi and directed networks are formed by viewing a citation by researcher vi of work by researcher vj as a directed link ei,j.
The dblp-collab network uses the same raw data, but links are based on co-authorship collaborations.
An undirected all available longitudinal data.
C represents average clustering coe cient and ra represents assortativity coe cient.
Name calls condmat-collab dblp-cite dblp-collab disease-g disease-p hepth-cite hepth-collab huddle patents-collab sms Directed Vertices














 Edges






















 ra

 -0.046
 -0.310 -0.406

 -0.211

 link exists between vi and vj if both are an author on the same paper.
disease-g is a network in which nodes represent diseases and the links between diseases represent the co-occurrence of particular genotypic characteristics.
Links are undirected.
This network is not longitudinal, but  nding unobserved links is an important task, so we have no choice but to estimate performance by randomly removing links to construct test sets.
disease-p is from the same source as disease-g.
The di erence is that the links in disease-p represent the co-occurrence of phenotypic characteristics.
Predictions of common expressions between diseases are uninteresting since expressions are either observed between diseases or they are not, so practically speaking the value of phenotypic predictions is negligible.
Nonetheless, holding out phenotypic links and subsequently predicting their presence is equally instructive for the purposes of predictor evaluation.
hepth-cite and hepth-collab are formed in exactly the same way as dblp-cite and dblp-collab respectively.
The raw data for these networks is a set of publications in theoretical high-energy physics.
In particular, we used a data set post-processed by the Knowledge Discovery Lab at the University of Massachusetts for use in [16] rather than the original 2003 KDD Cup competition data set.
This form of the data set o ers advantages in data quality and entity consolidation and disambiguation.
The huddle data set from [20] is transaction data gathered at a convenience store on the University of Notre Dame campus.
The data was collected from June 2004 to February 2007.
Products are represented by nodes, and products purchased together in the same transaction are represented by undirected links.
The patents-collab data set is constructed from the data at the National Bureau of Economic Research.
Nodes represent authors of patents and undirected links are formed between authors who work together on the same patent.
To run our experiments, we integrated VCP with the LP-made link prediction software [14].
LPmade uses a GNU make architecture to automate the steps necessary to perform supervised link prediction.
This integration will allow those interested in VCP for link prediction and other purposes to test it on their networks easily.
We compare link prediction output against representatives from di erent predictor families established as strong by prevailing literature [13].
The unsupervised selections include the Adamic/Adar common neighbors predictor [1], the Katz path-based predictor [11], and the preferential attachment model [2, 18].
We also compare against the HPLP supervised link prediction framework contributed by [15] including the PropFlow feature.
HPLP combines simple topological information such as node degree and common link predictors into a bagged random forests classi cation framework with undersampling, a framework that the authors showed works well.
When performing classi cation using VCPs, we opted for the bagged [3] random subspaces [9] implementation from WEKA 3.5 [22].
This classi cation scheme o ers signi -cantly lower peak memory requirements than random forests while simultaneously providing the potential to handle feature redundancy [9].
We considered presenting results with HPLP also using random subspaces, but we determined that random subspaces produced decreased or comparable performance to the original reference implementation, so we present HPLP results unmodi ed using random forests [4].
We used the default values from HPLP of 10 bags of 10 random forest trees, 10 bags of 10 random subspaces for VCP classi ers, and training set undersampling to 25% positive class prevalence in training.
We did not change the size or distribution of the testing data.
For undirected networks, we resolve f (vs, vt) 6= f (vt, vs), by computing the arithmetic mean to serve as the  nal prediction output.
By default, LPmade includes features that consider edge weights such as the sum of incoming and outgoing link weights, and PropFlow inherently considers edge weights.
We are interested in the comparative prediction performance of the link structure alone, so we ran all predictors on the networks disregarding edge weights.
There are many di erent ways to assign edge weights to all the networks here, and the particular choice of edge weight and the precise decision about how to incorporate it into the VCPs would distract from the study.
Computing and evaluating predictions for all possible links on large, sparse networks with any prediction method is in-feasible for multiple computational reasons including time and storage capacity.
Link prediction within a two-hop geodesic distance provides much greater baseline precision in many networks [15, 21], so e ectively predicting links within this set o ers a strong indicator of reasonable deployment performance.
For all compared prediction methods, we sus lowly ranked links as output from Adamic/Adar on the sms network.
Address Element Distance







 s s s s s s s s t t t t t t t t







 restricted the prediction task by distance and only considered performance comparisons for potential links spanning two hops within the training data due to their higher prior probability of formation and computational feasibility.
Reciprocity is an important consideration for link formation in directed networks, so when performing undirected VCP computations on directed networks, we deviate slightly from the de nitions above to consider existing reciprocal links as a di erent relation type and accordingly double the width of the VCP feature space to include elements with and without the reciprocal link.
VCPs can assist with a variety of functions regarding link analysis, and post hoc analysis of link prediction output is an interesting example.
We start with the performance of the Adamic/Adar predictor in the sms network.
As we show in Table 5, it achieves AUROC performance of 0.642 and AUPR performance of 0.009410.
It may be helpful to us as modelers to understand better why Adamic/Adar fails.
We can do this by looking at other simple characteristics of the graph such as degree, centrality measures, or clustering coe cient, but VCPs o er a  ne-grained and informative view of links as they are embedded in the broader topology.
We select the Adamic/Adar predictor and  rst extract the positives from the top 10 million predictions and place them in one set.
We place all remaining positives in a second set.
For the positives in each of these sets, we can very quickly compute the VCPs of our choice.
For simplicity in the demonstration, we choose undirected VCP3,1.
Since sms is a directed network, we extend VCP3,1 to include reciprocal edges between vi and vj if they exist.
This procedure provides two multi-column distributions of corresponding columns.
One logical  rst step is to compute the distributional divergences of these columns.
The distributions are highly skewed, so we use Hellinger distance [10], a non-parametric measure of divergence ranging from 0 to  2.
The distances are shown in Table 4.
We select the most divergent element, the  fth, and examine the distribution of highly ranked and lowly ranked s k n
 i f o r e b m u







 High-ranked Predictions Low-ranked Predictions



 Structure Membership Figure 5: Distributional comparison of extended VCP3,1(5) membership for highly ranked and lowly ranked Adamic/Adar prediction outputs.
Adamic/Adar outputs more closely in Figure 5.
The  fth element is one in which a reciprocal link precedes the target link in the prediction.
The distributions indicate that highly ranked predictions in Adamic/Adar tend to have more connected source vertices than lowly ranked predictions.
Since having many neighbors in common tends to follow from simply having many neighbors, this is not surprising, but the greater dissimilarities of elements 1, 5, and 7 and lesser dissimilarities of 6 and 2 suggest that the connectedness of the link initiator may be more signi cant than that of the receiver.
Adamic/Adar as a model fails to su ciently separate links containing low-degree source vertices in this network.
In this particular case, we could have obtained the same information by examining the degree distributions of the two sets, but 4-vertex VCPs o er much more distinctive structural information with their greater complexity.
This is only one of many ways to perform post hoc link prediction analysis that focuses on the causes of type 2 error in prediction output.
Similar analysis could be applied to analyze type 1 error in an attempt to increase precision.
Many more powerful and imaginative variations on these techniques apply to link analysis and clustering in general.
The area under the receiver operating characteristic curve (AUROC) can be deceptive in scenarios with extreme imbalance [8] and area under the precision-recall curve (AUPR) exhibits higher sensitivity in the same scenarios [7].
We will provide results for those interested in traditional AUROC, but we will also present AUPR results and will mainly restrict our analysis to those results.
Table 5 shows the comparative AUROC and AUPR performance of Adamic/Adar, Katz, preferential attachment, HPLP, and VCPs in link prediction for potential links spanning a geodesic distance of two hops.
In general, we expect the information content of VCPs to increase in the left-to-right order presented in the table.
Depending on the signi cance of directedness in the network, the expectation of performance from VCP 3D and VCP 4U may change.
We point the reader to calls, dblp-cite, dblp-collab, disease-g, disease-p, hepth-cite, huddle, patents-collab, and sms as conformant examples.
We sus-condmat dblp-cite dblp-collab disease-g disease-p hepth-cite hepth-collab huddle patents-collab sms











 Katz






















 --









































------------calls condmat dblp-cite dblp-collab disease-g disease-p hepth-cite hepth-collab huddle patents-collab sms











 Katz










 (a) AUROC























 (b) AUPR











 ----















---

-
---
---
Table 5: Comparative performance for Adamic/Adar (AA), Katz, preferential attachment (PA), HPLP, and VCP.
For VCP, U indicates that directionality is ignored and D indicates that it is considered.
t e a
 e v i t i s o
 e u r
 i i n o s c e r











 Adamic/Adar
 VCP4Undirected




 False Positive Rate Adamic/Adar
 VCP4Undirected t e a
 e v i t i s o
 e u r
 i i n o s c e r











 t e a
 e v i t i s o
 e u r







 Adamic/Adar
 VCP4Undirected




 False Positive Rate (a) AUROC Adamic/Adar
 VCP4Undirected i i n o s c e r




 t e a
 e v i t i s o
 e u r
 Adamic/Adar
 VCP4Undirected




 False Positive Rate Adamic/Adar
 VCP4Undirected i i n o s c e r











 Adamic/Adar
 VCP4Undirected




 False Positive Rate Adamic/Adar
 VCP4Undirected























 Recall (i) calls Recall (ii) hepth-cite Recall (iii) huddle Recall (iv) sms (b) AUPR Figure 6: ROC and precision-recall curves for selected networks.
s d n o c e s ( e m
 i Features Training Predicting








 ) s d n o c e s ( e m
 i Features Training Predicting






 ) s d n o c e s ( e m
 i Features Training Predicting 1.8e+06 1.6e+06 1.4e+06 1.2e+06 1e+06







 a t z















 Task (a) dblp-collab


 a t z















 Task (b) disease-g


 a t z

























 Task (c) sms Figure 7: Timing analysis for three di erent networks.
Network size information is available in Table 3.
pect that the exceptions indicate cases in which the classi- cation algorithm was either over tting the training set or failed to create a su ciently optimized model in the high-dimensional space.
In 7 of the 11 networks, VCP classi cation o ers superior AUPR performance.
In a slightly di erent selection of
 of the cases in which VCP o ers the best performance, the di erences are quite wide.
In the sms network it o ers an AUPR that is 2.3 times as high as the best competitor.
In the condmat network, it o ers AUPR 1.53 times the nearest competitor.
In two of the networks in which VCP classi cation does not provide the best performance, HPLP does.
As an interesting side note, when weights are removed as they were to obtain these results, HPLP does not always outperform the unsupervised predictors.
Figure 6 shows a closer look at the performance di er-ences.
The black dashed line represents the baseline performance of a random predictor.
Across all the selected networks, VCP maintains high precision longer at increasing values of recall.
This is especially important in link prediction where high precisions are so di cult to achieve.
Despite the strong and competitive performance that the VCP method of supervised prediction exhibits, it is not our intent to present the most e ective possible classi cation scheme.
Our experiences with random forests, random sub-spaces, and other classi cation techniques suggest that the potential for improvement through feature selection and alternative classi cation algorithms is high.
Another option for potential improvement is to concatenate VCP3,r and VCP4,r into a single feature vector.
VCPs contain much information, and the task is simply to determine how best to leverage it to achieve whatever goals are desired.
We used two di erent types of machines for timing.
All feature computation and VCP generation was performed serially on a quad-core Opteron 2218 running at 2.6 GHz with
 runs required more than 4 GB of memory with the speci- ed training set undersampling and algorithm parameters, so all WEKA classi cation was performed on a dual quad-core Xeon E5620 running at 2.4 GHz with 12 MB cache and
 mentation dependent, and though the implementations of predictors, feature computations, and VCPs are not na ve, we cannot claim that they are fully optimized.
Figure 7 shows the results.
Adamic/Adar, O (cid:16) |E| |V |(cid:17) per prediction, and preferential attachment, O(1) per prediction, perform very few operations to generate their output.
They are so inexpensive to compute that they are invisible within the same scale as Katz and the supervised prediction methods for all three networks in Figure 7.
We note that for all three networks the total time to perform supervised link prediction with VCPs is often less than that necessary for HPLP.
Most of this is due to the expense of the Katz feature, which involves  nding paths up to length 5 with the aid of memoization in our implementation.
Based on these results, Adamic/Adar is clearly an e ective and inexpensive option for a wide variety of networks, but VCP o ers signi cant potential for performance enhancement.
Perhaps the most interesting conclusion lies in the inconsistency of the results in terms of the breakdown of time requirements for di erent components.
Timing is related to the interplay between the speci c algorithms involved, the local densities or global density of the graph, and the raw size of the graph in terms of the number of vertices and edges.
Whether the bulk of time is consumed in feature generation, VCP computation, training, or testing varies greatly across networks as does the total time for any particular method.
The VCP implementations provided are slightly limited in e ciency because of the graph implementation to which they are tied in LPmade.
With a more amenable supporting graph implementation and slight changes to the selection of data structures, we expect that it would be possible to decrease the running time of the VCP vector computation itself by a factor of at least 2.
Nonetheless, the computation of even VCP4,2 is competitive in terms of running time with much simpler and less e ective path-based prediction methods.
The results in Figure 7 show that VCP is more e cient from a cost-performance standpoint than classi cation based on computing and combining simpler unsupervised predic-the extended times for the sms network include computing VCPs for tens of millions of vertex pairs.
The extended feature vector of VCP4,2 greatly increases training time, but feature selection or the application of di erent training algorithms or parameters could reduce this greatly, and training is parallelizable across bags.
VCP is a new method of link analysis with solid theoretical roots.
We presented evidence of its utility in some applications here, but there are many possible applications.
It is useful for post hoc analysis of classi cation output, comparative analysis of network link structure, and it competes effectively with an existing recently published method, HPLP, often outperforming it by wide margins.
In well-established networks with past observational data, VCP can serve as a sensitive change detection mechanism for tracking the evolving link formation process.
In addition to link prediction and link analysis for the purpose of network growth modeling, VCP can be used for link or vertex pair clustering.
Its ability to handle multiple relations naturally extends its utility into many domains and o ers an alternative to the practice of combining or discarding edge types or edge directionality.
The VCP computations for the directed and undirected variants of both VCP3,1 and VCP4,1 are integrated into the LPmade link prediction framework.
The LPmade branch containing the software is available at http://mloss.org/ software/view/307/.
Most of the data sets are publicly available elsewhere, but we have also published all public data sets to http://nd.edu/~rlichten/vcp so that our experiments can be repeated with the same longitudinal thresholds and thus the same network saturation.
We have provided code to perform VCP subgraph-to-element mappings at the same location.
Research was sponsored in part by the Army Research Laboratory and was accomplished under Cooperative Agreement Number W911NF-09-2-0053 and in part by the National Science Foundation (NSF) under Grant BCS-0826958.
The views and conclusions contained in this document are those of the authors and should not be interpreted as representing the o cial policies, either expressed or implied, of the Army Research Laboratory or the U.S. Government.
The U.S. Government is authorized to reproduce and distribute reprints for Government purposes notwithstanding any copyright notation hereon.
