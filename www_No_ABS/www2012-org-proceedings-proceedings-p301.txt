Passwords are one of the most common forms of authentication that users encounter, particularly on the web.
While there is a large literature of advice on how to choose passwords (e.g.
[11]), there are many reasons not to follow it.
It has even been argued that in general, the cost of following such advice is greater than the cost of losing the information being protected [7].
Consequently, rather than a theoretically desirable uniform distribution, we see that some passwords are signi cantly more common than others.
In this paper we investigate frequency distributions that passwords are chosen with.
We consider abstract issues, such as how to model the distribution and practical problems, such as the password cracking and how to improve users  choices.
Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
One interesting candidate to model this distribution is Zipf s Law.
Zipf s Law is a probability distribution where the frequency of an event is inversely proportional to its rank on the frequency table.
Here the rank of the most common event is 1, the rank of the second most common is 2, and so on.
Zipf s Law has been observed in the frequencies with which words are used in natural language.
While there are a number of substantial di erences between the choice of passwords and the use of words in natural language, Zipf s Law has the potential to capture the skewed nature of the password distribution.
We expect that rather than uniformly choosing from a list of non-dictionary words, the average user is likely to choose a password which they can easily remember (their name, city, favourite team, .
.
. )
which leads to certain passwords being used more frequently than others.
To study this, we use lists of users and passwords from hotmail.com,  irtlife.de, computerbits.ie and rockyou.com, which are described in Section 2.
In each case, the list of usernames and passwords were made public after a security incident.
Our Zipf model has frequencies proportional to r s, where r is the rank of a password and s is a parameter close to one.
In Section 3 we analyse our datasets and  t a value for s. We will see that, while a Zipf distribution does not fully describe our data, it provides a reasonable model, particularly of the long tail of password choices.
To our knowledge, this is the  rst paper to study if Zipf s Law applies to the choice of passwords.
Seeing Zipf s Law, or any other distribution that is indeed skewed in favour of a subset of passwords, has implications for security.
If the right distribution of passwords can be identi ed, the cost of guessing a password can be reduced.
One expects that, say, the demographic of users of a site could be used to target an attack; a website with a .ie domain is more likely to have Irish themed passwords than a site with a .fr domain.
A heavy-tailed distribution of password choices could be exploited by algorithm designers to more e ciently deal with passwords (e.g.
algorithms in [15]).
To establish if models such as a Zipf distribution can provide useful predictions, in Section 4 we use metrics such as guesswork [13] and Shannon entropy.
We calculate these metrics for both the  tted model and the actual data, and compare the results.
We  nd that the actual metrics are within a factor of two of those predicted by the Zipf distribution, and that the Zipf model usually provides better predictions than a simple uniform model.
In Section 5 we study a more important question: how much does one set of password choices tells us about general password choices.
We compare the similarity of our data sets #users #pass hotmail  irtlife computerbits rockyou







 #pass #users




 using guessing as a metric.
We show that by using common passwords from one list, an attacker can obtain a speed up when guessing passwords from another list, in some cases an order of magnitude faster than techniques assessed in [4].
Finally, in Section 6, we introduce a defensive technique for making the passwords in use more uniform.
When a user sets or resets a password, the technique probabilistically asks them to choose a di erent password.
This technique uses the Metropolis-Hastings algorithm [6, 12] and produces a more uniform distribution of used password by stochastically limiting their frequency, rather than imposing hard limits as discussed in [15].
We collected sets of passwords belonging to sites which were compromised and the lists of passwords subsequently publicly leaked.
Since the sets were gathered by di er-ent methods (e.g.
key-logging, network sni ng or database dumps) the lists may only contain a random, and possibly biased, sample of users.
Our lists are from hotmail.com in 2009,  irtlife.de in 2006, computerbits.ie in 2009 and rock you.com in 2009.
Some of the lists also give multiple passwords for a small number of users.
In this case, we cleaned up the sets by taking the user s password as the last entry seen for that user, which would hopefully correspond to a user initially typing the wrong password and then typing the correct one, or in the case that the password was changed, the most recent password.
We also omitted any user with a whitespace password.
After the data was cleaned up, we produced a table ranking passwords in order of decreasing frequency of use by users.
Table 1 shows the number of users and the number of distinct passwords for each set of data.
As is obvious from the table, for smaller lists there are relatively more unique passwords.
Table 2 summarises the top 10 passwords in each list.
We see that passwords such as 123456 and password are very common.
The most common password,  123456  accounts for 0.7% of the total passwords in the hotmail data, 3.3% in the  irtlife list and 2.0% in the rockyou list;  password  accounts for 1.2% of the total passwords of the computerbits list.
This indicates that the password distribution is skewed in favour of some common passwords.
The demographic of the users from each list is evident in the  rst 10 passwords of the lists with each ccTLD.
Note that the hotmail.com data is believed to have been collected with phishing targeted at the Latino community.
The  irtlife list shows clear signs of users speaking German and Turkish, and the computerbits list contains place names of Irish interest.
If we look at the data from computerbits and rockyou we see that the name of the website appears in the top ten of each list.
It seems likely that this method for choosing a password will also be used on other sites.
hotmail
  irtlife
 c-bits
 rockyou
















 s raw s binned  m raw m binned 1 + 1/s binned
 squares  ts to frequency and nk vs. k graphs.
Knowing the demographic of the users of a site, one could build a dictionary covering the most likely common passwords in use.
This implies that users, if they are concerned about their accounts being hacked, should use less common passwords.
Advice such as changing some of the characters to uppercase or writing the word in  leet speak , aims to move the password out of the most-common list.
These results also con rms something that system administrators have observed empirically, that including a localised dictionary when checking password hashes with crack will usually increase the number of recovered passwords.
In this section we look at how passwords are distributed in our lists, and see how well these distributions match a Zipf model.
We will be interested in the frequency fi with which we see the ith most popular password.
Where passwords are seen equal numbers of times, we break the tie randomly.
It turns out to be not that helpful to plot the rank vs.
frequency of our data on a linear scale.
There are a small number of passwords with a high frequency, and many passwords with a frequency of 1 or 2, which makes the graphs illegible.
Instead, we plot the frequency versus rank on a log-log scale in Figure 1.
These graphs certainly show evidence of heavy-tailed behaviour, with the frequency dropping more slowly than exponentially.
A Zipf distribution would appear as a straight line on a log-log plot, where the parameter s is the negative of the slope.
If we  t a least-squares line to this data, as shown in Figure 1, we get a slope which is too shallow because a large fraction of the points have frequency 1 or 2, which biases the slope towards 0.
To account for this, we follow the method in [1] and bin the data logarithmically, as shown in Figure 2.
Here, we sum the frequency of all ranks between 2n and
 our data, and that the line appears a relatively good  t.
We use this binned slope as a basis for modelling our data with a Zipf distribution.
An alternate way to view the data is to look at the number of passwords nk that are each used by exactly k users.
We plot this in Figure 3 on a log-log scale.
As explained in [1], if the data is Zipf-distributed, we expect this graph to also be a straight line with slope  (1 + 1/s).
As we can see, we also need to bin this data before  tting a line.
If we do this, we see a line is a relatively good  t, with the largest discrepancy appearing for computerbits, the smallest list.
The resulting slopes are summarised in Table 3.
We can also build a maximum liklihood estimator (MLE)


 y c n e u q e r




 Rank

 (a) hotmail least squares s=0.15


 y c n e u q e r




 Rank

 (c) computerbits y c n e u q e r
 y c n e u q e r







 1e+06






 least squares s=0.64




 Rank (b)  irtlife least squares s=0.51

 100 1000 10000 100000 1e+06 1e+07 1e+08 Rank (d) rockyou
 least squares s=0.44


 y c n e u q e r






 Rank (binned) (a) hotmail least squares s=0.45


 y c n e u q e r
 y c n e u q e r
 y c n e u q e r






 Rank (binned) (c) computerbits least squares s=0.69









 Rank (binned)

 (b)  irtlife 1e+06






 least squares s=0.78

 100 1000 10000 100000 1e+06 1e+07 1e+08 Rank (binned) (d) rockyou










 hotmail



 tequiero
 alejandro sebastian estrella
 #users









  irtlife
  cken
 hallo
 schatz
 daniel
 askim #users computerbits #users

 password

 computerbits




 dublin

 letmein

 qwerty

 ireland



 liverpool

 171 munster rockyou


 password iloveyou princess
 rockyou
 abc123 #users













 k n







 k n



 least squares m=-1.72






 k n






 least squares m=-2.46
 k (a) hotmail least squares m=-2.56 k n 1e+08 1e+07 1e+06








 k (b)  irtlife least squares m=-1.37



 10000 100000 1e+06 k (d) rockyou
 k
 (c) computerbits
 for a truncated Zipf distribution, which assigns probability proportional to r s to passwords with rank r = 1 .
.
.
N .
The MLE for N is just the number of passwords with nonzero frequency and the MLE for s can be constructed using standard techniques as described in [3].
This has the advantage of providing both estimates of the standard error in s and a p-value1.
The results are shown in Table 4.
We see that the estimates for s provided by the MLE for the  irtlife and rockyou data are quite close to those provided by least-squares estimate.
The MLE estimates for s for the smaller data sets are between the binned values (around 0.45) and the raw values (around 0.15).
We see that the p-values indicate that the hotmail, computerbits and rockyou data are unlikely to actually be Zipf distributed.
However, for the hotmail and computerbits data the largest
 with the estimated parameters, applying the same sorting and estimation.
We then calculate the fraction which exceed the Anderson-Darling statistic of our actual data.
s
 s stderr p-value hotmail
  irtlife
 c-bits
 rockyou



 < 0.01
 < 0.01
 discrepancy between the Zipf s Law and the data is for the  rst few passwords, indicating that the tail of the data could pass for Zipf with a higher p-value.
To summarise, we have seen that the password frequency data has heavy-tailed characteristics by plotting it on a log-log plot.
Both least-squares and maximum-liklihood estimates indicate that if Zipf distributed, the s parameter is small.
However, p-values indicate the data is unlikely to be drawn exactly from Zipf s Law.
In this section we will look at a number of statistics relevant to passwords that can be derived from the distribution of how passwords are chosen.
We will look at these statistics when calculated directly from our lists, and compare the results when they are calculated using two models: Uniform and Zipf.
For the real lists, we calculate our statistics assuming the probability of the password of rank i appearing is fi/N , where fi is the frequency with which we observed that password and N is the total number of passwords observed.
The  rst model assumes password choices are uniform over all passwords seen, i.e., if the number of passwords is N then a password is chosen with probability 1/N .
The second model assumes that password choices are distributed with a Zipf distribution, i.e., the probability of password with rank i being used is Pi = Ki s, where s is the parameter found in Section 3 and K is a normalising constant.
Now let us describe the statistics of interest.
The  rst statistic is the guesswork, which is the mean number of guesses needed to correctly guess the password [13], when the ranked list of passwords is known, but the exact password is not.
Guesswork is given by, G = i=1 iPi, where Pi is the probability of the password of rank i.
This statistic places considerable emphasis on the tail of the distribution, and can be sensitive to relatively small gaps between the model and the data.
Another strategy for guessing passwords, given the distribution, is to try the common passwords, but to give up when some fraction   of the distribution has been covered.
The Pr  mean number of guesses associated with this is known as the  guesswork, G  [13].
Its value is given by, G  = i=1 iPi, where r  is the rank of the password when the cumulative probability of being successful is at least  .
We will work with   = 0.85, so that we cover most of the distribution, but avoid the tail.
The Shannon Entropy, H =  P Pi log2 Pi, is a common measure of the number of bits of uncertainty associated with a random variable.
While Shannon Entropy has been used as a measure of security of password and key distributions, it does not relate directly to how easy it is to guess a password [10, 8].
R enyi entropy, which is a generalisation of Shannon Pi)2.
It is asymptoti-entropy, is given by R = log2( cally related to the guessability of a password [2, 9].
The min-Entropy is also used as a conservative measure of pass-word/key security [5].
Figure 4 compares the guesswork statistics for the uniform model, the real data and the Zipf model.
The three bars on the left show the guesswork and the three on the right show the 0.85-guesswork.
As expected, the guesswork estimates for the uniform model overestimate the required number of guesses.
A relatively small percentage of the total number of passwords in the hotmail.com and computerbits.ie lists are shared.
This seems to be re ected in the predictions for guesswork, where the uniform distribution provides a relatively good prediction for hotmail and computerbits, while the Zipf model underestimates.
For  irtlife and rockyou, shared passwords make up a larger percentage of the total passwords, and the guesswork is far lower than the uniform guesswork, but the Zipf model provides better predictions, though it still underestimates.
Figure 5 shows the Entropy values for the actual data and models.
Shannon Entropy is shown on the left, min-Entropy in the middle and R enyi Entropy on the right.
The Uniform model, again as expected, tends to overestimate the Entropy.
However, for the R enyi Entropy both models and the data seem to give results that are close together.
The Zipf model seems to provide relatively good approximations in all cases.
While the popular passwords in our lists have things in common (e.g., the password 123456), they also show features speci c to the website or service.
In Section 3 we also saw that all lists have a number of relatively frequently used passwords followed by a long tail of uncommon passwords.
In this section, we would like to quantify how much in common there is between the passwords in these lists.
Pt Consider the problem of guessing the password of a randomly selected user from one of our lists.
If we guess the passwords in the order from most popular to least popular in that list, then after t guesses we will have guessed the passwords used by C(t) = i=1 fi users.
If we guess one password at each trial, guessing in this order recovers users  passwords as quickly as possible, and is in this sense optimal.
Figure 6 shows C(t) as a solid line for each of our datasets.
The right-hand axis is scaled to show C(t)/N , which we can interpret as the probability of successfully guessing in t guesses or the fraction of users whose passwords have been guessed.
For example, after 100 guesses using the hotmail data, we have recovered around 400 users  passwords, which is a 5% probability of success against a particular user.
Since we guess in the optimal order, other orderings recover fewer users and have a lower probability of success.
Pt If we do not know the optimal order in which to guess the passwords, we may instead guess them in the optimal order for another reference data set.
Suppose we have a password of rank i in the reference data set, and it has rank  (i) in the data set being guessed.
If we guess in the order given by the reference data set, after t guesses, we will have guessed the passwords of C(t|| ) = i=1 f (i) users, where we assume f (i) is zero if password i is not in the list we are guessing.
If the ordering of the passwords by popularity is the same for both lists, then this function will be C(t|| ) =C (t), otherwise C(t|| )   C(t).
Figure 6 shows C(t|| ) for each of our lists, when using each of the other lists as a reference.
Consider the situation after 1000 trial guesses.
The number of users whose passwords match one of these 1000 guesses, C(1000|| ), can be seen to vary by almost an order of magnitude, depending on the list used as a reference.
Thus, to guess passwords quickly, we would like a good reference list.
Observe that for any list, once we have made more than 10 100 guesses, the larger reference lists lead to more suc- cesses than smaller lists.
This suggests that beyond the most popular passwords, there may be a more general ordering of passwords that is more apparent from the larger data sets.
The top one million rockyou passwords cover close to 40% of users in the other lists.
In practice, the number of guesses that can be made depends on the details of the attack.
An attacker targeting a single online account from one IP, might  nd the account locked after a small number of guesses.
However, if the attacker is cycling through many users from a number of vantage points, the number of guesses could be considerably higher: the attempts may only be limited by the amount of CPU time available to the attacker.
We can apply this directly to a password cracking probe s s e u
 s e s s e u
 s t i
 s t i

































 Uniform model Guesswork Real data Guesswork Zipf model Guesswork Uniform model 0.85 Guesswork Real data 0.85 Guesswork Zipf model 0.85 Guesswork (b)  irtlife Uniform model Guesswork Real data Guesswork Zipf model Guesswork Uniform model 0.85 Guesswork Real data 0.85 Guesswork Zipf model 0.85 Guesswork Uniform model Guesswork Real data Guesswork Zipf model Guesswork Uniform model 0.85 Guesswork Real data 0.85 Guesswork Zipf model 0.85 Guesswork (a) hotmail Uniform model Guesswork Real data Guesswork Zipf model Guesswork Uniform model 0.85 Guesswork Real data 0.85 Guesswork Zipf model 0.85 Guesswork s e s s e u
 s e s s e u






 8e+06 7e+06 6e+06 5e+06 4e+06 3e+06 2e+06 1e+06
 (c) computerbits (d) rockyou
 Uniform model Entropy Real data Entropy Zipf model Entropy Uniform model Min Entropy Real data Min Entropy Zipf model Min Entropy Uniform model Renyi Real data Renyi Zipf model Renyi (b)  irtlife Uniform model Entropy Real data Entropy Zipf model Entropy Uniform model Min Entropy Real data Min Entropy Zipf model Min Entropy Uniform model Renyi Real data Renyi Zipf model Renyi Uniform model Entropy Real data Entropy Zipf model Entropy Uniform model Min Entropy Real data Min Entropy Zipf model Min Entropy Uniform model Renyi Real data Renyi Zipf model Renyi (a) hotmail Uniform model Entropy Real data Entropy Zipf model Entropy Uniform model Min Entropy Real data Min Entropy Zipf model Min Entropy Uniform model Renyi Real data Renyi Zipf model Renyi s t i
 s t i















 (c) computerbits (d) rockyou
 guesses from rockyou guesses from flirtlife guesses from computerbits
 optimal guessing guesses from rockyou guesses from hotmail guesses from computerbits
 1e+00 1e+01 1e+02 1e+03 1e+04 1e+05 1e+06 1e+07 1e+08 1e+00 1e+01 1e+02 1e+03 1e+04 1e+05 1e+06 1e+07 1e+08 guesses (a) hotmail guesses (b)  irtlife 1e+03 1e+02 s r e s u 1e+01 1e+00 1e+03 1e+02 s r e s u 1e+01 1e+00 1e+00 1e+05 1e-01 1e-02 1e-03 s r e s u f o n o i t c a r f / y t i l i b a b o r p s r e s u 1e+04 1e+03 1e+02 1e+01 1e+00 1e+00 1e-01 1e-02 1e-03 s r e s u f o n o i t c a r f / y t i l i b a b o r p 1e+07 1e+06 1e+05 1e+04 1e+03 1e+02 1e+01 s r e s u 1e+00 1e+00 1e-01 1e-02 1e-03 1e-04 s r e s u f o n o i t c a r f / y t i l i b a b o r p 1e-05 1e+00 1e-01 1e-02 1e-03 1e-04 1e-05 1e-06 1e-07 s r e s u f o n o i t c a r f / y t i l i b a b o r p optimal guessing guesses from flirtlife guesses from hotmail guesses from computerbits
 optimal guessing guesses from rockyou guesses from flirtlife guesses from hotmail
 1e+00 1e+01 1e+02 1e+03 1e+04 1e+05 1e+06 1e+07 1e+08 1e+00 1e+01 1e+02 1e+03 1e+04 1e+05 1e+06 1e+07 1e+08 guesses (c) computerbits guesses (d) rockyou
 1e+05 1e+04 s r e s u 1e+03 1e+02 1e+01 1e+00 1e+00 1e-01 1e-02 1e-03 1e-04 1e-05 s r e s u f o n o i t c a r f / y t i l i b a b o r p guesses from rockyou guesses from flirtlife guesses from hotmail guesses from computerbits guesses from dictionary
 1e+00 1e+01 1e+02 1e+03 1e+04 1e+05 1e+06 1e+07 1e+08 guesses
 ing the password ordering from di erent distribution on the Gawker.com password hashes.
lem.
In December 2010, the password database from Gawker.com was leaked.
This database did not contain plaintext passwords, but instead contained hashes of passwords using the well-known DES and Blow sh password hashing schemes.
We can use the words in our list as guesses in an o line cracking attack against the Gawker hashes.
The Gawker dataset contained 748,090 users potentially valid (i.e. 13 character) DES hashes.
The hashes use 3844 di erent salts.
A simple perl script can attempt password guesses at a rate of approximately 80,000 trials per hour per core on a modern CPU.
As the DES hash truncates passwords to 8 characters, we truncate long passwords and reaggregate our previous lists.
The number of users whose passwords were cracked after t trials is shown in Figure 7.
Again, the large lists provide the fastest recovery of passwords, and recovers 40% of users in less than one million trials.
Even our smaller lists do well, recovering the passwords of more than 10,000 users in around 1,000 trials (less than one minute of CPU time).
For comparison, in Figure 7 we show the results of using a dictionary in lexical order as list of guesses.
The dictionary is based on the contents of /usr/share/dict/ on Mac OS X, truncated to 8 characters and sorted using the Unix sort command.
This results in a return on e ort that is substantially lower than with ranked password lists.
Up to now, we have measured the e ectiveness of guessing passwords by counting the number of distinct users whose passwords would have been correctly guessed after t guesses.
An alternative metric counts the number of distinct passwords that have been correctly guessed after t guesses.
Note, we recover either zero or one password at each guess.
Figure 8 shows results for our main lists.
The optimal rate at which we can recover passwords is 1 per guess, so we plot the optimal line y = x.
We see that with about 500,000 5,000,0000 guesses we obtain about 40% of the pass words, except when guessing rockyou passwords, when the other lists simply do not have enough guesses to reach 40%.
Despite this, when guessing passwords from the rockyou dataset, the curves for the other lists stay close to the optimal line, showing that there is a good return for each guess.
Figure 9 shows the results for guessing the Gawker passwords, in terms of fraction of passwords recovered.
As not all hashes have been cracked and the hashes are salted, we do not know the total number of distinct passwords.
However, we can upper bound the number by assuming that all uncracked passwords are unique.
guesses from rockyou guesses from flirtlife guesses from computerbits
 1e+00 1e+01 1e+02 1e+03 1e+04 1e+05 1e+06 1e+07 1e+08 1e+00 1e+01 1e+02 1e+03 1e+04 1e+05 1e+06 1e+07 1e+08 guesses (a) hotmail guesses (b)  irtlife 1e+03 1e+02 s d r o w s s a p 1e+01 1e+00 1e+03 1e+02 1e+01 s d r o w s s a p 1e+00 1e+00 1e-01 1e-02 1e-03 s d r o w s s a p f o n o i t c a r f / y t i l i b a b o r p 1e+04 1e+03 1e+02 1e+01 s d r o w s s a p 1e+00 1e+00 1e-01 1e-02 1e-03 s d r o w s s a p f o n o i t c a r f / y t i l i b a b o r p 1e+07 1e+06 1e+05 1e+04 1e+03 1e+02 1e+01 s d r o w s s a p 1e+00 1e+00 1e-01 1e-02 1e-03 1e-04 optimal guessing guesses from rockyou guesses from hotmail guesses from computerbits
 1e+00 1e-01 1e-02 1e-03 1e-04 1e-05 1e-06 1e-07 optimal guessing guesses from flirtlife guesses from hotmail guesses from computerbits
 s d r o w s s a p f o n o i t c a r f / y t i l i b a b o r p s d r o w s s a p f o n o i t c a r f / y t i l i b a b o r p optimal guessing guesses from rockyou guesses from flirtlife guesses from hotmail
 1e+00 1e+01 1e+02 1e+03 1e+04 1e+05 1e+06 1e+07 1e+08 1e+00 1e+01 1e+02 1e+03 1e+04 1e+05 1e+06 1e+07 1e+08 guesses (c) computerbits guesses (d) rockyou
 s d r o w s s a p 1e+05 1e+04 1e+03 1e+02 1e+01 1e+00 1e+00 1e+01 1e+02 1e+03 optimal guesses from rockyou guesses from flirtlife guesses from hotmail guesses from computerbits guesses from dictionary upper limit on 40% 1e+04 guesses 1e+05 1e+06 1e+07 1e+08
 First we note that using other password lists to guess still provides signi cantly better return than using a dictionary.
Indeed, the curves stay relatively close to the optimal line for guesses based on the rockyou data set for between 10 and 10,000 guesses, indicating a success rate of almost 100%.
After using all 14 million passwords in this list, we have cracked close to 40% of the passwords.
The curve for dictionary words stays a signi cant distance from the optimal line, suggesting less than 10% of dictionary words are actually used as passwords in the Gawker data set.
In [4], the authors consider various techniques for generating candidate passwords for guessing/cracking.
These techniques include dictionary attacks, mangled dictionaries and Markov generators, which can be trained on sample passwords.
They assess these techniques using the fraction of passwords recovered in three data sets.
They show that in order to recover a substantial fraction of passwords, say 40%, the number of required guesses is over 100 million, un- less the candidate-password-generating technique is trained on a similar dataset.
Our results show that the use of a large set of passwords as a source of guesses seems to o er considerably better returns than these techniques, being able to recover 40% of passwords in a less than 10 million guesses.
Of course, once exhausted, a list provides no more candidate guesses, whereas the mangling and Markov techniques can theoretically yield unbounded candidate sets.
We have seen that people s choice of passwords is nonuniform, leading to some passwords appearing with a high frequency.
The previous section demonstrated one consequence of this: a relatively small number of words can have a high probability of matching a user s password.
To combat this, sites often ban dictionary words or common passwords (e.g.
the Twitter banned password list [16]), in an e ort to drive users away from more common passwords.
If password choices were uniform (over a large set of passwords) some attacks based on the existence of common passwords become ine ective.
With this in mind, a scheme was suggested in [15] which prevents users from choosing particular passwords when they become relatively too popular, to reduce the non-uniformity of the password distribution.
We consider an alternative way to address this problem, by treating users as biased random password generators.
There are well-known schemes that take the output from a random generator and manipulate it to achieve a di erent distribution.
For example, the Metropolis-Hastings scheme [6, 12] allows the generation of a desired distribution P (.)
by chain Q(., .
).
It has the property that the density of the desired distribution does not need to be known, as long as a function proportional to the density is known.
The basic Metropolis-Hastings scheme is as follows:

 with distribution Q(x(cid:2), xt).
  Q(xt,x(cid:2)) Q(x(cid:2),xt)
  
 P (x) go to step 4 (accept), otherwise return to step 2 (reject).
4. t   t + 1, xt   x(cid:2) .
where the terms of the sequence xt are the output.
Usually, the initial outputs are discarded, to wash out the initial choice of x0 and allow the sequence to approach its stationary behaviour.
This is sometimes referred to as burn in.
We can apply this scheme to produce a more uniform choice of passwords.
Our desired distribution P (.)
will be uniform over all passwords that users are willing to use, so P (x(cid:2) )/P (x) = 1.
Suppose that if a user is asked to choose a password that they choose it independently of previous choices with probability Q(.).
Though we do not know Q(.
), we make an online estimate of it, by tracking the frequency F (.)
with which users attempt to use particular passwords.
This suggests the following scheme that could be applied when users select a password as part of a password set/reset procedure:


 )] ).
If u   F (x) go to step 4 and then increment F (x(cid:2) (accept), otherwise return to step 2 (reject).
.
as password.
This scheme aims to generate a uniform distribution via users  choices using a Metropolis-Hastings scheme.
There are a few things to note.
First, by choosing x uniformly over all seen passwords, we aim to avoid the need for a burn-in period, because we begin with a choice drawn from the distribution we want.
Second, the password x is never actually used, only its frequency F (x), so we can use 0 for F (x) if the scheme has seen no previous passwords.
Finally, the scheme learns F (.)
online, so the more password choices it sees, the better we expect it will be at making choices uniform.
We implemented this scheme and tested it by choosing passwords from the rockyou dataset, where the probability a password was selected was proportional to its frequency in the dataset.
We generated passwords for 1,000,000 users, with the Metropolis-Hastings scheme and, for comparison, when users were free to choose any password or when there was a hard relative frequency limit on passwords.
The results are shown in Figure 10.
We see that with the Metropolis-Hastings scheme, the distribution is much more uniform, and the frequencies of the most common passwords have been reduced from over 1,000 to just over 10, a reduction of more than two orders of magnitude.
One concern with this scheme is that is may reject a user s choice of password many times, and frustrate the user.
However, over these trials, users are asked on average for 1.28 passwords First Choice Metropolis-Hastings Scheme Hard limit 1/1000000



 y c n e u q e r




 10000 100000 1e+06
 Rank
 frequency for users generated from rockyou dataset, with free choices, the Metropolis-Hastings scheme and a hard relative frequency limit (similar to [15]).
with a variance of 0.61 (compared to 1.36 and 0.72 respectively for a  xed relative frequency limit of 1/1, 000, 000).
We note that the Metropolis-Hastings scheme has some similarities to the scheme in [15].
Both schemes store frequency information about passwords and guide users  choices.
To avoid storing passwords in plain text, one could store the frequency of hashed passwords.
Our scheme, however, stores the frequency with which users choose a password rather than the frequency of passwords in use.
This has some advantages if the frequency table is stolen by an attacker, as even if the hashes can be cracked, frequent choices are not so commonly used because of the Metropolis-Hastings scheme.
Rather than using a simple frequency table, both these schemes can be implemented with count-min sketches.
This is an e cient data structure that stores estimates of frequencies.
As described in [15], there are advantages to storing the information in a sketch, particularly if the sketch is stolen by an attacker.
This is because it uses multiple hash functions with a smaller output space, leading to false-positives if an attacker tries to identify high-frequency passwords.
One di erence in these schemes is that the Metropolis-Hastings algorithm aims to make the whole distribution more uniform, rather than limit the frequency of the most popular passwords.
As we saw in Section 5 mid-ranked passwords, say from rank 10 1,000, are important for increasing the success rate when guessing a user s password; these guesses increase the success probability from a fraction of a percent up to a few percent.
By moderating the frequency of these passwords, we may reduce the e ectiveness of attacks that use both high and mid-ranked passwords.
We also note that while this scheme learns the password frequency distribution online, it could also be initialised using a known list of password frequencies.
While we chose to target a uniform distribution, this scheme could also be combined with a list of banned passwords (by setting the desired frequency P (x) to be zero) or implement a soft-ban on some passwords (by reducing P (x) for those passwords).
We have seen that while Zipf s law is not an exact match, it seems to provide a passable description of the frequencies with which passwords are chosen.
Estimates of the parameter s are considerably less than one.
While this might be interpreted as indicating a strongly heavy tailed behaviour, another interpretation is that as s   0 the distribution be-These observations may be of use to algorithm designers, for dimensioning data structures or even taking advantage of the relatively heavy-tailed nature of users  choices.
We also see that  tting a distribution provides relatively good approximations of the Shannon Entropy, guesswork and other statistics that are of interest when assessing a password distribution.
Using a uniform model, where all passwords are equally likely, provides reasonable approximations for the data sets with smaller s, but provides a poor estimate of min-Entropy.
We have seen that demography of the userbase choosing the passwords can be evident in the most popular passwords, and even the name of the website is a likely password.
Some sites, for example Twitter, have noticed this and implement banned password lists [16], which includes many of the more common passwords, including the name of the site.
This gives weight to the advice that site administrators checking the security using password cracking software should include custom dictionaries including locally used terms.
The Zipf distribution decays relatively slowly, so we expect there to be a large number of relatively commonly chosen passwords.
We investigated if these passwords vary signi -cantly from site to site.
We see that the lists of passwords from each site have quite a lot in common.
While they do not provide the optimal order for guessing, the larger lists provide good guidance about the ranking of passwords in other lists.
We ve demonstrated that this can provide a signi cant speedup in guessing or cracking passwords using moderate numbers of guesses, particularly over simple dictionary attack, but also over a range of the guess-generating techniques described in [4].
An attacker can gain a useful starting point for cracking passwords if they collect leaked passwords.
If a hashed password is exposed, the time for an attacker to hash, say, 20 million passwords is relatively small, even on a single CPU.
We note that this adds extra weight to the advice that reusing passwords between websites is a risk, even if there is no way for an attacker to identify which pairs of users are common to the websites.
This is because if just one site stores the password in plaintext format and that password is leaked, then it facilitates the subsequent cracking of that password on systems where the passwords are hashed.
Banning more commonly chosen passwords may result in a more even spread of password in use.
Interestingly, we saw that most English dictionary words are not necessarily common passwords: out of more than 220,000 dictionary words, less than 15,000 appeared as passwords in the Gawker data set.
We proposed a scheme based on the Metropolis-Hastings algorithm that aims to generate more uniform password choices, without having to know a list of common passwords in advance.
A basic implementation of this is relatively straight forward, and could be easily incorporated into a password management system or PAM module [14].
We have seen that a Zipf distribution is a relatively good match for the frequencies with which users choose passwords.
We have also seen that the passwords found in the lists that we have studied have relatively similar orderings.
Consequently, passwords from one list provide good candidates when guessing or cracking passwords from another list.
Finally, we presented a scheme that can guide users to distribute their passwords more uniformly.
Acknowledgment: We thank Ken Du y and Niall Murphy for thought-provoking comments and Dermot Frost for an o er of CPU cycles.
The authors were supported by NUIM SPUR, SFI 07/SK/I1216a and 08/SRC/I1403.
