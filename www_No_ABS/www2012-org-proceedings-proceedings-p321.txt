It is well known that password authentication is vulnerable to malware on the client s computer and that users logging in from untrusted machines, such as a friend s computer, an airport terminal, or other public access machines, are especially at risk [23].
Moreover, we show that many of the Alexa Top 100 sites do not use HTTPS on their login pages, further putting users at risk by sending passwords in the clear.
Among the risks encountered by users of an insecure terminal and WiFi network, password theft has arguably the greatest consequence on users, since stolen passwords have long period of validity, are dif cult to detect as stolen, and are commonly applicable across multiple site.
Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
To address this issue many elegant proposals have tried to improve user authentication by using a smartphone as a security token [6,7,27,29,30,34].
All these approaches, however, require either client-side or server-side changes.
Prior to our work no solution provided a universal mechanism that supports secure login to every website from any untrusted terminal using an off the shelf phone.
We also mention that Google provides a clever solution where users, prior to going on a trip, request a number of onetime passwords that they then use to login at public terminals.
Alternatively, the Google authenticator application can provide onetime passwords on the  y.
With this system, a password stolen by malware is of no use to the attacker.
While Google s solution works well for Google, it does not help the user login to other sites who do not implement this system.
In this work, our goal is to improve user authentication for all web sites and therefore we propose a solution that requires no server-side changes and uses an unmodi ed terminal.
We only require that the terminal run a modern web browser with the ability to install a Javascript bookmarklet.
Our contributions.
We demonstrate an architecture called Session Juggler (http://sessionjuggler.net) that enables users to login without ever entering their long term credentials on the terminal.
In essence Session Juggler works as follows: the user  rst navigates the terminal to the desired web site.
The resulting URL is then transferred to the phone and the user is asked to login to the site from her phone.
Once the login phase is completed the entire session state is deliberately  hijacked  and copied from the phone to the insecure terminal.
Many solutions, including Google s onetime passwords, focus on protecting the user s long-term credential, but do little to prevent malware from hijacking the session after login.
Similarly, sites that allow browsing over HTTP do little to prevent session hijacking by a network sniffer [9].
The reasoning is that a session hijack gives the attacker a short-term session token rather than a long term password and this short-term token is revoked as soon as the user logs out.
Therefore, session hijacking is a lesser concern.
One dif culty with this reasoning is that an infected terminal may replace the logout button by a  no-op.  The user will be fooled into thinking that the session was terminated, where in fact, the attacker is free to continue abusing the user s account.
Similarly, for cleartext sessions, an attacker can simply block the logout request.
because the phone and the untrusted terminal share the same session data, malware cannot prevent the user from logging out through the phone app.
When the user logs out via the phone, the website logout process should, in theory, invalidate all session state associated with the session, thus invalidating all session state stored on the untrusted terminal.
Analyzing session management in the wild.
To validate the session juggling concept we begin with a number of studies of web applications in the wild that are of independent interest.
Our  rst study shows that 75% of the Alexa Top 1000 sites still do not use HTTPS on their login pages and transmit user passwords in the clear.
Users at Internet Cafes are consequently vulnerable to password theft.
Since users heavily reuse password across sites [16], an attacker who learns the user password at one of these insecure sites can easily attack the user at other sites that implement proper login.
Session Juggler can help protect users on sites that use HTTP login.
Users enter their long term credential on the phone which is then transmitted via 3G over the air.
The session is then transferred to the user s laptop and continues over HTTP.
Since 3G data is encrypted over the air, the user s credential is protected from snooping at the Cafe.
When the phone is connected on a WiFi network Session Juggler requires the user to click through a warning before sending the credentials over HTTP.
Since Session Juggler transfers the session from one machine (the phone) to another (the user s laptop or terminal), we may inadvertently trigger the anti-hijacking defense at the site and thereby invalidate the session.
Our second study veri es the effectiveness of Session Juggler by manually analyzing how popular web sites bind sessions to devices.
In Section 2.2 we show that only a few sites bind the user session to speci c browser characteristics, such as an IP address (e.g.
Apple and Amazon) or the local computer time (e.g.
eBay) [14].
Our evaluation shows that Session Juggler works on all but eight of the 64 Alexa Top 100 websites that offer a login mechanism 1.
Two of these failures were due to a bug that makes the Android webview unable to render those sites.
The last failure was due to an aggressive browser  ngerprinting that our prototype currently does not handle.
Moreover Session Juggler works  aw-lessly with Facebook connect which ensures that it can currently be used on over 85000 web sites [36].
Our third study looks at how web sites handle logout requests.
As discussed above, secure logout limits the window of opportunity that an attacker has to use a hijacked session token.
Once the user suspects that hijacking is taking place he or she can use Session Juggler s secure logout mechanism and the session is invalidated.
To ensure that Session Juggler s secure logout effectively protects users we tested how web sites handle logout requests.
To our surprise we found that many popular websites including Linkedin, Blogspot, IMDB, CNN, MSN, eBay and Yahoo!, do not properly invalidate session tokens on logout (see Table 2 for a complete list).
These sites instruct the browser to delete the cookie client-side, but do not invalidate the session server-side.
As a result, even a passive attacker who eavesdrops on HTTP traf c (e.g.
Firesheep) can continue to transact on the user s account after the user clicks logout.
Session Juggler s secure logout mechanism only works on websites that enforce logout request on the server side.
We discuss this issue in Section 2.3.
hence the  low  number of sites tested.
Figure 1: Fraction of sites using HTTPS login as a function of popularity.
Sites listed from Alexa top 100,000

 We begin with three studies that examine speci c features of session management at popular web sites.
These studies expose several widespread vulnerabilities, such as improper handling of logout requests.
While running the studies we discovered that Google and Microsoft did not properly handle logout requests on their health records services (Google Health and Microsoft HealthVault).
Both organizations quickly  xed the problem and acknowledged our  nd-ings in their hall of fame [19, 28].
Our  rst study examines the number of sites that do not use HTTPS on the login page.
Passwords at those sites are transmitted in the clear and can be easily sniffed at open WiFi hotspots such as Internet Cafes.
Since people tend to reuse passwords across many sites, an HTTP login page may put all of the user s accounts at risk.
Session Juggler helps mitigate these issues by transmitting user credential over 3G rather than the WiFI.
Default 3G encryption makes snif ng harder.
To measure the number of sites that use cleartext login we inspected the HTTP login pages at the Alexa top 100,000 sites an look for sites that post the credentials over HTTP.
The results are summarized in Figure 1.
The horizontal axis orders site by Alexa popularity and the vertical axis shows the fraction of sites of that popularity that use HTTPS login.
For example, only 25% of the Alexa top 1000 use HTTPS and the situation is worse after this: only

 Our second study examines how web sites bind sessions to devices.
Recall that Session Juggler transfers sessions from one device (phone) to another (terminal or laptop).
To ensure that Session Juggler will work properly with existing sites we had to determine whether web sites bind session tokens to client devices to prevent session hijacking.
Recall that Panopticlick [14] is a system that is able to uniquely identify browsers.
The question is whether web sites use Panopticlick-like techniques to monitor when sessions move from the originating browser to a new and unknown browser.
Such a move could indicate a session hijack.
We note that session migration may legitimately take place due to browser sync, where the user moves a session from a home computer to an of ce computer, but in these cases both machines will already be known to the web site and this would not trigger the site s hijack defenses.
% of site using HTTPS 0%10%20%30%40%50%60%70%80%90%Number of sites (logarithmic)102103104105% of sites using HTTPS to log usersWWW 2012   Session: Security 1April 16 20, 2012, Lyon, France322To study how web sites bind sessions to devices we created accounts and manually logged in to all 64 Alexa Top 100 websites that have a login facility (we used Firefox under Windows).
Once logged in, we clobbered various variables used by Panopticlick and then reconnected to the site to test if the session remained active.
If not then the site was using the clobbered variable to bind to the device.
To test session binding to IP address we used two different networks that had different address classes but belonged to the same AS.
The results are summarized in Table 1.
Defense Using HTTPS Using secure cookies Separating mobile and desktop sessions Binding session to IP address Checking local time Binding session to user-agent header Binding session to local language Logout over HTTPS % of Alexa100







 Table 1: Anti-hijacking defenses at the Alexa top 100 sites Of all the web sites we tested only gmail.com did not revert back to cleartext HTTP after the login page.
This issue received considerable attention recently [10, 33] thanks to automated tools released last year.
As a result, Facebook, Twitter, and LinkedIn now offer a full HTTPS version of their sites, but it is not enabled by default.
More worrisome is the fact that only a fraction of the websites that use HTTPS use secure cookies (83% vs 52%), which leaves them totally open to session hijacking by a network eavesdropper.
An even smaller fraction (6%) of websites separate desktop sessions from mobile sessions.
That is, for most sites session tokens generated on a desktop can be used to transact on the mobile site and vice versa.
On these sites one can transfer a session from a mobile device to a desktop without invalidating the session.
For 6% of the sites, however, the session would be killed and therefore, Session Juggler s phone application emulates a desktop browser so that the session transfer appears to be from desktop to desktop.
Surprisingly our survey reveals that only 9 websites out of the 64 most visited websites use nonbasic session binding and only 5 of them use the client IP as the binding parameter (including Amazon and Apple).
We discuss in which case Session Juggler works on websites that perform IP binding in section 5.
Only eBay uses the local time on the client s machine for session binding.
To use Session Juggler on a site like eBay we had to ensure that Session Juggler s phone application emulates the desktop s local time.
None of the websites we tested use more sophisticated browser  ngerprints (user agent, local language, plugins) which we found surprising.
Our third study examines the logout procedure at popular sites.
We thought it was obvious that when a user clicks logout web sites should invalidate the active session server-side.
To our surprise we found that many popular web sites remove the session cookie from the browser, but do not invalidate the session on the server.
Consequently, an attacker who somehow obtains the user s session token can continue to transact on behalf of the user after logout.
This has two consequences:
 HTTP can leak the session token to a network eavesdropper, as in the Firesheep attack [9].
With improper logout the eavesdropper can continue to transact even after the user explicitly logs out.
The user has no way to invalidate the session token even if he or she suspect that the session was hijacked.
and requires a second factor to login, as is often the case in healthcare settings.
If the site implements improper logout then malware on the client can steal the session token and continue to transact after the doctor or nurse logs out of the terminal.
In effect, the session token becomes a single factor credential that cannot be revoked by the user.
As mentioned above, many web sites implement improper logout and this is a wide spread bug.
Some web sites, including Twitter and Amazon, default to a partial logout state after the user clicks logout.
In this state websites still accept the user s session token and provide basic information, but request re-authentication for sensitive actions.
Our  ndings, listed in Table 2, show websites that allow users to perform sensitive operations after the user clicks logout.
This listing summarizes all the websites from Alexa-top 100 that are not honoring logout requests on the server side.
We also tested popular open-source software, such as Wikimedia, PHPBB, Wordpress, Drupal, Cake, but all implemented logout correctly.
We also found that Google and Microsoft health record system where subject to logout issue.
Finally we analyzed the following four open-source popular health record systems: OpenMR, FreeMed, ClearHealth, OpenClinic.
Of these four, only OpenMR was subject to the logout issue.
The most interesting case we encountered was Google: while Google properly implements logout for core services such as GMail and Reader, many  side  services including Youtube, Blogger, Orkut, and, Health do not.
The reason is that each of these services retained their custom session management system and added the standard Google authentication system as a secondary mechanism.
This double authentication leads to problematic logout issues.
For example, after logout the session token could still be used to edit the user s blog posts on Blogger but could not be used to access Gmail data.
Another interesting case is Twitter.
As discussed earlier, Twitter s mobile site is different from its main site.
The two sites have different session management systems: while the main Twitter site correctly implements logout requests, the mobile site does not.
This is another example in a general theme showing that mobile sites have weaker security than their desktop counterparts [32].
Is poor logout management a security vulnerability?
For sites that login over HTTPS but then move to HTTP, poor logout is a signi cant risk.
For other sites there is no clear position on this as was apparent from our discussions with affected companies.
Google and Microsoft treated their respective health service logout issue as a vulnerability and quickly  xed the problem.
As far as we know, Microsoft did not  x the Hotmail issue.
Other companies who responded to us acknowledged the issue, but said that it was not a priority because of the lack of attack surface and the heavy cost of changing their session management infrastructure.
From the Session Juggler perspective, logout issues are vulnerabilities because it prevents Session Juggler secure logout functionality to work properly.
Site health.google.com View and edit health record healthvault.com View and edit health record Editing and saving pro le Linkedin Accessing and sending emails Yahoo Accessing and sending emails Hotmail/MSN Posting a blog post Blogger.com Ebay Bidding on an auction Uploading photos Flickr Posting a blog post wordpress.con Editing and saving pro le
 ask.com Editing and saving pro le Editing and saving pro le cnn.com Editing and saving pro le conduit.com Uploading  les megaupload.com Uploading  les media re.com 4shared.com Uploading  les Editing and saving pro le cnet.com Editing and saving pro le weather.com Uploading photos imageshack.us OpenMR Accessing, changing medical records Table 2: Sites with improper logout

 We now describe how Session Juggler works.
We start by describing step by step how the session transfers occur from the user s perspective.
Then we describe in detail how the juggling protocol works and how its participants are implemented.
Finally we review the security bene ts of using Session Juggler.
The goals of Session Juggler are two fold.
First, it ensures that the attacker cannot learn the the user s long term credential.
In particular, Session Juggler mitigates the risk of a man-in-the-middle attack against websites that transmit user login credentials in the clear.
Session Juggler does so by transmitting the user s credentials over a 3G connection that is encrypted and harder to intercept.
Second, Session Juggler provides a trusted logout to invalidate an ongoing session for sites that securely implement logout.
Session Juggler does not protect against post-login attacks other than by providing a trusted logout.
It should be noted that since many web sites only use HTTPS for the login page and then drop back to HTTP, session hijacking is currently easily done by a network attacker using standard tools [10] without the need for client-side malware.
Often users have no recourse against a session hijack, even if they are aware that their session was hijacked   clicking  logout  can be intercepted by a network attacker and blocked (on sites we tested that fall back to HTTP the logout action was also over HTTP).
In contrast, our secure logout will immediately invalidate the session once the user detects the attack.
A storyboard of the user experience with Session Juggler is shown in  gure 22.
As shown there, users login as follows:
 trusted terminal to the site she wishes to log on.
In our example our user goes to http://www.facebook.com.
Then instead of entering her credentials on the untrusted terminal, she clicks on the Session Juggler bookmarklet.
In the  gure 2, the bookmarklet button is located on the bookmark bar and is highlighted in green.
Clicking the bookmarklet creates a div which contains a QR code and an input box as shown in the  gure (highlighted in green).
displayed on the targeted web site, the user starts the Session Juggler application on her phone.
There she can choose between the two ways of initiating the juggling: the visual login mode that will use the QR code or the pin login mode that will use the bookmarklet input box.
In the visual mode, the phone camera is used to read the QR code from the page to get all the necessary information to initiate the juggling.
As we will see in more detail in the next section, the information exchanged includes the user agent, the url, and an AES key.
With the pin login mode, the phone generates an AES key that the user then must input in the bookmarklet input box.
While generating the key on the phone and inputting on the browser creates one more round of exchanges in the juggling protocol, it is generally easier to type a string on the terminal keyboard than on the phone.
During our tests, we didn t notice any visible difference between using the visual login and the pin login mode in terms of latency.
the site, the session juggler app displays a con rmation dialog showing the website favicon and domain name and asks the user to con rm that it is the website where she wants to logon.
This con rmation dialog is used to mitigate phishing attacks and in particular a phishing attack where the malware changes the URL requested by the bookmarklet.
Session Juggler also checks the URL against the google blacklist as an additional layer of defense.
Android app navigates to the login page and the user logs in on the phone.
At this point, the Android native password manager will ask the user if she wants to login.
This step is only required during the  rst login since the password manager saves the credentials.
On subsequent logins the interaction with the phone this step is skipped.
the last step is to click on the transfer session button (highlighted in green on the  gure) to transfer session state to the insecure terminal.
We need to ask the user to click the transfer button since some web sites, such as bankofamerica.com and sfcu.org, have a multi-step login process where the user enters her ID on the  rst page and the password on a subsequent page.
Consequently, only the user can tell when login is complete.
and our open source Android implementation of Session Juggler.
sion button is clicked, the bookmarklet resumes the session on the insecure terminal and the user can enjoy her session.
The user s login and password were never entered on the insecure terminal.
All the terminal sees is the ephemeral session token.
Setup phase.
Setting up Session Juggler is straightforward: On the Android phone, installing the app is as easy as installing any other app from the Android Market.
To install the bookmarklet on the untrusted terminal the user has simply to remember the bookmarklet URL or use the short url associated with it.
As a reminder, a short URL to the bookmarklet is displayed in the setting menu of the Android app.
Logging out.
Since the session was  rst initiated on the phone, the phone has the session token and can, at a later time, issue a logout request for the user when it is asked to do so.
This logout request, if properly honored, will invalidate the session token server-side thereby terminating the session on both the phone and the untrusted terminal.
Note that in practice, as discussed in section 2, this might not work as some websites, such as Linkedin, that do not properly honor logout requests.
Until a standard format to describe logout URL is adopted, Session Juggler has no way of automatically  nding the logout URL.
This means that we have to resort to requiring the user to logout manually.
To make this process easier, we implemented two workarounds.
First, for popular sites like Facebook, Google, Linkedin, and Twitter, we built a database of logout URLs that give a single-click logout.
Second, Session Juggler learns the URLs that the user previously used to logout of a given website.
After the  rst time logout, Session Juggler provides a single-click logout button on the phone.
Note that in either case we show the resulting page so the user can visually verify that logout succeeded.
Juggler Principals Now that we have explained what the user experience with Session Juggler is, we describe how the juggling if effectively implemented.
We start by describing the participants involved in the juggling and then we describe the juggling protocol step by step.
Overall juggling a session involves three main principals, which are depicted in  gure 3: a web service named "Blackboard" after the design pattern of the same name [40], a phone application, and a bookmarklet on the browser in the insecure terminal.
The Bookmarklet.
The bookmarklet is a small piece of javascript that allows us to perform computations on the untrusted terminal browser.
Using a bookmarklet is commonly used by many websites, including Wordpress and Readable, to provide quick cross browser access to a feature that requires executing javascript without requiring the user to install anything on the browser.
As mentioned earlier, when the user starts using an untrusted terminal, she has to visit the book-marklet website and drag and drop a link to the bookmarklet on her bookmark bar.
When the user clicks on the bookmarklet, the javascript code is executed in the context of the site, which allows the bookmarklet to read the page location and content, set cookies, and navigate to the logged-in page once the juggling is done.
encrypt/decrypt requests with AES and can be downloaded from http://ly.tl/sj.
The Blackboard.
The blackboard is a web service that facilitates the exchange of information between the phone and the terminal.
This  middleware  which obeys the  Blackboard  design [40] pattern is needed because often the phone can t be reached directly by the terminal.
For instance, the phone and the terminal might be on two different networks (3G / WiFi).
Accordingly, the bulletin board can be viewed as a convenient way to write and read encrypted data and therefore does not need to be trusted.
Note that the bulletin board can be any web service that allows a user to read and write data (i.e. Twitter).
It can even be an HTTP server on the phone if the terminal is able to connect to it.
The blackboard is a very simple piece of code that can be implemented in less than 200 lines.
In our short PHP implementation, each juggling session is identi ed by a parameter called ID that allows our blackboard to know which data to store and retrieve.
Having a unique identi er for each juggling session is all it is takes to allow our blackboard to handle simultaneous users and sessions.
Juggling data are stored in a simple  le that is wiped after 24h by a cron script.
Note here that all the data stored in the blackboard are encrypted so the blackboard can t tamper with any juggling session data (except to block the session transfer by erasing  les).
As a security precaution, we limit the size of the data written to the  le, as the amount of information exchanged during the juggling is very small.
Note that the bookmarklet javascript is subject to the same origin policy and therefore the blackboard needs to authorize cross-domain requests via pre- ight requests [39] to allow the bookmarklet to read content.
For older browsers that don t implement cross-domain requests, it is possible to use "hacks" such as the external script include trick to circumvent the same origin policy [5].
The trusted phone application.
The phone application is the trusted piece of software that is used to logon to the website requested by the user.
In addition, the phone application is responsible for transferring the session data to the bookmarklet through the blackboard and for providing a secure logout system.
We have implemented our trusted application on Android using the standard framework.
However, because the application needs to impersonate the untrusted terminal browser (i.e spoo ng the user-agent), the standard webview is not directly usable.
We ended up doing the HTTP requests ourselves and then passing the returned content to the web view to render for the user.
As illustrated in section 3.2 , juggling can be initiated using a QR code (visual login) or by entering a pin code (pin login).
Figure 3 describes the juggling protocol when the QR code is used, and the  gure 4 depicts the protocol when a pin code is used.
Because the visual login protocol requires one less exchange than the pin code protocol, we start by describing it.
Figure 3: QR mode message  ow The Visual Login Protocol.
As visible in  gure 3, the visual login version of the juggling protocol is achieved in  ve steps:
 on the bookmarklet, it generates a 128 bit AES key k using the crypto library (SJCL).
k will eventually be used to encrypt the session data.
Then the bookmarklet computes the id required to use the blackboard as follows: idi = HMACk(0).
When this is done the bookmarklet encodes the key k, the browser version, the untrusted terminal OS version, and the target URL into a QR code.
Finally the bookmarklet displays the QR code on top of the web site in the browser.
The bookmarklet will keep polling the blackboard via XHR requests until it receives session data from the phone via the blackboard.
On the phone side, the user input to the application the QR code content by taking a picture of the untrusted terminal screen.
marklet via the QR code, the application navigates to the login page.
Our application uses the browser and OS version supplied by the bookmarklet to spoof the user-agent header.
This is mandatory because if we don t set the user-agent appropriately, the target web site might respond with the mobile version of the site or may later refuse the transfer of the session because of the site unlikely use of anti-hijacking defenses (See section 2).
Once the user has con rmed she wants to login, the page is loaded and the user s password manager asks the user if she wants to supply her credentials.
her credentials, the web site redirects the mobile browser to the logged-in page and sets the cookies pertaining to the user s session.
Once the logged-in page is loaded and the user has clicked on "transfer session," the session data are gathered by the application, encrypted with the key k and posted to the blackboard under the id idi.
The session data contains the URL with all its arguments and the cookies.
Note that the Android framework does not offer a method to read all the cookies  information, such as the cookie path, so we had to use the CookieSyncManager class to force Android to store all cookies present in RAM into the  webview.db  sqlite database and then run a SQLite query to retrieve them.
ing an insecure network (Snif ng, SSL strip) by transmitting user credentials over a 3G network which is encrypted.
The blackboard does not know the key k and does not see the key exchange, as it is done through an out of band exchange (QR code/pin code input).
Thus the blackboard is unable to decrypt the session data.
Accordingly an attacker has no incentive to create a rogue blackboard since it will only contain useless encrypted data.
The only advantage that a rogue blackboard offers to the attacker is that it allows him to prevent the user from logging in by erasing all data.
However since nothing prevents the user from switching blackboards, there is little incentive to do so.
On the other hand, the owner of the untrusted computer s malware has no incentive to prevent the session from being be executed as it will still get him the short terms credentials.
In order to steal the long term credentials, the malware owner can resort to phishing the user by replacing the url sent by the bookmarklet with a malicious url.
This kind of phishing is actually less dangerous than the regular phishing attacks because Session Juggler has three phishing defenses  a user consent popup that emphases the domain request, a domain blacklist check, and a password manager that only discloses passwords to the right url  already builtin on Android phones, leaving them out of harm s way.
Finally, because the phone and the untrusted terminal share the same session data, the malware can t prevent the user from logging out through the phone app, which leaves the malware owner with a smaller window of opportunity.
Note that many websites, including Amazon and Twitter, require users to input their passwords on signi cant changes, which limits even further the effectiveness of hijacking a session.
Our evaluation shows that Session Juggler can be successfully used to login on 87% of the Alexa Top-100 websites.
Additionally we also have a 100% success while using Session Juggler to login on websites that use Facebook connect, which implies that Session Juggler can be used to login on more that 85000 sites [36].
We manually tested if we were able to use Session Juggler and Firefox to login on the 64 Alexa Top-100 websites that have a login system.
The relatively low number of sites that have login capabilities is partially explained by the fact that Google appears multiple times in the Alexa top-100 rankings due to its various local versions.
We only counted all these versions as one site so as not to skew the results in our favor.
We chose the visual mode to verify that websites  designs do not interfere with the QR code reading process.
Overall we can report that Session Juggler is a viable solution as we were able to successfully perform a session transfer for 87% of the most popular websites in the world.
Moreover Session Juggler works perfectly with Facebook connect which implies that, according to the latest statistics, Session Juggler can be used to login successfully on more than 80000 websites [36].
The three case where Session Juggler fails (msn.com, megaupload.com and rapidshare.com) provide a couple of interesting observations that are discussed below.
Figure 4: Pin-code message  ow
 successfully posted the encrypted data on the blackboard, the bookmarklet polls the blackboard by supplying the id idi, and fetches the data.
polled from the blackboard using the key k, sets the cookies in javascript using the document.cookie object, and then navigates to the page by setting the document.location to the logged-in url page.
The browser reacts to this by navigating to the logged-in page and the session is successfully transferred to the untrusted browser/terminal.
The pin login protocol.
As visible in  gure 4, the pin code juggling protocol is very similar to the visual mode except that it requires an extra exchange (steps 1 and 2) at the beginning.
When the pin code protocol is used the AES key k is generated on the phone and then entered via the keyboard (128bits in hex) on the untrusted terminal s browser.
Accordingly, after the key is exchanged, the phone has no idea which website the user wants to login to and therefore the extra exchange is needed so the bookmarklet can tell the phone application which website the user wants to log into.
The content of this exchange is pretty straightforward: the bookmarklet takes all the information that was encoded into the QR code and encrypts it using the key k. Then it posts it on the blackboard using the id idi.
A few milliseconds later the phone polls the request data from the blackboard by requesting data for the id ki.
From there the protocol is similar to the visual login protocol.
Let s now analyze why Session Juggler improves login security.
First and foremost, Session Juggler improves the security by limiting malware s effectiveness by allowing it only to capture short-lived session credentials rather than long term ones.
During the juggling the user s long term credentials are never inputted nor transferred to the insecure terminal, so even if the terminal is infected with malware, the attacker learns nothing about these credentials.
tion 2, websites like twitter.com and eBay differentiate between authenticated sessions depending on whether the client is a smartphone or a regular web browser.
Because they use the user-agent header to distinguish between the two, we had to modify our early prototype so the terminal browser s information is encoded into the transfer request.
On the Android side we had to write custom a HTTP request code to emulate as closely as possible the terminal side headers, thus concealing the fact that the login was performed by a smartphone.
Finding Webview Limitations.
Unfortunately, 2 out of the 3 Session Juggler failures are not directly  xable by us as they stem from the fact that the Android WebView is unable to render the full version of msn.com and rapidshare.com.
Our other failure is due to the fact that megaupload.com automatically gets redirected to the website s mobile version, preventing session transfers.
It is likely that Megaupload performs some kind of browser  ngerprinting in javascript that requires us to develop a way to clobber the webview javascript variables.
As discussed below, dealing with javascript browser  ngerprinting is part of the extensions we propose for this work.
Note that the megaupload  ngerprinting behavior was not detected during our survey of the website hijacking defenses because megaupload does not use it for session binding.
Handling Secure Cookies.
The  rst version of our Android application extracted cookies from the WebView object directly using the CookieManager interface.
During our evaluation we found out that this mechanism failed to retrieve cookies marked  secure .
We observed this odd behavior while testing authentication on bing.com, where certain cookies like KievRPSSecAuth were missing on the client browser even after the session transfer.
In its current version, our application fetches the cookies directly from the cookie repository via the Sqlite interface as explained in section 3.
The Third Party Login Challenge.
While testing we observed that, for  ickr.com and bing.com, the actual authentication is done in a different domain (for example yahoo.com for  ickr.com).
While Session Juggler works with third-party login, we unfortunately had to enter our credentials twice, once on the domain and once an third party domain, to make the transfer work.
Finding a more elegant solution to this problem is an open question.
Note that this issue does not affect Facebook connect.
Before concluding, we discuss some extensions we made to improve Session Juggler and discuss our plan to deal with more aggressive session binding mechanisms if such mechanisms are put in place in the future.
Improving Usability via Long Term Pairing.
One of the drawbacks of our architecture is that it requires the user to exchange a new key between the phone and the desktop every time the user want to login.
If appropriate, this process can be made easier by using a long-term pairing between the phone and the desktop.
Due to security concerns, the pairing key K cannot be stored in the book-marklet [3], but can be stored in a browser extension, if one can be installed.
At setup the key is copied to the phone via a QR code.
Once the setup is completed, the phone app runs a service that polls the blackboard regularly and prompts the user to login as soon as it polls a new request.
This might prove for computers that the user use frequently but do not fully trust such as a family s computer or a corporate one.
Improving Security via Cookie Editing.
As sessions are transferred from the phone to the terminal, our phone application rewrites the transferred cookies so they become session cookies by removing the expiration date.
Removing the expiration date improves user privacy as the cookies will not be written to disk.
It also slightly improves the user s security because if the user forgets to logout but still closes the browser, the cookies are removed from memory.
Dealing with IP Binding.
As mentioned in section 2.2, some websites bind the session to a speci c IP.
In this case the main options is to have the phone connected on the same network.
However connecting the phone to the same network might not always possible.
Another potential issue with this approach is the case where the website doesn t use HTTPS to transmit the credentials.
In this case, the bene t of using session-juggler to protect against man-in-the-middle attack disappears as the 3G connection ceases to be used as an alternative-encrypted channel.
We plan to add to Session Juggler a con rmation dialog when the user tries to send credential over HTTP on a WiFI connection.
Dealing with Aggressive Fingerprinting.
While none of the web sites we tested use aggressive browser  ngerprinting to bind a session to a browser, this may change in the future.
More aggressive browser  ngerprinting (such as testing the screen resolution, installed plugins, etc.)
will make it harder to move the session from the phone to the terminal.
Dealing with this kind of  ngerprint-ing will require a signi cant additional development effort so the phone can impersonate an arbitrary version of Flash or Java.
An alternative option would be to turn Java or Flash off on the terminal side.
However since none of this is needed today   web sites do not  ngerprint the browser for session binding   we leave this as interesting future work.
In this section we present the previous work pertaining to using a trusted device such as a PDA or a phone to login from an untrusted terminal and explain why it is not suf cient for our purposes.
Overall, as visible in the summary table 3, as far as we can tell all the proposals to date require at least a server-side or terminal-side mod-i cation.
It is only by leveraging the advance in mobile browsers and using session hijacking attack principle in an unexpected (and benevolent!)
way the that Session Juggler is able to use a smartphone to login with no terminal-side or server-side modi cations.
In a seminal work [7], the authors propose to use the Palm Pilot as a second authentication factor by implementing a onetime password generator on it.
This work, as well as all related subsequent works requires server modi cations.
In [29], the authors propose using a PDA as a trusted third party by connecting it to the insecure terminal via USB.
This scheme requires terminal-side modi cations and server-side modi cations.
In [35], the authors propose using a mobile phone as a trusted input device to input data on untrusted terminal.
The phone and the terminal are connected via a so-called  thin-client server  that acts as a relay.
Installing this thin-client requires a terminal-side modi cation to be installed and a server-side modi cation to be used.
In [27] the authors propose the MP-Auth protocol that works by storing the user s long-term secret on a mobile device.
The MP-Auth protocol requires server-side changes and needs the untrusted browser to communicate with the phone either via bluetooth or USB, Trusted device Server-side modi cation Terminal-side modi cation Connection type Hardware needed [7]
 Palm Pilot (cid:88) (cid:88)
 [35] [29]

 PDA Phone (cid:88) (cid:88)
 (cid:88) (cid:88) Net [27]
 Phone (cid:88) (cid:88)
 [17]
 Phone (cid:88)

 [34]
 Phone (cid:88) (cid:88) Net [38]
 Phone (cid:88)

 Session Juggler
 Phone
 Table 3: Comparison to previous approaches which requires a client-side modi cation that involves installing a binary and a Firefox extension.
In [17] the authors combine the use of the terminal Trusted Platform Module (TPM), virtual machine, and phone to convince users they can trust the executed virtual machine.
While this approach involves a huge-client side modi cation (using a speci c hyper-visor) and the presence of speci c hardware, it is one of the  rst approaches, if not the  rst approach, to not require server side changes.
The idea of using phone-attested virtual machine on the terminal-side was extended in 2009 [38] to use NFC (Near Field Communication) as a direct channel for the TPM s identity proof.
In [34], the authors propose splitting the display between the untrusted terminal and the phone.
Their scheme requires a terminal-side modi cation that involves installing a Firefox extension.
The aforementioned extension acts as a RDC (Remote Desktop Client) agent that forwards data to the phone.
This scheme also requires a server-side modi cation so the web site is "separation aware."
This scheme additionally requires an HTTP daemon on the phone which implies that there is a direct connection between the phone and the untrusted terminal.
Another approach, followed by some websites (such as Google), is to allow users to generate a list of passwords that are only usable one time.
This approach requires a server-side modi cation and forces the user to carry a list of passwords for each site he or she wants to use.
This approach also does not address the issue that a malware can prevent the user from logging out.
Finally, while three-leg protocols such as OAuth [11] are becoming the standard to delegate permission to "semi"-trusted applications, it is not a suitable approach to deal with untrusted terminals as the pairing process involves supplying the long term credentials at some point during the pairing process.
This approach also requires server-side and terminal-side modi cations.
The Phone as a Second Factor.
In [13] the authors survey the type of devices that can be used as second factors.
In [6] the authors propose to use the phone as a onetime password generator.
This work proposes a solution that is similar to the SecurID one time password solution [26].
In [20] the authors perform a formal analysis of protocols that use a phone as a second factor.
Session Hijacking.
Session hijacking by a network attacker can be mitigated in part by HTTPS and marking all cookies as secure [25].
Other ideas include [24] which proposes to defend against session hijacking using a proxy, [15] which advocates end-to-end security, [22] which uses client-side policies to defend against session hijacking, and [2] which proposes an elegant idea for embedding a session token in the URL fragment identi er.
In [18] the authors study methods to detect passive WiFi session hijacking by leveraging physical layer properties.
Defenses against session hijacking by malware are based on  transaction con rmation  and such systems are presented in [21, 30, 31] and used by authentify.com.
Browser Snif ng.
Browser  ngerprinting is a very active  eld that includes a wide set of techniques.
For instance Panopticlick [14] uses installed fonts, plugins, time zone, and many other parameters to identify the browser.
Companies such as 41st Parameters [1] sell this kind of technology to websites for fraud detection.
In [4], the authors showed that web browsers can still be tracked even with the private mode enabled.
Storing Passwords on Phones.
Storing passwords on phones is an active area.
In [8] the authors propose to hide passwords in plain sight by creating thousands of decoys that are indistinguishable from the real password set.
They also propose to use  honey words  to defend against online attacks.
A related concept is mentioned in [12].
In this paper we present Session Juggler which is the  rst universal solution to perform a secure web login on an untrusted terminal.
Session Juggler is universal as it does not requires any website mod-i cation and do not requires any speci c software on the terminal beside a modern browser.
Our evaluation shows that Session Juggler works with every Alexa Top 100 websites except eight.
Session Juggler also works  awlessly with Facebook connect, which allows users to use it on more than 85000 websites.
Finally Session Juggler is the  rst solution that provides a trusted logout mechanism that ensures that the user session will be killed as soon as the user is  nishing using the website.
Acknowledgments The authors thank Charlie Reis and Collin Jackson for many helpful discussions about this work.
This work was supported by NSF, DARPA, and an AFOSR MURI grant.
