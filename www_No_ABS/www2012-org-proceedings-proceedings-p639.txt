As more and more RDF data is published as Linked Data, developing intuitive ways of accessing this data becomes increasingly important.
One of the main challenges is the development of interfaces that exploit the expressiveness of Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
the underlying data model and query language, while hiding their complexity.
As a good compromise between intuitiveness and expressivity, question answering approaches allow users to express arbitrarily1 complex information needs in natural language without requiring them to be aware of the underlying schema, vocabulary or query language.
Several question answering systems for RDF data have been proposed in the past, for example, Aqualog [14, 23], Power-Aqua [24], NLP-Reduce [6] and FREyA [1].
Many of these systems map a natural language question to a triple-based representation.
For example, consider the simple question Who wrote The Neverending Story?.
PowerAqua2 would map this question to the triple representation (cid:104)[person,organization], wrote, Neverending Story(cid:105).
Then, by applying similarity metrics and search heuristics, it would retrieve matching subgraphs from the RDF repository.
For the above query, the following triples would be retrieved from DBpedia, from which the answer  Michael Ende  can be derived: (cid:104)Writer, IS A, Person(cid:105) (cid:104)Writer, author, The Neverending Story(cid:105) While this approach works very well in cases where the meaning of the query can be captured easily, it has a number of drawbacks, as in many cases the original semantic structure of the question can not be faithfully captured using triples.
For instance, consider the questions 1a and 2a below.
PowerAqua would produce the triple representations in 1b and 2b, respectively.
The goal, however, would be SPARQL queries3 like 1c and 2c, respectively.
(a) Which cities have more than three universities?
(b) (cid:104)[cities], more than, universities three(cid:105) (c) SELECT ?y WHERE {
 language.
ac.uk:8080/poweraqualinked/jsp/index.jsp.
<http://dbpedia.org/ontology/>.
?x onto:city ?y .
} HAVING (COUNT(?x) > 3)
 (a) Who produced the most  lms?
(b) (cid:104)[person,organization], produced, most  lms(cid:105) (c) SELECT ?y WHERE { ?x rdf:type onto:Film .
?x onto:producer ?y .
} ORDER BY DESC(COUNT(?x)) OFFSET 0 LIMIT 1 Such SPARQL queries are di cult to construct on the basis of the above mentioned triple representations, as aggregation and  lter constructs arising from the use of speci c quan-ti ers are not faithfully captured.
What would be needed instead is a representation of the information need that is much closer to the semantic structure of the original question.
Thus, we propose a novel approach to question answering over RDF data that relies on a parse of the question to produce a SPARQL template that directly mirrors the internal structure of the question and that, in a second step, is instantiated by mapping the occurring natural language expressions to the domain vocabulary.
For example, a template produced for Question 2a would be:
 ?x ?p ?y .
?y rdf:type ?c .
} ORDER BY DESC(COUNT(?y)) LIMIT 1 OFFSET 0 In this template, c stands proxy for the URI of a class matching the input keyword  lms and p stands proxy for a property matching the input keyword produced.
In a next step, c has to be instantiated by a matching class, in the case of using DBpedia onto:Film, and p has to be instantiated with a matching property, in this case onto:producer.
For instan-tiation, we exploit an index as well as a pattern library that links properties with natural language predicates.
We show that this approach is competitive and discuss speci c cases of questions that can be precisely answered with our approach but not with competing approaches.
Thus, the main contribution of this paper is a domain-independent question answering approach that  rst converts natural language questions into queries that faithfully capture the semantic structure of the question and then identi es domain-speci c entities combining NLP methods and statistical information.
In the following section we present an overview of the system s architecture, and in Sections 3, 4 and 5 we explain the components of the system in more detail.
In Section 6 we report on evaluation results and then point to an online interface to the prototype in Section 7.
In Section 8 we compare our approach to existing question answering systems on RDF data, before concluding in Section 9.
Figure 1 gives an overview of our approach.
The input question, formulated by the user in natural language, is  rst processed by a POS tagger.
On the basis of the POS tags, lexical entries are created using a set of heuristics.
These lexical entries, together with pre-de ned domain-independent lexical entries, are used for parsing, which leads to a semantic representation of the natural language query, which is then converted into a SPARQL query template.
This process is explained in Section 3.
The query templates contain slots, which are missing elements of the query that have to be  lled with URIs.
In order to  ll them, our approach  rst generates natural language expressions for possible slot  llers from the user question using WordNet expansion.
In a next step, sophisticated entity identi cation approaches are used to obtain URIs for those natural language expressions.
These approaches rely both on string similarity as well as on natural language patterns which are compiled from existing structured data in the Linked Data cloud and text documents.
A detailed description is given in Section 4.
This yields a range of di erent query candidates as potential translations of the input question.
It is therefore important to rank those query candidates.
To do this, we combine string similarity values, prominence values and schema conformance checks into a score value.
Details of this mechanism are covered in Section 5.
The highest ranked queries are then tested against the underlying triple store and the best answer is returned to the user.
The main assumption of template generation is that the overall structure of the target SPARQL query is (at least partly) determined by the syntactic structure of the natural language question and by the occurring domain-independent expressions.
Consequently, our goal is to generate a SPARQL query template such as the one in Example 3 in the introduction, which captures the semantic structure of the user s information need and leaves open only speci c slots for resources, classes and properties, that need to be determined with respect to the underlying dataset.
SPARQL templates specify the query s select or ask clause, its  lter and aggregation functions, as well as the number and form of its triples.
Subject, predicate and object of a triple are variables, some of which stand proxy for appropriate URIs.
These proxy variables, called slots, are de ned as triples of a variable, the type of the intended URI (resource, class or property), and the natural language expression that was used in the user question, e.g.
(cid:104)?x, class,  lms(cid:105).
For example, for the question in 4 (taken from the QALD-
given in 4a and 4b are built.
(a) SELECT COUNT(?y) WHERE { ?y rdf:type ?c .
?x ?p ?y .
} Slots:   (cid:104)?x, resource, Leonardo DiCaprio(cid:105)   (cid:104)?c, class,  lms(cid:105)   (cid:104)?p, property, star(cid:105) (b) SELECT COUNT(?y) WHERE { ?x ?p ?y .
} Slots:   (cid:104)?x, resource, Leonardo DiCaprio(cid:105)   (cid:104)?p, property,  lms(cid:105) The reason for constructing two templates is that the noun  lms could either correspond to a class (as in 4a) or to a property (as in 4b).
Since we want the template generation mechanism to use only domain-independent, linguistic information, such that it does not depend on how a particular dataset is modelled, we start by generating all possible templates and later select the one that captures the structure of the considered data.
In order to get from a natural language question to a SPARQL template, we adopt the parsing and meaning construction mechanism of the question answering system Pythia [22].
The main reason for doing so is ease of adaption to our purposes, but another parser, e.g.
the Stanford parser, together with some semantic interpretation process could do as well.
Pythia s parsing process relies on a lexicon, which speci es for each expression a syntactic and a semantic representation.
The former are trees from Lexicalized Tree Adjoining Grammar [16] and the latter are representations similar to Underspeci ed Discourse Representation Theory (see [22] for more details).
Such a lexicon consists of two parts.
One part comprises domain-independent expressions, which were speci ed manually and can be reused across all domains.
This part contains 107 entries, mainly light verbs (to be, to have, and imperatives like give me), question words (what, which, how many, when, where) and other determiners (some, all, no, at least, more/less than, the most/least), together with negation words, coordination and the like.
The other part of the lexicon comprises domain-dependent expressions.
But since in our approach it is not known beforehand which URIs these expressions should be mapped to, their lexical entries cannot be fully speci ed.
So instead, they contain slots and are built on-the- y while parsing, based on part-of-speech information provided by the Stanford POS tagger [18], and a set of simple heuristics that specify which POS tag corresponds to which syntactic and semantic properties, such as the following:   Named entities are noun phrases and are usually mod-elled as resources, thus a lexical entry is built comprising a syntactic noun phrase representation together with a corresponding semantic representation containing a resource slot.
  Nouns are often referring to classes, while sometimes to properties, thus two lexical entries are built   one containing a semantic representation with a class slot and one containing a semantic representation with a property slot.
  Verbs most often refer to properties, thus a lexical entry with a property slot is built.
However, in some cases, the verb does not contribute anything to the query structure (like have in Which cities have more than 2 million inhabitants?
), thus an additional entry is built, that does not contain a property slot corresponding to the verb but assumes that the property slot is contributed by a noun (inhabitants in this case).
The work ow of template generation thus is the following: The input natural language question is  rst tagged with part-of-speech information.
Then all lexical entries for domain-independent expressions are looked up in the pre-de ned lexicon, and for each expression not covered in this lexicon are built based on its POS tag and a set of heuristics.
For example, processing the question 2a (Who produced the most  lms?)
starts with the tagged input in 5a.
The expressions who and the most are domain-independent expressions found in the lexicon, while for produced and  lms entries need to be build on-the- y.
Natural Language QuestionSemantic RepresentaionSPARQL Query TemplatesTemplates with URI slotsRanked SPARQL QueriesAnswerLODEntity identi cationEntity and Query RankingQuery SelectionResourcesand ClassesSPARQL EndpointType Checkingand ProminenceBOA PatternLibraryPropertiesTagged QuestionDomain Independent LexiconDomain Dependent LexiconParsingCorpora?
!LoadingStateProcessUsesWWW 2012   Session: Ontology Representation and Querying: RDF and SPARQLApril 16 20, 2012, Lyon, France6415.
(a) who/WP produced/VBD the/DT most/JJS films/NNS (b) Covered tokens: who, the most, the, most (c) Building entries for: produced/VBD, films/NNS Now, all lexical entries are input to the parser, which constructs a set of syntactic and corresponding semantic representations of the whole question.
An example is given in 6 and 7, respectively.
who

 produced

 the most
  lms ?x
 y  lms(y) (cid:104) THE MOST y (cid:105) produced (x, y) The semantic representations are  nally translated into SPARQL templates, in the case of Who produced the most  lms?
yielding the following two templates (one where the property is contributed by the verb, corresponding to 7, and one where the verb is assumed to be empty and the property is contributed by the noun):
 (a) SELECT ?x WHERE { ?x ?p ?y .
?y rdf:type ?c .
} ORDER BY DESC(COUNT(?y)) LIMIT 1 OFFSET 0 Slots:   (cid:104)?c, class,  lms(cid:105)   (cid:104)?p, property, produced(cid:105) (b) SELECT ?x WHERE { ?x ?p ?y .
} ORDER BY DESC(COUNT(?y)) LIMIT 1 OFFSET 0 Slots:   (cid:104)?p, property,  lms(cid:105) In order to arrive at fully speci ed SPARQL queries, all slots need to be replaced by appropriate URIs.
The mechanism achieving this is explained in detail in the following section.
The entity identi cation problem can be formalized as follows: Given a string s and a knowledge base K, retrieve and assign a score to entities (i.e., classes, instances or properties) that are similar to the input string s. This problem is particularly complex when retrieving properties, as the semantics of a property can be expressed by using a wide variation of natural language expressions.
Hence, we use the following entity detection approach: We run our generic approach to entity detection on all labels.
In addition, if s stands for a property label, we also compare s with the natural language expressions stored in the BOA pattern library.
These two strategies return the highest ranking entities which are then used to  ll the query slots.
In the following we describe both approaches.
We begin by identifying the most common synonyms of s.
This is carried out by retrieving the union S(s) of all synsets of s from WordNet.
Given this synset, our goal is now to retrieve all entities e with label label(e) from K that abide by the restrictions of the slot which the entity is supposed to  ll.
We then retrieve the set E(s) of entities e that are such that their label is highly similar to the elements of the synset S(s).
Formally, E(s) = arg max s(cid:48) S(s) (cid:48)  (s , label(e)), (1) where the string similarity function   is the average of the trigram, Levenshtein and substring similarities.
While the detection of resources and classes can be reduced to a retrieval task, the detection of predicates from natural language is a di cult task.
This is mostly due to the large number of expressions that can be used to denote the same predicate.
For example, the expressions X, the creator of Y and Y is a book by X are di cult to match by using synset expansion but they both imply that X is the author of Y.
To address this problem, we make use of the pattern library extracted by the BOA framework4 [9] in addition to string matching to detect properties.
The basic idea behind BOA is to use the considerable amount of instance knowledge available in the Linked Data cloud to compute natural language expressions that stand for predicates from the knowledge base K. By these means, expressions used in natural language questions can be mapped to predicates automatically.
Formally, BOA assumes a set P of predicates p for which equivalent natural language expressions are to be detected from an arbitrary input corpus (e.g., Wikipedia, or the Web).
For each p, BOA begins by computing the set of pairs I(p) = {(x, y) : (x p y)   K}.
BOA searches through the input corpus and retrieves all sentences that contains pairs (label(x), label(y)) with (x, y)   I(p), where label(r) denotes the label of any resource r. From these sentences, it extracts the substrings that match the regular expressions  label(x) * label(y)  or  label(y) * label(x) .
From these substrings, BOA  nally generates natural language expressions (NLE)   of the form ?D?
representation ?R?
or ?R?
representation ?D?, where ?D?
resp.
?R?
are placeholders for the labels of x resp.
y, i.e., of the entities which matched the domain resp.
range of p. For example, the NLE ?D?, the creator of ?R?
and ?R?
is a book by ?D?
both express the authorship relation.
The result of the NLE extraction process is a large number of pairs (p, ), which we call BOA patterns.
Distinguishing the patterns that are speci c to a given property p is carried out by computing a score based on the following assump-tions:

 boa.aksw.org tion Retrieval to capture this characteristic.
The speci city spec( ) is thus given by the following expression: (cid:19) (cid:18) |P| |M ( )| spec( ) = log , (4) where M ( ) is the set of predicates of which   is a NLE.
All three equations can now be combined to the global con dence score c( , p) used by BOA as shown in Equation 5: c( , p) = sup( , p)   typ( , p)   spec( ).
(5)

 After identifying entities that could  ll the slots of a template, we arrive at a range of possible SPARQL queries.
The task now is to rank these queries and to pick one, which is then used to retrieve the answer to the input question.
The goal of the query ranking step is to provide a function for deciding on the order of execution of queries that possibly match a question.
Given a slot that is to be  lled, we compute two scores for each possible entity e that can be used to  ll a slot: a similarity score and a prominence score.
The similarity score  (e) is the string similarity used during the entity detection phase.
The prominence score  (e) is given by  (e) = log2 |{(x, y) : x e y}| log2 |{(x, y) : x y e}| if e is a property else, (6) (cid:40) I(p).
This characteristic is modeled by computing the support of the pattern.
such that the placeholders ?D?
resp.
?R?
can be matched to labels of entities whose rdf:type correspond with rdfs:domain resp.
rdfs:range of p. We call this characteristic typicity.
occurs in a small number of pattern mappings.
We call this last characteristic speci city.
To be able to compute these characteristics of good patterns numerically, BOA collects the following supplementary information during the NLE extraction process:   the number of sentences that led to   and that contained label(x) and label(y) with (x, y)   I(p), which we denote l(x, y,  , p), and   I(p,  ), the subset of I(p) which contains only pairs (s, o) that led to  .
Support
 We calculate the support sup( , p) of the pattern   for the predicate p as the product of the number of subject-object pairs the pattern has been learned from and the maximum value for a single subject-object pair: (cid:18) (cid:19) sup( , p) = log max (s,o) I(p) l(s, o,  , p) log(|I(p,  )|).
(2) where x e y holds when this triple can be found in the reference knowledge base K. The  nal score score(e) of each entity is then de nded as Since both components of the support follow a long-tail distribution, we use the logarithm to reduce the boosting of very popular patterns.
A pattern   is considered to display a high typicity with respect to a predicate p if its placeholders ?D?
and ?R?
match only labels of entities whose rdf:type matches the range and domain restrictions of p in the reference corpus.
Let d resp.
r be functions that map each p to its rdfs:domain resp.
rdfs:range.
Furthermore, let d( , s) resp.
r( , s) be functions which map the class of the named entity used to substitute ?D?
resp.
?R in the pattern   for the given sentence s. Finally, let the function  (x, y) be Kronecker s delta function, which returns 1 if x = y and 0 in all other cases.
We de ne the typicity of   as (cid:18)  (d(p), d( , s)) +  (r(p), r( , s)) (cid:19) typ( , p) = (cid:88) s S

 log(|S|+1), (3) where S is the set of sentences used to evaluate the typicity of  .
Note that the  rst term of the typicity is simply the precision of the pattern.
We multiply this factor with the logarithm of (|S|+1) to prevent overly promoting patterns which have a low recall, i.e., patterns that return only a small number of sentences.
A NLE   is considered to be speci c if it is used to expressed a small number of predicates p. We adapted the idea (cid:48) , label(e)) + (1    ) (e),  (s score(e) =   max s(cid:48) S(s) (7) where     [0, 1] decides on the impact of similarity and prominence on the  nal score of each entity.
The score of a query is computed as the average of the scores of the entities used to  ll its slots.
In addition to this, we perform type checks on queries: We  rst extract all triple patterns of the form ?x rdf:type c in the query, where ?x stands for a variable and c for a class.
We compute types(?x, q) = {c | (?x, rdf:type, c)   TP (q)} where TP stands for the set of triple patterns in the considered query q.
For each such variable, we search for triple patterns ?x p e and e p ?x in the query.
In the former case, we check whether the domain of the property p is disjoint with an element of types(?x, q).
In the latter case, we perform the same check with the range of p.
If any of these type checks fails, the query is rejected.
We perform this to avoid queries, which do not follow the schema of the knowledge base, but could still return results because of modelling errors in the data.
Once a ranked list of SPARQL queries is available, we need to decide which of those queries should be returned as answer.
If only the highest ranking query would be returned, the problem arises that most of those queries actually do not return a result.
The reason for this is that the query ranking method can only take limited information into account for reasons of e ciency.
It uses string similarity, prominence of entities and the schema of the knowledge base to score a query.
However, this does not guarantee that the combination of triple patterns in a query is meaningful and leads to a nonempty result.
Therefore it is necessary to execute system returns the highest scored query with a nonempty result.
A special case are COUNT queries: In most of those queries, a return value of 0 is also discarded in our method, since this usually means that the WHERE clause of the corresponding SPARQL query does not yield a match in the considered RDF graph.
The evaluation is based on the QALD5 benchmark on DB-pedia6 [10].
It comprises two sets of 50 questions over DB-pedia, annotated with SPARQL queries and answers.
Each question is evaluated w.r.t.
precision and recall de ned as follows: Recall = number of correct resources returned by system number of resources in gold standard answer Precision = number of correct resources returned by system number of resources returned by system Before we turn to the evaluation results, one important preliminary remark: The reported results are results based on natural language questions tagged with ideal part-of-speech information.
The reason is that questions often lead to POS tagging errors.
For example, in Which  lms did Leonardo di Caprio star in, the in nitive verb form star is tagged as a noun by the Stanford POS tagger as well as the Apache OpenNPL7 POS tagger, which leads to a parse failure.
The same holds for a range of in nitives such as play, border, die, cross and start.
In order to separate such external errors from errors internal to our approach, we manually corrected erroneous POS tags in seven questions, that otherwise would not have been parsed.
But this is only a temporal solution, of course; the next step is to train a POS tagger model on a corpus containing a su cient amount of questions.
Of the 50 training questions provided by the QALD benchmark, 11 questions rely on namespaces which we did not incorporate for predicate detection: FOAF8 and YAGO9.
Especially the latter poses a challenge, as YAGO categories tend to be very speci c and complex (e.g., FemaleHeadsOf-Government and HostCitiesOfTheSummerOlympicGames).
We did not consider these questions, thus only 39 questions are processed by our approach.
Of these 39 questions, 5 questions cannot be parsed due to unknown syntactic constructions or uncovered domain-independent expressions.
This mainly concerns the noun phrase conjunction as well as and ordinals (the 5th, the  rst).
These constructions will be added in the future; the only reason they were not implemented yet is that they require signi cant additional e ort when specifying their compositional semantics.
Of the remaining 34 questions, 19 are answered exactly as required by the benchmark (i.e. with precision and recall 1.0) and another two are answered almost correctly (with precision and recall > 0.8).
Figure 3 at the very end of the paper lists the results of each of the 39 processed questions.
5http://www.sc.cit-ec.uni-bielefeld.de/qald 6http://dbpedia.org 7http://incubator.apache.org/opennlp/ 8http://www.foaf-project.org/ 9http://www.mpi-inf.mpg.de/yago-naga/yago/ The mean of all precision scores is therefore 0.61 and the mean of all recall scores is 0.63, leading to an F-measure10 of 0.62.
These results are comparable with those of systems such as FREyA and PowerAqua.
The key advantage of our system is that the semantic structure of the natural language input is faithfully captured, thus complex questions containing quanti ers, comparatives and superlatives pose no problem, unlike in PowerAqua.
Moreover, our system does not need any user feedback, as FREyA does.
In the following, we identify the main sources of errors and discuss how they can be addressed in future work.
In the examples given in this section, we will use the following abbreviations for relevant DBpedia namespaces:   res for <http://dbpedia.org/resource/>   onto for <http://dbpedia.org/ontology/>   prop for <http://dbpedia.org/property/> Incorrect templates It only very rarely happens that a parse is found but no sensible template is constructed.
However, it does happen that none of the constructed templates captures the structure of the data.
One example is question 36 (Is there a video game called Battle Chess?
), where the generated template assumes a property slot title or name corresponding to the participle called; however, none such property exists in DBpedia.
The appropriate property rdfs:label, on the other hand, is not part of the index and thus is not found by the predicate detection algorithm.
Incorrect templates are most eminent when the semantic structure of the natural language question does not coincide with the triple structure of the target query.
For example, the phrase join the EU would lead to a template containing a property slot join related to the resource EU; the appropriate property in DBpedia, however, is prop:accessioneudate.
The same structural mismatch would arise with complex YAGO caterogies.
Cases like these suggest that the  xed structure of the templates is sometimes too rigid.
We are currently working on two solutions to this problem, see Section 9 below.
Another reason for incorrect templates is the sporadic failure of named entity recognition.
E.g., if a phrase like Battle of Gettysburg is not recognized as a named entity, no resource slot is built   instead the template would contain a slot for a class battle related to an entity Gettysburg, which does not lead to a meaningful result.
Entity identi cation Errors due to entity identi cation occur when a resource, class or property cannot be found on the basis of the slot.
These are the most frequent errors in our approach.
A particularly hard case for entity identi cation is when a property in the intended target query does not have a correspondent in the natural language question.
This is the case in questions 11 (Give me all soccer clubs in the Premier League) and 29 (Give me all movies with Tom Cruise).
The templates constructed for these questions contain a property slot that arises from the prepositions in and with; the correct properties onto:league (for 11) and onto:starring 10(2   precision   recall)/(precision + recall) basis of Premier League and  lms.
This type of inferences is not part of our approach at the moment.
Examples for entities which do have a correspondent in the natural language input but are nevertheless hard to match are the following:   inhabitants, the correct property being prop:population or prop:populationTotal (question 9)   owns, the property speci ed in the Gold query being onto:keyPerson (question 10)   higher, the target property being prop:elevationM (question 33) These cases would require the incorporation of additional semantic similarity measures, such as Explicit Semantic Analysis [8].
Query selection Sometimes the correct entity is among the entity candidates, but still a query with the wrong entity instantiating the slot is picked.
An example of this is question 32 (Who wrote The pillars of the Earth?).
The expression wrote is matched with the property onto:writer, as this is higher ranked than the property onto:author.
Using the former, the name The pillars of the Earth is incorrectly matched with res:The_Pillars_of_the_Earth_(TV_Miniseries) because it gives a nonempty result in combination with onto:writer.
Another case in which the wrong entity is picked is when the slot contains too little information in order to decide among candidates.
E.g., there are three questions (24, 41, 44) containing the participle founded.
There are several candidates of properties that founded could correspond to, e.g.
prop:foundation, prop:foundingYear, prop:foundingDate, onto:foundationPerson, onto:foundationPlace.
Without a hint about the intended range of the property, the decision for one of these properties has to be quite arbitrary.
In order to capture these cases, slots would need to comprise more information, e.g.
also specify the property s range, in order to distinguish constructions like founded in 1950, founded in California and founded by Goofy.
A  rst step towards this goal is already implemented: In case the argument is a numeral or the question contains a wh-word like when or where, the slot contains the information that a date or place is intended (thus question 41 works  ne and for question 24 a sensible template is built, although it fails due to query ranking and selection).
Other reasons In some cases our approach is doing the right thing, however not, or only partially, matching the Gold query.
One example is question 13 (What languages are spoken in Estonia?).
The target query speci ed in the Gold standard contains a union of countries related to Estonia via the property onto:language and countries related to Estonia via the property onto:spokenIn.
Our approach  nds the former property and stops, thus misses the latter and thereby achieves 1.0 precision but a lower recall.
The solution would be to perform an exhaustive search, i.e. not stopping after one successful query is found.
Another example is question 38, which asks for the country with the most o cial languages.
Our approach choses the property onto:officialLanguage, while the Gold query uses the more general (and arguably less appropriate) property onto:language.
In general, question answering over DBpedia has to face the challenge of two schemas   a manually created ontology modelling mostly neat and consistent data in the ontology namespace, and an automatically created one modelling a large amount of quite noisy data in the property namespace.
The namespaces partly overlap and chosing one over the other often leads to di erent results of di erent quality.
A prototype for the described algorithm was implemented and deployed, see Figure 2.
It is a freely accessible web application, which allows a user to enter natural language questions.
The answers are shown in a tabular view if appropriate.
The view allows the user to enrich the generated answers by displaying further appropriate property values for the returned resources.
Interesting queries can be saved and reused by other users.
For the prototype, we used DBpedia as underlying knowledge base.
To be able to use the mentioned techniques, some components were created o ine: Separate Lucene indices were created for resources, properties and classes by querying for the labels of those elements in the used DB-pedia triple store.
Additionally, a BOA index was created for properties, since it vastly improves the mapping of properties in natural language queries compared to using a text index.
The same approach can be applied to other knowledge bases and we plan to evaluate this in future work.
Several approaches have been developed for the purpose of question answering.
PowerAqua is a question answering system over Linked Data that is not tailored towards a particular ontology; especially it does not make any assumptions about the vocabulary or structure of datasets.
The main focus of the system is to combine and merge data from di erent sources, focusing on scalability, and using iterative algorithms,  ltering and ranking heuristics to limit the search space.
PowerAqua is therefore very strong on large, heterogeneous datasets, although it does struggle on complex mappings such as the aforementioned YAGO categories.
For a detailed explanation of the system s architecture and an evaluation see, e.g., [15, 13].
The major shortcoming of PowerAqua is its limited linguistic coverage.
In particular, PowerAqua fails on questions containing the most (such as question 31), and more than (such as question 12), which pose no problem for a system with a deeper linguistic analysis of the input question.
Pythia [22] is such a system.
It relies on a deep linguistic analysis (on which the approach based in this paper is based) and can therefore handle linguistically complex questions, in particular questions containing determiners such as the most and more than.
Pythia s major drawback is that it requires a lexicon, which up to this moment has to be created manually.
It therefore fails to scale to very large datasets.
The approach proposed in this paper tries to combine both a deep linguistic analysis with the  exibility of approaches focusing on matching natural language questions to RDF triples.
The triple structure is derived from the semantic structure of the question.
Another possibility to determine the triple structure is by exploration of the dataset, as in the question answering system FREyA [2, 3].
However, FREyA partly relies on the user s help in selecting the entity that is most appropriate as match for some natural language expression.
The drawback of such an approach is that the naive end-user is often not informed about the modeling and vocabulary of the data and thus is not able to help.
Further approaches related to question answering over Linked Data include, e.g., Treo [7], which combines entity search, semantic relatedness and spreading activation for exploring RDF data, and Ontolook [12], which focuses on relation-based search.
In addition to question answering, keyword-based approaches have been gaining momentum over the past years.
This led to semantic search engines, such as Swoogle [5], Watson [4], Sigma [20] and Sindice [21], which aim to index RDF across the Web and make it available for entity search.
The approaches described in [17] and [19] extend upon the paradigm of simple entity search and try to generate interpretations of keyword queries which exploit the semantics available on the Linked Data Web.
Especially, [19] implements a graph exploration approach to detect subgraphs of the input knowledge base that can be used to compute an answer to the user s query.
On the other hand, [17] uses schema knowledge to infer SPARQL queries that represent possible interpretations of the user-given keywords.
We presented a novel approach to question answering over Linked Data that relies on a deep linguistic analysis yielding a SPARQL template with slots that need to be  lled with URIs.
In order to  ll those slots, possible entities were iden-ti ed using string similarity as well as natural language patterns extracted from structured data and text documents.
The remaining query candidates were then ranked and, on the basis of scores attached to the entities, one of them was selected as  nal result.
One of the strengths of this approach is that the generated SPARQL templates capture the semantic structure of the natural language input.
Therefore questions containing quanti ers like the most and more than, comparatives like higher than and superlatives like the highest do not pose a problem   in contrast to most other question answering systems that map natural language input to purely triple-based representations.
However, in some cases the semantic structure of the question and the triple structure of the query do not coincide, thus faithfully capturing the semantic structure of the input question sometimes leads to too rigid templates.
We are currently exploring two approaches to solve this problem.
The  rst one concentrates on more  exible processing.
On the one hand side, we are considering a preprocessing step that can detect complex (especially YAGO) categories before parsing the natural language question.
On the other hand side, we are investigating the relaxation of templates, such that the triple structure is not completely  xed but is discovered through exploration of the RDF data.
The second approach concerns incorporating a more  ex-ible fallback strategy in case no successful SPARQL query is found.
In particular, we are working on combining our approach with active learning methods as described in [11].
Active learning allows the user to give feedback on the presented query results, i.e. the user can say whether particular query results are incorrect and/or whether further results should be returned.
This will allow two enhancements over the presented question answering system: First, if the returned answers are incorrect or incomplete, then the user can indirectly modify the query via his feedback.
And second, if our approach cannot generate a query at all, then the system can still recover by allowing the user to specify one or more query results.
This procedure can be assisted with standard search and disambiguation methods.
Once these enhancements are in place, i.e. once the shortcomings mentioned in Section 6.2 are addressed, we will evaluate our approach on a larger scale, for example using the data provided by the second instalment of the QALD open challenge, which comprises 100 training and 100 test questions on DBpedia, and a similar amount of questions on Mu-sicBrainz.
In particular, we will test how well our approach carries over to di erent types of domains.
Additionally, we plan to conduct a small usability study.
Ultimately, our goal is to provide robust question answering for large scale heterogeneous knowledge bases.
Our vi-question answering systems a standard task in everyday life in a similar but more powerful way as web search.
exploring the Semantic Web.
Semantic Web Journal, In Press (2011).
