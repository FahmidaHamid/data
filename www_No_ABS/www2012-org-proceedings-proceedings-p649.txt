In this paper, we study the problem of directly mapping a relational database to an RDF graph with OWL vocabulary.
A direct mapping is a default and automatic way of translating a relational database to RDF.
One report suggests that Internet accessible databases contained up to 500 times more data compared to the static Web and roughly 70% of websites are backed by relational databases, making automatic translation of relational database to RDF central to the success of the Semantic Web [13].
We build on an existing direct mapping of relational database schema to OWL DL [23] and the current draft of the W3C Direct Mapping standard [5].
We study two properties that are fundamental to a direct mapping: information preservation and query preservation.
Additionally we study two desirable properties: monotonic-ity and semantics preservation.
To the best of our knowledge, we are presenting the  rst direct mapping from a relational database Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
to an RDF graph with OWL vocabulary that has been thoroughly studied with respect to these fundamental and desirable properties.
Information preservation speaks to the ability of reconstructing the original database from the result of the direct mapping.
Query preservation means that every query over a relational database can be translated into an equivalent query over the result of the direct mapping.
Monotonicity is a desired property because it assures that a re-computation of the entire mapping is not needed after any updates to the database.
Finally, a direct mapping is semantics preserving if the satisfaction of a set of integrity constraints are encoded in the mapping result.
Our proposed direct mapping is monotone, information preserving and query preserving even in the general and practical scenario where relational databases contain null values.
However, given a database that violates an integrity constraint, our direct mapping generates a consistent RDF graph, hence, it is not semantics preserving.
We analyze why our direct mapping is not semantics preserving and realize that monotonicity is an obstacle.
We  rst show that if we only consider primary keys, we can still have a monotone direct mapping that is semantics preserving.
However this result is not suf cient because it dismisses foreign keys.
Unfortunately, we prove that no monotone direct mapping is semantics preserving if foreign keys are considered, essentially because the only form of constraint checking in OWL is satis ability testing.
This result has an important implication in real world applications: if you migrate your relational database to the Semantic Web using a monotone direct mapping, be prepared to experience consistency when what one would expect is inconsistency.
Finally, we present a non-monotone direct mapping that overcomes the aforementioned limitation.
We foresee the existence of monotone direct mappings if OWL is extended with the epistemic operator.
Due to lack of space, the paper does not include the proofs of the results.
We refer the reader to [19] for these proofs.
In this section, we de ne the basic terminology used in the paper.
Assume, a countably in nite domain D and a reserved symbol NULL that is not in D. A schema R is a  nite set of relation names, where for each R   R, att(R) denotes the nonempty  nite set of attributes names associated to R. An instance I of R assigns to each relation symbol R   R a  nite set RI = {t1, .
.
.
, t } of tuples, where each tuple tj (1   j    ) is a function that assigns to each attribute in att(R) a value from (D   {NULL}).
We use notation t.A to refer to the value of a tuple t in an attribute A.
Relational algebra: To de ne some of the concept studied in this databases.
Given that we consider relational databases containing null values, we present in detail the syntax and semantics of a version of relational algebra that formalizes the way nulls are treated in practice in database systems.
Formally, assume that R is a relational schema.
Then a relational algebra expression   over R and its set of attributes att( ) are recursively de ned as follows:
 over R such that att( ) = att(R).
algebra expression over R such that att( ) = {A}.
a   D and   is any of the expressions  A=a( ),  A6=a( ),  IsNull(A)( ) or  IsNotNull(A)( ), then   is a relational algebra expression over R such that att( ) = att( ).
  =  U ( ), then   is a relational algebra expression over R such that att( ) = U .
is an attribute such that B 6  att( ) and   =  A B( ), then   is a relational algebra expression over R such that att( ) = (att( ) r {A})   {B}.
( 1    2), then   is a relational algebra expression over R such that att( ) = (att( 1)   att( 2)).
att( 1) = att( 2) and   is either ( 1    2) or ( 1 r  2), then   is a relational algebra expression over R such that att( ) = att( 1).
Let R be a relational schema, I an instance of R and   a relational algebra expression over R. The evaluation of   over I, denoted by J KI , is de ned recursively as follows:

 t : {A}   (D   {NULL}) is a tuple such that t.A = NULL.
If   =  A=a( ), then J KI = {t   J KI | and a   D.
t.A = a}.
If   =  A6=a( ), then J KI = {t   J KI | t.A 6= NULL and t.A 6= a}.
If   =  IsNull(A)( ), then J KI = {t   J KI | t.A = NULL}.
If   =  IsNotNull(A)( ), then J KI = {t   J KI | t.A 6= NULL}.
  =  U ( ), then J KI = {t : U   (D   {NULL}) | there exists t    J KI such that for every A   U : t.A = t .A}.
is an attribute such that B 6  att( ) and   =  A B( ), then J KI = {t : att( )   (D   {NULL}) | there exists t    J KI such that t.B = t .A and for every C   (att( )r {B}): t.C = t .C}.
( 1    2), then J KI = {t : att( )   (D   {NULL}) | there exist t1   J 1KI and t2   J 2KI such that for every A   (att( 1)   att( 2)): t.A = t1.A = t2.A 6= NULL, for every A   (att( 1) r att( 2)): t.A = t1.A, and for every A   (att( 2) r att( 1)): t.A = t2.A}.
It is important to notice that the operators left-outer join, right-outer join and full-outer join are all expressible with the previous operators.
For more details, we refer the reader to [19].
Integrity constraints: We consider two types of integrity constraints: keys and foreign keys.
Let R be a relational schema.
A key   over R is an expression of the form R[A1, .
.
.
, Am], where R   R and   ( {A1, .
.
.
, Am}   att(R).
Given an instance I of R, I satis es key  , denoted by I |=  , if: (1) for every t   RI and k   {1, .
.
.
, m}, it holds that t.Ak 6= NULL, and (2) for every t1, t2   RI , if t1.Ak = t2.Ak for every k   {1, .
.
.
, m}, then t1 = t2.
A foreign key over R is an expression of the form R[A1, .
.
.
, Am]  FK S[B1, .
.
.
, Bm], where R, S   R,   ( {A1, .
.
.
, Am}   att(R) and   ( {B1, .
.
.
, Bm}   att(S).
Given an instance I of R, I satis es foreign key  , denoted by I |=  , if I |= S[B1, .
.
.
, Bm] and for every tuple t in RI : either (1) there exists k   {1, .
.
.
, m} such that t.Ak = NULL, or (2) there exists a tuple s in SI such that t.Ak = s.Bk for every k   {1, .
.
.
, m}.
Given a relational schema R, a set   of keys and foreign keys is said to be a set of primary keys (PKs) and foreign keys (FKs) over R if: (1) for every      , it holds that   is either a key or a foreign key over R, and (2) there are no two distinct keys in   of the form R[A1, .
.
.
, Am] and R[B1, .
.
.
, Bn] (that is, that mention the same relation name R).
Moreover, an instance I of R satis es  , denoted by I |=  , if for every      , it holds that I |=  .
Assume there are pairwise disjoint in nite sets I (IRIs), B (blank nodes) and L (literals).
A tuple (s, p, o)   (I B)  I (I B L) is called an RDF triple, where s is the subject, p is the predicate and o is the object.
A  nite set of RDF triples is called an RDF graph.
Moreover, assume the existence of an in nite set V of variables disjoint from the above sets, and assume that every element in V starts with the symbol ?.
In this paper, we consider RDF graphs with OWL vocabulary [1], which is the W3C standard ontology language based on description logics, without datatypes.
In particular, we say that an RDF graph G is consistent under OWL semantics if a model of G with respect to the OWL vocabulary exists (see [1] for a precise de nition of the notion of model and the semantics of OWL).
In this paper, we use SPARQL as a query language for RDF graphs.
The of cial syntax of SPARQL [17, 12] considers operators OPTIONAL, UNION, FILTER, SELECT, AS and concatenation via a point symbol (.
), to construct graph pattern expressions.
The syntax of the language also considers { } to group patterns, and some implicit rules of precedence and association.
In order to avoid ambiguities in the parsing, we follow the approach proposed in [16], and we present the syntax of SPARQL graph patterns in a more traditional algebraic formalism, using operators AND
 FILTER (FILTER), SELECT (SELECT) and AS (AS).
More precisely, a SPARQL graph pattern expression is de ned recursively as follows.
1.
{ } is a graph pattern (the empty graph pattern).
pattern (a triple pattern).
att( 1) = att( 2).
If   = ( 1    2), then J KI = J 1KI   J 2KI .
If   = ( 1 r  2), then J KI = J 1KI r J 2KI .
(P1 OPT P2), (P1 UNION P2) and (P1 MINUS P2) are graph patterns.
then the expression (P FILTER R) is a graph pattern.
.
.
., ?Cn is a sequence of pairwise distinct elements from V (m   0 and n   0) such that none of the variables ?Bi (1   i   m) is mentioned in P , then (SELECT {?A1 AS ?B1, .
.
.
, ?Am AS ?Bm, ?C1, .
.
.
, ?Cn} P ) is a graph pattern.
A SPARQL builtin condition is constructed using elements of the set (I   V) and constants, logical connectives ( ,  ,  ), inequality symbols (<,  ,  , >), the equality symbol (=), unary predicates such as bound, isBlank, and isIRI (see [17, 12] for a complete list).
In this paper, we restrict to the fragment where the builtin condition is a Boolean combination of terms constructed by using = and bound, that is: (1) if ?X, ?Y   V and c   I, then bound(?X), ?X = c and ?X =?Y are builtin conditions, and (2) if R1 and R2 are builtin conditions, then ( R1), (R1   R2) and (R1   R2) are builtin conditions.
The version of SPARQL used in this paper includes the following SPARQL 1.1 features: the operator MINUS, the possibility of nesting the SELECT operator and the operator AS [12].
The answer of a SPARQL query P over an RDF graph G is a  nite set of mappings, where a mapping   is a partial function from the set V of variables to (I   L   B).
We de ne the semantics of SPARQL as a function J   KG that, given an RDF graph G, takes a graph pattern expression and returns a set of mappings.
We refer the reader to [19] for more detail.
A direct mapping is a default way to translate relational databases into RDF (without any input from the user on how the relational data should be translated).
The input of a direct mapping M is a relational schema R, a set   of PKs and FKs over R and an instance I of R. The output is an RDF graph with OWL vocabulary.
Assume G is the set of all RDF graphs and RC is the set of all triples of the form (R,  , I) such that R is a relational schema,   is a set of PKs and FKs over R and I is an instance of R.
De nition 1 (Direct mapping) A direct mapping M is a total function from RC to G.
We now introduce two fundamental properties of direct mappings: information preservation and query preservation; and two desirable properties of these mappings: monotonicity and semantic preservation.
Information preservation is a fundamental property because it guarantees that the mapping does not lose information, which is fundamental in an Extract-Transform-Load process.
Query preservation is also a fundamental property because it guarantees that everything that can be extracted from the relational database by a relational algebra query, can also be extracted from the resulting RDF graph by a SPARQL query.
This property is fundamental for workloads that involve translating SPARQL to SQL.
Monotonic-ity is a desirable property because it would avoid recalculating the mapping for the entire database after inserting new data.
In addition to practical considerations when translating relational data to RDF graphs, we must deal with the closed-world database semantics and open world RDF/OWL semantics.
Understanding the expressive power of a mapping and, its ability to properly deal with integrity constraints is important.
Thus our choice of examining semantics preservation.
Information preservation: A direct mapping is information preserving if it does not lose any information about the relational instance being translated, that is, if there exists a way to recover the original database instance from the RDF graph resulting from the translation process.
Formally, assuming that I is the set of all possible relational instances, we have that: De nition 2 (Information preservation) A direct mapping M is information preserving if there is a computable mapping N : G   I such that for every relational schema R, set   of PKs and FKs over R, and instance I of R satisfying  : N (M(R,  , I)) = I.
Recall that a mapping N : G   I is computable if there exists an algorithm that, given G   G, computes N (G).
Query preservation: A direct mapping is query preserving if every query over a relational database can be translated into an equivalent query over the RDF graph resulting from the mapping.
That is, query preservation ensures that every relational query can be evaluated using the mapped RDF data.
To formally de ne query preservation, we focus on relational queries that can be expressed in relational algebra [3] and RDF queries that can be expressed in SPARQL [17, 16].
In Section 2.1, we introduced a version of relational algebra that formalizes the semantics of null values in practice.
In Section 2.3, we introduce an algebraic version of SPARQL that follows the approach proposed in [16].
Given the mismatch in the formats of these query languages, we introduce a function tr that converts tuples returned by relational algebra queries into mappings returned by SPARQL.
Formally, given a relational schema R, a relation name R   R, an instance I of R and a tuple t   RI , de ne tr(t) as the mapping   such that: (1) the domain of   is {?A | A   att(R) and t.A 6= NULL}, and (2)  (?A) = t.A for every A in the domain of  .
Example 1 Assume that a relational schema contains a relation name STUDENT and attributes ID, NAME and AGE.
Moreover, assume that t is a tuple in this relation such that t.ID = 1, t.NAME = John and t.AGE = NULL.
Then, tr(t) =  , where the domain of   is {?ID, ?NAME},  (?ID) = 1 and  (?NAME) = John.
De nition 3 (Query preservation) A direct mapping M is query preserving if for every relational schema R, set   of PKs and FKs over R and relational algebra query Q over R, there exists a SPARQL query Q  such that for every instance I of R satisfying  : tr(JQKI ) = JQ KM(R, ,I).
It is important to notice that information preservation and query preservation are incomparable properties in our setting.
On one side, if a direct mapping M is information preserving, this does not guarantee that every relational algebra query Q can be rewritten into an equivalent SPARQL query over the translated data, as M could transform source relational databases in such a way that a more expressive query language is needed to express Q over the generated RDF graphs.
On the other side, a mapping M can be query preserving and not information preserving if the information about the schema of the relational database being translated is not stored.
For example, we de ne in Section 4 a direct mapping DM that includes information about these relational schemas.
It will become clear in Sections 4 and 5 that if such information is not stored, then DM would be query preserving but not information preserving.
Monotonicity: Given two database instances I1 and I2 over a relational schema R, instance I1 is said to be contained in instance I2, A direct mapping M is considered monotone if for any such pair of instances, the result of mapping I2 contains the result of mapping I1.
In other words, if we insert new data to the database, then the elements of the mapping that are already computed are unaltered.
De nition 4 (Monotonicity) A direct mapping M is monotone if for every relational schema R, set   of PKs and FKs over R, and instances I1, I2 of R such that I1   I2: M(R,  , I1)  
 Semantics preservation: A direct mapping is semantics preserving if the satisfaction of a set of PKs and FKs by a relational database is encoded in the translation process.
More precisely, given a relational schema R, a set   of PKs and FKs over R and an instance I of R, a semantics preserving mapping should generate from I a consistent RDF graph if I |=  , and it should generate an inconsistent RDF graph otherwise.
De nition 5 (Semantics preservation) A direct mapping M is semantics preserving if for every relation schema R, set   of PKs and FKs over R and instance I of R: I |=   iff M(R,  , I) is consistent under OWL semantics.
We introduce a direct mapping DM, that integrates and extends the functionalities of the direct mappings proposed in [23, 5].
DM is de ned as a set of Datalog rules1, which are divided in two parts: translate relational schemas and translate relational instances.
In Section 4.1, we present the predicates that are used to store a relational database, the input of DM.
In Section 4.2, we present predicates that are used to store an ontology and Datalog rules to generate an ontology from the relational schema and the set of PKs and FKs.
In Section 4.3, we present the Datalog rules that generate the OWL vocabulary from the ontology that was derived from the relational schema and a set of PKs and FKs.
Finally, we present in Section 4.4 the Datalog rules that generates RDF triples from a relational instance.
this database consists of Throughout this section, we use the following running example.
Consider a relational database for a university.
The schema of tables STUDENT(SID,NAME),
 and ENROLLED(SID,CID).
Moreover, we have the following constraints about the schema of the university: SID is the primary key of STUDENT, CID is the primary key of COURSE, DID is the primary key of DEPT, (SID,CID) is the primary key of ENROLLED, CODE is a foreign key in COURSE that references attribute DID in DEPT, SID is a foreign key in ENROLLED that references attribute SID in STUDENT, and CID is a foreign key in ENROLLED that references attribute CID in COURSE.
Given that the direct mapping DM is speci ed by a set of Datalog rules, its input (R,  , I) has to be encoded as a set of relations.
We de ne the predicates that are used to store the triples of the form (R,  , I).
More precisely, the following predicates are used to store a relational schema R and a set   of PKs and FKs over R.
  REL(r): Indicates that r is a relation name in R; e.g.
REL("STUDENT") indicates that STUDENT is a relation name.2

   ATTR(a, r): Indicates that a is an attribute in the relation r in R; e.g.
ATTR("NAME", "STUDENT") holds.
  PKn(a1, .
.
.
, an, r): Indicates that r[a1, .
.
.
, an] is a primary key in  ; e.g.
PK1("SID", "STUDENT") holds.
  FKn(a1, .
.
.
, an, r, b1, .
.
.
, bn, s): r[a1, .
.
.
, an]  FK e.g.
FK1("CODE", "COURSE", "DID", "DEPT") holds.
s[b1, .
.
.
, bn] Indicates that is a foreign key in  ; Moreover, the following predicate is used to store the tuples in an relational instance I of a relational schema R.
  VALUE(v, a, t, r): Indicates that v is the value of an attribute a in a tuple with identi er t in a relation r (that be-a tuple t1 of table STUDENT such that longs to R); e.g.
t1.SID = "1" and t1.NAME = NULL is stored by using the facts VALUE("1", "SID", "id1", "STUDENT") and VALUE(NULL, "NAME", "id1", "STUDENT"), assuming that id1 is the identi er of tuple t1.
In order to translate a relational database into an RDF graph with OWL vocabulary, we  rst extract an ontology from the relational schema and the set of PKs and FKs given as input.
In particular, we classify each relation name in the schema as a class or a binary relation (which is used to represent a many-to-many relationship between entities in an ER/UML diagram), we represent foreign keys as object properties and attributes of relations as data type properties.
More speci cally, the following predicates are used to store the extracted ontology:   CLASS(c): Indicates that c is a class.
  OPn(p1, .
.
.
, pn, d, r): Indicates that p1, .
.
.
, pn (n   1) form an object property with domain d and range r.
  DTP(p, d): Indicates that p is a data type property with domain d.
The above predicates are de ned by the Datalog rules described in the following sections.
Identifying binary relations: We de ne auxiliary predicates that identify binary relations to facilitate identifying classes, object properties and data type properties.
Informally, a relation R is a binary relation between two relations S and T if (1) both S and T are different from R, (2) R has exactly two attributes A and B, which form a primary key of R, (3) A is the attribute of a foreign key in R that points to S, (4) B is the attribute of a foreign key in R that points to T , (5) A is not the attribute of two distinct foreign keys in R, (6) B is not the attribute of two distinct foreign keys in R, (7) A and B are not the attributes of a composite foreign key in R, and (8) relation R does not have incoming foreign keys.
In Datalog this becomes:



 (1)
 In a Datalog rule, negation is represented with the symbol   and upper case letters are used to denote variables.
Thus, the previous rule states that the relation R is a binary relation between two relations S and T if the following conditions are satis ed.
(a) Expression PK2(A, B, R) in (1) indicates that attributes A and B form a primary key of R. (b) Predicate THREEATTR checks whether a relation has at least three attributes, and it is de ned as follows from the base predicate ATTR:

 least two attributes.
Notice that by combining this expression with PK2(A, B, R), we conclude that A, B are exactly the attributes of R. (c) Expressions FK1(A, R, C, S) and FK1(B, R, D, T ) in (1) indicate that A is the attribute of a foreign key in R that points to S and B is the attribute of a foreign key in R that points to T , respectively.
(d) Expressions R 6= S and R 6= T in (1) indicate that both S and T are different from relation R. (e) Predicate TWOFK checks whether an attribute of a relation is the attribute of two distinct foreign keys in that relation, and it is de ned as follows from the base predicate FK1:



 Thus, expressions  TWOFK(A, R) and  TWOFK(B, R) in (1) indicate that attribute A is not the attribute of two distinct foreign keys in R and B is not the attribute of two distinct foreign keys in R, respectively.
(f) Predicate ONEFK checks whether a pair of attributes of a relation are the attributes of a composite foreign key in that relation:

 Thus, expression  ONEFK(A, B, R) in (1) indicates that attributes A, B of R are not the attributes of a composite foreign key in R.
(g) Finally, predicate FKTO checks whether a relation with two attributes has incoming foreign keys:

 Thus, expression  FKTO(R) in (1) indicates that relation R does not have incoming foreign keys.
For instance, BINREL("ENROLLED", "SID", "CID", "STUDENT", "SID", "COURSE", "CID") holds in our example.
Note that there is no condition in the rule (1) that requires S and T to be different, allowing binary relations that have their domain equal to their range.
Also note that, for simplicity, we assume in the rule (1) that a binary relation R consists of only two attributes A and B.
However, this rule can be easily extended to deal with binary relations generated from many-to-many relationships between entities in an ER/UML diagram that have more than two attributes.
Identifying classes: In our context, a class is any relation that is not a binary relation.
That is, predicate CLASS is de ned by the following Datalog rules:

 In our example, CLASS("DEPT"), CLASS("STUDENT") and CLASS("COURSE") hold.
Identifying object properties: For every n   1, the following rule is used for identifying object properties that are generated from foreign keys: 3 OP2n(X1, .
.
.
, Xn, Y1, .
.
.
, Yn, S, T )   FKn(X1, .
.
.
, Xn, S, Y1, .
.
.
, Yn, T ),  ISBINREL(S)
 the de nition of DM, for every concrete relational database we will need only a  nite number of these rules.
This rule states that a foreign key represents an object property from the entity containing the foreign key (domain) to the referenced entity (range).
It should be noticed that this rule excludes the case of binary relations, as there is a special rule for this type of relations (see rule (1)).
In our example, OP2("CODE", "DID", "COURSE", "DEPT") holds as CODE is a foreign key in the table COURSE that references attribute DID in the table DEPT.
Identifying data type properties: Every attribute in a non-binary relation is mapped to a data type property:
 For instance, we have that DTP("NAME", "STUDENT") holds in our example, while DTP("SID", "ENROLLED") does not hold as ENROLLED is a binary relation.
We now de ne the rules that translates a relational database schema into an OWL vocabulary.
and data type properties We introduce a family of rules that produce IRIs for classes, binary relations, object properties and data type properties identi- ed by the mapping (which are stored in the predicates CLASS, BINREL, OPn and DTP, respectively).
Note that the IRIs generated can be later on replaced or mapped to existing IRIs available in the Semantic Web.
Assume given a base IRI base for the relational database to be translated (for example, "http://example.edu/db/"), and assume given a family of builtin predicates CONCATn (n   2) such that CONCATn has n+1 arguments and CONCATn(x1, .
.
.
, xn, y) holds if y is the concatenation of the strings x1, .
.
., xn.
Then by following the approach proposed in [5], DM uses the following Datalog rules to produce IRIs for classes and data type properties: CLASSIRI(R, X)   CLASS(R), CONCAT2(base, R, X) DTP_IRI(A, R, X)   DTP(A, R), CONCAT4(base, R, "#", A, X) for instance, http://example.edu/db/STUDENT is For and the STUDENT relation in our example, the IRI
 http://example.edu/db/STUDENT#NAME is the that for attribute NAME in the STUDENT relation (recall DTP("NAME", "STUDENT") holds in our example).
Moreover, DM uses the following family of Datalog rules to generate IRIs for object properties.
First, for object properties generated from binary relations, the following rules is used:

 CONCAT10(base, R, "#", A, ",", B, ",", C, ",", D, X) Thus, http://example.edu/db/ENROLLED#SID,CID,SID,CID is the IRI for binary relation ENROLLED in our example.
Second, for object properties generated from a foreign key consisting of n attributes (n   1), the following rule is used: OP_IRI2n(X1, .
.
.
, Xn, Y1, .
.
.
, Yn, S, T, X)   OP2n(X1, .
.
.
, Xn, Y1, .
.
.
, Yn, S, T ), CONCAT4n+4(base, S, ",", T, "#", X1, ",", .
.
.
, Xn 1, ",", Xn, ",", Y1, ",", .
.
.
, Yn 1, ",", Yn, X) that holds in our given

 Thus,

 http://example.edu/db/COURSE,DEPT#CODE,DID is generated to represented the fact that CODE is a foreign key in the table COURSE that references attribute DID in the table DEPT.
example, The following Datalog rules are used to generate the RDF representation of the OWL vocabulary.
First, a rule is used to collect all the classes: TRIPLE(U, "rdf:type", "owl:Class")  
 Predicate TRIPLE is used to collect all the triples of the RDF graph generated by the direct mapping DM.
Second, the following family of rules is used to collect all the object properties (n   1): TRIPLE(U, "rdf:type", "owl:ObjectProperty")   OPn(X1, .
.
.
, Xn, S, T ), OP_IRIn(X1, .
.
.
, Xn, S, T, U ) Third, the following rule is used to collect the domains of the object properties (n   1): TRIPLE(U, "rdfs:domain", W )   OPn(X1, .
.
.
, Xn, S, T ), OP_IRIn(X1, .
.
.
, Xn, S, T, U ), CLASSIRI(S, W ) Fourth, the following rule is used to collect the ranges of the object properties (n   1): TRIPLE(U, "rdfs:range", W )   OPn(X1, .
.
.
, Xn, S, T ), OP_IRIn(X1, .
.
.
, Xn, S, T, U ), CLASSIRI(T, W ) Fifth, the following rule is used to collect all the data type properties: TRIPLE(U, "rdf:type", "owl:DatatypeProperty")  
 The direct mapping DM generates three types of triples when translating a relational instance: Table triples, reference triples and literal triples [5].
Following are the Datalog rules for each one of these cases.
For table triples, DM produces for each tuple t in a relation R, a triple indicating that t is of type r. To construct these tuples, DM uses the following auxiliary rules:
 CLASS(R), PKn(A1, .
.
.
, An, R), VALUE(V1, A1, T, R), .
.
.
, VALUE(Vn, An, T, R), ROWIRIn(V1, .
.
.
, Vn, A1, .
.
.
, An, T, R, X)
 CLASS(R),  HASPKn(R),
 That is, TUPLEID(T, R, X) generates the identi er X of a tuple T of a relation R, which is an IRI if R has a primary key or a blank node otherwise.
Notice that in the preceding rules, predicate HASPKn is used to check whether a table R with n attributes has a primary key (thus,  HASPKn(R) indicates that R does not have a primary key).
Predicate HASPKn is de ned by the following n rules: HASPKn(X)   PKi(A1, .
.
.
, Ai, X) i   {1, .
.
.
, n}
 The following rule generates the table triples: Finally, the following rule is used to collect the domains of the data type properties: TRIPLE(U, "rdfs:domain", W )   TRIPLE(U, "rdf:type", W )  

 For example, the following is a table triple in our example:
 We now de ne the rules that map a relational database instance into RDF.
More speci cally, we  rst introduce a series of rules for generating IRIs, and then we present the Datalog rules that generate

 We introduce a family of predicates that produce IRIs for the tuples being translated, where we assume a given a base IRI base for the relational database (for example, "http://example.edu/db/").
First, DM uses the following Datalog rule to produce IRIs for the tuples of the relations having a primary key: ROWIRIn(V1, V2, .
.
.
, Vn, A1, A2, .
.
.
, An, T, R, X)   TRIPLE("http://example.edu/db/STUDENT#SID=1", "rdf:type", "http://example.edu/db/STUDENT") For reference triples, DM generates triples that store the references generated by binary relations and foreign keys.
More precisely, the following Datalog rule is used to construct reference triples for object properties that are generated from binary relations:





 PKn(A1, A2, .
.
.
, An, R), VALUE(V1, A1, T, R), VALUE(V2, A2, T, R), .
.
.
, VALUE(Vn, An, T, R), CONCAT4n+2(base, R, "#", A1, "=", V1, ",", A2, "=", V2, ",", .
.
.
, ",", An, "=", Vn, X) Moreover, the following Datalog rule is used to construct reference triples for object properties that are generated from foreign keys (n   1):
 the facts PK1("SID", "STUDENT") and Thus, given that VALUE("1", "SID", "id1", "STUDENT") hold in our example, the IRI http://example.edu/db/STUDENT#SID=1 is the identi er for the tuple in table STUDENT with value 1 in the primary key.
Moreover, DM uses the following rule to generate blank nodes for the tuples of the relations not having a primary key:

 OP2n(A1, .
.
.
, An, B1, .
.
.
, Bn, S, T ), VALUE(V1, A1, T1, S), .
.
.
, VALUE(Vn, An, T1, S), VALUE(V1, B1, T2, T ), .
.
.
, VALUE(Vn, Bn, T2, T ),
 OP_IRI2n(A1, .
.
.
, An, B1, .
.
.
, Bn, S, T, V ) Finally, DM produces for every tuple t in a relation R and for every attribute A of R, a triple storing the value of t in A, which is called a literal triple.
The following Datalog rule is used to generate such triples:
 Notice that in the above rule, we use the condition W 6= NULL to check that the value of the attribute A in a tuple T in a relation R is not null.
Thus, literal triples are generated only for non-null values.
The following is an example of a literal triple: TRIPLE("http://example.edu/db/STUDENT#SID=1", "http://example.edu/db/STUDENT#NAME", "John")

 We now study our direct mapping DM with respect to the two fundamental properties (information preservation and query preservation) and the two desirable properties (monotonicity and semantics preservation) de ned in Section 3.
First, we show that DM does not lose any piece of information in the relational instance being translated: Theorem 1 The direct mapping DM is information preserving.
The proof of this theorem is straightforward, and it involves providing a computable mapping N : G   I that satis es the condition in De nition 2, that is, a computable mapping N that can reconstruct the initial relational instance from the generated RDF graph.
Second, we show that the way DM maps relational data into RDF allows one to answer a query over a relational instance by translating it into an equivalent query over the generated RDF graph.
Theorem 2 The direct mapping DM is query preserving.
In [4], it was proved that SPARQL has the same expressive power as relational algebra.
Thus, one may be tempted to think that this result could be used to prove Theorem 2.
However, the version of relational algebra considered in [4] does not include the null value NULL, and hence cannot be used to prove our result.
In addition to this, other researchers have addressed the issue of querying answering on DL ontologies with relational databases [21].
Our work is similar in the sense that we address the issue of query preservation between a database and an ontology.
However, the main difference is that rather than a domain ontology, the ontology we use is synthesized in a standard way from the database schema.
Therefore, their results cannot be directly applied to our setting.
We present an outline of the proof of this theorem, and refer the reader to [19] for the details.
Assume given a relational schema R and a set   of PKs and FKs over R. Then we have to show that for every relational algebra query Q over R, there exists a SPARQL query Q  such that for every instance I of R (possibly including null values) satisfying  : For the sake of readability, we introduce a function   that retrieves the IRI for a given relation R, denoted by  (R), and the IRI for a given attribute A in a relation R, denoted by  (A, R).
The inductive proof starts by considering the two base relational algebra queries: the identity query R, where R is a relation name in the relational schema R, and the query NULLA.
These two base queries give rise to the following three base cases for the inductive proof.
Non-binary relations: Assume that Q is the identity relational algebra query R, where R   R is a non-binary relation (that is, ISBINREL(R) does not hold).
Moreover, assume that att(R) = {A1, .
.
.
, A }, with the corresponding IRIs  (R) = r,  (A1, R) = a1, .
.
.
,  (A , R) = a .
Then a SPARQL query Q  satisfying (2) is constructed as follows: SELECT {?A1, .
.
.
, ?A }        (?X, "rdf:type", r) OPT (?X, a1, ?A1)  OPT (?X, a2, ?A2)  OPT (?X, a3, ?A3)        OPT (?X, a , ?A ) .
Notice that in order to not lose information, the operator OPT is used (instead of AND) because the direct mapping DM does not translate NULL values.
In our example, the relation name STUDENT is a non-binary relation.
Therefore the following equivalent SPARQL query is generated with input STUDENT: SELECT {?SID, ?NAME}  (?X, "rdf:type", :STUDENT)

 It should be noticed that in the previous query, the symbol : has to be replaced by the base IRI used when generating IRIs for relations and attributes in a relation (see Section 4.3.1) 4.
Binary relations: Assume that Q is the identity relational algebra query R, where R   R is a binary relation (that is, ISBINREL(R) holds).
Moreover, assume that att(R) = {A1, A2}, where A1 is a foreign key referencing the attribute B of a relation S, and A2 is a foreign key referencing the attribute C of a relation T .
Finally, assume that  (R) = r,  (B, S) = b and  (C, T ) = c, Then a SPARQL query Q  satisfying (2) is de ned as follows: SELECT {?A1, ?A2} ((?T1, r, ?T2) AND (?T1, b, ?A1) AND (?T2, c, ?A2)).
Given that a binary relation is mapped to an object property, the values of a binary relation can be retrieved by querying the datatype properties of the referenced attributes.
In our example, the relational name ENROLLED is a binary relation.
Therefore the following equivalent SPARQL query is generated with input ENROLLED: tr(JQKI ) = JQ KDM(R, ,I).
(2)
 Interestingly, the proof that the previous condition holds is by induction on the structure of Q, and thus it gives us a bottom-up algorithm for translating Q into an equivalent SPARQL query Q , that is, a query Q  satisfying condition (2).
In what follows, we consider the database used as example in Section 4 and the relational algebra query  Name=Juan(STUDENT)   ENROLLED, which we will use as a running example and translate it step by step to SPARQL, showing how the translation algorithm works.
in the query: @prefix : <http://example.edu/db/>, if the base IRI is <http://example.edu/db/>.
the empty graph pattern { }.
Then we have that condition (2) holds because of the de nition of the function tr, which does not translate NULL values to mappings.
We now present the inductive step in the proof of Theorem 2.
Assume that the theorem holds for relational algebra queries Q1 and Q2.
That is, there exists SPARQL queries Q  2 such that:
 tr(JQ1KI ) = JQ  tr(JQ2KI ) = JQ 



 (3) (4) The proof continues by presenting equivalent SPARQL queries for the following relational algebra operators: selection ( ), projection ( ), rename ( ), join ( ), union ( ) and difference (r).
It is important to notice that the operators left-outer join, right-outer join and full-outer join are all expressible with the previous operators, hence we do not present cases for these operators.
Selection: We need to consider four cases to de ne query Q  satisfying condition (2).
In all these cases, we use the already established equivalence (3).
These equivalences are straightforward.
However, it is important to note the use of bound( ) in the second case; as the semantics of relational algebra states that if Q is the query  A16=a(Q1), then JQKI = {t   JQ1KI | t.A1 6= NULL and t.A1 6= a}, we have that the variable ?A1 has to be bound because the values in the attribute A1 in the answer to  A16=a(Q1) are different from NULL.
Following our example, we have that the following SPARQL query is generated with input  Name=Juan(STUDENT):   SELECT {?SID, ?NAME}  (?X, "rdf:type", :STUDENT)

 FILTER (?NAME = Juan) =
 It is important Assume that Q satisfying condition (2)  {A1,...,A }(Q1).
Projection: Then query Q  is de ned as (SELECT {?A1, .
.
.
, ?A } Q  to notice that we use nested SELECT queries to deal with projection, as well as in two of the base cases, which is a functionality speci c to
 Rename: Assume that Q =  A1 B1 (Q1) and att(Q) = {A1, .
.
., A }.
Then query Q  satisfying condition (2) is de ned as (SELECT {?A1 AS ?B1, ?A2, .
.
.
, ?A } Q 
 equivalence holds because the rename operator in relational algebra renames one attribute to another and projects all attributes of Q.
Join: Assume that Q = (Q1   Q2), where (att(Q1) att(Q2)) = {A1, .
.
.
, A }.
Then query Q  satisfying condition (2) is de ned as follows:



 Note the use of bound( ) which is necessary in the SPARQL query in order to guarantee that the variables that are being joined on are not null.
Following our example, Figure 1 shows the SPARQL query generated with input  Name=Juan(STUDENT)  
 Union: Assume that Q = (Q1   Q2).
Then query Q  satisfying condition (2) is simply de ned as (Q 
 in this case we are using the already established equivalences (3) and (4).
Difference: We conclude our proof by assuming that Q = (Q1 r Q2).
In this case, it is also possible to de ne a SPARQL query Q  satisfying condition (2).
Due to the lack of space and the complex structure of this query, we refer the reader to [19] for its complete description.
of DM Finally, we consider the two desirable properties identi ed in Section 3.2.
First, it is straightforward to see that DM is monotone, because all the negative atoms in the Datalog rules de ning DM refer to the schema, the PKs and the FKs of the database, and these elements are kept  xed when checking monotonicity.
Unfortunately, the situation is completely different for the case of semantics preservation, as the following example shows that the direct mapping DM does not satisfy this property.
Example 2 Assume that a relational schema contains a relation with name STUDENT and attributes SID, NAME, and assume that the attribute SID is the primary key.
Moreover, assume that this relation has two tuples, t1 and t2 such that t1.SID = 1, t1.NAME = John and t2.SID = 1, t2.NAME = Peter.
It is clear that the primary key is violated, therefore the database is inconsistent.
However, it is not dif cult to see that after applying DM, the resulting RDF graph is consistent.
In fact, the result in Example 2 can be generalized as it is possible to show that the direct mapping DM always generates a consistent RDF graph, hence, it cannot be semantics preserving.
Proposition 1 The direct mapping DM is not semantics preserving.
Does this mean that our direct mapping is incorrect?
What could we do to create a direct mapping that is semantics preserving?
These problems are studied in depth in the following section.
We now study the problem of generating a semantics-preserving direct mapping.
Speci cally, we show in Section 6.1 that a simple extension of the direct mapping DM can deal with primary keys.
Then we show in Section 6.2 that dealing with foreign keys is more dif cult, as any direct mapping that satis es the condition of being monotone cannot be semantics preserving.
Finally, we present two possible ways of overcoming this limitation.
(?X, :STUDENT#NAME, ?NAME)  FILTER (?NAME = Juan)  FILTER (bound(?SID)) 

 (?T2, :COURSE#CID, ?CID)  FILTER (bound(?SID))  Figure 1: SPARQL translation of the relational algebra query  Name=Juan(STUDENT)   ENROLLED.
primary keys Recall that a primary key can be violated if there are repeated values or null values.
At a  rst glance, one would assume that owl:hasKey could be used to create a semantics preserving direct mapping for primary keys.
If we consider a database without null values, a violation of the primary key would generate an inconsistency with owl:hasKey and the unique name assumption (UNA).
However, if we consider a database with null values, then owl:hasKey with the UNA does not generate an inconsistency because it is trivially satis- ed for a class expression that does not have a value for the datatype expression.
Therefore, we must consider a different approach.
Consider a new direct mapping DMpk that extends DM as follows.
A Datalog rule is used to determine if the value of a primary key attribute is repeated, and a family of Datalog rules are used to determine if there is a value NULL in a column corresponding to a primary key.
If some of these violations are found, then an arti- cial triple is generated that would produce an inconsistency.
For example, the following rules are used to map a primary key with two attributes: TRIPLE(a, "owl:differentFrom", a)   PK2(X1, X2, R),

 TRIPLE(a, "owl:differentFrom", a)   PK2(X1, X2, R),
 TRIPLE(a, "owl:differentFrom", a)   PK2(X1, X2, R),
 In the previous rules, a is any valid IRI.
If we apply DMpk to the database of Example 2, it is straightforward to see that starting from an inconsistent relational database, one obtains an RDF graph that is also inconsistent.
In fact, we have that: Proposition 2 The direct mapping DMpk is information preserving, query preserving, monotone, and semantics preserving if one considers only PKs.
That is, for every relational schema R, set   of (only) PKs over R and instance I of R: I |=   iff DMpk(R,  , I) is consistent under OWL semantics.
Information preservation, query preservation and monotonicity of DMpk are corollaries of the fact that these properties hold for DM, and of the fact that the Datalog rules introduced to handle primary keys are monotone.
A natural question at this point is whether DMpk can also deal with foreign keys.
Unfortunately, it is easy to construct an example that shows that this is not the case.
Does this mean that we cannot have a direct mapping that is semantics preserving and considers foreign keys?
We show in the following section that monotonicity has been one of the obstacles to obtain such a mapping.
primary keys and foreign keys The following theorem shows that the desirable condition of being monotone is, unfortunately, an obstacle to obtain a semantics preserving direct mapping.
Theorem 3 No monotone direct mapping is semantics preserving.
It is important to understand the reasons why we have not been able to create a semantics preserving direct mapping.
The issue is with two characteristics of OWL: (1) it adopts the Open World Assumption (OWA), where a statement cannot be inferred to be false on the basis of failing to prove it, and (2) it does not adopt the Unique Name Assumption (UNA), where two different names can identify the same thing.
On the other hand, a relational database adopts the Closed World Assumption (CWA), where a statement is inferred to be false if it is not known to be true.
In other words, what causes an inconsistency in a relational database, can cause an inference of new knowledge in OWL.
In order to preserve the semantics of the relational database, we need to ensure that whatever causes an inconsistency in a relational database, is going to cause an inconsistency in OWL.
Following this idea, we now present a non-monotone direct mapping, DMpk+fk, which extends DMpk by introducing rules for verifying beforehand if there is a violation of a foreign key constraint.
If such a violation exists, then an arti cial RDF triple is created which will generate an inconsistency with respect to the OWL semantics.
More precisely, the following family of Datalog rules are used in DMpk+fk to detect an inconsistency in a relational database:
 FKn(X1, .
.
.
, Xn, S, Y1, .
.
.
, Yn, T ), VALUEn(V1, X1, T, S), .
.
.
, VALUE(Vn, Xn, T, S), V1 6= NULL, .
.
.
, Vn 6= NULL,  ISVALUEn(V1, .
.
.
, Vn, Y1, .
.
.
, Yn, T ) In the preceding rule, the predicate ISVALUEn is used to check whether a tuple in a relation has values for some given attributes.
The predicate ISVALUEn is de ned by the following rule: ISVALUEn(V1, .
.
.
, Vn, B1, .
.
.
, Bn, S)   VALUE(V1, B1, T, S), .
.
.
, VALUE(Vn, Bn, T, S) Finally, the following Datalog rule is used to obtain an inconsistency in the generated RDF graph: TRIPLE(a, "owl:differentFrom", a)   VIOLATION(S) In the previous rule, a is any valid IRI.
It should be noticed that DMpk+fk is non-monotone because if new data in the database is added which now satis es the FK constraint, then the arti cial RDF triple needs to be retracted.
