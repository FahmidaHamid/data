Are you looking for a house?
Are you tired of  lling registration forms with your search criteria on the websites of hundreds of local agencies?
You fear to miss the site with the very best offer?
Wouldn t you wish to automatize these tiresome tasks?
Web forms  The research leading to these results has received funding from the European Research Council under the European Community s Seventh Framework Programme (FP7/2007 2013) / ERC grant agreement DIADEM no.
246858.
Giorgio Orsi has been supported by the Oxford Martin School, Institute for the Future of Computing.
Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
are the gates of all these websites.
Gates designed for human admission, leaving programs in the conundrum of web design ambiguity: Even web forms within a single domain denote search criteria differently, e.g.,  address ,  city ,  town , and  neighborhood  all refer to locations, while other terms denote different criteria ambiguously, e.g.,  tenure  might refer to the choice either between  freehold  vs.  leasehold  or between  buy  vs.  rent .
Moreover, web forms present their criteria in different manners, e.g., for a choice among several options, a form may contain either a drop-down lists or a set of radiobuttons.
Automatically understanding these variants is key for programs to pass these gates as needed by a broad range of applications: crawling and surfacing the deep web [14, 10, 5], classifying the domain of web databases [2] for web site classi cation, sampling the contents of web databases [11,
 neering, automated form understanding contributes e.g.
to web accessibility and usability [7], web source integration [6], automated testing on form-related web applications.
(3) Heuristics are translated into monolithic algorithms limiting maintainability and adaptability.
For example, [15] and [13] encode speci c assumptions on the spatial distance and alignment of  elds and labels, [8] employs hard-coded token classes for certain concepts such as  min ,  from  vs.  max ,  to .
To overcome these limitations, we present OPAL (ontology based web pattern analysis with logic), a domain-aware form understanding system that combines visual, textual, and structural features with a thin layer of domain knowledge.
The visual, textual, and structural features are used in a domain-independent analysis to produce a highly accurate form labeling.
However, for most applications what is actually needed is a form model consistent with a given domain schema, where all the  elds are associated with given types.
In OPAL, the domain schema is not only used to classify the Form understanding has attracted a number of approaches [16,
 observations on common features of web forms (in general, across domains) into speci cally tailored algorithms and heuristics, but generally suffer from three major limitations: (1) Most approaches are domain independent and thus limited to observations that hold for forms across all domains.
This limitation is acknowledged in [16, 13, 8], but addressed only through domain speci c training data, if at all.
Our evaluation supports [8] in that a set of generic design rules underlies all domains, but that spe-ci c domains parameterise or adapt these design patterns in ways uncommon to other domains.
(2) Most approaches are limited in the classes of features they use in their heuristics and often based on a single sophisticated heuristics based on one class of features, e.g., only visual features [6] or textual and  eld type features in [8].
(b) form (c)  eld labeling (d) segment labeling (e) classi cation Figure 1: OPAL on Colin Mason  elds and segments of the form model, but also to improve the form model based on a set of structural constraints that describe typical  elds and their arrangement in forms of the domain, e.g., how price ranges are presented in forms.
To ease the development of these domain schemata, OPAL extends Datalog, a staple for declarative ontology and schema speci cation, with templates to enable reuse of generic form, e.g., how ranges (of any type) are presented in forms.
With this approach, OPAL achieves nearly perfect analysis results (> 98% accuracy).
Contributions.
OPAL s main contributions are: (1) Multi-scope domain-independent analysis (Section 3) that combines structural, textual, and visual features to associate labels with  elds into a form labeling using three, sequential  scopes  increasing the size of the neighbourhood from a subtree to everything visually to the left and top of a  eld.
(i) At  eld scope, we exploit the structure of the page between  elds and labels; (ii) at segment scope, observations on  elds in groups of similar  elds, and (iii) at layout scope, the relative position of  elds and texts in the visual rendering of the page.
We impose a strict preference on these scopes to disambiguate competing labelings and to reduce the number of  elds considered in later scopes, as the complexity of the analysis increases from earlier to latter scopes (though overall bounded by O(n2) where n is the page size).
(2) Domain awareness.
(Section 4) OPAL is domain-aware while being as domain-independent as possible without sacri cing accuracy.
This is based on the observation that generic rules contribute signi cantly to form understanding, but nearly perfect accuracy is only achievable through a thin layer of domain knowledge.
To this end, we add an optional, domain-dependent classi cation and form model repair stage after the domain-independent analysis.
Driven by a domain schema OPAL classi es form  elds based on textual annotations of their labels and values assigned in the domain-independent form labeling, as well as the structure of that form labeling.
This classi cation is often imperfect due to missing or misunderstood labels.
OPAL addresses this in a repair step, where structural constraints on the domain types, such as price, are used to disambiguate and complete the classi cation and reshape the form segmentation.
(3) Template Language OPAL-TL.
(Section 4.1) To specify a domain schema, we introduce OPAL-TL.
It extends Datalog to express common patterns as parameterizable templates, e.g., describing a group consisting of a minimum and maximum  eld for some domain type.
Together with some convenience features for annotation queries and access to the  eld labeling, OPAL-TL allows for very compact, declarative speci cation of domain schemata.
We also provide a template library of common phenomena, such that the adaption to new domains often requires only instantiating these templates with domain speci c types.
OPAL-TL preserves the polynomial data complexity of Datalog.
(4) Extensive Evaluation.
(Section 5) In an evaluation on over
 highly accurate (>93%) form labelings for any domain and, with a suitable domain schema, near perfect accuracy in form classi cation (> 98%).
To compare with existing approaches (which only perform form labeling), we show that OPAL s domain-independent analysis achieves 94  100% accuracy on the ICQ benchmark and
 outperforms existing approaches by at least 5%.
At [17], we presented a preliminary version of OPAL, only demonstrating the relevance of the domain awareness, for a single domain with a limited ontology, not only lacking OPAL-TL but also missing the visual analysis, and the extensive evaluation we provide now.
We present the OPAL approach to form understanding using the form from the UK real estate agency Colin Mason (cmea.co.uk/ properties.asp).
Figure 1a presents the web page with its sim-pli ed CSS box model.
The page contains two forms: one for detailed search and the other for quick search.
OPAL is able to identify, separate, label, and classify both forms correctly yielding two real-estate form models.
The following discussion focuses on the detailed search form (Figure 1b), in which each of the components (1)-(10), each of the  elds (3)-(7) and the two groups of checkboxes in (2) are enclosed in a table, tr, or td element.
Labels for each of the components such as  Bedrooms:  appear in separate tr s.
Field scope.
(Section 3.1) OPAL starts by analysing individual  elds assigning labels that explicit reference the  eld (using the for attribute) or have a common ancestor that has no other  elds as descendant.
In our example, no explicit references occur, but the second approach correctly labels all  elds except the checkboxes in (2).
In Figure 1c we show this initial form labeling using same color for  elds and their labels.
Segment scope.
(Section 3.2) We increase the scope of the anal-ments.
OPAL constructs these segments from the HTML structure, but eliminates segments that likely have no semantic relevance and are only introduced, e.g., for formatting reasons.
This elimination is primarily based on similarity between elements approximated via semantic attributes such as class and visual similarity.
In our example, components (2)-(7) become segments, with (2) further divided into two segments for each of the vertical checkbox groups.
In each of the segments, OPAL identi es repeated patterns of interleaving  elds and texts.
Here, each check box in (2) is labeled with the text appearing after it as shown in Figure 1d.
OPAL also associates text nodes to segments to create segment labels.
Segment labels can be useful to verify the form model and to classify  elds that have no labels otherwise.
In this example, OPAL assigns the text in bold face appearing atop each segment as the label, e.g.,  Price:  becomes the label for (4).
Layout scope.
(Section 3.3) In the layout scope, OPAL further enlarges the scope of the analysis to all  elds visually to the left and above a  eld.
The primary challenge in this scope is  overshadowing , i.e., if other  elds appear to in the quadrants to the left and above a  eld.
In this example the layout scope is not needed.
The result of the layout scope is the form labeling derived without using domain knowledge.
Domain scope.
If a classi cation and semantic grouping of the form  elds is desired, the  nal step in OPAL produces a form model that is consistent with a given domain schema.
It uses domain knowledge to classify and verify the labeling and segmentation from the form labeling.
In the classi cation step, OPAL annotates  elds and segments with types based on annotation on the text labels.
The veri cation step repairs and veri es the domain model if needed.
For both steps, OPAL uses constraints speci ed in OPAL-TL.
These constraints model typical patterns of forms in the domain.
E.g., the  rst  eld in (4) is classi ed as MIN_PRICE as we recognise this segment as an instance of a price range pattern.
These constraints also disambiguate between multiple annotations, e.g.,  elds in (6) are annotated with order_by and price, but the price annotation is disregarded due to the group label.
Even without the group label, price would be disregarded as the domain schema give precedence to order_by over price due to the observation that if both occur as labels of a  eld, that  eld will likely be about the order of the returned results rather than about the actual price.
In this case, only one repair is performed: We collapse the two checkbox segments in (2) as they are the only children of their parent segment and both of the same type.
Figure 1e shows the  nal  eld classi cation as produced by OPAL.
OPAL constructs a conceptual model of a form consistent with a domain schema.
A domain schema describes the form patterns occurring in a given domain, such as the UK real estate domain.
OPAL divides the general form understanding problem into form labeling and form interpretation.
The form labeling identi es forms and their  elds, arranges the  elds into a tree, and labels the found  elds, segments, and forms with text nodes from the page.
The form interpretation aligns a form labeling with the given domain schema and thereby classi es the form  elds based on their labels.
Form Labeling.
A web page is a DOM tree P =(cid:0)(U)U Unary, (cid:1) where (U)U Unary are unary type and label Rchild,Rnext-sibl,Rattribute relations, Rchild is the parent-child, Rnext-sibl the direct next sibling, and Rattribute the attribute relation.
Further XPath relations (such as descendant) are derived from these basic relations as usual [3].
U contains relations for types as in XPath (element, text, attribute, etc.)
and two kinds of label relations, namely labell for text nodes containing string l, and boxb for elements with bounding box b in the canonical rendering of the page.
To normalize the representation of textual content, we represent the value of an attribute as text child node of the attribute (thus, labell also applies to attributes).
DEFINITION 1.
A form labeling of a web page P is a tree F with mappings   and  , such that   maps the nodes of F into P. Leafs in F are mapped to form  elds and inner nodes to form segments, that is an element grouping a set of  elds.
Each node n in F is also mapped to a set  (n) of text nodes, the labels of n.
A node can be labeled with no, one, or many labels.
The form labeling contains a representative for each form.
A representative contains all  elds (and segments) of that form.
This allows us to distinguish multiple forms on a single page, even if no form element is present or multiple forms occur in a single form element.
DEFINITION 2.
Given a DOM tree P, the form labeling problem (or schema-less form understanding problem) asks for a form labeling F where for each form f in P (i) there is a node r   F such that   (r) is a suitable representative of f and (ii) for each  eld e in f , there exists a leaf node ne   F such that ne is a descendant of r and   (ne) = e where  (ne) is a suitable label set for e.
We call a form labeling complete for a web page, if, for all e,  (ne) contains all text nodes suitable as labels for e and de ne the corresponding complete form labeling problem.
The suitability of a form representative   (r) and a label set  (ne) cannot be de ned formally, but needs to be evaluated by human annotators.
Our evaluation (Section 5) shows that OPAL produces form labelings Ff that match the gold standard in nearly all cases (> 95% without using any domain knowledge).
Form Interpretation.
To de ne the form interpretation problem, we formalize the notion of schema and introduce a form model as a form labeling extended with type information consistent with a given domain schema.
First, we de ne an annotation schema that provides the necessary knowledge to interpret text nodes.
DEFINITION 3.
An annotation schema   =(cid:0)A, <, , (isLabela, isValuea : a   A)(cid:1) de nes a set A of annotation types, a transitive, re exive subclass relation <, a transitive, irre exive, antisymmet-ric precedence relation  , and two characteristic functions isLabela and isValuea on text nodes for each a   A.
For each annotation type a   A, we distinguish proper labels and values, with isLabela and isValuea as corresponding characteristic functions.
Proper labels are text nodes, such as  Price: , describing the  eld type, values, such as  more than  500 , contain possible values of the  eld.
Hence isLabelprice( Price: ) and isValueprice( more than  500 ) hold.
The < relation holds for subtypes, e.g., postcode < location, and the   relation de nes precedence on annotation types used to disambiguate competing annotations.
For example, an unlabeled select box with options  Choose sorting order ,  By price , and  By postcode  is annotated with order-by, price, and postcode.
If order-by   price and order-by   postcode, we pick order-by.
DEFINITION 4.
A domain schema   = ( ,T ,CT ,C ) de nes an annotation schema  , a set of domain types T , and CT and C  that map domain types to classi cation and structural constraints.
For example, C (PRICE) requires an annotation price and prohibits order-by annotations for a  eld to be typed as PRICE.
The structural constraint set CT (PRICE-RANGE) for a PRICE-RANGE segment requires a MIN-PRICE and MAX-PRICE  eld or a PRICE-RANGE  eld.
We while n has a parent do Algorithm 1: FieldScopeLabelling(DOM P)





 if n is already coloured then colour n red; break; colour n orange; n   parent of n;

 n   new leaf node in F;
   (n)   f ;
 if  l   P with for attribute referencing f then

 assign all text node descendants of l as labels to n ; p   parent of f ; while p not coloured red do f   p; p   parent of f ;



 assign all text node descendants of f as labels to n ; Finally, in the (4) domain scope (Section 4) we turn the form labeling produced by the  rst three scopes into a form model consistent with a given domain schema.
(i) The labeling model is extended with (domain-speci c) annotations on the textual content of proper labels and values.
(ii) Fields and segments of the form labeling are classi ed according to classi cation constraints in the domain schema.
(iii) Finally, violations of structural schema constraints are repaired in a top-down fashion.
Types and constraints of the domain schema are speci ed using OPAL-TL, an extension of Datalog that combines easy querying of the form labeling and of annotations with a rich template system.
Datalog rules already ease the reuse of common types and their constraints, but the template extension enables the formulation of generic templates for such types and constraints that are instantiated for concrete types of a domain.
An example of a type template is the range template, that describes typical patterns for specifying range values in forms.
In the real estate domain it is instantiated, e.g., for price and various room ranges.
In the used car domain, we also  nd ranges for engine size, mileage, tax band, etc.
Thus, creating a domain schema is in many cases as easy as importing common types and instantiating templates.
In OPAL, form labeling is split into three scopes.
Each scope is focused on a particular class of input features (e.g., visual, structural, textual).
By combining form labeling approaches for these different features, OPAL captures the diverse range of form design patterns and eases extensions, such as the introduction of new scopes that future web design trends might require.
This contrasts with previous approaches that rely on one or two such feature classes.
The form labeling scopes,  eld, segment, and layout scope, use domain-independent labeling techniques to associate form  elds or segments with textual labels, building a form labeling F. If a domain schema is available, the form labeling is extended to a form model in the domain-dependent analysis (Section 4).
The form labeling F is constructed bottom-up, applying each scope s technique in sequence to yet unlabelled  elds.
Whenever a  eld is labelled at a certain scope level, further scopes do not consider this  eld again.
This application order re ects higher con -dence in earlier scopes and addresses competing label assignments.
Based on the DOM tree of the input page, the  eld scope assigns text nodes in unique structural relation to individual  elds as labels to these  elds (see Algorithm 1).
To that end, OPAL (1) colours Figure 2: OPAL Overview write S |= C, if a constraint set C is satis ed by a set S of annotation or domain types.
The empty constraint set is always satis ed.
Formally, a form interpretation (F, ) is a form labeling F with a partial type-of relation  , relating nodes in F with the types T of  .
Given a node n in F, we denote with A(n) = {a   A  :  l   sociated with n via its labels, and with child-T (n) =(cid:83)  (n) with isValuea(l) or isLabela(l)} the set of annotation types as-(n,n(cid:48)) F  (n(cid:48)) the set of domain types of the children of n.
DEFINITION 5.
A form interpretation (F, ) is a form model for  , iff A(n) |= C (t) and child-T (n) |= CT (t) for all n   F, t    (n).
DEFINITION 6.
Given a domain schema   and a form labeling F, the form interpretation problem asks for a form model (F(cid:48), ) for   such that F(cid:48) differs from F only in inner nodes.
Thus, form representatives,  elds, and labels are shared between F and F(cid:48), but the form segments may be rearranged to conform with form patterns prescribed by the structural constraints of  .
Form Understanding DEFINITION 7.
Given a domain schema   and a DOM tree P, the form understanding (or schema-based form understanding) problem asks for a form model (F, ) of P under  , such that F is a solution of the complete form labeling problem for P and for each form  eld e in P, there is a leaf node ne in F with   (ne) = e and  (ne) is a suitable concept from   for e.
OPAL is divided in two parts, a domain-independent part to address the form labeling problem and a domain-dependent part for form interpretation according to a domain schema.
OPAL produces form labelings in a novel multi-scope approach that incrementally constructs a form labeling combining textual, structural, and visual signals (Figure 2).
Each of the three labeling scopes considers signals not considered in prior scopes: (1) In  eld scope, we consider only  elds and their immediate neighbourhood and thus use only the DOM tree as input.
(2) In segment scope, we detect and arrange form segments into a segment tree to interleave the contained text nodes and  elds.
(3) In layout scope, we broaden the potential labels of a  eld by searching in the layout tree, i.e., the visual rendering of the page, and assign text nodes to  elds, given a strong visual relation.
Each scope builds on the partial form labeling of the previous scope and uses the information from the additional input to  nd labels for previously unlabeled  elds (or segments).
Only the segment scope adds nodes, namely form segments, whereas  eld and layout scope only add labels.
Form LabelingForm ModelDOM treeSegment treeLayout treeSchema treeSegment ScopeLayout ScopeDomain ScopeInputOutputField ScopeField ScopeWWW 2012   Session: Web Engineering 1April 16 20, 2012, Lyon, France8323 Algorithm 2: SegmentTree(DOM P),   (cid:54)  n for any n

 delete n and all incident edges from P(cid:48); delete n from P(cid:48) and move its child to the parent of n;








 C   { f : Rchild( f ,n)   P(cid:48)   f is a  eld}; C   C {Representative(n(cid:48)) : Rchild(n(cid:48),n)   P(cid:48)}} ; choose r   C arbitrarily ; if  r(cid:48)   C : r   r(cid:48) then Representative(n)   r; delete all non eld children of n and move their children to n; else Representative(n)     ;

 (lines 1 6) all nodes in P that are ancestors of a  eld and do not have other form  elds as descendants in orange.
The least ancestor that violates that condition is coloured red.
(2) It identi es (line
 leaf node for each such  eld.
(3) It considers (lines 11 12) explicit HTML label elements with direct reference to a form  eld.
(4) It labels (lines 13 16) each  eld f with all text nodes t whose least common ancestor with f has no other form  eld as descendant.
This includes all text nodes in the content of f .
We  nd these text nodes in linear time with the tree colouring.
Each value v of a  eld f (in select, input, or textarea element) becomes a label for f , as the least common ancestor of f and v is f .
At segment scope, the labeling analysis expands from individual  elds to form segments, i.e., groups of consecutive  elds with a common parent.
These segments are then used to distribute text nodes to unlabeled  elds in that segment.
Segmentation tree.
We observe that the DOM is often a fair approximation of the semantic form structure, as it re ects the way the form author grouped  elds into segments.
Therefore, we start from the DOM structure to  nd the form segments, but we eliminate all nodes that can be safely identi ed as super ous: nodes without  eld descendants, nodes with only one child, and nodes n where all  elds in n are style-equivalent to the  elds in the siblings of n. Two  elds are style-equivalent ( ) if they carry the same class attribute (used to indicate a formatting or semantic class) or the same type attribute and CSS style information.
If all  eld descendants of the parent of an inner node n are style-equivalent, then n should be eliminated from the segment tree, as it arti cially breaks up the sequence of style-equivalent  elds and is thus referred to as equivalence breaking.
(1) (cid:12)(cid:12){c   P(cid:48) : Rchild(c,n)}(cid:12)(cid:12) > 1, DEFINITION 8.
The segment tree P(cid:48) of a form page P is the maximal DOM tree included in P (i.e., obtained by collapsing nodes) such that the leafs of P(cid:48) are all  elds and for all its inner nodes n (2)  d   P(cid:48) : Rdescendant(d,n)  d is a  eld, and (3) n is not equivalence breaking.
As an example, consider the DOM tree on the left of Figure 3, where diamonds represent  elds and style-equivalent  elds carry the same colour.
On the right hand side, we show OPAL s segment tree for that DOM.
Nodes 1 and 3 from the original DOM are eliminated as they have only one child, and node 2 as it is equivalence breaking.
Nodes 4 and 5 are retained due to the red  eld.
THEOREM 1.
The segment tree P(cid:48) of a DOM tree P can be computed in O(n  d) where n is the size and d the depth of P.
Figure 3: Example DOM and Segment Tree Algorithm 3: SegmentScopeLabeling(DOM P,Form Labeling F)












 create a new segment ns in F;   (ns)   s; create an edge (ns,cs) in F for every   (cs) child of s; Nodes, Labels   new List(); textGrp   /0 ; foreach c : Rdescendant(c,  (n))   P in document order do if textGrp (cid:54)= /0 then Labels.add(textGrp); textGrp   /0; Nodes.add(c); skip all descendants of c in the iteration ; if   f   F :   ( f ) = c then







 else if c is a text node   (cid:54)  d   F : c    (d) then textGrp   textGrp {c}; if textGrp (cid:54)= /0 then Labels.add(textGrp); textGrp   /0; if Labels.size() = Nodes.size() + 1 then add Labels[0] to  (n); delete Labels[0] from Labels; if Labels.size() = Nodes.size() then foreach i do add Labels[i] to  (Nodes[i]); PROOF.
Algorithm 2 computes the segment tree P(cid:48) for any DOM tree P. Its leafs are  elds (as any non  eld leafs are eliminated in line 2 3) and any inner node must have more than 1 child (due to line 4 5), a  eld descendant (due to line 2 3), and not be equivalence breaking (due to lines 6 13).
In lines 6 13, we compute a Representative for each inner node in a bottom-up fashion: If all  eld children (line 7) and the representatives of all inner children (line 8) are style-equivalent (line 9 10; since   is an equivalence relation it suf ces to compare a representative to each of the elements in C), we choose an arbitrary representative and collapse all inner children of that node.
Otherwise, we assign   as representative, which is not style-equivalent to any node or to itself.
Thus it prevents this node (and its ancestors) from ever being collapsed.
This can not introduce new violations to condition (1) and (2), as we never decrease the number of children, turn a leaf into a inner node, or remove  elds.
P(cid:48) is maximal: Any tree P(cid:48)(cid:48) that includes P(cid:48) but is included in P must contain at least one node from P that has been deleted by one of the above conditions.
Such a node, however, violates at least one of the conditions for a segment tree and thus P(cid:48)(cid:48) is not a segment tree.
This holds because the order of the node deletions does not affect the nodes deleted.
Algorithm 2 runs in O(n d): Lines 2 3 are in O(n).
Lines 4 5 and lines 6 13 are both in O(n  d) as they are dominated by the collapsing of the nodes.
In the worst case, we collapse d   2 inner nodes and thereby move O(n) leafs d   2 times.
Segment Labeling.
We extend the existing form labeling F of the  eld scope with form segments according to the structure of the segment tree and distribute labels in regular groups, see Algorithm 3.
First (lines 2 5), we create a form segment node s in the form labeling for each inner node ns in the segment tree and choose Segment TreeDOM Tree12345WWW 2012   Session: Web Engineering 1April 16 20, 2012, Lyon, France833Figure 4: Example for Segment Scope Labeling ns as representative for s (  (s) = ns).
For each segment with regular interleaving of text nodes and  eld or segment nodes, we use those text nodes as labels for these nodes, preserving any already assigned labels and  elds (from  eld scope).
In detail, we iterate over all descendants c of each segment in document order, skipping any nodes that are descendants of another segment or  eld itself contained in n (line 13).
In the iteration, we collect all  eld or segment nodes in Nodes, and all sets of text nodes between  eld or segment nodes in Labels, except those text nodes already assigned as labels in  eld scope (line 14), as we assume that these are outliers in the regular structure of the segment.
We assign the i-th text node group to the i-th  eld, if the two lists have the same size (possibly using the  rst text node as labels of the segment, line 17 19).
Figure 4 illustrates the segment scope labeling with triangles denoting text nodes, diamonds  elds, black circles segments, and white circles DOM nodes not in the segment tree.
The numbers indicate which text nodes are assigned as labels to which segments or  elds.
E.g., for the left hand segment, we observe a regular structure of (text node+,  eld)+ and thus we assign the i-th group of text nodes to the i-th  eld.
For the right hand segment (4), we  nd a subsegment (5) and  eld 8 that is already labeled with text node
 mains directly in 4, which becomes the segment label.
In 5, we  nd one more text node group than  elds and thus consider the  rst text node group as a segment label.
The remaining nodes have a regular structure ( eld, text node+)+ and get assigned accordingly.
At layout scope, we further re ne the form labeling for each form  eld not yet labelled in  eld or segment scope, by exploring the visible text nodes in the west, northwest, or north quadrant, if they are not overshadowed by any other  eld.
To this end, OPAL constructs a layout tree from the CSS box labels of the DOM nodes: DEFINITION 9.
The layout tree of a given DOM P is a tuple (NP, , w, nw, n, ne, e, se, s, sw, aligned) where NP is the set of DOM nodes from P, , w, nw, n, .
.
.
the  belongs to  (containment), west, northwest, north, .
.
.
relations from RCR [12], and aligned(x,y) holds if x and y have the same height and are horizontally aligned.
We call w, nw, .
.
.
the neighbour relations.
The layout tree is at most quadratic in size of a given DOM P and can be computed in O(|P|2).
For convenience, we write, e.g., w-nw-n to denote the union of the relations w, nw, and n.
In cultures with left-to-right reading direction, we observe a strong preference for placing labels in the w-nw-n region from a  eld.
However, forms often have many  elds interspersed with  eld labels and segment labels.
Thus we have to carefully consider overshadowing.
Intuitively, for a  eld f , a visible text node t is overshadowed by another  eld f (cid:48) if t is above f (cid:48) or also visible from, but closer to f (cid:48).
In the particular case of aligned  elds, the former would prevent any labeling for these  elds and thus we relax the condition.
DEFINITION 10.
Given a text node t, a  eld f (cid:48) overshadows another  eld f if (1) f and f (cid:48) are unaligned, w-nw-n( f (cid:48), f ), and Figure 5: Layout Scope Labeling w-nw-n-ne-e(t, f (cid:48)) or (2) f and f (cid:48) are aligned and (i) w(t, f (cid:48)) or (ii) nw-n(t, f (cid:48)) and there is a text node t(cid:48) not overshadowed by another  eld with ne-e(t(cid:48), f (cid:48)) and w-nw-n(t(cid:48), f ).
To illustrate this overshadowing, consider the example in Figure 5.
For  eld F1, T2 and T4 are overshadowed by F2 and T3 by F3, only T1 is not overshadowed, as there is no other text node that is southeast or south from T3 not overshadowed by another  eld.
The layout scope labeling is then produced as follows: For each  eld f , we collect all text nodes t with w-nw-n(t, f ) and add them as labels to f if they are not overshadowed by another  eld and not contained in a segment that is no ancestor of f .
The latter prevents assignment of labels from unrelated form segments.
There is no straightforward relationship between form  elds for domain concepts, such as location or price, and their structure within a form.
Even seemingly domain-independent concepts, such as price, often exhibit domain speci c peculiarities, such as  guide price ,  current offers in excess , or payment periods in real estate.
OPAL s domain schemata allow us to cover these speci cs.
We recall from Section 2 that a form model (F(cid:48), ) for a schema   is derived from a form labeling F by extending F with types and restructuring its inner nodes to  t the structural constraints of  .
OPAL performs form interpretation of a form labeling F in two steps: (1) the classi cation of nodes in F according to the domain types T to obtain a partial typing  P.
This step relies on the annotation schema   and its typing of labels in F; (2) the model repair where the segmentation structure derived in the segmentation scope (Section 3.2) is aligned with the structure constraints of  .
OPAL provides a template language, OPAL-TL, for easily specifying domain schemata reusing common concepts and their constraints as well as concept templates.
To implement a new domain, we only need to provide (1) a set of annotators implementing isLabela and isValuea and (2) an OPAL-TL speci cation of the domain types and their classi cation and structural constraints.
OPAL-TL extends Datalog with templates and prede ned predicates for convenient querying of annotations and DOM nodes.
An OPAL-TL program is executed against a form labeling F and a DOM P. Relations from F and P are mapped in the obvious way to OPAL-TL.
We only use child (descendant, resp.)
for the child (descendant, resp.)
relation in F. We extend document and sibling order from P to F: follows(X,Y ) for X,Y   F, if Rfollowing(  (X),  (Y ))   P and no other node in F occurs between X and Y in document order; adjacent(X,Y ), if Rnext-sibling(  (X),  (Y ))   P or vice versa.
Finally, we abbreviate labell(  (X)) as l(X).
Annotation types and their queries.
Annotations (instances of annotation types) are characterised by an external speci cation of the characteristic functions isLabela and isValuea for each a   A.
In the current version of OPAL, these functions are implemented with simple GATE (gate.ac.uk) gazetteers and transducers, that
 are either provided by human domain experts or derived from external sources such as DBPedia and Freebase.
The current OPAL version contains a large set of such artefacts for common domain types such as price, location, or date.
DEFINITION 11.
Given a form labeling F on a DOM P and an annotation schema  , an OPAL-TL annotation query is an expression of the form: X@A{d, p,e} where X is a  rst-order variable, A   A, and d, p, and e are annotation modi ers.
An annotation query X@A  with     {d, p,e} holds for all X  (cid:74)A (cid:75) with (cid:74)@A (cid:75) = {n   P : Allow  (n)  Match  (A) (cid:54)= /0}\ Block  (A) otherwise.
Match  (A) is to {l :(cid:83) with Allow  (n) set to  (n) for d    , and  (n)    (parent of n) {l :(cid:83) A(cid:48)< A isLabelA(cid:48) (l)} for p    , and A(cid:48)< A(isLabelA(cid:48) (l) isValueA(cid:48) (l))} otherwise.
Block  (A) equals {n :  A(cid:48)   A,|Match  (A)| < |Match  (A(cid:48))|} if e    , and /0 otherwise.
Intuitively, an annotation query X@A returns all nodes labeled with a label that is annotated with A.
If the modi er d (direct) is not present, we also consider the (direct) segment parents, otherwise only direct labels are considered.
If the modi er p (proper) is present, only isLabelA is used, otherwise also isValueA.
If the modi- er e (exclusive) is present, a node that full ls all other conditions is still not returned, if there are more labels with annotations of a type that has precedence over A.
Consider the form labeling of Figure 6 under a schema with C < B and B   A. Labels are denoted with triangles,  elds with diamonds, segments with circles.
Labels are further annotated with matching annotation types (here always only one).
If value labels are drawn as outlines.
Then, X@A{} matches 2,3,4; X@A{e,d} matches 2,4, but not 3 as 3 has more labels of B (or one of its sub-classes) than of A and the exclusive modi er e is present; X@A{e, p} matches 2,3, but not 4 as the proper modi er p prevents the value labels in white to be considered.
The latter matches 3 despite the presence of e, as we consider also the labels of the parent of 3 (since the direct modi er d is absent) and thus there are two A labels.
OPAL-TL templates.
OPAL-TL extends Datalog  (Datalog with strati ed negation) by templates to de ne reusable patterns for domain concepts.
Examples of such patterns are basic classi cation patterns that derive a domain type from a conjunction of annotation types or min-max range patterns where we look for multiple  elds with related annotations in a group and some clue that they represent a range.
In general, there are two types of template patterns, one for classi cation constraints, one for structural constraints.
The former specify patterns for relationships between domain and annotation types, the latter the abstract structure of domain concepts.
DEFINITION 12.
An OPAL-TL template is an expression TEMPLATE N<D1, .
.
.
,Dk> { p   expr } where N names the template, D1, .
.
.
,Dk are template parameters, p is a template atom, expr a conjunction of template atoms and annotation queries.
A template atom p<C1, .
.
.
,Ck>(X1, .
.
.
,Xn) consists of  rst-order predicate name p, template variables C1, .
.
.
,Ck, and  rst-order variables X1, .
.
.
,Xn.
Multiple rules with the same head express union as usual.
For convenience, we use   and   over conjunctions, which are translated to pure Datalog  rules as usual (not effecting data complexity).
TEMPLATE basic_concept<C,A> { concept<C>(N)  N@A{d,e,p} } TEMPLATE concept_by_segment<C,A> { concept<C>(N)  N@A{e,p} }

 TEMPLATE concept_minmax<C,CM,A> {


 N1@A{e,d},(concept<C>(N2)   N2@A{e,d}) concept<C>(N1),N2@range_connector{e,d}, (A1   A, N2@A1{d}) N1@A{e,p},N2@A{e,p},(cid:0)(N1@min{e,p},N2@max{e,p})   (N1@max{e,p},N2@min{e,p})(cid:1)
 Figure 7: OPAL-TL classi cation templates As an example, the following template de nes a family of constraints that associate the domain type D to a node N whenever N is labeled by an exclusive direct and proper annotation of type A.
TEMPLATE basic_concept<D,A> { concept<D>(N)   N@A{e,d,l} } A template tpl is instantiated to produce a family of rules where the formal template variables D1, .
.
.
,Dk are instantiated using values vi k from a template instantiation expression of the form 1, .
.
.
,vi INSTANTIATE tpl<D1, .
.
.
,Dk> using { <v1 k > } 1, .
.
.
,v1 k > .
.
.
<vn 1, .
.
.
,vn For example, the following expression instantiates basic_concept replacing D with type RADIUS and A with annotation type radius INSTANTIATE basic_concept<D,A> using {<RADIUS, radius>} and produces the following instantiated rule: concept<RADIUS>(N)  N@radius{e,d,l} PROP.
1.
OPAL-TL has the same data complexity as Datalog .
Classi cation is based on the classi cation constraints of the domain schema.
In OPAL these constraints are speci ed using OPAL-TL to enable reuse of domain concepts and concept patterns.
In the real estate and used car domains, we identify three patterns that suf- ce to describe nearly all classi cation constraints.
These patterns effectively capture very common semantic entities in forms and are parametrized using domain knowledge.
The building blocks are a domain type (or concept) C and an annotation type A that is used to de ne a classi cation constraint for C. None of these patterns uses more than one annotation type as template parameter, though many query additional (but  xed) annotation types in their bodies.
Figure 7 shows the classi cation templates for real-estate and used car: (1) Basic concept.
The  rst template captures direct clas-si cation of a node N with type C, if N matches X@A{d,e,p}, i.e., has more proper labels of type A than of any other type A(cid:48) with A(cid:48)   A.
This template is used by far most frequently, primarily for concepts with unambiguous proper labels.
(2) Concept by segment.
The second template relaxes the requirement by considering also indirect labels (i.e., labels of the parent segment).
In the real estate and used car domains, this template is instantiated primarily for control  elds such as ORDER_BY or DISPLAY_METHOD (grid, list, map) where the possible values of the  eld are often misleading (e.g., an ORDER_BY  eld may contain  price ,  location , etc.
as values).
(3) Min-max concept.
Web forms often show pairs of  elds representing min-max values for a feature (e.g., the number of bedrooms of a property).
We specify this pattern with three simple rules (line 5 12), that describe three con gurations of segments with  elds as sociated with value labels only (proper labels are captured by the AAAABBC3421WWW 2012   Session: Web Engineering 1April 16 20, 2012, Lyon, France8352





 TEMPLATE segment<C>{ segment<C>(G)  outlier<C>(G),child(N1,G), (cid:0)child(N2,G),  (concept<C>(N2)   segment<C>(N2))(cid:1) } TEMPLATE segment_range<C,CM> { segment<C>(G)  outlier<C>(G),concept<CM>(N1),concept<CM>(N2), N1 (cid:54)= N2,child(N1,G),child(N2,G) } TEMPLATE segment_with_unique<C,U> { segment<C>(G)  outlier<C>(G),child(N1,G), concept<U>(N1,G),  (cid:0)child(N2,G),N1 (cid:54)= N2, (concept<C>(N2) segment<C>(N2))(cid:1). }
TEMPLATE outlier<C>{ outlier<C>(G)  root(G) child(G,P),child(G(cid:48),P), (segment<C>(G(cid:48))) } Figure 8: OPAL-TL structural constraints  rst two templates).
It is the only template with two concept template parameters, C and CM where CM < C is the  minmax  variant of C. The  rst locates, adjacent pairs of such nodes or a single such node and one that is already classi ed as C. The second rule locates nodes where the second follows directly the  rst (already classi ed with C), has a range_connector (e.g.,  from  or  to ), and is not annotated with an annotation type with precedence over A.
The last rule also locates adjacent pairs of such nodes and classi es them with CM if they carry a combination of min and max annotations.
In addition to these templates, there is also a small number of speci c patterns.
In the real estate domain, e.g., we use the following rule to describe forms that use a links for submission (rather than submit buttons).
Identifying such a link (without probing and analysis of Javascript event handlers) is performed based on an annotation type for typical content, title (i.e., tooltip), or alt attribute of contained images.
This is mostly, but not entirely domain independent (e.g., in real estate a  rent  link).
concept<LINK_BUTTON>(N1)  form(F),descendant(N1,F),link(N1), N1@LINK_BUTTON{d}, (cid:0)descendant(N2,F), (concept<BUTTON>(N2)   follows(N1,N2))(cid:1)
 With  elds and segments classi ed, OPAL veri es and repairs the structure of the form according to structural constraints on the segments, such that it  ts to the patterns prescribed by the domain schema.
As for classi cation constraints, we use OPAL-TL to specify the structural constraints.
The actual veri cation and repair is also implemented in OPAL-TL, but since it is not domain independent, it is not exposed to the user for modi cation.
Here, we  rst introduce typical structural constraints and their templates and then outline the model repair algorithm, but omit the OPAL-TL rules.
Structural constraints.
The structural constraints and templates in the real estate and used car domains are shown in Figure 8 (omitting only the instantiation as in the classi cation case).
All segment templates require that there is an outlier among the siblings of the segment: outlier<C>(G) holds if at least one of G s siblings is not a C segment.
(1) Basic segment.
A segment is a C segment, if its children are only other segments or concepts typed with C. This is the dominant segmentation rules, used, e.g., for ROOM, PRICE, or PROPERTY_TYPE in the real estate domain.
(2) Minmax segment.
A segment is a C segment, if it has at least two  eld children typed with CM where CM < C is the minmax type for C. This is used, e.g., for PRICE and BEDROOM range segments.
(3) Segment with mandatory unique.
A segment is a C segment, if its children are only segments or concepts typed with C except for one (mandatory)  eld child typed with U where U (cid:54)< C. This is used for GEOGRAPHY segments where only one RADIUS may occur.
Repairing form interpretations.
The classi cation yields a form interpretation F, that is, however, not necessarily a model under  , and may contain violations of structural constraints.
We adapt the types of  elds and segments and the segment hierarchy of F with the rewriting rules described below to construct a form model compliant with  . OPAL performs the rewriting in a strati ed manner to guarantee termination and introduces at most n new segments where n is the number of  elds in the form.
(1) Under Segmentation: If there is a segment n with type t such that CT (t) requires additional child segments of type t1, .
.
.
,tk (cid:54)  child-T (n), we try to partition the children of n into k +1 partitions P1, .
.
.
,Pk,Pn such that Pi |= CT (ti) and Pn  {t1, .
.
.
,tk} |= CT (t).
For each Pi we add a new segment node as child of n, classify it with ti, and move all nodes assigned to Pi from n to that segment.
In practice, few cases of multiple under segmentations occur at the same node and we can limit the search space using a total order on T .
Though in general this would require value invention, the number of segments is actually bounded by the number of  elds in the form, which is typically between 2 10.
Therefore, we provide a pool of unused segments in the segmentation.
children c1, .
.
.
,ck such that (cid:83)child-T (ci)  (cid:83) (2) Over Segmentation: If there is a segment n of type t with n(cid:48) C  (n(cid:48)) |= CT (t) where C is the set of children of n without c1 .
.
.ck, then we move the children of each ci to n and delete all ci.
with child c typed t1 and t2 such that {t1} (cid:83) (3) Under Classi cation: If there is a segment n of type t with untyped children c1, .
.
.
,ck and corresponding types t1, .
.
.
,tk such that child-T (n) {t1, .
.
.
,tk}|=CT (t) and, for each ci, child-T (ci)|= CT (ti) holds, then we type ci with ti.
(4) Over Classi cation: If there is a segment node n of type t c(cid:48) C  (c(cid:48)) |= CT (t) where C is the set of children of n without c, we drop t2 from  (c).
(5) Miss Classi cation: If there is a node n of type t where child-T (n) (cid:54)|= CT (t), then we delete the classi cation of n as t.
We perform experiments on several domains across four different datasets.
Two datasets are randomly sampled from the UK real estate and UK used-car domains, respectively.
We compare with existing approaches via ICQ and TEL-8, two public benchmark sets, on which we only evaluate OPAL s form labeling for fair comparison to existing approaches, as they only label forms and do not use domain knowledge.
Even with these limitations, OPAL outperforms these approaches in most domains by at least 5%.
We also perform an introspective analysis of OPAL to show (1) the impact of  eld, segment, layout, and domain scope and (2) OPAL s performance and scalability with increasing page size.
For the evaluation, we evaluate the proper assignment of text nodes to form  elds using precision, recall and F1-score (harmonic mean F1 = 2PR/(P + R) of precision and recall).
Precision P is de ned as the proportion of correctly labeled  elds over total labeled  elds, while recall R is the fraction of correctly labeled  elds over total number of  elds.
For all considered datasets, we compare the extracted result to a manually constructed gold standard.
We evaluate segmentation through their impact on classi cation, see Figure 10b and the improved performance on the two datasets where we perform form interpretation (UK real estate and used car) versus the ICQ and TEL-8 datasets.
Datasets.
For UK real estate domain, we build a dataset randomly selecting 100 real estate agents from the UK yellow pages (yell.com).
Similarly, we randomly pick 100 used-car dealers from the UK largest aggregator website autotrader.co.uk.
The forms in these two domains have signi cantly different characteris-(b) ICQ results Figure 9: OPAL comparison (c) TEL-8 results tics than the ones in ICQ and TEL-8, mainly due to changes in web technology and web design practices.
The usage of CSS stylesheets for layout and AJAX features are among the most relevant.
The ICQ and TEL-8 datasets cover several domains.
ICQ presents forms from  ve domains: air traveling, car dealer, book, job, real estate.
There are 20 web pages for each of the domains, but two of them are no longer accessible and thus excluded from this evaluation.
TEL-8, on the other hand, contains forms of eight domains: books, car rental, jobs, hotels, airlines, auto, movies and music records.
The dataset amounts to 477 forms, but only 436 of them are accessible (even in the cached version).
Field Labeling Accuracy.
In our  rst experiment we evaluate the accuracy of OPAL s  eld labeling on all four datasets, but only in the UK real estate and used car domain we employ the form interpretation to further improve the  eld labeling.
Figure 9a shows the results.
The  rst two bars are for the random sample datasets.
For the real estate domain, OPAL classi es  elds with perfect precision and 98.6% recall.
Overall we obtain a remarkable 99.2% F-score.
The result is similar for the used car domain, where OPAL obtain 98.2% precision and 99.2% recall, that amount to 98.7% F-score.
OPAL achieves lower precision than recall in the used car domain due to the fact that web forms in this domain are more interactive: certain  elds are enabled only when some other  eld is  lled properly.
However, instead of the HTML attribute disabled, a placeholder is used with text displaying the original  eld s value label.
This introduces noise to  eld labeling and thus classi cation.
For the real estate domain, our domain schema consists of a few dozen element and segment types and about 40 annotation types.
Similarly, in the used car domain, there are about 30 annotation types.
In our experience, creating an initial domain schema (including gazetteers and testing) for a domain takes a single person familiar with the domain and OPAL-TL roughly 1 week.
The other two bars in Figure 9a regard  eld labeling on ICQ and TEL-8 datasets.
On these, OPAL applies only its domain-independent scopes ( eld, segment, scope) as no domain schema is available for these domains.
Nonetheless, OPAL reports very high accuracy also on these forms, con rming the effectiveness of our domain-independent analysis.
However, not unexpected, OPAL performs signi cantly better in presence of domain knowledge.
Cross Domain Comparison.
We use ICQ and TEL-8 to compare  eld labeling in OPAL against existing approaches, on a wide set of domains.
Figure 9b details the result of OPAL on each domain of the ICQ dataset.
It shows perfect F-score values for the jobs domain (100%) as well as auto and air travelling (99.3% and 98.3%).
For comparison, [6] reports 92% F-score for labeling on ICQ on average, which we outperform even in the most dif cult domain (books).
[15] reports slightly better precision and recall than [6], but OPAL still outperforms it by several percents.
(a) Time (b) Scopes Figure 10: OPAL evaluation The results for the TEL-8 dataset are depicted in Figure 9c.
Here, the overall F-score is 96.3%, again mostly affected by the performance in the books domain.
Note that, especially on TEL-8, OPAL obtains very high precision compared to recall.
Indeed, lower recall means OPAL is not able to assign labels to all  elds, missing some of them.
For comparison, [6] reports 88   90% overall F-score, which we outperform by a wide margin.
[13] reports F-scores between 89% and 95% for four domains in the TEL-8 dataset.
Though they perform slightly better on books, we signi -cantly outperform them on the three other domains included in their results, as well as on average.
Contributions of Scopes.
We demonstrate the effectiveness of combining different types of analysis by measuring to what extent each of our four scopes contributes to the overall quality of form understanding.
We use again the two domain datasets from the previous experiment.
For both we show the results for recall (though the picture is similar for precision and F-score).
As illustrated in Figure 10b, for the  eld labeling in the real-estate dataset, the  eld scope already contributes signi cantly (67%).
The Segment scope increases recall by 18%, page and domain scope add together another 13%.
Note that, the contribution of the domain scope is more signi cant than that of the layout scope, indicating the importance of domain knowledge to achieve very high accuracy form understanding.
In the used car domain,  eld scope alone is even more signi cant 85% (as many of the websites use modern web technologies and frameworks with reasonable structure).
Scalability.
As discussed in Sections 3 and 4, overall the analysis of OPAL is bounded by O(n2) due to the layout scope.
As expected actual performance follows a quadratic curve, but with very low constants.
There is a signi cant amount of outliers, partially due to long page rendering time and partially due to variance in the depth and sophistication of the HTML structure.
Figure 10a reports OPAL performance on all 534 forms in the combined TEL-8 and ICQ datasets.
The highlight area covers 80% of the forms with
 page rendering) of these forms.
Further analysis on the effect of in-
and page size is the dominant factor.
Current approaches to form understanding roughly fall into two categories: rule and heuristic approaches, such as MetaQuerier [16], ExQ [15], and SchemaTree [6], and machine learning approaches, such as LabelEx [13] and HMM [8], cf.
[9] for a general survey.
Aside of system design, OPAL primarily differs from these approaches in two aspects: (1) They mostly incorporate only one or two of OPAL s scopes (and feature classes): MetaQuerier,ExQ, and SchemaTree mostly ignore the HTML structure (and thus  eld and segmentation scope) and rely on visual heuristics only; LabelEx ignores  eld grouping; HMM visual information.
(2) None of the approaches provides a proper form model classifying the form  elds according to a given schema.
Furthermore, no domain knowledge is used to improve the labeling, though LabelEx analyses domain speci c term frequencies of label texts and HMM checks for generic terms, such as  min .
As evident in our evaluation, each of the scopes in OPAL considerably affects the quality of the form labeling and classi cation.
The fact, that each of these approaches omits at least one of the domain-independent scopes, explains the signi cant advantage in accuracy OPAL exhibits on Tel-8 and ICQ.
Notice also that not using domain knowledge keeps these approaches out of reach of the nearly perfect  eld classi cation achieved by OPAL.
Rule and heuristic approaches.
Most closely related in spirit to OPAL, though very different in realisation and accuracy, is Meta-Querier [16].
It is built upon the assumption that web forms follow a  hidden syntax  which is implicitly codi ed in common web design rules.
To uncover this hidden syntax, MetaQuerier treats form understanding as a parsing problem, interpreting the page a sequence of  atomic visual elements , each coming with a number of attributes, in particular with its bounding box.
In a study covering 150 forms, the authors of MetaQuerier identi ed 21 common design patterns.
These patterns are captured by production rules in a 2P grammar.
In contrast, the domain independent part of OPAL achieves nearly perfect accuracy with only 6 generic patterns by combining visual, structural, and textual features.
Metaquerier is not parameterisable for a speci c domain.
ExQ [15] is similarly based primarily on visual features such as a bias for the top-left located labels comparable to OPAL, but disregards most structural clues, such as explicit for attributes of label tags and does not allow for any domain speci c patterns.
Also [6] uses only visual features (and the tabindex and for attributes for  elds and labels).
It follows nine observations on form design, e.g., that query interfaces are organized top-down and left-to-right or that  elds form semantic groups.
It uses a hierarchical alignment between  elds and text nodes similar to OPAL s segment scope and a  schema tree  where the nine observations are observed.
Again no adaptation to a speci c domain is possible.
Machine Learning Approaches.
In contrast to the above approaches, the following machine learning approaches can be trivially adapted to a speci c domain using domain-speci c training data.
The evaluation in [8], however, shows little effect of domain-speci c training data: a training set from the biological domain outperforms domain-speci c training set in four out of  ve domains.
LabelEx [13] uses limited domain knowledge when considering the occurrence frequencies of label terms.
Domain relevance of the terms occurring in a label, measured as the occurrence frequency in previous forms, is one signal used to score  eld-label candidates.
Field-label candidates are otherwise created primarily using neigh-bourhood and other visual features, as well as their HTML markup.
However, LabelEx does not consider  eld groups and thus is unable to describe segments of semantically related  elds or to align  elds and labels based on the group structure and does not use any domain knowledge aside of term frequency.
HMM [8] uses prede ned knowledge on typical terms in forms, such as  between ,  min , or  max , but does not adapt these for a speci c domain.
HMM employs two hidden Markov models to model an  arti cial web designer .
During form analysis, the HMMs are used to explain the phenomena observed on the page: The state sequences, that are most likely to produce the given web form, are considered explanations of the form.
Compared to OPAL, HMM uses no visual features and no domain knowledge.
As premise of this paper, we assume that form understanding has been limited by overly generic, domain independent, monolithic algorithms relying on narrow feature sets.
With OPAL we present a system that addresses these limitations without requiring an inordinate effort in domain engineering.
This is achieved through a very accurate domain independent form labeling, exploiting visual, textual, and structural features, by itself already outperforming existing approaches.
We complement the domain independent part with a domain dependent form  eld classi cation that signi cantly improves the overall quality of the form understanding in verifying the labeling, classi cation, and segmentation with domain constraints.
To minimize the efforts in domain engineering, we provide a template language that facilitates compact domain knowledge speci cations and enables signi cant cross domain reuse.
