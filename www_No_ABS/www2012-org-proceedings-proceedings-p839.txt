We consider the problem of forming teams on a networked community of people with diverse skill sets.
The goal is to assemble teams to deal with an incoming stream of tasks that are not known in advance.
Each task requires a set of skills that must be covered by members of the assembled team.
Each team should have small coordination cost, that is, it should be well-connected according to the underlying  The research leading to these results has received funding from the EU FP7 Project N. 255403 SNAPS; the Spanish Ministry of Science and Innovation (project CEN-20101037 Social Media and Torres Quevedo programme); and the PRIN 2008 research projects COGENT.
Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
social network.
Finally, this allocation should be fair, in the sense that no one should be overloaded with tasks or unfairly singled out.
In previous works (i) Lappas et al. [14] considered the team-formation problem for a single task with the objective of minimizing the coordination cost, but ignored the issue of balancing the workload, and (ii) Anagnostopoulos et al. [2] considered the formation of teams with the objective of balancing the workload, but ignored the coordination costs.
According to our observations (detailed in Section 6) focusing exclusively on one of these aspects can lead to an unfair allocation of work or poorly connected teams.
Contributions.
In this paper we propose the  rst online algorithms that assemble teams to deal with tasks, in a way that keeps coordination costs bounded and results in a fair allocation of the workload.
Speci cally:   we introduce the Balanced Social Task Assignment problem and consider several variants, that include the problems studied by Lappas et al. [14] and Anagnostopoulos et al. [2] as special cases;   we provide online competitive algorithms [21] with provable performance guarantees for these variants, noting that all of them are NP-hard;   we demonstrate the e ectiveness of our approach on two real-world datasets; compared with solutions that ignore user workloads, our algorithms achieve a signi cant decrease in the unbalance of the workload (60% 70%) with a small increase on the coordination overhead (5% 10%).
Roadmap.
The next section discusses related work.
Section 3 describes the general framework we use.
Sections 4 and 5 describe our methods, which are tested experimentally in Section 6.
The last section presents our conclusions.
Scheduling with load balancing: A well-studied problem since the work of Graham [12], is the scheduling of jobs on a set of machines with the goal of minimizing the maximum load on a machine.
The setting has been extended to the restricted-assignment problem, in which the goal of balancing the workload is kept but additionally each job can only be processed by a subset of the available machines.
The latter problem is NP-hard and has competitive ratio O(ln k) (where k is the number of jobs), shown to be asymptotically tight even for randomized online algorithms [4,5].
Our work deals with a problem harder than restricted assignment, since forming a team entails solving a set-cover prob-even in the o ine case [22].
Matching people to tasks: Refereed conferences and journals require submissions to be reviewed by members of a program committee.
This is a matching problem for which several systems have recently been proposed, for instance Easychair.org, Linklings.com and SoftConf.com.
Easychair is currently based on a preliminary bidding process where reviewers rank papers into three classes.
The problem of providing e cient solutions in the bidding model has recently been addressed by Mehlhorn [17].
Our work does not use explicit bids and is based on solving a covering problem instead of a matching problem.
We also have the additional requirement of optimizing the coordination cost of formed teams.
Agent-organized team formation: Gaston et al. [11] study the team-formation problem in a setting where networked agents form teams in a decentralized manner.
Agents are able to locally rewire their social network.
We consider a setting where the social network is given, and also load balancing is taken into account.
Team formation with coordination costs: Lappas et al. [14] introduce the problem of team formation in social networks.
The objective is to minimize the coordination cost, for example, in terms of diameter or weight of the minimum spanning tree for the team.
This problem has been extended to cases in which potentially more than one member possessing each skill is required, and where density-based measures are used as objectives [9,15].
It has also been extended to allow partial coverage of the required skills, introducing a multi-objective optimization problem that is optimized using simulated annealing [8].
More recently, Kar-gar and An [13], consider a variation with a di erent cost model: when a user who participates in a task contributes with a variety of his skills (more on this in Section 3), the contribution to the cost is independent for each skill.
Apart from modeling di erent scenarios with respect to the rest of previous (and our) work, technically this model simpli es the problem as it avoids the  set-covering  aspect of it.
Team formation with load balancing: In our previous work [2] we studied o ine and online versions of the problem of allocating teams to tasks with the objective of balancing workload, but ignoring coordination costs.
In this section, we present our framework and notation and formally de ne the problem that we study.
Our notation is also summarized in Table 1.
Tasks.
We denote by J = {Jj; j = 1, 2, .
.
.
, k} a set of tasks (or jobs).
In the online setting that we consider, the jth task arrives at the jth time step and is assigned to a team of experts before the arrival of the (j + 1)th task.
Skills.
Each task requires a subset of the m available skills to be completed.
We use the notion of skill space S = {0, 1}m, which is the space that contains the possible ways that m skills combine to form a task, so, each task is a point in the skill space: Jj   S. We use Jj i = 1 to denote that ith skill is required by the jth task, while Jj i = 0 otherwise.
Thus, we have Jj = (Jj

 m).
pj Jj d(pj , pj 0 d(j, j0) pj i Jj i Qj qj qj i L(p)
 c(Q) c(T ) a(Q) a(pj ) Table 1: Notation n Number of people m Number of skills k Number of tasks Set of people Set of skills Set of tasks jth person jth task ) Distance between persons j and j0 ) d(pj , pj 0 ith skill of jth person ith skill of jth task Team assigned to jth task Skill pro le of team j ith skill of pro le of team j Load of person p Load of team Q Coordination cost of team Q Coordination cost of subgraph T Allocation cost of team Q Allocation cost of person j People.
We consider a set of people (or experts) P = {pj ; j = 1, 2, .
.
.
, n}.
Each expert has a subset of skills in her pro le, so she is also represented by a point in the skill space: pj   S. We use pj i = 1 to denote that the jth person has the ith skill, while pj i = 0 otherwise.
Thus, we have pj = (pj 2, .
.
.
, pj 1, pj m).
Teams.
Each task needs to be assigned to a team of experts.
We let Qj   P denote the team assigned to the jth task.
We use qj i = 1 to denote that the ith skill is covered by the jth team, so we have qj = (qj m).
For each team Qj we compute its team pro le qj   S in the additive skill model [2] that de nes the expertise of the team as the (binary) sum of the skills of each individual: 2, .
.
.
, qj 1, qj i = min{ X qj p` Qj p` i , 1}i=1,...,m.
In other words, a skill is covered by the team if there exists at least one member who has that skill.
We refer to a team for task Jj by using the notation qj and Qj interchangeably.
Given a team Q with pro le q assigned to task J, we de ne cov(q, J)   {0, 1} to be 1 if and only if qj i ,  i =
 Note that this happens if every skill required by the task is possessed by the team.
i   Jj We aim to form teams that can accomplish the speci- ed tasks while optimizing two, possibly con icting, goals: achieving a fair allocation of the overall workload among people and forming teams that have the lowest possible coordination cost.
We now make these notions more precise.
Load.
The  rst quantity we want to optimize is the load L(p) of an expert p, which we de ne to be the number of In particular, as in our previous work [2], we are interested in minimizing the maximum load over all the experts.
tasks in which p participates: L(p) = (cid:12)(cid:12){j; p   Qj}(cid:12)(cid:12).
Coordination cost.
In practice, team work faces coordination costs.
Such costs limit the size of organizations, as formalized in the seminal work of Coase [7].
In our setting, the coordination overhead in collaboration may nullify the potential advantages of a larger expertise coverage.
over the set of people, G = (P, E), and assume a metric distance function d : E   R+ on the edges of the network.
This function may model preferences based on past interactions, geographical proximity, compatibility in collaborating, distance in a company s hierarchy, and so on.
We extend the de nition of the distance function d( ,  ) to any pair of people in the network, by considering the sum of the distances along a shortest path connecting the two people.
There are many ways of de ning the coordination cost of a team as a function of the pairwise distances among the people in the social network.
Before describing speci c coordination-cost measures, we  rst consider two natural options with respect to de ning the  underlying network  of the team.
Implicitly Connected Teams (ICT).
In this model we do not require each team Q to form a connected graph; we only ask for communication paths between people in the team through other members of the social network (not necessarily present in Q).
This model is realistic if the existence of a short chain of acquaintances is enough to declare people as  compatible.  Explicitly Connected Teams (ECT).
This follows the approach of Lappas et al. [14] and requires that each team Q forms a connected graph using the set of edges T = {(pi, pj ) : pi, pj   Q}.
We also denote by d the distances computed in subgraph (Q, T ).
The di erence between the ICT and ECT cases is the subgraph over which the coordination cost is computed.
In the ICT case, it is computed over the whole social network; in the ECT case, over the subgraph induced by the team.
In both cases we use the following measures of coordination cost, which are the ones considered by Lappas et al. [14]
 Steiner tree T that has as terminal nodes the team members.
 Q dj(i, i0)
 In general, we denote by c(Q) the coordination cost of team Q, which we also write as c(T ) if the set of edges T connecting team members is given.
We have also studied the sum-of-distances cost,1 however due to lack of space we omit the results from this version.
Assembling teams while accounting for two objective functions, coordination cost and load, leads to a bi-criteria objective, which in general is hard to analyze, especially if we seek for theoretical guarantees.
A principled approach that is usually adopted in the literature [19, 20] to address bi-criteria optimization problems is to bound the cost on one objective function and optimizing on the other.
This allows to turn the bi-criteria optimization problem into an optimization problem for a single objective function.
In our case, we put a bound B on the coordination cost for each job Jj and we optimize the maximum load of a person, with the interpretation that B is a bound on the coordination cost that we are willing to accept for the particular application.
In this spirit, we consider the following generic optimization problem, which we call Balanced Social Task Assignment.
It consists in minimizing the maximum load of
  Q dj (i, i0) Table 2: Notation for analysis solution for modi ed Optimal solution for the Social Task Assignment problem Optimal problem instance with ratio   Optimal cost for modi ed problem instance with ratio    approximate solution for modi- ed problem instance with ratio    approximate cost for modi ed problem instance with ratio  
 (Qopt, T opt) = (Qopt   , T opt   ) f opt( ) =  a(Qopt) + c(T opt) (Qapx, T apx) = (Qapx   , T apx   ) f apx( ) =  a(Qapx) + c(T apx)   = c(T  )/a(Q ) a person while assigning each job to a team that covers all the skills of the job, with a bounded coordination cost: min max i P L(pi) cov(Jj, qj) = 1 c(Qj)   B  j   J  j   J .
In the next section we propose algorithms with theoretical guarantees for this problem under di erent coordination cost functions in the online setting.
Another option would be to attempt to bound the maximum load and minimize the coordination cost.
Note though that such an attempt is more unnatural in our online setting.
Since we do not know a priori the number of tasks it is hard to set a bound on the total maximum load.
Instead it is more sensible to preset an acceptable level of coordination and attempt to minimize the load as new tasks keep arriving.
However, despite the choice to set up a  xed bound B on the coordination cost for analysis reasons, in Sections 5 and 6 we observe that by weighing di erently the load and the coordination costs we can tradeo  between those two objectives.
In this section, we introduce and analyze the performance of a general online algorithm for Balanced Social Task Assignment that can be applied to a variety of coordination cost functions.
For easy reference, we summarize our notation in Table 2.
Our online algorithm works as follows: upon arrival of a new task J, a team is formed for task J by solving a suitably-de ned instance of the (o ine) Social Task Assignment problem.
The Social Task Assignment subproblem for task J consists in selecting the team Q that minimizes a speci c cost allocation function a(Q) subject to a constraint on the coordination cost c(Q).
The problem for task J is as follows: min
 a(Q) cov(J, q) = 1 c(Q)   B.
The Social Task Assignment problem depends on the speci c coordination cost c(Q) and allocation cost a(Q) that we adopt.
As we mentioned in the previous section for the coordination cost we consider two measures for Q: Steiner(Q) and Diam(Q).
used in the Social Task Assignment instance depends on the individual loads on the persons, as they have resulted from the previous allocation of the  rst j   1 tasks.
Di er-ent choices of the allocation cost function a ect the performance of the overall online algorithm.
There exist several natural allocation cost functions one can consider, such as minimizing the team size, the maximum load, or the total load; in our previous work [2] we analyze such functions explicitly, and we have shown that their performance, in terms of balancing workload, is not as good as the ExpLoad allocation cost function that we describe below.
The ExpLoad function is motivated by research in online scheduling, and is proven to be e ective when the coordination cost is not taken into account [2].
Here we extend the results by showing that ExpLoad is an e ective allocation cost function also when coordination cost is taken into account.
Let us denote by L(pi) the load of person i when task J is presented, and let   be an appropriately chosen value that depends on the cost of the optimal solution.
Then, the ExpLoad function is de ned as follows: a(Q) = X pi Q (2n) L(p i)
 Details on how to adaptively estimate   during the execution of the algorithm can be found in our previous work [2].
Using ExpLoad guarantees e ective algorithms both in theory and in practice.
For evaluating the performance of online algorithms we resort to the notion of competitive analysis [21].
Competitive analysis compares an online algorithm against an of ine adversary who knows the entire input sequence in advance and serves it optimally.
An online algorithm is c-competitive if for any input sequence it provides a solution with cost bounded by c times the optimal cost.
Observe that even an online algorithm that optimally solves the Social Task Assignment problem for each task may not provide an optimal solution for the overall problem, given the lack of information about future tasks.
The following result, proven similarly to [3], shows that using the ExpLoad allocation cost function guarantees the optimal asymptotic performance possible.
The full proof will be included in an extended version of this work.
Theorem 1.
Consider the Balanced Social Task Assignment problem and assume the corresponding Social Task Assignment problem using the ExpLoad allocation cost function can be solved optimally.
Then this algorithm is  (ln k)-competitive.
In addition this is the best competitive ratio possible.
However, the Social Task Assignment problem can not be solved optimally e ciently unless P = NP, since it entails the set-cover and the Steiner-tree problems.
Bi-criteria approximation guarantee.
Every algorithm A for Social Task Assignment returns for a task J a pair (QA, T A), where T A is a subset of edges used to connect the members of team QA and c(T A) is the coordination cost.
Let (Qopt, T opt) be the optimal solution to the problem of minimizing a(Q) subject to coordination cost being bounded by B.
The performance of the algorithm on a single instance of Social Task Assignment will be measured through a bi-criteria approximation guarantee: Definition 1.
An ( ,  ) bi-criteria approximation algorithm for the Social Task Assignment problem for a task J will return in polynomial time a pair (Q, T ) such that: (i) a(Q)       a(Qopt) and (ii) c(T )    B.
The values of the approximation factors   and   depend on the speci c coordination cost c(T ) that we consider.
Next we show how a bi-criteria algorithm for the Social Task Assignment problem, together with the ExpLoad cost allocation function, can yield an online algorithm for the Balanced Social Task Assignment problem.
The proof is similar to the proof of Theorem 3 in [2] and will be included in an extended version of this paper.
Theorem 2.
Assume that there exists an ( ,  ) bi-criteria approximation algorithm for the Social Task Assignment problem with the ExpLoad allocation cost function and with a coordination cost function c(T ).
Then there exists a polynomial time algorithm for the Balanced Social Task Assignment problem that is  (  ln k)-competitive and for each task J attains a coordination cost c(T )    B.
Remarks.
Theorem 2 shows that the competitive ratio of the overall online algorithm depends on how closely we approximate the optimum of the Social Task Assignment instances.
In the remainder of this section we provide algorithms with provable performance for the Social Task Assignment problem under the Steiner and Diam coordination cost functions in the ICT model.
Heuristics to solve this problem (and, thus, the overall scheduling problem) in the ECT model are described in Section 5.
In this section we describe an approach that guarantees a solution for the Balanced Social Task Assignment problem with an optimal competitive ratio in the case of Steiner cost and implicitly connected teams.
Given Theorem 2, we need to provide a solution to the following Social Task Assignment problem:
 min a(pi) pi Q cov(J, q) = 1 c(Q)   B, L(p i )   , so that a(Q) = Ppi Q a(pi).
where we de ne a(pi) = (2n) The constraint c(Q)   B speci es that the Steiner-tree cost of the nodes in the selected team Q has to be at most B.
This constraint, along with the coverage constraint cov(J, q) = 1, de ne a group Steiner tree problem [6, 10].
Note that the connection to the group Steiner tree was also considered by Lappas et al. [14] for the algorithms they developed.
In the group Steiner tree problem, we are given a network G = (V, E), where |V | = n, with a distance function d : E   R+, and a family G = {g1, .
.
.
, g`} of groups of nodes, with gi   V .
The objective is to  nd a minimum-cost subtree T of G that contains at least one node from each group gi.
This problem has a   = O(ln2 n ln ln n ln `) approximation [6].
In fact, our problem is more complicated as we need to  nd an algorithm A that returns a pair (QA, T A) that not

 the text.
*/



  A binarySearch(J, 0, upperBound) /* Estimate the threshold; we  nd the largest value below the threshold with an accuracy of .
*/ (QA, T A)  findGroupForGivenLambda(J,  A) return (QA, T A)

 c(Q) is below the threshold, with an accuracy gap of .
*/ if ( 2    1 <     2) /* The two endpoint are very close; value found */ return  1










 end if     ( 1 +  2)/2 (Qapx   , T apx if (c(Qapx   ) findGroupForGivenLambda(J,  )   ) < 2 B) return binarySearch(J,  ,  2) else return binarySearch(J,  1,  ) end if

 given value of   */ G0  createModifiedGraph( ) (Q , T )  solveGroupSteinerTree(G0 , J) return (Q , T )




  .
*/ V 0   A copy of V E0 = {ei = (i, i0); i   V, i0   V 0, w(ei) = c(i)    } i0   V 0 belongs to group j i  user i possess skill j G0 = (V   V, E   E0, w) return G0




 only satis es the group Steiner tree constraints, but that also minimizes the cost allocation function a(Q) over the nodes returned.
Let (Q , T  ) be the optimal solution to our Social Task Assignment problem.
The description of the algorithm findGroup(J), which solves the Social Task Assignment problem for task J, is in Algorithm 1.
Our high-level strategy to solve the Social Task Assignment problem is the following: (i) First we de ne a family of problem instances, which we call the modi ed problem instances, parametrized by a value     R+.
Each of the modi ed problem instances will be an instance of the group Steiner tree problem.
We can also show that there is a value   =   such that the solution to the modi ed problem instance is an approximate solution to the original Social Task Assignment problem.
(ii) Next we show that although it is hard to compute the value   exactly, we are able to compute e ciently an approximate value that yields an approximate solution to the original problem.
We now proceed with the details.
(i) Build modi ed problem instance.
For a given value of parameter   we construct the following modi ed problem instance (see Figure 1).
If the initial graph is G = (V = P, E) we create a new graph G0 = (V   V 0, E   E0) with a new  ctitious node i0   V 0 for each node i   V , and with a new edge ei = (i, i0)   E0 of cost  a(i), for each node i d(i, j) j a(i)   l i d(i, j) a( j)   l j (a) Original network (b) Modi ed problem instance Figure 1: The original network on which we want to solve the Social Task Assignment problem and the modi ed problem instance on which we solve the group Steiner tree problem.
With bold we can see an example solution (Q, T ).
Notice that the cost of the solution is the coordination cost c(T ) (of the original network) and the cost of the new edges, which is equal to the cost allocation a(Q).
i   V .
We then consider the group Steiner tree problem on this modi ed instance, in which each skill required by the arrived task corresponds to a group and a node i0 belongs to the rth group if the corresponding expert i possesses the rth skill.
A solution to the group Steiner tree on the modi ed problem instance is a pair (Q, T ) where Q is the set of nodes selected that cover all the groups (skills) and T a subtree that connects the nodes in Q.
Note that the cost of the solution (Q, T ) on the modi ed instance is given by f (Q, T,  ) =  a(Q) + c(T ).
For a given algorithm A, let us de ne the cost of the solution (QA, T A) that it outputs as f A( ) =  a(QA) + c(T A), with the understanding that if A is a randomized algorithm then f A( ) is the expected cost of its solution.
Let also opt = opt  be the optimal algorithm for the given modi ed problem instance so that f opt( ) is the cost of its optimal solution (Qopt, T opt).
Similarly, for a  approximation algorithm apx = apx , we have that f apx( ) is the cost of the solution (Qapx, T apx) produced by apx.
When we want to explicitly specify the value of   for which the solution is optimal or approximate we will write (Qopt   ) and (Qapx   , T apx Recall that (Q , T  ) is the optimal solution to the Social   , T opt   ).
Task Assignment problem.
Let us de ne   = c(T  ) a(Q ) .
It turns out that the value   is the value of   for which we would like to solve our problem, as the solution to the modi ed problem for   =   provides an approximation solution to the STA problem, as one can see in the following proposition, whose proof is straightforward and omitted for the sake of space.
Proposition 3.
The following are true.
  )   2B.
  )   2a(Q ).
know the value   then we can de ne the appropriate mod-i ed problem instance to solve, which in turn can give us an approximate solution to the original Social Task Assignment problem.
The second claim that we need to show is that we can  nd the value   e ciently.
Actually, since we cannot solve the group Steiner tree on the modi ed problem instances exactly, we cannot compute the value   exactly.
However, we can estimate it and we will show that our estimate will provide a bi-criteria approximate solution to the original problem.
To estimate the value   we exploit the fact that the function f opt( ) is a monotone function of  , as we show in the next key lemma (whose proof we defer to an extended version of this paper).
This will allow us to estimate   using a binary search.
Also it will allow us to show that having only an estimate of   can provide a bi-criteria approximation.
Lemma 4.
The following hold:

  1 a(Qopt  2 ) and c(T opt  1 )   c(T opt  2 ).
)   Recall that (Qopt In essence, this lemma allows us to estimate   with the required accuracy, using a binary search, each iteration of which involves solving an instance of the modi ed problem for some value  .
The exact description is in Algorithm 1.
Note that our technique is an example of the parametrized-search approach for the solution of constrained optimization problems, originally proposed by Megiddo [16] and used in subsequent work (see for example [19] for its application to bi-criteria spanning tree problems).
Care needs to be taken because we cannot solve each problem instance optimally when performing the binary search, but only approximately.
  ) is the optimal solution of the mod-i ed problem instance for parameter   (i.e., the value that minimizes f (Q, T,  )).
To obtain an understanding of our algorithm, it is easier to describe a version where we could solve optimally the modi ed problem instance for any value of  .
Then we estimate the value   by performing a binary search.
In every step of the binary search we pick the value of   that is the average of the two endpoints  1 and  2 and we solve the modi ed problem instance.
Throughout the entire execution we maintain the invariant that c(T opt
  1 and c(T opt )   B.
We stop when  1 and  2 are close to each  2 other, and the second claim of Lemma 4 guarantees that  1        2.
  , T opt Since we can only solve the modi ed problem with an approximation of  , we cannot compute the value  .
Instead we modify the search to  nd a value that satis es the constraint allowing for room because of the approximation ratio.
For the sake of brevity, let A denote Algorithm find-Group so that the solution it returns is (QA, T A), and let  A the estimate of   computed by A.
The above considerations are at the basis of the following theorem, whose proof is omitted for the sake of space.
The result establishes that our algorithm is an (O( ), O( )) bi-criteria approximation algorithm for the Social Task Assignment problem.
Theorem 5.
For any task J, Algorithm findGroup(J) returns a solution (QA, T A) such that:


 r   arg mini S Pj P pj /* r now is (one of ) the rarest skill */
 foreach (` such that p` Algorithm 2 The diameter algorithm.
U   {pj ; d(p`, pj )   B} Q   greedyWeightedSetCover(U ) if (a(Q) < a(QA) end foreach return QA
 r = 1) i end if Combining Theorems 1, 2, and 5 it follows that there exists a bi-criteria approximation algorithm for the Balanced Social Task Assignment problem (recall that n is the number of people, m the number of skills, and k the number of tasks): Theorem 6.
There exists an O(ln2 n ln ln n ln m ln k)-competitive algorithm for the Balanced Social Task Assignment problem, which for each task attains a Steiner-tree coordination cost bounded by O(B ln2 n ln ln n ln m).
Running time.
It is easy to see that the complexity of the algorithm 1 is polynomial.
This follows because (i) every invocation of findGroupForGivenLambda runs in polynomial time [6] and (ii) the function binarySearch) is invoked a polynomial number of times.
To see why (ii) holds, note that the parameter upperBound in line 3 of the algorithm is set to the largest possible value of the ratio c(T )/a(Q).
Note that c(T )   Ppj ,p`  P d(pj, p`).
Moreover, a trivial lower bound to a(Q) is 1 (the load on every person is 0 when the  rst task is allocated and the team size is 1).
The claim then follows since binarySearch is invoked a number of times that is at most logarithmic in upperBound, for a constant .
Notice however that, although polynomial, the cost of the algorithm can be high in practice, due to the super-linear cost of the group Steiner tree algorithm [6].
For this reason, in Section 5, we consider computationally less demanding heuristics to implement findGroupForGivenLambda.
For the diameter coordination cost (Diam) we follow a di erent, simpler approach, which we present in Algorithm 2.
Similar to the previous coordination cost functions, we try to  nd a team of users Q with diameter at most  B (it turns out that for the diameter we can obtain   = 2) that minimizes a(Q).
However, in this case we do not build a new problem instance to combine the load with the social cost function.
Instead we solve the problem directly.
Our results are summarized in the following theorem, whose proof will be given in the full version of the paper.
Theorem 7.
There exists an O(ln m ln k)-competitive algorithm for the Balanced Social Task Assignment problem, which for each task attains a diameter coordination cost bounded by 2B.
Running time.
The running time of the algorithm is obviously polynomial: the main loop (lines 6 12 of Algorithm 2) a run of the (polynomial) greedy heuristics for weighted set cover.
For the sum-of-distances coordination cost (Sum) we can apply a similar technique, and de ne an appropriate mod-i ed problem instance.
Due to lack of space we will include the details in an extended version of this work.
We only mention that to solve it we de ne an appropriate class of modi ed problem instances that we solve by formulating them as a convex program and rounding it performing randomized rounding.
This allows us to obtain results along the lines of Theorems 6 and 7.
In the previous section we developed algorithms that provably approximate the optimal solution in the online case and also run in polynomial time.
These algorithms are speci -cally suited for the implicitly connected team (ICT) model.
For the explicitly connected team (ECT) model, we note that the problem is as hard: for example, the explicitly connected version for the Steiner coordination cost is as hard as the node-weighted group Steiner tree problem that is strictly harder than the edge-weighted group Steiner tree problem.
Moreover, it still relies on an approximation algorithm for the group Steiner tree problem.
In this section we address several issues regarding the practicality of our approach.
In particular, to be able to formulate an optimization problem that addresses the multi-criteria objectives, we attempt to minimize the maximum load, while keeping the coordination cost bounded by a constant B (see Section 3.3).
Second, to provide approximation guarantees we need to employ theoretical results for the group Steiner tree problem.
For the Diam coordination cost this is not an issue, since the approach that we describe in Section 4.4 is e cient both in theory and in practice.
The theoretical algorithm used for the group Steiner tree problem [6], while it provides asymptotic guarantees, is not practical; it involves a probabilistic embedding of the graph to a tree, solving a linear program and appropriate rounding.
Therefore, in our experiments we apply some simpler heuristics.
One heuristic is the approach used by Lappas et al. [14], which is based on the creation of (yet) another graph instance, on which the Steiner tree problem is solved.
Brie y, for each skill (group), we create a new node that is connected to all the experts that possess it with a large cost D. Then we compute the Steiner tree that connects the required skills.
For the latter task we employ the minimum spanning-tree heuristic.
We also develop a second algorithm, which we call the set-cover heuristic and we present in detail in Algorithm 3.
We will represent the allocation costs (appropriately scaled by  ) on the nodes of the social network and social costs on the edges of the social network.
Since we want to produce solutions that are close to the optimum, we assume that our algorithm s solution shares at least one expert with the team of the optimal solution.
This is obtained by trying as roots all the experts that possess the rarest skill of the the task (i.e., the skill owned by the least number of experts).
Let Q and T be the team and Steiner tree constructed so far in the execution of the algorithm.
In line 8, gain(pj) is set to the number of required skills owned by expert pj that Algorithm 3 The set-cover Steiner algorithm.
heuristic.
*/







 mostCostE ective   0 foreach (pj   P \ Q) i=1 1








 gain(pj )   Pm j {p i =1   Ji=1   qi=0} loss(pj )   cost in G for adding pj in Q costE ectiveness   gain(pj )/ loss(pj ) if (costE ectiveness > maxCostE ectiveness) maxCostE ectiveness   costE ectiveness mostCostE ective   j end if end foreach T   T  shortest path from pmostCostE ective to T  Q   Q   {pmostCostE ective} /* This is for the ICT model.
For the ECT model we add all the experts of the path.
See the text for more details.
*/

 end while return (Q, T ) are not covered yet by Q.
(The notation 1A denotes the indicator function for A.)
To see why this is the case, note that expert pj contributes to the ith skill if and only if he possesses the skill (pj i = 1), the skill is required (Ji = 1), but not yet covered (qi = 0).
In line 9 we set loss(pj) to the cost of adding expert pj to team Q as we discuss in the next paragraph.
Then, at each step of the algorithm we add to Q the most cost-e ective expert, where cost-e ectiveness is de ned by the ratio gain(pj ) loss(pj ) .
The algorithm terminates when all skills of the task are covered.
).
 Q `s(pj , pj 0 We de ne loss(pj) = minpj0 The algorithms for the di erent notions of coordination cost and for the models ICT and ECT di er only in the de nition of the costs loss(pj ).
Denote by `s(pj, pj 0 ) the length of the min cost path ps(pj , pj 0 ) in social network N that connects pj to pj 0 plus the (appropriately scaled) allocation costs of all the people on the path, excluding pj 0 .
In the ICT model once we  nd the most cost-e ective people pj , we add path ps(pj , pj 0 ) to T and expert pj is included in team Q.
In the ECT model, once we  nd the most cost-e ective expert pj , we add path ps(pj, pj 0 ) to T and team Q is extended to include all experts on the path, to ensure the team resulting team is a connected subgraph.
Therefore, in this case, `s(pj , pj 0 ) takes into account the cost of including these experts as well.
We note that in the ECT model, experts on path ps(pj , pj 0 ) may contribute not only by connecting others but often provide additional skills for the task, that are considered covered by those experts given that they will be part of the generated team.
Now we address the  rst issue that we raised in the beginning of the section, which is that in our modeling we choose to optimize the cost allocation subject to an upper bound B in the coordination cost for the reasons explained in Section 3.3.
While for the theoretical analysis we wrote a principled version of the problem, in many practical applications, the upper bound B on the coordination cost is neither explicitly given nor clearly de ned.
Another approach to bi-criteria optimization problems is to compute the set of Dataset Bibsonomy n (people)
 m (skills)

 k (tasks)
 Average skills per expert
 Average skills per task Average degree soc.
net.
Power-law parameter  
 Average edge distance St. dev.
of edge distance










 Pareto optimal solutions [18], which are those solutions that are not outperformed by other solutions on both allocation and coordination costs.
The set of all Pareto-optimal solutions usually form a convex curve that de nes a clear trade-o  between allocation and social cost.
It is of course highly desirable that the Pareto curve is not far from the point in the space with coordinates equal to the minimum coordination cost and the minimum allocation cost of any solution.
The two approaches are tightly related and algorithms for one problem can be used for solving the other problem.
If the underlying optimization problems are NP-hard we can only hope to  nd in polynomial time Pareto-nearly-optimal solutions, which are solutions that are provably not outperformed from other solutions in all objectives for more than a limited amount [18].
The idea of the algorithms developed in Section 4 is that the right trade-o  between allocation and coordination cost is given by the ratio   between coordination and allocation costs in the optimal solution.
The problem is therefore reduced to solving the Social Task Assignment problem with allocation cost scaled by  .
An algorithm A will return a solution (QA, T A) that minimizes f A( ) =  a(QA) + c(T A).
Given that we do not assume in practice a bound on the coordination cost, we do not compute the pro le of the Pareto solutions.
Rather, we proceed with the optimization of f A( ) for di erent scaling factors  .
This will allow us to identify the best trade-o  between social and allocation cost.
Nevertheless, note that to solve (approximately) the optimization problem as formulated in Section 3.3 it su ces to observe only the values of   that are requested by the algorithms in Section 4.
Finding datasets that re ect the application scenarios of team formation is challenging, as such systems are not yet in widespread use, and most data from them is not publicly available.
For this reason, we follow the approach of previous work [2,13,14], and we use bibliography and movie datasets that can demonstrate the e ectiveness of our approach.
Summary statistics from these datasets are included in Table 3.
We expect that emerging crowdsourcing and labor marketplaces will provide in the future more realistic datasets for this line of research.
IMDB.
Our  rst dataset is extracted from the Internet Movie Database.
We focus on two types of movie personnel, directors and actors.
For skills we use the movie genres.
We assume that the set of genres of the movies that a person has participated make the set of skills for that person.
For example, Alfred Hitchcock has the skills {comedy, crime,  lm-noir, mystery, romance, thriller}.
We run our algorithms so that directors represent experts and actors represent tasks, where a random subset of 1000 actors was sampled.
Our setting simulates an imaginary scenario in which people who have directed a movie create small committees to audition actors.
We do not consider actors who have only one skill, because those can be assigned to a single director, which is not an interesting case.
Next, we de ne a social graph among the directors.
Since, typically movies are directed by only one director, we  connect  directors using actors as intermediaries: we form an edge between two directors if they have directed at least two distinct actors in common.
The cost of the edge is set to e rD, where D is the number of distinct actors directed by the two directors.
The distance function e rD takes values between 0 and 1, and it approaches very fast the value 0 as the number of commonly directed actors D between two directors increases.
We select the value of parameter r = 1
 for which we experimentally verify that it yields an intuitive range of values for the distance values on the edge weights.
Bibsonomy.
Our second dataset is extracted from bibson-omy [1], a social-bookmarking and publication-sharing system.
The dataset contains a large number of computer-science related publications.
Each publication is written by a set of authors.
The bibsonomy website is visited by a large community of users who use tags to annotate the publications, for example, theory, software, or ontology.
We use the set of tags associated with the papers of an author to represent the set of skills for that author.
We partition the set of authors into two sets: one set representing the experts and another set representing the tasks.
This setting simulates a scenario where committees of scientists interview other scientists, say, for a job position.
We consider the experts to be the most proli c authors in the dataset, and this explains why in Table 3 the number of skills per expert is higher than the number of skills per task.
For the set of authors who represent the tasks, we sample 2000 authors, and as before, we do not consider authors who have only one skill.
For creating a social graph among the experts we use co-authorship: two authors are connected with an edge if they have written at least one paper together.
The cost of an edge is set to e rD, where D is the number of common papers coauthored by the two authors, and we set again r = 1

 We implement the algorithms discussed in Section 5 in the cases where the coordination cost is the Steiner-tree cost and the diameter.
Tasks arrive sequentially and at each point the state of the system is described by the allocation cost a(p) for each person p   P, which is set according to the ExpLoad strategy based on the number of teams in which p has participated so far.
The allocation costs re ect the load of people due to the previous tasks.
Given a new task J our heuristic returns a sub-graph having nodes Q and edges T with the goal of minimizing f ( ) =  a(Q) + c(T ).
Following the discussion of Section 5, we study the behavior of our algorithm as we vary the parameter  .
We start with a very small value of  , which down-weights the load-balancing factor and emphasizes the coordination cost, and we increase   exponentially, so that load balancing becomes more important.
The results are shown in Figure 2 for the IMDB   implicitly connected Bibsonomy   explicitly connected Bibsonomy   implicitly connected
















 d a o l x a m d a o l x a m
















 coordination cost (Steiner) (a) Steiner cost vs. load on IMDB dataset coordination cost (Steiner)










 d a o l x a m



 coordination cost (Steiner)





 coordination cost (Steiner) (b) Steiner cost vs. load on Bibsonomy dataset



 d a o l x a m



 i e z s m a e t





 IMDB   explicitly connected IMDB   implicitly connected Bibsonomy   explicitly connected Bibsonomy   implicitly connected


 i e z s m a e t












 coordination cost (Steiner)







 coordination cost (Steiner)




 i e z s m a e t















 coordination cost (Steiner)



 i e z s m a e t











 coordination cost (Steiner)



 (c) Steiner cost vs. average team size on IMDB dataset (d) Steiner cost vs. average team size on Bibsonomy dataset Figure 2: Trade-o s between Steiner coordination cost vs. max load and average team size.
For computing the group Steiner tree on a task instance, two algorithms are used, the set-cover heuristic proposed in this paper (SC) and the heuristic proposed by Lappas et al. (LLT).
The label next to the  rst and last data points shows the value of  .
For the in-between points shown in the curve the value of   increases exponentially.
IMDB   explicitly connected IMDB   implicitly connected Bibsonomy   explicitly connected Bibsonomy   implicitly connected d a o l x a m









 d a o l x a m







 coordination cost (diameter)






 coordination cost (diameter) d a o l x a m











 d a o l x a m








 coordination cost (diameter)



 coordination cost (diameter)
 (a) Diameter vs. max load on IMDB dataset (b) Diameter vs. max load on Bibsonomy dataset Figure 3: Trade-o  between diameter and max load.
The label next to the  rst and last data points shows the value of  .
For the in-between points shown in the curve the value of   increases exponentially.
Steiner cost, and in Figure 3 for the diameter cost.
The plots show the trade-o s among coordination cost, team size, and maximum load obtained in di erent runs of the algorithm parametrized by  .
In these plots one can see clearly that our heuristic exploits nicely the trade-o  between load and coordination cost, making it possible to choose this parameter according to application-dependent objectives.
The results also indicate that ignoring the coordination costs (     ) as in [2] yields solutions that have high coordination costs.
Conversely, ignoring the workload (    0) as in [14] yields solutions that generate imbalanced schedules.
Improvements from these extremes in one of the components of the cost (coordination cost or load balance) can be obtained by paying a moderate price in the other component.
Steiner cost.
For the Steiner coordination cost, in addition to the set-cover heuristic discussed in Section 5, we also implement and compare with the group Steiner heuristic proposed by Lappas, Liu and Terzi [14], which we consequently refer to as the LLT heuristic.
Figures 2(a) and 2(b) show the trade-o  between Steiner cost and max load, as obtained by our online algorithm with call to the two di erent Steiner heuristics.
Similarly, Figures 2(c) and 2(d) show the trade-o  between Steiner cost and average team size.
We see that in almost all cases the set-cover heuristic is better that the LLT heuristic.
For the IMDB dataset, the set-cover heuristic produces solutions that dominate the LLT heuristic in terms of coordination cost and load.
Also the LLT heuristic gives teams of signi cantly larger size.
For the Bibsonomy dataset the di erence between the two heuristics is not so clear.
First we see that in the case of implicitly-connected teams, the LLT heuristic outperforms slightly the set-cover heuristic in the coordination-cost vs.
max-load space.
On the other hand, in the case of explicitly-connected teams, the LLT heuristic performs signi cantly worse than the set-cover heuristic.
In terms for average team size, for the smaller values of   the two heuristics produce solutions that do not dominate each other, while the LLT heuristic produces very similar solutions to each other.
cost the set-cover heuristic gives smaller teams than the LLT heuristic.
Overall, the set-cover heuristic explores better the coordination-cost vs. max-load trade-o  as a function of  , it gives smaller teams, and produces solutions that in most cases dominate the solutions produced by the LLT heuristic.
Diameter.
Our results for the diameter coordination cost on our two datasets (Figure 3) show the trade-o  of diameter vs. maximum load for the IMDB dataset.
We see that the dependency of the solution variables to the parameter   is similar as in the case of Steiner cost, however the range of values is smaller than the corresponding values in the Steiner case, and the curves are less smooth, especially on the Bib-sonomy dataset.
One characteristic of the solutions we obtain for the diameter is that the average team size remains constant for all values of  .
For the IMDB dataset it is about 4.5 for the explicitly-connected teams, and about 3.3 for the implicitly-connected teams.
For the Bibsonomy dataset it is about 7.5 for the explicitly-connected teams, and about 2.5 for the implicitly-connected teams.
Note also the strange artifact that in some few cases (e.g., in Figure 3(b)) we obtain solutions that have both higher cost and load by increasing the  .
This is due to the limitation that we can obtain only an approximate solution to the Social Task Assignment problem, and while rare, it demonstrates how the hardness of the problem can lead to suboptimal solutions.
Alternative load measure.
Measuring the load of the single most-loaded person is a measure that may be sensitive to outliers.
For this reason we computed an alternative, most robust, measure, which is the average load of the 10% most-loaded people.
We report here that the behavior of this measure is identical to the max-load measure, however, we omit the plots for lack of space.
Running time.
Overall, our method is also e cient in practice: we observe running times of 4-5 seconds per task for the Steiner cost, and 9-10 seconds per task for the diameter.
These times are recorded on a 4GB RAM, 2.5 GHz laptop.
We consider the problem creating teams of experts and assigning tasks to these teams, taking into account the requirements of every task, the work load of the experts, and their potential to collaborate or coordinate with each other.
We develop approximation algorithms with provable theoretical guarantees, and our experiments demonstrate the ability of our solutions to keep low coordination costs and to balance the workload simultaneously also in practice.
The potential applications of the framework are numerous, resulting to a large number of di erent future directions.
In this work we have assumed that we know the social network as well as the skill pro les of people.
In practice, this information needs to be learned, for example, from observed data.
It is also worth exploring how well teams can be created across di erent social networks exhibiting varying degrees of homophily.
For instance, if the only connections are among experts with similar skills, covering a large set of skills with a tightly connected group may be di cult.
We have used two di erent measures of coordination cost; further results, not included here, indicate that similar ideas can be applied to the case where coordination cost is measured as the diameter of a team.
We have also assumed that we want teams of people that are close to each other.
The converse can be true in other settings, for instance if we want to create a panel or jury of experts from which we want independent opinions here we probably want them to be far apart in the social network.
Finally, in this paper we have presented a static social network, while in practice people arrive and leave continually while the strength of their connections changes over time.
In addition, we have assumed that the strength of the connections are independent of the individual task.
Note that our algorithms and our results hold for all these settings as well.
In future work we would like to evaluate the performance of our algorithms in such dynamic settings.
