Collaborative web applications are pervasive in our daily lives since they exhibit numerous advantages in contrast to traditional desktop applications.
Leveraging the web as application platform provides access from a myriad of devices (e.g.
PCs, smartphones, etc.)
and allows for immediate adoption without requiring time-consuming installation procedures.
Moreover, providing real-time collaboration features allowing multiple users to edit the very same document simultaneously supersedes conventional document merging or document locking techniques.
These bene ts altogether prompted prominent collaborative web applications like Google Docs serving millions of users each and every day.
Even though there is a variety of shared editing use cases (e.g.
jointly create documents, spreadsheets, presentations, source code  les, CAD models, etc.
), web-based collaboration tools o ering shared editing capabilities are rare.
From the plentitude of web applications   for example the Chrome Web Store lists more than 6 000   we could only identify very few web applications targeting some form of shared editing.
We attribute this mismatch of existing applications to potential use cases to the poor technology support.
In particular, web frameworks do not support concurrency control services to the same extent they support common programming tasks like form validation or asynchronous communication.
On the one hand, general-purpose frameworks like jQuery or Knockout do not supply any functionality regarding concurrency control; on the other hand, speci c collaboration frameworks like ShareJS o er only a very limited set of features (e.g.
only strings can be synchronized).
Hence, programmers face the dilemma of having to get familiar with an extra framework which might not even suit their needs.
In essence, having to learn a speci c collaboration framework or implementing the required collaboration capabilities from scratch is a time-consuming and costly endeavor.
To lower the development costs implementing collaboration capabilities, we propose the Collaborative Applications via Data Annotations (ColADA) approach.
ColADA leverages source code annotations to enrich existing general-pur-pose web frameworks with concurrency control support.
Annotations are a speci c form of metadata and represent a widely adopted, lightweight approach to enhance applications with additional runtime features that are supplied by a dedicated annotation engine.
For example, Java frameworks
 @Column, etc.)
accompanied by an annotation engine to enhance applications with features like object persistence, dependency injection or container con guration.
We adopt source code annotations as a means to con gure a collaboration engine.
While developers enrich the application s source code with annotations to declare data objects as synchronized, the ColADA collaboration engine processes these annotations and accomplishes the synchronization.
The implemented ColADA system enriches the widely-adopted Knockout framework with collaboration capabilities.
In contrast to using a comprehensive programming library, we assume that a minimal annotation language eases learnability and reduces development time as well as boilerplate code.
Moreover, an annotation-based solution allows for multiple product variants.
While evaluating annotations activates the collaboration feature, removing annotations results in a fully functional single-user application.
To con rm our assumptions that an annotation-based solution can speed up the development of collaborative web applications, we conducted a thorough developer study involving eight programmers which had to use the ColADA solution and a conventional concurrency control library to develop a collaborative web application.
The main contributions of this paper are threefold: (cid:129) We propose an annotation-based approach to enrich existing general-purpose frameworks with concurrency control support to speed up the development of collaborative web applications.
(cid:129) We report on a developer study with eight programmers comparing the developer productivity of an anno-tation-based approach with a traditional approach leveraging a speci c collaboration library.
(cid:129) We carve out the framework characteristics that are required to incorporate a collaboration engine for the rapid development of shared editing applications and discuss the entailed bene ts as well as the induced limitations.
The rest of this paper is organized as follows: Section 2 exposes related work and Section 3 introduces the design goals of the ColADA system as well as the ColADA architecture.
Section 4 elaborates on the ColADA implementation and Section 5 shows the results of the conducted developer study considering development time, lines of code, etc.
While Section 6 discusses limitations of the proposed approach and requirements to adopt the ColADA system, Section 7 draws conclusions.
There are various approaches aiming to accelerate programmer productivity when developing collaborative applications.
Those approaches can be divided into two main categories: (1) concurrency control libraries exposing a set of low-level methods and (2) transformation approaches capable of converting single-user applications into collaborative multi-user applications.
In this section, we will introduce examples for each category and compare them to our work.
All approaches supporting the implementation of shared editing applications (e.g.
collaborative text editors, shared whiteboards, etc.)
have to expose document synchronization and con ict resolution services.
While the synchronization ensures that the input from various geographically dispersed users is synchronized without notable delay, the con ict resolution allows resolving editing con icts automatically.
For example, an editing con ict may occur if two users of a shared word processor add a character simultaneously at the very same document position or assign di erent fonts concurrently to the very same paragraph.
Numerous concurrency control libraries o er the synchronization of various document copies in real-time as well as the reconciliation of emerging editing con icts.
The predominant concurrency control algorithm is the Operational Transformation (OT) algorithm which has been introduced by Ellis and Gibbs in 1989 [6].
In the meantime, the OT algorithm has been evolved to suit numerous document structures (e.g.
SGML [5]) and to support advanced concurrency control operations (e.g.
undo [9] or operation compression [13]).
ShareJS [7] is an example of a concurrency control library.
The open-source ShareJS project is implemented in Co ee-Script which is compiled to JavaScript and thus, ShareJS can be embedded in arbitrary web applications.
The OT-based library is capable of synchronizing simple string objects and JSON documents.
However, the library does not allow syncing comprehensive data structures (e.g.
graph models).
Apache Wave [2] emanated from the former Google Wave product and represents a full edged collaboration platform including an OT library.
Its support for XML data structures allows implementing rich text editors that typically manage their data in some variation of a tree data structure.
Adopting Apache Wave entails the usage of the Google Web Toolkit (GWT).
Thereby, applications are implemented in Java and compiled to JavaScript.
The rigid GWT development approach lacks interoperability with other development approaches.
SAP Gravity [10] represents another OT library which is part of SAP Process Flow, an SAP product for collaborative business process modeling.
In terms of data structure support, SAP Gravity is more  exible than Apache Wave or ShareJS since it allows syncing graph models that may include cycles.
Thus, it is capable to accommodate arbitrary business processes that can be expressed in BPMN.
Since a tree is a connected graph without cycles, all tree data structures (e.g.
XML) are also supported by SAP Gravity.
The pure JavaScript library provided by SAP Gravity is suited for all standards-based web applications.
Even though OT libraries give developers a  exible means to implement collaboration capabilities at hand, adopting these solutions imposes various challenges.
First, web developers have to become familiar with the Application Programming Interface (API).
Second, using these APIs to introduce collaboration features into an existing application requires scattered and verbose source code changes.
For example, developers have to capture local document changes and replay remote document changes.
Third, some libraries (e.g.
Apache Wave) are not interoperable with general-purpose frameworks or common development approaches.
Considering these challenges we claim that an annotation-based approach can (1) reduce the entry barrier, (2) minimize required source code changes and (3) properly integrate with existing development approaches.
Transformation approaches were pioneered by Sun et al.
who advocated transparent adaptation [15] as a viable means to lower the development e ort for groupware systems.
The transparent adaption approach aims  to convert existing sin-gle-user applications into collaborative ones, without changing the source code of the original application  [15].
Thereby, a speci c collaboration adapter links the application model to a generic collaboration engine in order to locally record and remotely replay manipulations.
Sun et al. reported on the successful transformation of numerous prominent single-user tools such as Autodesk Maya [3], Microsoft Word [16] or Microsoft PowerPoint [15].
A second transformation approach targeting the conversion of single-user web applications was introduced in [8].
The conversion leverages a Generic Collaboration Infrastructure (GCI) that allows capturing and replaying Document Object Model (DOM) manipulations in an application-agnostic manner.
The GCI transformation was adopted to successfully convert two widely-adopted, open-source editors (SVG-edit and CKEditor).
In contrast to transparent adaptation requiring an application-speci c collaboration adapter, the GCI represents a more e cient transformation technique depending solely on a tailored con guration  le.
Both approaches incur limitations that we aim to address with the annotation-based ColADA solution.
On the one hand, transparent adaption promotes the use of an extra collaboration adapter for each application which signi cantly increases the transformation e ort.
On the other hand, the GCI is only adoptable by web applications which expose a data model accommodated in the DOM.
Web applications that expose an external data model represented by a speci c JavaScript data structure are not supported.
We propose the ColADA approach to overcome the limitations of existing approaches, i.e. the boilerplate code required by concurrency control libraries, the substantial e ort induced by transparent adaptation and the missing support of the GCI for external data models.
Therefore, in this section, we introduce the design goals and challenges of the ColADA approach as well as framework requirements allowing to adopt ColADA.
Moreover, we present the architecture of the ColADA system.
The overarching goal of our work is to increase programmer productivity in the context of the development of collaborative web applications.
We re ned this coarse-grained goal into the following objectives: (cid:129) Learnability: The approach should be easy to learn.
(cid:129) Collaboration Functionality Completeness: The collaboration engine should expose mature and  exible concurrency control services.
(cid:129) Interoperability: The collaborative applications should support cross-browser and cross-device scenarios, i.e.
users can leverage shared editing capabilities using an arbitrary modern browser and an arbitrary Internet-ready device.
Table 1: Catalog of MVC web frameworks (cid:129) Separation of Concerns: Collaboration features should be clearly separated from other functional aspects.
While learnability ensures that programmers can rapidly adopt the approach, collaboration functionality and inter-operability assure that the envisioned collaboration engine meets the requirements of industrial-scale projects in terms of quality,  exibility as well as browser coverage.
The separation of concerns goal facilitates product maintainability and eases the bundling of several product variants (i.e.
single-user and multi-user versions).
To address the learnability objective, we adopt an annota-tion-based solution exhibiting a minimal set of annotations that enriches an existing framework instead of devising an extra framework.
Hence, developers might leverage their existing skill set with respect to the host framework.
To furthermore provide mature collaboration functionality, we aim to incorporate the operational transformation engine SAP Gravity that has a proven track record of serving real applications since it powers the industrial-strength product SAP Process Flow [10].
Interoperability is the most challenging objective since there is a myriad of browsers and a plentitude of Internet-ready devices whereas device characteristics (e.g.
screen size) and browser characteristics (e.g.
supported JavaScript libraries) strongly di er.
Instead of dealing with varying browser or device characteristics, we plan to employ an existing web application framework providing a robust abstraction and hiding browser inconsistencies as well as device speci cs.
Satisfying the separation of concerns objective can also be accomplished through annotations since their declarative style establishes a distinctive isolation.
In the following, we derive from the design goals a set of requirements that a framework has to ful ll.
First, a framework that quali es for the enrichment with collaboration capabilities should enforce the separation of the presentation and the data layer.
The availability of an encapsulated data model is the key to synchronize numerous application instances in a device and browser-independent way since application models are a means to store data without including speci cs about their presentation.
Thus, the inter-operability goal can be satis ed.
Table 1 lists frameworks that enforce the established Model-View-Controller (MVC) structure [4].
(b) Subgraph-based Data Model Application Application Client View Controller
 Model Server







 Client View Controller
 Model Application Application Data Access Reference Business Logic Business Logic Reference Annotated Data Objects Data Reference Data Objects Application Components Collaboration Engine Components FCA - Framework-specific Collaboration Adapter OTE - Operational Transformation Engine SCA - Source Code Annotations Figure 1: Classi cation of typical data model structures A second framework requirement stems from the fact that we have to attach a collaboration engine providing suitable collaboration functionality (i.e.
concurrency control services).
Therefore, captured model changes have to be supplied to the collaboration engine which requires a noti cation mechanism.
This noti cation mechanism allows the collaboration engine to react upon model changes.
Hence, model manipulations can be recorded and propagated.
As depicted in Table 1, all considered frameworks supply an appropriate mechanism to register event handlers.
A last requirement is induced by the adoption of an anno-tation-based approach supporting the learnability and separation of concerns objective.
Annotations represent a viable means to declaratively mark the data model in order to con gure the collaboration engine.
Consequently, the data model structure determines the quantity of required annotations.
Thus, we further analyzed the frameworks shown in Table 1 and established a data model classi cation depicted in Figure 1 grouping MVC applications into (1) scattered and (2) subgraph-based data model structures.
Applications with a scattered data structure (cf.
Figure 1a) expose numerous partial data models that are not interlinked.
To discover and synchronize each model, the collaboration engine requires an annotation for each root node of a partial model.
In contrast, applications with a subgraph-based data structure (cf.
Figure 1b) require solely one annotation since the interlinked data structure can be completely discovered marking the single root node of the data model.
Minimizing the number of source code annotations is essential to increase developer productivity and therefore, we only consider frameworks that enforce applications to expose a subgraph-based data model.
After carving out framework requirements, we devised the ColADA architecture depicted in Figure 2.
The distributed ColADA system consists of a server and an arbitrary number of clients.
ColADA components are divided into white components belonging to the original application and grey components representing the collaboration engine.
The white boxes illustrate a framework-based application including the model, the view and the controller.
The controller mediates between view and model, i.e. once the user triggers view changes they are propagated to the model and vice versa.
Additionally, the application model represents the interface to the collaboration engine which captures local model manipulations and replays remote model modi cations.
The capture and replay logic is accommodated in the Framework-Figure 2: Architecture of the ColADA system speci c Collaboration Adapter (FCA).
This FCA also includes the annotation processor that replaces introduced Source Code Annotations (SCAs) with JavaScript function calls once the application is loaded.
Those inserted function calls are a means to register listeners as well as to attach replay handlers.
To support proper document synchronization and con ict resolution, an Operational Transformation Engine (OTE) handles all sync mechanics.
Thereby, the FCA supplies change noti cations which are converted by the OTE into OT operations.
Transforming concurrent OT operations allows to resolve con icts and to maintain consistent document copies.
For example, if two users simultaneously add a character at the  rst position of their document copy, the OTE adapts the indexes so that one character is added at the  rst position while the other character is inserted at the second position.
Hence, the editing con ict is resolved and both document copies are consistent.
Another responsibility of the OTE is to serialize OT operations in a JSON representation.
Serialized OT operations are sent to a central server using common bidirectional, HTTP-based communication techniques such as long polling or HTTP streaming [17].
The server instance forwards the messages to all clients except the sender client.
Once the message is delivered to a client, the JSON message is deserialized into an OT operation.
In order to reconcile potential con icts, this OT operation has to be transformed against concurrent local operations.
Transformed OT operations are translated into model manipulations to sync the respective model instance.
The ColADA architecture is materialized by a concrete implementation that we will discuss in the following.
In essence, the implementation section focuses on the annotation language, the annotation incorporation work ow, the annotation replacement process as well as the sync procedures.
When selecting a speci c framework for the ColADA implementation, we took into account the three identi ed framework requirements: (1) the availability of a noti cation mechanism, (2) the subgraph-based data structure and (3) the MVC compliance.
Consequently, only four frameworks in Table 1 are eligible for adding shared editing capabilities.
Due to the overwhelming adoption of the Knockout framework in recent months (i.e. approximately 1 million downloads in 2012), we selected Knockout [11] for the integration of an application-agnostic collaboration engine.
Hence, we translated the generic ColADA architecture depicted in
 whereas the framework-speci c adapter is materialized by the Knockout Collaboration Adapter (KCA).
We devised a Knockout-speci c annotation language comprising the source code annotations @Sync and @Class.
This compact annotation language is a means to con gure sync processes in the following way: (cid:129) @Sync: The @Sync(modelName) annotation marks the Knockout model that should be synchronized among all application instances sharing the same session.
The parameter modelName identi es the name of the JavaScript variable pointing to the data model.
(cid:129) @Class: The @Class(className) annotation acts as a selector for object constructors.
In order to allow for a proper replay of a local object creation at all remote sites, an object constructor has to be leveraged since the object creation might incur side e ects.
For example, creating a new object might entail to increment a global counter.
This side e ect of incrementing a counter cannot be replayed in a generic fashion and thus, the collaboration engine requires a handle to the actual object constructor.
To illustrate how source code annotations can be adopted to implement collaborative Knockout applications, we introduce the minimal example of a todo list application.
This collaborative application should allow multiple users to concurrently add, remove or edit tasks that are organized in a list.
Knockout applications commonly comprise two distinct parts: a view de nition as well as a model de nition which are automatically associated at runtime.
To enhance such an application with collaboration support, the following steps are required: (cid:129) Annotation Insertion: Insert source code annotations in all  les encapsulating data model de nitions.
(cid:129) Con guration: Complete a dedicated con guration by listing all  les which contain annotations.
(cid:129) KCA Import: Adapt the view de nition in order to replace the original model import with the KCA import.
Figure 3 and Figure 4 show the collaboration-enabled view as well as the model for to the exemplary todo list application.
The view de nition (cf.
Figure 3) mainly comprises regular HTML tags intermingled with a Knockout-speci c data-bind attribute.
While HTML tags de ne the UI to enter new tasks and to enumerate them in a dedicated list, the data-bind attribute establishes the link to the data model.
The only di erence between the original and the collaboration-enabled view de nition is the script import section.
Instead of embedding the original Knockout model (encapsulated in the <! - / - > tags), the collaboration adapter kca.js has to be included.
The kca.js script
 ment a second collaboration adapter targeting the SAPUI5 framework [12] which is solely exploited for SAP-internal use cases.
...
<! <script type="text/javascript" src="model.js"/> > <script type="text/javascript" src="kca.js"/> ...
<input data-bind="value: input"/> <button data-bind="click: addTask">Add Task</button> <ul data-bind="foreach: tasks"> <li> <span data-bind="text: name"></span> <a href='#' data-bind="click: delete">Delete Task</a> </li> </ul> ...
Figure 3: Exemplary Knockout view including the kca.js script // @Class("Task") var Task = function (data) { this.name = ko.observable(data.name) } Task.prototype.delete = function() { model.tasks.remove(this) } // @Sync("model") var model = { input: ko.observable(), tasks: ko.observableArray() } model.addTask = function() { model.tasks.push(new Task({'name': model.input()})); model.input("") } ko.applyBindings(model); ...
Figure 4: Exemplary Knockout model enhanced with annotations exploits a dedicated con guration  le to retrieve associated model de nitions.
Eventually, the parser encapsulated in the kca.js locates all annotations and replaces them with the synchronization logic.
In Figure 4, an annotated model de nition associated to the view de nition in Figure 3 is depicted.
The @Class annotation marks the object constructor to allow for the creation of new task objects and @Sync points to the model variable to get a handle to the actual data model.
Note that all annotations are encapsulated in JavaScript comments since JavaScript does not o er a native annotation concept.
To illustrate the explained example, we additionally produced a screencast demonstrating the creation of the collaborative todo application and made it available on our ColADA page http://vsr.informatik.tu-chemnitz.de/demo/ColADA/.
To grasp the inner workings of the Knockout-speci c implementation, it is crucial to understand the annotation processor that replaces annotations with JavaScript source code at runtime.
The annotation processing starts by parsing all model de nition  les speci ed in the con guration and iden-ti es inserted annotations.
Those annotations are expanded to blocks of JavaScript code which for the @Class annotation is straightforward.
The logic replacing the @Class annotation expands to a function call storing a reference to the constructor method in a global map.
In contrast to this minimal substitution, the replacement of @Sync is challenging since the injected code has to bridge the gap between the Knockout model and the OTE which essentially enables the propagation of local manipulations and the replay of remote manipulations.
Figure 5 depicts a skeleton of the inlined





 function traverseModel(knockoutModel) { ... // list includes all nodes of the Knockout model return koNodeList; } foreach(koNode in traverseModel(knockoutModel)) { koNode.setUUID(); if(koNode.isType(Primitive)) { // create Gravity node and set inital value gravityNode = gravityModel.addNode(...); // propagate local changes koNode.subscribe(function(newValue) {...}); // subscribe to Gravity model changes gravityModel.addModelListener(...); } if(koNode.isType(Array)) {...} } Figure 5: Skeleton of the JavaScript function replacing the @Sync annotation function replacing the @Sync annotation.
Note that this pseudocode is bound to the speci c SAP Gravity OTE [10].
The SAP Gravity OTE consists of a graph model accommodating nodes, attributes and edges.
A graph model is created using a dedicated JavaScript API that o ers functions like createModel(), addNode(), etc.
SAP Gravity synchronizes this speci c graph model automatically adopting an OT-based con ict resolution scheme.
Hence, to sync an application, the Knockout model has to be mapped to the Gravity data structure and vice versa.
This bidirectional mapping is materialized by the functions depicted in Figure 5.
Establishing the mapping is subdivided in (I) traversing the Knockout model, (II) assigning a unique ID to Knockout nodes, (III) creating Gravity counterparts for Knockout nodes, (IV) registering listeners on Knockout nodes to inform about local changes and (V) attaching listeners to Gravity nodes to replay remote changes.
In comparison to inserting a one-line annotation, the complex inlined function supporting arbitrary Knockout models adds up to more than a thousand lines of JavaScript code.
This complexity originates from the generic applicability of the function that supports the traversal of all graph-structured Knockout models, the mapping of various Knockout node types, the callback registration for di erent model change operations, etc.
Note that adding the code for a speci c Knockout model would drastically reduce the code complexity but the  ve major code blocks (cf.
Figure 5) are still required.
After all annotations were replaced with corresponding JavaScript functions, the synchronization work ows as depicted in Figure 6 are executed by the browser s JavaScript engine.
The synchronization is divided into two processes: the local change propagation (cf.
Figure 6a) and the remote change incorporation (cf.
Figure 6b).
The local change propagation encompasses various steps.
First, listeners registered on the Knockout model translate all kinds of model manipulations (e.g.
change, create or delete operations) into Gravity API calls and inform the model handler.
As soon as the model handler is noti ed, the Gravity API calls are applied on the Gravity model.
These changes to the Gravity model are observed by the operation generator which is in charge of extracting and grouping the (a) Local Change Propagation (b) Remote Change Incorporation Knockout Application Knockout Application View Controller Model* View Controller Model* Gravity Model
 Operation Generator


 Model Handler
 Gravity Model

 Model Handler

 Serializer
 Operation Generator
 Deserializer
 SAP Gravity OTE SAP Gravity OTE * Annotations have already been replaced by JavaScript code.
Figure 6: Synchronization work ows resulting OT operations.
Grouping OT operations is a spe-ci c Gravity OTE concept allowing to encapsulate numerous primitive OT operations in one complex OT operation that is executed in a transactional manner, i.e. complex operations are either completely executed or completely rolled back.
For example, inserting a table in a word processor might comprise the creation of various table cells whereas this compound create-table operation can be easily translated to Gravity s complex operation concept.
Aggregated OT operations are forwarded by the model handler to the JSON serializer.
Eventually, the JSON serializer converts OT operation objects into a JSON representation that is transmitted to the server.
The server distributes the JSON messages to all clients except the sender client.
Clients receiving JSON change sets trigger the remote change incorporation process (cf.
Figure 6b).
Initially, the JSON deserializer transforms JSON messages into JavaScript objects accommodating OT operations.
The model handler then transforms these operations against concurrent local operations and the resulting transformed operations are applied to the Gravity model.
Thereby, the operation generator is detached from the Gravity model to avoid propagating the change back to remote clients.
Moreover, the model handler leverages the inlined code to re ect the changes in the Knockout model.
Annotated web applications can be deployed on regular HTTP servers whereas an additional sync server is required.
Once the application is deployed, a modern browser is su -cient to execute the annotation processing and the synchronization on the client side.
Nevertheless, deploying a mini ed version requires the running of the annotation processor before the mini cation step since the mini cation removes the comments from the source code including annotations.
Besides combining the annotation processor with a mini cation step, it is also feasible to produce a single-user product variant.
Thereby, the mini cation step is run exclusively without the annotation processing step.
To assess developer productivity, the Knockout-speci c ColADA system and the set of annotations were leveraged in a developer study and compared to a traditional concurrency control library.
In this section, we report on the selected evaluation characteristics, the adopted evaluation
 Quality in Use Functional Suitability Compatibility Usability Maintainability Performance Efficiency Reliability Security Portability Effectiveness Efficiency Satisfaction Freedom from Risk Context Coverage Relevant Characteristics Irrelevant Characteristics Figure 7: Product quality and quality in use model de ned in the ISO/IEC 25010 procedure, the devised development task as well as the detected evaluation results.
In order to yield meaningful results conducting a developer study, we embraced a number of established software metrics that target the evaluation of software systems.
In particular, we took into account the product quality model and the quality in use model which are both de ned in the ISO/IEC 25010 standard [1].
While the product quality model determines the static quality of a software system, the quality in use model emphasizes characteristics that are relevant in concrete usage scenarios.
Both models encompass various quality aspects whereas some are not appropriate for the assessment of developer productivity.
Figure 7 shows relevant characteristics that we embraced in the developer study as well as irrelevant characteristics that we chose to neglect.
Before conducting the actual developer study, several aspects had to be planned in advance.
For example, developers were recruited, introductory lectures about the ColADA approach and the selected concurrency control library were prepared, a suitable task description for the development of a collaborative application was devised and a questionnaire to assess the selected quality characteristics was authored.
To limit the evaluation costs, we o ered a three months course at the Dresden University of Technology instead of recruiting professional developers.
Students were only eligible for the course if they were enrolled at the faculty of computer science.
Eventually, eight students participated and completed a questionnaire assessing their programming expertise at the beginning of the course.
The completed questionnaires showed that all students were familiar with numerous programming languages (e.g.
Java, C, etc.).
However, no student was acquainted with the development of shared editing applications.
The o ered course was divided into three development sprints where students were asked to  rst develop a single-user application using the Knockout framework.
Moreover, students had to enrich this single-user application with collaboration capabilities using, on the one hand, the devised Cost-Benefit Analysis New Item Delete Item ...
...
Discontinue - Item A1 - Item A2 Alternatives - Item C1 h g h i t s o
 w o l Review Costs - Item B1 - Item B2 Continue - Item D1 low Benefit high Functional Requirements: (1) Cost and benefit items shall be classified in a 2 x 2 matrix.
(2) Matrix cells shall accommodate user-created items.
(3) Users shall be able to add and remove items.
(4) Users shall be able to move and reorder items using drag-and-drop.
(5) Matrix cells and the matrix itself shall expose a heading and the matrix axes shall exhibit a label.
(6) Headings, labels and items shall be editable.
(7) All user changes shall be synchronized in real-time and conflicts shall be automatically resolved.
Figure 8: Mockup and requirements of the cost-bene t analysis application ColADA solution; and on the other hand, leveraging the concurrency control library SAP Gravity.
Each development sprint started with a tailored lecture targeting (1) the Knockout framework, (2) the annotation-based programming model and (3) the SAP Gravity API.
The collaborative web application that was going to be developed to compare the traditional approach leveraging the Gravity API with the proposed annotation-based solution should support cost-bene t analyses.
A Cost-Bene t Analysis (CBA) is a systematic process to justify an investment or to compare various projects by listing all positive and all negative factors.
For example, a CBA might be used to review the construction of a new highway or to rethink the introduction of an enterprise resource planning system.
The development speci cation in Figure 8 de nes the functional requirements and a mockup of the CBA application that students had to implement.
After receiving an introductory session about programming Knockout applications, the task speci cation (cf.
Figure 8) was distributed among all participants.
In the  rst development sprint, students had to program the single-user application which served as the base application for the development of the collaborative CBA applications.
In the second sprint, students programmed the collaborative CBA application adopting the Knockout collaboration adapter and in the third sprint, they were asked to introduce shared editing capabilities using the SAP Gravity API.
Adopting the Gravity JavaScript API means students have to manually write the source code to sync the Knockout model and the Gravity model which includes traversing the models, registering callback functions, etc.
(cf.
Figure 5).
During the entire development period, students had to work and implement their prototypes autonomously.
However, a weekly meeting was setup to discuss issues with other participants or with a dedicated supervisor.
To properly analyze the students  work, various qualitative and quantitative data sources were captured.
In particular, the following data sources were used to compare the two approaches for collaborative application development:
 time analysis (cid:129) Development Documentation: In every development sprint, students were asked to complete a form.
This form was divided into two parts: the time recording and the issues section.
In the time recordings  part, students had to enter a subtask description associated to the time spent for the completion.
In the issues section, students explained encountered problems.
(cid:129) Source Code: The source code handed in at the end of each sprint was analyzed to assess the ful llment of the functional requirements and to measure the resulting lines of code.
The lines-of-code analysis divided the code contributions into the individual programming languages (e.g.
JavaScript, HTML, etc.
).
(cid:129) Questionnaire: After completing the three development sprints, all students had to  ll out a questionnaire comprising 34 questions, 17 of which addressed the Gravity-based development and the other 17 aimed to assess the annotation-based development approach.
The questionnaire depicted in Figure 11 was designed to evaluate product quality characteristics (cf.
Q1 -Q12) as well as quality in use aspects (cf.
Q13 - Q17).
To compare the e ectiveness and e ciency of the ColADA approach with the conventional concurrency control library, we  rst employed two quantitative measures: (1) the development time and (2) the lines of code measure.
Therefore, we exploited data collected in the form of development documentation and handed in source code.
Only if all functional requirements were ful lled, the collected data was included in the e ectiveness and e ciency assessment.
From eight students seven were able to completely  nish the development of the single-user application as well as the implementation of the two collaborative applications.
Consequently, when calculating the mean   of the total development time, we only considered the timesheets from seven students.
On average, students spent 54 hours to get familiar with the Gravity API and to program the collaborative application in contrast to 42 hours adopting source code annotations (cf.
Figure 9).
Hence, employing the annotation-based approach could reduce the development e ort by 22 percent.
The overall development times of 54 hours and 42 hours respectively include 25 hours that were dedicated to the implementation of the single-user application.
Thus, the actual development e ort for introducing shared editing capabilities adds up to 29 hours versus 17 hours.
This represents a 41 percent reduction when adopting the annotation-based approach.
Even though the evaluation was only conducted with eight developers and solely included one speci c concurrency control library (the Gravity API) as well as one speci c annotation solution, the trend is apparent that con guring a collaboration engine using Figure 10: Calculated mean   in the lines of code analysis source code annotations is bene cial in terms of e ciency and can signi cantly outperform conventional collaboration libraries.
In terms of e ectiveness, both development approaches are suitable to develop collaborative applications since the resulting implementations were able to ful ll all functional requirements.
The second quantitative measure analyzed the Lines of Code (LoC) metric whereas seven valid source code contributions were included in the analysis.
The code contributions were divided into the individual categories (1) HTML code, (2) JavaScript code, (3) annotation code and (4) con guration code.
Figure 10 shows the LoC measurements whereas in each category the mean   is depicted.
One distinguishing factor between the use of the Gravity API and the use of annotations is the JavaScript LoC measure.
On average, developers needed 97 lines of JavaScript code accompanied by 4 annotations and 7 con guration lines to inject collaboration capabilities in contrast to 515 lines of JavaScript code for adopting the Gravity API.
This represents a considerable reduction of 81 percent in terms of JavaScript code when leveraging the proposed annotation-based approach.
Even though the HTML LoC exposes only minor di erences, the overall LoC measure resulting in 878 LoC versus 462 LoC once again shows a 47 percent source code reduction adopting the introduced ColADA solution.
The substantial LoC reduction is another demonstration of the e ciency an annotation-based solution can deliver.
Besides employing quantitative measures, we also exploited qualitative evaluation techniques.
Therefore, we created a questionnaire (cf.
Figure 11) that targeted the selected evaluation characteristics (cf.
Figure 7).
For both development approaches, eight completed questionnaires were used to calculate the mean   as well as the con dence interval [14].
While the mean   is depicted in Figure 11 by grey bars, the con dence interval is visualized using black error bars.
Con dence intervals are associated to a con dence level of
 dence level expresses the likelihood that further equally conducted developer studies would also expose a mean within the limits of the con dence interval.
Moreover, con dence intervals are a viable means to detect whether the di erence of various mean constants (e.g.
the means calculated for the two development approaches) are signi cant or not.
If con dence intervals do not overlap, the di erences of the means are signi cant [14].
If, on the contrary, con dence intervals do overlap, deriving an assured conclusion is not possible.
In general, the results of the experiment demonstrate that the ColADA approach constantly received superior ratings compared to the conventional approach leveraging the Gravity API.
The functional suitability ratings could con rm that both approaches provide the necessary functionality
 to develop collaborative applications (Q1:  KCA = 4.50,  Gra = 3.88).
However, the ColADA approach could sig-ni cantly outperform the Gravity approach with respect to the ease of development (Q2:  KCA = 4.50,  Gra = 3.25).
Regarding the compatibility characteristics (Q3-Q4) developers stated that both programming methodologies did not restrict their choice of technology and that the technology interplay worked well.
Even though the KCA ratings are slightly better (Q3 2 :  KCA = 2.25,  Gra = 2.38, Q4:  KCA = 4.00,  Gra = 3.25), the di erence is not substantial.
The same trend with modestly better ratings for the KCA approach continued in the usability category where students were asked to assess the learnability, the ease of use and the error prevention.
We would, however, have expected a larger di erence, in particular in terms of learnability (Q5:  KCA = 3.63,  Gra = 2.88).
Maintainability ratings once again exhibited considerable advantages for the KCA approach.
In particular the separation of synchronization code from the rest of the application code is appropriately supported by the annotation-based approach (Q8:  KCA =
 reconstruct failures leaves room for improvement.
For the KCA approach error detection and debugging is especially cumbersome since annotations are replaced at runtime and
 rating.
consequently, the design time and the runtime de nition differ.
The satisfaction category once again assured that the KCA is easily adoptable (Q16:  KCA = 4.00,  Gra = 2.63) and represents a comfortable means to develop collaborative applications (Q17:  KCA = 4.38,  Gra = 2.88).
The non-overlapping con dence intervals in Q16 and Q17 exhibit that this di erence is signi cant.
While exploring an annotation-based concurrency control solution, we observed numerous bene ts and limitations.
In the evaluation section, we reported on the bene ts.
For example, development time and lines of code were crucially reduced.
In addition, evaluated software characteristics constantly received superior ratings compared to a traditional concurrency control API.
In this section, limitations regarding the Knockout-based implementation are discussed.
Debugging Support: As described in Section 4.3 an annotation processor is in charge of replacing annotations with blocks of JavaScript code that are executed at runtime.
When debugging the annotated application, developers are confronted with generated code and not with familiar annotations.
This representation switch may hinder the debugging e ciency since developers have to adapt to the injected source code representing annotations.
Nevertheless, the in-lined JavaScript functions (cf.
Figure 5) are  xed and thus, 559the replacement of an annotation is analog to stepping into the de nition of a function call.
The only di erence is that the method body entered during debugging is associated to an annotation and not to a function call.
Individual model properties (e.g.
Noti cation Bypassing: The Knockout-speci c noti- cation mechanism is established through observable functions that allow inspecting model elements and thus, this mechanism is exploited by the KCA to capture model manipulations.
task name or task due date) can only be monitored if they are declared as Knockout observables.
The Knockout framework o ers three methods to declare observables: observable(), computed() and observableArray().
While the observable method allows declaring simple model properties (e.g.
name), the computed method can declare aggregated properties (e.g.
 rst and last name) and observableArray is used to declare arrays.
However, if developers circumvent this Knockout-speci c noti cation mechanism, the KCA has no means to record model manipulations and the sync mechanism breaks.
Runtime Model Enhancements: Once the kca.js script is loaded by the browser, the included annotation processor locates annotations and replaces them with JavaScript code that accommodates the listener and the replay logic.
If the model de nition changes at runtime (e.g.
a task object is enhanced with a new priority property), the KCA will not take notice and will fail syncing this novel model property.
Constantly examining all runtime objects for property enhancements could eliminate this limitation but at the cost of performance degradation.
Since changing the model definition at runtime is rather exceptional, we did not adapt the current KCA implementation.
Incorporating shared editing capabilities in web applications using traditional concurrency control libraries is a time-consuming and tedious task.
Therefore, we evaluated the ColADA solution which promised to increase development productivity since lightweight source code annotations are leveraged instead of using conventional collaboration libraries that induce the need to rigorously change the application s source code.
Through the transformation of the widely-adopted Knockout framework into a collaboration-enabled web application framework, we showed that source code annotations are in the  rst place a viable option to introduce collaboration features.
Moreover, a developer study employing the adapted Knockout framework could a rm our hypothesis that the annotation-based ColADA approach can outperform a traditional concurrency control library.
In the particular developer study, we compared the enriched Knockout framework with the SAP Gravity library and the results showed that the development time as well as the required source code changes can be substantially reduced when adopting an annotation-based solution.
Additionally, the developer study exhibits that programmers are generally more satis ed with an annotation-based approach when comparing software quality characteristics like functional suitability, compatibility, usability, maintainability and satisfaction.
Besides being bene cial for development e ciency, annotations are also a capable means to de ne multiple product variants (e.g.
single-user and multi-user version) in one single code branch.
