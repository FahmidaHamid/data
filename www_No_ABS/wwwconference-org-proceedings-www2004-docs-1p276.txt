E-Commerce is a growing phenomenon as consumers gain experience and comfort with shopping on the Internet [33].
E-Com-merce Web sites are typically composed of a three-tiered architecture consisting of a front-end Web server, an application server and a back-end database.
Online merchants desire to maintain a continuous, consistent presence on the Web in order to keep customers satis ed and maximize revenues and returns on their infrastructure.
Two problems are typically encountered with deploying e-com-merce Web sites.
First is overload, where the volume of requests for content at a site temporarily exceeds the capacity for serving them and renders the site unusable.
Second is responsiveness, where the lack of adequate response time leads to lowered usage of a site, and subsequently, reduced revenues.
Both issues are instances of a larger problem: given the unpredictability of Web accesses, how can an e-commerce site provide responsive service to clients, even when user demand outstrips the capacity of the site?
This paper presents a method for providing admission control and request scheduling for multiply-tiered e-commerce Web sites.
Our approach externally measures execution costs online, differentiating between different types of requests, enabling overload protection and dramatic improvements in response time.
Our admission control scheme accounts for variations in service costs.
By measuring service times online, our system is more robust to overload than approaches which assume that measurements taken under light load are applicable to heavy load situations.
As will be seen, service costs can change as a function of load in the system.
Our approach also accounts for variation in the execution times of different types of requests; other approaches only account for a single metric such as overall response time or queue length, or assume a simple linear model of service costs.
In contrast, we track the amount of work generated by each request directly.
Other proposals require extensive modi cations to the operating system or a complete rewrite of the server.
Our implementation requires no changes to the source code, server software, application programs, or to the database.
The bene ts of such an approach are clear: the use of unmodi ed commodity software components reduces development effort tremendously.
As a result, we are able to demonstrate our approach using standard software components and workload generators.
app protocol
 web server application server database server Figure 1: Architecture of an e-commerce Web site.
Our method is embodied in a proxy, called Gatekeeper.
A key feature is that it is transparent to the database and application server.
For our evaluation, we use a standard test-bed environment of a multiple-tiered e-commerce Web site, with Linux, Apache, Tomcat, MySQL and DB2.
In this environment, the database is the bottleneck, and thus Gatekeeper is placed so as to transparently intercept requests from the application server to the database.
Driving the system with the industry-standard TPC-W benchmark, Gatekeeper achieves both stable behavior during overload and dramatically improved response times.
Even though our approach is external and treats the system as a black box, we gain many of the bene ts of admission control and request scheduling.
Examples include: (cid:127) We show consistent performance during overload, across different database implementations and locking approaches.
(cid:127) We demonstrate how admission control can improve peak throughput by up to 10 percent, by preventing thrashing and improving memory reference locality.
(cid:127) We show how preferential scheduling in the form of shortest job  rst (SJF) can make dramatic improvements to response time for dynamic Web requests, while penalizing large jobs only slightly.
Average response time improves up to 14-fold, while penalizing large jobs by only 15 percent.
(cid:127) We present and evaluate an aging mechanism that prevents starvation of large jobs when preferential scheduling is used.
Our results show a continuum of behavior between FIFO and SJF request scheduling; Web site operators can use the mechanism to implement a policy enforcing a particular behavior.
These results show that relatively invasive techniques that require extensive modi cations to systems are not always necessary, particularly in the context of multiply-tiered e-commerce Web sites.
The remainder of this paper is organized as follows: Section 2 overviews the relevant background for our work.
Section 3 presents our implementation of admission control and request scheduling in the Gatekeeper proxy.
Section 4 describes our experimental environment, and Section 5 shows our results in detail.
Section 6 discusses related work.
Finally, Section 7 summarizes our conclusions and offers possible directions for future work.
In this section, we provide a brief overview of dynamic content generation, admission control, overload control, and request scheduling, in the context of Web servers.
An e-commerce Web site is typically comprised of three components as depicted in Figure 1: a front-end Web server, application server and back-end database.
The front-end Web server usually handles the static component of the workload, such as images and infrequently-changing HTML pages.
The application server provides an environment to invoke methods that implement the business and presentation logic of the application.
Examples of these methods include PHP scripts, Active Server Pages (ASPs) and Java Servlets.
The application logic issues a number of queries to the database, which stores the true dynamic state of the Web site (for example, the number of copies of a book in stock).
The application server formats the returned database query results as an HTML page, which is passed back to the front-end Web server.
Finally, the Web server returns the aggregated content to the client.
Admission control and coping with overload is used to prevent systems from being overwhelmed in the presence of persistent or transient overload.
Research in this area can be roughly categorized under two broad approaches: reducing the amount of work required when faced with overload, and differentiating classes of customers so that response times of preferred clients do not suffer in the presence of overload.
Multiple proposals have been offered for using QoS techniques on Web servers [3, 11, 28, 44].
These have tended to include some form of classi cation in the form of client IP address, IP subnet, URL or cookie to identify requests as belonging to a particular differentiated level of service.
To support these classes, these approaches also include admission control and request scheduling, in order to provide a particular server throughput, network bandwidth, or client response time.
Some have advocated using observation-based measurements for providing QoS guarantees [35]; others have proposed a control theoretic approach [2].
Our work complements and extends the above results by applying admission control for Web sites with dynamic content, rather than simply static content.
We use admission control to prevent overload and maintain peak aggregate throughput, rather than for guaranteeing response times for differentiated classes of service.
We believe extending our system to guarantee response times should be straightforward.
In the last few years, a great deal of interest has arisen in applying a scheduling policy in the context of Web servers providing static content.
Cherkasova [16] proposed using shortest job  rst scheduling for static content Web sites.
By using the URL in an HTTP request to identify a  le, the cost of servicing that  le (that is, the  job size ) could be well approximated by the size of the  le.
Cherkasova evaluated her proposal via trace-driven simulation.
Crovella et al. [19] independently proposed a similar approach, scheduling outbound responses according to a  shortest connection  rst  policy similar to shortest remaining processing time  rst (SRPT).
They demonstrated experimental results showing that response time could be improved by up to a factor of 5.
Schroeder and Harchol-Balter [37] demonstrate an additional ben-e t from performing SRPT scheduling for static content Web requests.
Under a wide breadth of networking and server conditions, they show that SRPT scheduling can be used to mitigate the response time effects of transient overload conditions.
TPC-W Service Time Distributions (high load)




 y t i l i b a b o r
 e v i t l a u m u







 y t i l i b a b o r
 e v i t l a u m u


 Admin Request Admin Response Best Sellers Buy Confirm Buy Request Execute Search Home New Products Order Display Order Inquiry Product Detail Search Request Shopping Cart





 Time in Milliseconds Admin Request Admin Response Best Sellers Buy Confirm Buy Request Execute Search Home New Products Order Display Order Inquiry Product Detail Search Request Shopping Cart





 Time in Milliseconds Figure 2: Execution times of TPC-W servlets (no load).
Figure 3: Execution times of TPC-W servlets (peak load).
Our work advocates using preferential scheduling for dynamic content Web sites in a transparent fashion, and evaluates its ben-e ts.
We also address the starvation question by using an aging mechanism to prevent starvation.
In this section we describe the design of our method and its implementation in the Gatekeeper proxy, which transparently intercepts requests for dynamic Web Content.
In this work, we use Java servlets for application functionality, due to their frequent use in commercial Web sites and their competitive performance [13].
Admission control generally requires two components: knowing the load that a particular job will generate on a system, and knowing the capacity of that system.
By keeping the maximum amount of load just below the system capacity, overload is prevented and peak throughput is achieved.
In a dynamic content generation system, we satisfy the above requirements in the following manner.
For the  rst requirement, Gatekeeper identi es different request types (i.e., servlets) and maintains online estimates of their expected service times, based on measurements of recent executions.
The measurement interval is taken from when the servlet issues the  rst query until the response from the last query is received.
The execution times are  learned  in an online fashion through a simple moving average, and used as the estimated load that each request imposes on the system.
Given that any dynamic Web site has a  nite number of interactions, it is simple to maintain per-servlet estimates.
For example, the TPC-W workload has only 14 interactions, each of which is embodied by a single servlet.
While different servlets issue different sets of queries, any one servlet will typically issue the same set of database queries, albeit with different parameters.
Our experience is that the load generated by a particular request is generally consistent; namely, that service times depend primarily on which servlet is being executed rather than on the parameters to that servlet.
This is illustrated in Figures 2 and 3, which show the service time distributions of the 13 TPC-W interactions that communicate with the database.
Figure 2 shows the times when measured in isolation (i.e., under no load) and Figure 3 shows the times when measured at peak load.
The X-axis in Figures 2 and 3 is in log scale.
Also, we show the averages of the same data in Table 1.
Two signi cant observations can be made from these  gures.
First, variation across servlets is much greater than variation within servlets.
Service times between servlets vary signi cantly as they range from less than 1 ms to over 5 sec, a range covering four orders of magnitude.
Variation within the servlet is much less, as shown by the relatively vertical straight lines in the distributions.
While in some cases variation within the script can be as much as a factor of 10, it is still orders of magnitude smaller than the variation across scripts.
Second, service times under heavy load are very different from those measured in isolation; most are much higher than in the no-load case.
This shows the importance of measuring costs online rather than using of ine measurements.
Per-servlet estimates converge relatively quickly; in our experiments, 11 out of the 13 servlets converge to within 90 percent of their steady state values in under 50 seconds.
We then de ne the load produced by the servlet to be the average execution time (in milliseconds) that the servlet requires.
The second requirement is to determine the capacity of a system, which is a single numeric value.
For our current environment, we determine the capacity of the system of ine rather than online.
Our approach is to use the method of incremental steps [24].
Brie y, this method assumes that the functional relationship of the load and resulting performance is monotonically increasing up to a peak and then decreasing; in other words, it assumes the throughput function is relatively concave, with the existence of a local maximum that is also the global maximum.
We de ne capacity as the maximum load level that produces the highest throughput.
Capacity is essentially a  pool  of execution units that are allocated to requests.
To determine a particular system s capacity, we run experiments using several relatively large candidate values (e.g., 20,000 or 40,000 milliseconds) for the capacity.
We then perform a binary search process of changing the candidate numbers and measuring the resulting performance, seeking the proper candidate value that provides the maximum throughput.
When the binary search converges, we use the resulting value as our estimate of capacity.
Because we consider only the functional relationship between the load and resulting performance, our technique is oblivious to the bottleneck resource (which could be a physical resource such as CPU cycles or a logical resource such as database locks).
The capacity of the system should be recomputed if there is a change in the system, for example hardware upgrade, or a change in the workload.
Techniques with more elaborate adaptive algorithms for
 Name No Load High Load Frequency Admin Req


 Admin Resp


 Best Seller


 Buy Conf


 Buy Req


 Exec Home Search





 New Order Order Prod


 Disp


 Prod Inq.
Detail





 Search Req


 Shop Cart


 Table 1: Servlet average execution costs (ms) and servlet execution frequencies (percentage).
estimating the online capacity of a running system could also be used, and presumably control theoretic approaches as well.
With these two estimates, admission control is straightforward.
In the implementation, the Gatekeeper proxy maintains a running estimate of system load, initially set to zero.
When a servlet requests a database connection, the work estimate for that servlet is examined.
If admitting the servlet will not exceed the capacity, then the servlet is allowed to proceed, and the running load value is incremented accordingly.
Otherwise, the servlet is deferred to execute later, and is placed in the admission queue in FIFO order.
As jobs  nish, Gatekeeper decrements the running load value appropriately, and if jobs are waiting in the queue, they are admitted in turn as long as they do not overload the system.
Gatekeeper does not shed load by dropping requests; in persistent overload conditions, the request waiting time will eventually become in nite and pending requests will time out indicating the need to upgrade the system.
Other admission control policies, such as dropping certain requests, could easily be provided depending on the requirements of the Web site operator.
In summary, we use measurement-based admission control.
We maintain online estimates of request service times based on recent request executions.
The estimated request service time indicates the load that a request imposes on the system.
We estimate the current load on the system as the sum of the estimated service times of all executing requests.
The system capacity is measured of ine and it limits the number of requests admitted to the system; excess requests are queued.
The Gatekeeper proxy uses request scheduling to reduce the average response time of dynamic Web site interactions, in the form of a shortest-job  rst (SJF) policy.
As requests arrive, they are placed in the admission queue sorted based on their expected processing times.
When requests  nish, new requests are admitted from the front of the queue until the capacity threshold is reached.
After jobs are admitted, they run to completion, i.e., they are not preempted.
Scheduling cannot improve response times if the workload is completely homogeneous.
For example, if each request required the same service time, changing the order of execution would be pointless.
However, large variability has been found in many Internet workloads (e.g., [18]).
In TPC-W, for example, execution times vary by as much as  ve orders of magnitude, as was seen in Figures 2 and 3.
Most service times are small, less than 54 milliseconds.
However, two interactions, the  Best Seller  and  Administrative Control  servlets, have service times of over one and two seconds, respectively, in the no-load case.
Their cost is high because they issue complex database queries.
Luckily, the expensive queries tend to be infrequent.
Table 1 shows the frequency distribution for the thirteen interactions that invoke the database using the shopping mix of TPC-W.
The fourteenth TPC-W interaction requires no database access and it appears 3% of the time.
A frequent concern with preferential scheduling is that long jobs may starve in the presence of a large number of small requests.
To prevent starvation, we implemented an aging mechanism, which is similar to Alpha scheduling [16].
The aging mechanism enforces an upper bound on the amount of time a request is delayed in the queue.
That upper bound is de ned as a multiple of the expected service time for the request.
The upper bound is con gurable.
For example, a Web site operator can choose a policy such that a request will not wait more than twice its expected service time.
Shorter requests can be promoted towards the head of the queue only if this promotion does not cause any pending request to be delayed more than its bound.
Aging only affects request scheduling, it does not affect the average system throughput, as will be seen in Section 5.
In this section, we describe our environment for doing our experimental evaluation, including the hardware and software used, metrics, and experimental methodology.
Our testbed consists of a client PC, two server PCs, and a 100 Mbps Ethernet switch.
Each PC has a 1.33 GHz AMD Athlon, 768 MB RAM, and a 60 GB 5400 RPM disk.
All machines have a 100 Base-T Ethernet interface connected point-to-point full duplex with the switch.
One server machine runs the Web server and application server software, while the other contains the database.
The client machine drives the system with a workload generator, described in more detail in Section 4.4 below.
All machines run Red Hat Linux with the Linux kernel 2.4.18.
We use Apache version

 two versions: MySQL version 3.23.53-max for most experiments and DB2 for Linux version 7.2 for one experiment.
To measure the load on each machine, we used the sysstat utility [40] that collects CPU, memory, network and disk usage from the Linux kernel every second.
The AMD Athlon processor has four performance monitoring counters [4] that count processor events (e.g., level 1 data cache misses, level 1 and level 2 data TLB misses).
We also use Rabbit [25], a library and kernel module, to access these performance monitoring counters.
Since we are evaluating Gatekeeper in the context of an e-com-merce Web site, we place the proxy between the application server and the database, as shown in Figure 4.
To access a database, servlets produce SQL queries using the JDBC API.
In turn, the JDBC driver invokes the vendor-speci c connector code to interact with the database server.
Gatekeeper thus intercepts requests to communicate with the database through the JDBC API.
In e-commerce Web sites, locking can be performed in either of two places: on the database itself, or in the servlet that invokes the particular transaction.
The advantage of locking in the application server is that performance is greatly improved, as will be seen in Section 5.1.
The disadvantage is that all access to the database must be directed through the application server, which might not be feasible.
Since the decision of where locking is done will depend

 app protocol
 proxy
 web server application server database server Figure 4: Placement of the Gatekeeper proxy within an e-commerce Web site.
on many factors, such as the load on the site, architecture of the system, and perhaps even the inventory management technique (e.g., just-in-time, inexact inventory), we evaluate both scenarios.
When locking is done in the database, we use strict two phase locking.
For each servlet that accesses the database, we insert database read and write lock operations that obtain all necessary locks for the queries in that servlet.
Locks are held until the end of the execution of the servlet.
When locking is done in the servlet, no explicit SQL locking operations are added; the Java synchronization mechanisms are used instead to serialize con icting requests to the database.
When evaluating Web server performance, a workload generator is frequently used to drive the system in a hopefully representative manner.
We use what is effectively the current standard workload generator for e-commerce sites, TPC-W [31, 43].
The TPC-W benchmark from the Transaction Processing Council (TPC) is a transactional Web benchmark speci cally designed for evaluating e-commerce systems.
It is meant to model a  typical  e-commerce site, in the form of an online bookstore.
The TPC-W speci cation requires 14 different interactions, each of which must be invoked with a particular frequency.
Of these interactions, eight initiate queries that result in data being written to the database, whereas the other six generate read-only queries.
Each interaction may also involve requests for multiple embedded images, where each image corresponds to an item in the inventory.
With one exception, all interactions query the database server.
In our testbed, all persistent data is stored in the database, except for the static images used with each book.
All images are kept in the  le system of front-end Web server rather than stored in the database.
The database contains multiple tables that are meant to represent the data needed to maintain a real site, including customers, addresses, orders, credit card information, individual items, authors, and countries.
We scaled the TPC-W database to 10,000 items and 288,000 customers, which corresponds to 350 MB of data.
The size of the static images, which represent the inventory (i.e., book covers), is 183 MB.
TPC provides a speci cation but not source code.
We thus used the freely available TPC-W implementation developed by the Dy-naserver project at Rice University [5, 36].
The Rice implementation captures all the functionality required by the TPC-W speci cation that affects performance, including transactional consistency and support for secure transactions.
It does not implement some functionality speci ed that affects only price, such as the requirement to provide enough storage for 180 days of operation.
More detail on the Rice TPC-W implementation may be found at the Dy-naserver Web site and in their paper [5].
The Rice TPC-W implementation includes a workload generator, which is a standard closed-loop session-oriented client emulator.
Each emulated client represents a virtual user.
The amount of load generated is determined by the number of emulated clients.
Thus we use the number of clients to indicate the load on the system.
Each client opens a session to the front-end Web server using a persistent HTTP connection, issues a series of requests for the duration of the session, and then closes the connection.
Session duration is exponentially distributed with a mean of 15 minutes and a maximum of 60 minutes.
Within each session, the client repeatedly makes a request, parses the server s response, waits a variable amount of time, and then follows a link embedded in the response.
The server s response is a Web page consisting of the answer to the queries in the request, and contains links to the possible set of pages that the client can transition to from this response.
A  nite-state Markov model is used to determine which subsequent link from the response should be followed, using a transition matrix with probabilities attached to each transition from one state to another.
Each state in the transition matrix corresponds to a particular interaction de ned in the TPC-W speci cation.
The variable amount of time between requests is called the think time, and it is intended to emulate a real client who takes some period of time before clicking on the next request.
Therefore, each client alternates between two states: either thinking to generate the next request or waiting until it receives the full response of the last request.
TPC-W speci es that the think time should exponentially distributed with a mean between 7 to 8 seconds and is bounded at a maximum equal to ten times the average.
In all our experiments where locking is done in the application server, think time has an average of 7 seconds and is bounded to 70 seconds.
For locking in the database, think time has an average of 8 seconds and bounded to 80 seconds.
We evaluate throughput and response time, each as a function of the load.
Throughput is the average number of successful requests that clients issue per unit time.
Response time is the average amount of time it takes for a client to send a request and successfully receive the full reply.
The measured response time includes the execution time on the Web, application and database servers as well as the queue waiting time (if any) inside the Gatekeeper proxy.
However, the measured response time does not include the overhead of the Gatekeeper proxy (collecting and maintaining statistics, and sorting requests in ascending order of their expected service times in SJF scheduling).
If a request fails or times out, it is not included in the measured throughput and response time, even though some components of the system may have executed parts of the request.
Hence, throughput and response time are measured only for successful requests.
We use online measurements to estimate the load that each request imposes on the system in all experiments (except for the experiment that compares online measurements to of ine measurements).
The database capacity is always measured of ine.
ber of requests successfully executed.
When there is no admission control and when admission control is in effect with FIFO scheduling, requests that fail or time out during overload are distributed uniformly across all request types.
However, when using admission control with SJF scheduling during overload, requests that fail or time out tend to be long requests because they stay much longer in the system than short requests.
In the graphs we present, each data point is the average of  ve runs, where each run is the average over a 600 second sampling period after a 100 second warm-up.
Most graphs include 90 percent con dence intervals [26] calculated using the T distribution, which assumes that the distribution underlying the data is Gaussian.
In this section, we present our results in detail, showing the effectiveness of our techniques.
In all experiments, the bottleneck is in the database machine, and the bottleneck resource is either the host CPU or lock contention.
The front-end machine, which hosts both the Web server and the application server, has consistently low CPU utilization of about 30 percent.
As will be seen, the single client machine is capable of driving the system both to saturation and beyond into overload.
Figure 5 shows the throughput of the system, when locking is done in the application server.
The X-axis is the number of emulated clients, and the Y-axis is throughput in interactions per minute.
Three curves are presented: the original system without admission control, marked  original ; the system using the Gatekeeper proxy with FIFO scheduling, marked  gatekeeper-FIFO ; and the system using the Gatekeeper proxy with shorted-job- rst scheduling, marked  gatekeeper-SJF.  For small loads, the three systems behave similarly, up until roughly 50 clients where differences start becoming apparent.
The original system without admission control reaches a maximum throughput of about 852 interactions per minute, but then starts degrading above 250 clients, falling to 589 interactions per minute at 300 clients.
The system using the Gatekeeper proxy maintains a consistent throughput even at the higher loads, and exhibits a higher peak throughput than the original system, of 941 interactions per minute at 230 clients.
We see that the Gatekeeper proxy is effective at preventing overload, and even improves peak performance by about 10 percent.
Throughput is unaffected by changing the scheduling algorithm in Gatekeeper from FIFO to SJF.
Figure 6 illustrates the difference between the online and of ine approaches to measuring servlet response time.
The graph shows the same system as in Figure 5, but here the SJF curve is removed and a new curve is added showing throughput using of ine measurements taken in isolation.
While Gatekeeper using of ine measurements does perform better than without any admission control, the curve shows degrading throughput after about 270 clients.
Recall from Table 1 that service times change under high loads.
Thus, the of ine estimates are no longer accurate, leading to unstable behavior at high loads.
These results emphasize the importance of taking into account the behavior of the system under heavy load.
While theory would predict no change in peak throughput using admission control, we see that this is not the case in practice.
To determine why, we ran a number of pro ling experiments.
Table 2 shows various performance statistics for the system under 3 sce- narios from Figure 5: the original system at peak throughput, the original system during overload, and the system using Gatekeeper at peak throughput.
In all situations the database CPU is fully utilized, the database  ts in memory, and the network bandwidth is not a limiting factor.
Throughout the  plateau  in Figure 5, the statistics stay relatively consistent up until about 250 clients.
Several factors contribute to the explanation why the system throughput degrades during overload, and why Gatekeeper provides better performance.
First note that, while small, the I/O transfer rate goes up under overload, and shrinks when Gatekeeper is used.
Second, there are a signi cantly lower number of database processes when Gatekeeper is used.
Finally, memory pressure is clearly reduced, as the amount of memory used is much lower.
Pro ling measurements using the Athlon performance monitoring counters show that when the load is increased from 200 clients to 300, the rate of the L1 data cache misses increase 24.9 percent, L1 DTLB misses that causes a hit in the L2 DTLB increase 24.8 percent, and L1 DTLB misses that also cause a miss in L2 DTLB increase 22.5 percent.
Clearly the data cache and DTLB misses contribute to the thrashing behavior of the system.
We now turn to the case where locking is done in the database, rather than in the application server; this case is illustrated in Figure 7.
Note that the scales of this graph are different from the scales in Figure 5; the peak throughput here is much lower than in the previous graph.
This shows how locking in the database is more expensive than locking in the application server.
In this graph, the three curves show similar performance up to about 70 clients, after which the original system degrades quickly, but the experiments using Gatekeeper again demonstrate consistent performance even during overload.
The original system reaches the peak throughput of 515 interactions per minute at 70 clients.
At this point, the CPU utilization is 70 percent and all other system resources are far less utilized.
As the load increases beyond this point, contention for the data locks causes thrashing, as two phase locking is used and many database queries become blocked.
This is consistent with analytic models which show that the mean number of blocked transactions is a quadratic function of the total number of transactions [41].
This phenomenon explains the rapid decline in the throughput for the original system without Gatekeeper.
Conversely, Gatekeeper queues any excess database requests when the estimated maximum capacity for the database is reached, and thus maintains peak performance in the overload region.
One question that might occur is whether our results are dependent on artifacts of a particular implementation, in this case MySQL.
To test this notion, we ran our experiments using DB2 instead of MySQL, and the results are shown in Figure 8.
Note that this experiment uses a different system, unlike the other  gures, and thus results should not be compared across graphs.
Gatekeeper again shows consistent throughput during overload, whereas the original system degrades quickly after 400 clients.
These results demonstrate the applicability of our approach across database implementations whenever overload causes the database to thrash.
In this section we evaluate the effect of request scheduling using the Gatekeeper proxy.
Figure 9 shows the average response time in our system, corresponding to the experiments shown in Figure
 the X-axis is again the number of emulated clients, but the Y-axis is response time in milliseconds.
As expected, response times are low for small numbers of clients, but increase as a function of the load, as jobs queue up in the system.
The original system, as can be seen, performs the worst.
The system using the Gatekeeper proxy with FIFO scheduling gives better response time, as it provides better throughput and thus lower service and waiting times.
The curve showing the Gatekeeper proxy using SJF scheduling shows sub-281t e u n m i r e p s n o i t c a r e t n i f o r e b m u







 original gatekeeper FIFO gatekeeper SJF t e u n m i r e p s n o i t c a r e t n i f o r e b m u






 Number of clients






 original gatekeeper FIFO online gatekeeper FIFO offline





 Number of clients Figure 5: Throughput (MySQL, locking in application server).
Figure 6: Online vs. of ine (MySQL, locking in appl.
server).
Statistic Throughput (interactions/min) Number of Clients Database CPU Utilization (user/system) DB Memory Used (MB) DB Memory Free (MB) I/O Transfers/sec Network Bandwidth (Mbits/sec) Number of Processes (database/system) Context Switches/sec Interrupts/sec Original









 Overloaded









 Gatekeeper









 Table 2: Performance statistics (MySQL, locking in application server).
t e u n m i r e p s n o i t c a r e n t i f o r e b m u








 original gatekeeper FIFO gatekeeper SJF original gatekeeper FIFO





 t e u n m i r e p s n o i t c a r e n t i f o r e b m u






 Number of clients











 Number of clients Figure 7: Throughput (MySQL, locking in database).
Figure 8: Throughput (DB2, locking in application server).
282s m n i i e m
 e s n o p s e











 original gatekeeper FIFO gatekeeper SJF s m n i i e m
 e s n o p s e






 Number of clients










 original gatekeeper FIFO gatekeeper SJF





 Number of clients Figure 9: Response time (MySQL, locking in appl.
server).
Figure 10: Response time (MySQL, locking in database).
c e s i l l i m n i e m
 i





 waiting time service (execution) time

 Response Time Breakdown (Short Job) c e s i l l i m n i e m
 i





 waiting time service (execution) time
 waiting time service (execution) time c e s i l l i m n i e m
 i






 Response Time Breakdown (Average Job)

 Response Time Breakdown (Long Job) Figure 11:  Exec Search  request.
Figure 12:  Admin Response  request.
Figure 13: Average across all requests.
s m n i i e m
 e s n o p s e











 original gatekeeper FIFO gatekeeper SJF gatekeeper wait 1 gatekeeper wait 3 gatekeeper wait 5 s m n i i e m
 e s n o p s e






 Number of clients










 original gatekeeper FIFO gatekeeper SJF gatekeeper wait 1 gatekeeper wait 3 gatekeeper wait 5





 Number of clients Figure 14: Response time (MySQL, Locking in appl.
server).
Figure 15: Response time (MySQL, locking in database).
original system has an average response time of roughly 11 seconds, whereas with Gatekeeper, using FIFO scheduling provides a response time of 9 seconds, and using SJF scheduling gives a response time of about half a second.
In this case, SJF improves response time by a factor of 22.
Note that the knee of the SJF curve happens at about 290 clients in this experiment.
While SJF scheduling can reduce response time substantially, it cannot prevent the queuing effects that occur with overload.
If load exceeds capacity, and no load shedding is performed, response times will approach in nity.
Scheduling can help stave off degrading response time under overload, but cannot prevent it.
Figure 10 shows the average response time in our system when locking is done in the database, corresponding to the experiments shown in Figure 7.
While the absolute numbers are different, the trends are the same as in Figure 9.
The original system has the worst response time, the system using Gatekeeper with FIFO scheduling is better, and the system using Gatekeeper with SJF scheduling performs the best.
Here the magnitude of the improvement is not as great as in Figure 9, but the differences are still substantial, in this experiment by up to a factor of 4.
One concern about request scheduling using algorithms such as SJF is that large jobs will be penalized severely.
Since we are providing preferential treatment to short requests, it is important to see what slowdowns may be incurred by large jobs.
Figures 11,
 cies, distinguishing execution time from waiting time.
Three sample queries are shown: the  Exec Search  request, which is relatively inexpensive with an execution time of about 400 milliseconds, shown in Figure 11; the  Admin Response  request, which is complex and weighs in at roughly 4.8 seconds, shown in Figure 12; and the  Average  request, shown in Figure 13, the average across all queries in TPC-W, which is 425 milliseconds.
Note that the scales of the y-axis are different across all  gures.
As expected, execution times do not change in response to scheduling.
Instead, improvements in response time are due to reductions in the waiting time of the requests.
The  Exec Search  request waiting time shrinks from over 8 seconds using FIFO to 99 milliseconds using SJF, and the average waiting time falls from 8.8 seconds to 225 milliseconds.
The large job, however, is penalized, with waiting time increasing from about 12.9 seconds to 15.6 seconds.
Waiting time increases by about 21 percent, and overall response time, which includes the service time, increases by about 13 percent.
While large jobs are penalized slightly, the slowdown is not signi cant, and the substantial bene t in overall response time makes this trade-off worthwhile.
Finally, we evaluate our mechanism to prevent starvation.
Figure
 aging, and SJF with aging, all when locking is done in the application server.
Figure 15 shows the corresponding response times when locking is done in the database.
Figures 14 and 15 show the response time when three aging policies are used, where the label  gatekeeper wait X  corresponds to imposing an upper delay bound of X multiples of the expected service time.
For example,  gatekeeper wait 1  permits requests to be reordered such that each request can be delayed for at most as long as its service time.
This restrictive policy produces a graph that is closest to the FIFO policy.
The response time is lower (better) than FIFO because the scheduler still has a degree of freedom to reorder the requests in such a way to reduce average response time.
The curve marked  gatekeeper wait 5  presents a response time curve similar to the SJF policy.
However, SJF yields better average response time because it does not have any restrictions on reordering requests.
As can be seen, a continuum of behaviors is available between FIFO and SJF.
Web site operators can choose a value of X to achieve a speci c behavior based on their desired policy.
Much related work has been done in the areas of overload control, admission control, service differentiation, quality of service (QoS), and request scheduling for Web servers.
Due to space limitations, we provide a very brief overview here.
Early works focused on delivering priority to one class of requests over another [3, 23].
Other research investigates admission control, sometimes referred to as overload control.
Mogul and Ramakrishnan [32] showed how to prevent overload caused by interrupts generated by packet arrivals in software-based routers.
Dr-uschel and Banga [22] demonstrate a similar concept in the context of Web servers, showing how a network subsystem architecture can provide improved stability and throughput under high loads.
Cherkasova and Phaal [17] show how considering session characteristics rather than individual requests in admission control can be used to reject fewer sessions.
Chen et al. [15] use computation quantums, which are similar to the pool of units used to estimate the capacity of the database in our study.
They develop an analytical model to perform admission control using a double queue structure and verify their results using a simulation study driven by a Web trace.
More recent approaches seek to combine differentiated service with admission control.
Bhatti and Friedrich [11] propose an architecture for Web servers to provide QoS to differentiated clients, incorporating request classi cation, admission control, and request scheduling.
They do not examine SJF or SRPT scheduling to improve response time, and most importantly, do not experimentally demonstrate sustained throughput in the presence of overload.
Li and Jamin [28] provide an algorithm for allocating differentiated bandwidth to clients in an admission-controlled Web server based on Apache.
Bhoj et al. [12] present the Web2K mechanism, which prioritizes requests into two classes: premium and basic.
Connection requests are sorted into two different request queues, and admission control is performed using two metrics: the accept queue length and measurement-based predictions of arrival and service rates from that class.
The authors evaluate their system using Apache, and show how high priority requests maintain stable response times even in the presence of severe overload.
Voigt et al. [44] study different kernel and user-space mechanisms for admission control and service differentiation in overloaded Web servers.
They evaluate their proposed mechanisms in AIX and  nd that the kernel-based mechanisms provide better performance.
Prad-han et al. [35] present an observation-based framework for  self-managing  Web servers that adapt to changing workloads while maintaining QoS requirements of different classes.
Kanodia and Knightly [27] propose a mechanism that integrates latency targets with admission control.
Using both request and service statistical envelopes, the mechanism improves the percentage of requests that meet their QoS delay requirements.
The authors evaluate their scheme via trace-driven simulation.
Several researchers have examined how control theory can be applied in the context of Web servers.
Lu et al. [29] present a control-theoretic approach to provide guaranteed relative delays between different service classes.
Abdelzaher et al. [2] propose using classical control theory for Web servers to provide performance isolation, service differentiation, and QoS adaptation.
They provide an implementation using the Apache Web server.
Diao et al. [21] advocate a similar approach, using control theory to maintain Apache s KeepAlive and MaxClient parameters, showing
 directly address metrics of interest to the Web site, such as response time or throughput.
Heiss and Wagner [24] perform a simulation study of thrashing in transaction systems.
They present two admission control algorithms that prevent overload by limiting the amount of concurrency in the system.
Instead of performing admission control and refusing clients as a response to overload, several researchers have investigated using service degradation.
In this context, the service offered to clients is reduced, in the form of providing smaller content, e.g., lower resolution images.
Different approaches include using HTTP s content negotiation feature [38], content substitution [1], or transcoding [14] to improve Web client response times and server throughput in the presence of server overload or network congestion.
Recently a number of researchers have observed the value of integrating resource management with service differentiation, admission control, and quality of service.
Banga et al. [9] propose resource containers as an operating system abstraction that embodies a resource, improving robustness and control over priorities.
Aron et al. [8] build on this notion by recognizing the fundamental connection between resource allocation and providing predictable quality of service.
Their evaluation includes dynamic content based on a trace from Google that includes an average service time, but do not include database-driven workloads.
Resource management approaches have also been used in clusters of servers [7, 39].
Welsh and Culler [45] describe an adaptive approach to overload control in the context of the SEDA [46] Web server.
SEDA decomposes Internet services into multiple stages, each one of which can perform admission control.
By monitoring the response time through a stage, each stage can enforce a targeted 90th-percentile response time.
Their evaluation includes dynamic content in the form of a web-based email service.
Gatekeeper differs from the above works in many respects.
Most importantly, most of the above work has only addressed static content, a much simpler workload, whereas Gatekeeper is fundamentally concerned with dynamic content and database-driven Web sites.
Of the few that do consider dynamic content, two use a simple linear approximation of the service cost in the form of a dummy CGI script [12, 35].
We use a full implementation of the dynamic functionality and incur actual execution costs, which can vary orders of magnitude.
Relatively few works are closely related to ours in terms of being implemented and addressing dynamic content: Neptune [39], Aron s resource management framework [8], McWherter s priority mechanisms for transactional Web applications [30], and SEDA [45, 46].
Neptune and Aron s framework both use search as a dynamic workload, whereas we use a transaction-oriented e-commerce workload.
McWherter implemented preemptive and non-preemp-tive prioritization algorithms by modifying the database server in order to provide differentiated performance for some requests.
SEDA s evaluation includes dynamic content in the form of a custom email service driven by a homegrown workload generator.
Our evaluation is performed using standard software components and driven using an industry-standard e-commerce workload.
While SEDA s approach is perhaps more general, our approach has the advantage that it is completely transparent to the database and is thus more easily deployable.
Finally, many previous works have attempted to identify overload through indirect measurements such as queue length or bandwidth utilization.
Others have taken more direct indicators such as response time, but measured them for the entire system or for class-based categories.
We address the concept of load directly by measuring how per-script resources are used.
We believe this mechanism provides more accurate and  ner-grained approach to admission control, and is in fact complementary to other approaches.
For example, SEDA allows different scripts to be handled by different stages.
By including both an overall notion of system capacity with an estimate of per-script execution costs, the number of rejected requests at a given load could be lowered.
This paper presents a method for providing admission control and request scheduling for multiply-tiered e-commerce Web sites.
By externally measuring service costs online and distinguishing between different types of requests, our approach can achieve both stable behavior during overload and dramatically improved response times.
Other proposals require extensive modi cations to the operating system or a complete rewrite of the server.
Our approach requires no changes to the source code, server software, application programs, or to the database.
This allows ease of deployment, database independence, and use of standard software components.
Our method is embodied in a transparent proxy called Gatekeeper.
Gatekeeper intercepts requests from the application server to the database, allowing interoperability with standard software components.
We evaluated Gatekeeper experimentally using the Apache Web server, Tomcat servlet engine, and both the MySQL and DB2 databases, using the industry-standard TPC-W workload generator.
Despite being external to the system, our proxy provides many of the bene ts of admission control and request scheduling: (cid:127) We show consistent performance even in the presence of persistent overload, across database implementations and locking approaches.
(cid:127) We demonstrate improved peak throughput of 10 percent, due to reduced thrashing and better memory reference behavior.
(cid:127) We demonstrate drastically reduced response times via preferential scheduling using the shortest-job (SJF) scheduling policy.
Average response time is reduced by a factor of 14, whereas large queries are penalized by only 15 percent.
(cid:127) We present an aging mechanism that prevents starvation of jobs under SJF.
The mechanism allows decisions of where in the continuum between FIFO and SJF a Web site should operate based on operator policy.
These results show that extensive modi cations to server software are not always necessary in the context of e-commerce Web sites, where the database is the bottleneck.
A natural next step for future work is to evaluate our approach using other dynamic workloads.
In cases where the bottleneck resource is the application server, rather than the database, it would make sense to place the Gatekeeper proxy between the front-end Web server and the application server.
