In only a decade, the World Wide Web has grown to signi cantly affect all aspects of our lives.
Organizations from industry, government, education, entertainment, business, and services all use the Web to improve and enhance their operations.
Even traditional information and database systems have migrated to the Web.
Many organizations have successfully developed large and high-quality Web sites, but others have failed or have struggled to avoid Copyright is held by the author/owner(s).
major failures.
While some of these failures result from a lack of vision or shortsighted goals, others result from a  awed design and development process or poor management of development efforts [21].
Web developers commonly use ad hoc development processes that lack rigor, systematic techniques, sound methodologies, and quality assurance and may pay little attention to issues such as requirements analysis, quality, performance evaluation, con g-uration management, maintainability, and scalability [22].
In fact, Web development is often seen as being primarily an authoring task rather than an application development task.
Therefore, systematic, disciplined approaches are only beginning to be applied to the development of high-quality Web-based applications.
In response, the discipline of Web engineering has emerged, advocating a systematic approach to development of high quality Web-based systems [39].
It promotes the establishment and use of sound scienti c, engineering and management principles in the development, deployment and maintenance of Web-based systems.
To a large extent, Web engineering views Web development as an important variant of software development.
As a result, many of the tools and practices already used to produce other software are still relevant, though Web engineering does have distinct practices that arise from the nature of hypermedia and the Web [33, 45].
One task that is important for software and for the Web is the management of the evolution and maintenance of Web-based applications.
Dart [10, 11] has argued that Web systems would ben-e t greatly from the use of techniques from software con gura-tion management (SCM).
Web applications are software artifacts, and as such can bene t by making use of advanced version control and software con guration management technologies.
But Dart has also pointed out that the evolution of Web applications presents special challenges that are not well-addressed by existing SCM systems.
For our purposes, the most important of these challenges are: Variety of Types: Web systems are built from a wide diversity of objects including documents in any of markup languages, document templates, style sheets, images, streaming media, animations, applets, and scripts.
Unlike software engineering, where program source code is seen as the central artifact, in Web systems it is dif cult to identify one type of object as most important.
So, an SCM system for Web applications must be compatible with a wide variety of  le types, including their templates and their corresponding editing tools.
A versioning model which corresponds to the logical structure of these objects would also be desirable.
Intermixed Types: Furthermore, in Web applications it is common to intermix different object types in the same  le.
An example would be an HTML  le that contains embedded CSS style commands and JavaScript.
A versioning model that understands this would be helpful.
straints on deployed  le locations that are less often seen in traditional software.
It can be useful to think about the system as having a different logical structure than what is imposed by these other constraints.
Thus, an SCM system that can present logical models of the system structure, in addition to the structure of the deployed  les will provide a more transparent interface.
Developers: Web systems are developed by diverse teams ranging from graphic artists to specialized software engineers.
Thus, the SCM system s interface needs to be accessible to less technical users or they will resist its use, leaving important portions of the system outside the control of the SCM tools.
Rate of Change: Large Web systems appear to change faster than traditional software systems.
Some sites, such as news sites, must show thousands of daily content changes.
While substantive structural changes visible to end users may be more rare on these sites, they still appear to happen at a faster rate than in traditional software.
Continuous  ne-grained evolution is thus a distinguishing characteristic of Web systems [32, 39].
Thus, Web-oriented SCM must help developers understand changes at a very  ne-grained level.
In addition,  ne-grained change management in SCM tools must take into account the external and internal structures of a Web system [10].
External structure (also called navigational structure) of a Web system refers to the structure of a collection of Web documents with respect to hyperlinks among them.
Web documents in a Web system are logically related and connected to each other via these hyperlinks.
To facilitate the management of  dangling  links, the versions of Web documents need to be kept in synchrony.
Therefore, the history of networks formed by Web documents and hyperlinks needs to be recorded as a Web application evolves.
This navigational structure should be distinguished from the Web project s structure and architecture [29].
SCM tools need to allow developers to organize their Web project at the logical level according to their choice of design methodologies, and to support version control for the project s structure and architecture as well.
A Web document, either static or dynamic, has some internal structure.
An HTML document has a tree-based syntactic structure, while program source code can be regarded as an abstract syntax tree (AST) of syntactic units.
Researchers have been taking advantage of the internal structure of a Web page in order to process, visualize, search and retrieve information [23, 25, 50].
As the Internet moves toward XML [36], it is likely that Web documents will gain structure with semantics of growing importance.
These structural semantics are described, at least to some extent, by Document Type De nitions (DTD) or XML Schemas, which are also evolving objects.
So, Web content must evolve along with its structural rules.
Managing the evolution of structures and contents of a Web document will result in various bene ts in processing, visualizing, and retrieving Web content.
Traditional SCM tools are not well-suited to this task because they often use a line-oriented model of internal changes that disregards these internal structures of Web documents.
An SCM tool that can version data objects and handle change management at the logical level is needed.
To investigate the application of SCM technology to Web engineering, we have modi ed an extensible integrated development environment, the Software Concordance (SC), to be suitable for Web application development.
To meet the requirements and to address the problems mentioned above, SC uses a tree-based  ne-grained version control framework and a product versioning SCM system to manage the evolution and maintenance of Web applications.
The SC environment has been extended to support many types of Web objects including HTML and XML documents, audio clips, images, graphics and animations in Scalable Vector Graphics (SVG) format, and program source code in Java, Java Applet, and JavaScript.
The environment can be further extended to integrate additional editors supporting other types of documents.
A structure-oriented approach is used that represents all Web documents as tree-structured objects that are versioned in a  ne-grained manner.
On top of this  ne-grained, tree-structured ver-sioning framework, a product versioning SCM system, named Mol-hado, has been built that provides con guration management support for Web development projects in which the Web project is versioned as a whole entity.
The Web system can be structured and versioned at the logical level, independent of the physical locations of its components on the  le system.
A simple graphical user interface (GUI) has been designed to help Web developers in their versioning and con guration management tasks.
Networks of static Web documents and their links are also versioned in a  ne-grained manner.
A  ne-grained content change management tool has been developed, allowing Web developers to track the history and changes of any structural and logical unit in a Web document.
The next section will discuss related work on applying version control and con guration management to Web engineering.
Section 3 describes the SC document representation.
Our  ne-grained version control framework is presented in Section 4 and its application to Web content change management is discussed in Section 5.
Section 6 covers the con guration management system of SC environment while the SC editing system is described in Section 7 and the last section presents our conclusions.
Researchers and vendors in the con guration management area are taking different approaches to SCM for the Web.
All have added Web functions to their SCM tools by offering access to some or all SCM functionality through a browser [11].
WebSynergy [60] provides a Web front-end into all of its existing SCM capabilities as well as Web authoring tools.
Similar to our approach, MKS s We-bIntegrity [59] integrates its version control facilities with an authoring tool, while in Merant s PVCS [35], version control is the core part and is separate from authoring systems.
However, both of them version control at the  le level.
StarTeam [51] is Web-enabled with the intention of tool integration.
TrueChange [57] provides content change management along with its version control, but with less focus on con guration management.
Serena s eChangeMan [16] is focused on process management and change tracking.
Rational s ClearCase [31] provides con guration management via  tagging  all  les in the same con guration with the same label for later retrieval.
ClearQuest [7] is a change request management tool of ClearCase, coordinating many developers in changing Web documents.
Content change management in Source-Safe [49] is line-oriented.
Computer Associate s CCC/Harvest [5] pays considerable attention to supporting collaboration among distributed development teams.
Perforce [41] is more lightweight than other SCM tools and it has the ability to migrate repositories from other SCM tools such as CVS and PVCS into its internal repository.
Although all of these SCM tools have distinguished and valuable features, they are focused on version control of  les, rather than on con guration management for a Web project as a whole.
None of them supports  ne-grained change management at the logical level and all content change management is line-oriented.
On the other hand, some Web application development environments (also called Web authoring environments or Web content man-
be incorporated into their tools.
FrontPage [19], Macromedia s DreamWeaver [15], and ColdFusion [8] have no builtin version control support.
Other tools, such as StoryServer [52] and Team-Site [54], are designed to support many aspects of Web development, with particular strength in supporting collaborative work.
TeamSite provides visual differencing tools so that two versions of the same content can be examined side by side.
Inso s Dyn-aBase [27] is an integrated content management and publishing platform for Web applications.
Similar to our approach, it is XML-based, allowing better management and reuse of data.
In Dyn-aBase, con guration management use the  tagging  technique also seen in ClearCase.
Con gurations act like a bill-of-materials for the Web site, enumerating which items are included in the site and which version of each item is in use.
ArticleBase [1] integrates content management and version control into an authoring and publishing system.
Its version control support is on  le basis and no con guration management is provided.
None of these systems allows developers to structure their Web project and its objects at the logical level depending on their choice.
OOHDM-Web [44], an environment for the development of Web-based applications, is focused on the hypermedia design methodology de ned by the OOHDM model [45].
CGILua [6] is a tool for developing dynamic HTML pages and manipulating input data from forms, which enables the use of embedded code in normal HTML  les.
RMCase [12] is a CASE tool that supports the complete life cycle of a Web application.
Its main goal is to support the process model for developing Web applications.
Similarly, the WebComposition process model and its related product Eurovictor [20] focused on open process model that allows for the integration of processes and reuse of components.
The JESSICA system [2] provides a XML-based modeling language for the automatic mapping from the design to Web-resources.
Ariad-neTool [37], a design toolkit for hypermedia applications, allows a designer to generate dynamically XML templates.
No version control support is provided in these systems.
Many research in versioned hypermedia [24, 26, 61] community have focused on version control in the presence of hyperlinks.
However, the main goals of their versioned hypermedia systems often do not include supports for Web application development.
Therefore, supports for program source code are very limited.
The GAIA framework [30] combines open hypermedia and version-ing paradigms.
GAIA builds versioning mechanisms on top of traditional open hypermedia architecture to support versioning for links, documents and anchors.
RHYTHM [34] is a prototypical distributed hypertext system that tackled problems arising from distribution and versioning, both from a structural and from a cognitive point of view.
It is better suited for hypermedia systems than Web-based applications where program source code is also an important part.
Similar to RHYTHM, HyperProp [48] provides versioning supports for hypertext authoring systems without paying much attention to program source code.
HyperPro [40] provides versioning supports of program objects as small as Pascal procedures.
However, its goal is to map internal structure of a program into a hypertext and no program analysis is supported.
In RCS-based Hyper-Web [18], the smallest versionable object was a  le.
To improve the authoring and browsing features for versioned contents of Web pages, some researchers followed the language-oriented approach.
They have attempted to change the Uniform Resource Locator (URL) of a Web page to include a version iden-ti er [42, 46].
They use existing Web infrastructure such as forms, Java applets, and plugins to create a user interface for revision control systems on the server.
Vitali and Durand proposed VTML (versioned text markup language) [3] to express change operations for HTML documents.
For example, they introduced two new tags (INS and DEL) to express insertion and deletion.
The WebDAV protocol [62] is an extension of the Hypertext Transfer Protocol (HTTP) to support distributed authoring and versioning.
It extends HTTP to include versioning operations for Web pages.
WebDAV is designed to meet requirements [47] for distributed authoring and versioning on the Web environment.
Although functionality is not consistent across the tools, most of existing tools have very little or no support for con guration management.
Con guration management support is limited to version control of  les.
The similarities among them include supports for Web and scripting languages, templates and stylesheets, version-ing of  les, rollback of complete sites via backup, audit logging, work ow support for collaborative work, commercial database interfaces, and minimal change tracking and management support.
None of them cares about the external and internal structure of Web content in the sense described in the previous section.
Their content change management is coarse-grained, with differencing done on a line-by-line basis.
None of them have ability to allow developers to logically structure their Web projects.
Web content can consist of data objects, code, and component libraries.
Examples of data objects are data  les, documents, images, audios, and videos.
Code can be active controls and scripts that can be embedded into an HTML page.
Component libraries are reusable codes such as JavaBeans and Microsoft Foundation Classes.
Among Web documents, hyperlinks exist that can point to any page in the Web.
Templates such as stylesheets, which are written in some languages, enable separation of content and its presentation style.
To provide  ne-grained version control and content management for static documents, the SC environment follows the principle that textual information such as HTML, XML documents, and program source code are treated as structured objects and ver-sioned in a  ne-grained manner, while binary information such as audio clips, video clips, and component libraries are considered to have no internal structure and are versioned on a  le basis.
The SC s document representation uses a structure-oriented approach where each Web document is a document tree composed of document nodes (also referred to as structural units).
Each document node can be associated with multiple pairs of attribute name and value.
The document trees are versioned in a  ne-grained manner, which is described later.
Structural units in a document carry different logical senses depending on the document s type.
Program source code and scripts are represented as ASTs, therefore, in a program, a structural unit is equivalent to a syntactic unit such as a class, method, or statement.
On the other hand, in an HTML or XML document, depending on the document s DTD, a document node might represent a section, paragraph, sentence, or phrase.
In either case, a document node represents the logical semantics encoded by an XML or HTML element.
This document tree representation is logically equivalent to the structure supported by Document Object Model [13], though as described in the next section, the implementation details are quite different.
A conversion facility is implemented to allow the import and export of DOM-compatible documents into the SC s representation.
The maturity of XML technology [63] allows SC to support a wide variety of information types, including graphics and animation written in SVG [53], Uni ed Modeling Language (UML) [43] diagrams, Java programs, and HTML documents with embedded scripts.
The implementation of this structure-oriented approach uses the Fluid Internal Representation [4], which is described in the next section.
435v1 v2 v3    wing versions v2
 v3



 (modified)



 "con tent" "" "" "" "child  " seq1 seq3 null "pa  t" null n1 n1 undefined n1n1 n2 n3 n4 n1n1 n2 n3 n4 "con tent" "" "" "child  " seq4 "pa  t" null seq5 n1 undefined "" null v1




 "con tent" n1n1 n2 n3 n4 "" "" "" "" "child  " seq1 seq2 null null n5 "old" null  t" "pa null n1 n1 n2 n2 n5 "new" null n2 n5 "old" null seq1 seq2 n2 n3 n4 n5 seq3 n5 seq4 n2 "" n6 seq5 null n4 n5 n6 Figure 1: Tree versioning n2 n2 n2    c2#b"
   anchor="d"   c2#c"
  1 (v1) (v1) (v1)

    c1#d"  anchor="b" anchor="c"     erte  structure !
 c2#c" (v1) (v1,v2) (v2) (v1,v2)  1  
   anchor= "d"
   c2#c" " the change

    c1#d"  anchor="b" anchor="c"   



  erte  structure after the change Figure 2: Versioning for hypertext structure

 v1

 v2

 The SC environment makes extensive use of the data and version model supported by the Fluid system [4].
The primitive data model used by Fluid is called the Fluid Internal Representation (IR).
The Fluid IR is based on two notions: nodes and slots.
A node is the basic unit of identity and is used to represent objects.
A slot is a location that can store a value, possibly a reference to a node.
A slot can exist in isolation but more typically slots are attached to nodes, using an attribute.
An attribute is a mapping from nodes to slots.
An attribute may have particular slots for some nodes and map all other nodes to a default slot.
The Fluid data model can thus be regarded as an attribute table whose rows correspond to IR nodes and columns correspond to attributes.
The cells of the table are slots.
Once we add versioning, the table gets a third dimension: the version.
There are three kinds of slots.
A constant slot is immutable; such a slot can only be given a value once, when it is de ned.
A simple slot may be assigned even after it has been de- ned.
The third kind of slot is the versioned slot, which may have a different value in different versions.
Nodes are used to implement structural units (document nodes) in Web documents, while slots and attributes are used to represent attributes of a document node and their values.
For example, an href attribute has been de ned to represent hyperlinks in an HTML document.
Links are created by de ning a value for an href attribute that is a URL.
An additional attribute (anchor) is de ned for anchors within documents.
Similarly, links can also be de ned in a Java program since it is represented by an AST.
Importantly, this approach to binding hyperlinks to source code does not interfere with program analyses, which ignore these hyperlink attributes.
Also, the href attribute is de ned as versioned slots, therefore, the changes occurring to the href attribute can be recorded over time.
In Fluid s version model, a version is a point in a tree-structured discrete time abstraction, rather than being a particular state of a system component.
From the user s point of view, a uniform global version space is maintained across the entire Fluid IR data model.
This is a form of product versioning [9], where there is one global version space for the whole Web project, while in  le-based ver-sioning systems such as CVS [38] or RCS [56], each  le has its own version history.
On the other hand, the Fluid version model operates at a much  ner internal granularity   the versioned slot level   to effectively store, retrieve, compare, and construct versions.
The version model is state-based.
However, revisions and variants are not distinguished.
The set of versions is organized in a tree, called the version tree, with the root of the tree being the initial version of the Fluid IR world.
The current version is the version designating the current state of the Fluid IR world and any version may be made current.
Internally, every time a versioned slot is assigned a (different) value, a new version is produced, derived from and branching off the current version.
However, from the users  point of view, a new version is only recorded if users issue an explicit command.
A  ne-grained tree-based versioning technique is developed for document trees as well as a Web project s structure, which is often hierarchically organized.
Trees are represented via nodes, slots, attributes, and sequences.
A sequence, which has a unique identi er, is a container with slots of the same data type.
Sequences may be  xed or variable in size and share common slots together.
A tree is de ned with two main attributes: 1)  children  attribute that for each node gives the sequence of children for the node, and 2)  parent  attribute that for each node gives its parent.
The details are illustrated via an example in Figure 1.
In the example,  content  attribute is also de ned to hold string value for each node if any.
Assume that there are three versions: v1, v2, and v3.
Versions v2 and v3 are branching off version v1.
The shape of the tree at the three versions is shown.
Version v1 has  ve nodes numbered from

 has an inserted node (node 6) and node 3 was deleted.
The values of versioned slots in the attribute table changed to re ect modi cations to the tree in these versions.
For example, at the version v2, the  content  slot (i.e. the slot de ned by the attribute  content ) of node 5 contains a new value (the string  new ), and the  children  slot of node 2 contains a reference to a new sequence object (seq3).
Seq3 has only one slot, which contains a reference to node 5 since node 4 has been deleted.
If there is a request on values of slots associated with node 4 at v2, a run-time error will be reported.
Note that other attributes might be de ned for nodes.
A hypertext structure is the network consisting of a set of Web documents and the hyperlinks connecting them in a Web system (external Web pages are excluded).
A hypertext structure is ver-sioned in the same manner as versioning for document trees.
Suppose that we have two documents: doc1 and doc2, connected as in Figure 2.
At version v1, A links to B, B links to D, and D links to C.
Suppose that now node A points to node C, and a new version v2 is created.
That is, at the version v2, the value of the href attribute of node A is  doc2#c .
It means that the link between A and B is no longer present at v2, while C can be reached directly from A now.
The links between B and D, and between D and C are still valid.
  Figure 3: History of a section Figure 4: History of a method Depending on the current version, the correct destination node of a link is implicitly determined.
Therefore, the shape of the network is properly exposed in the current version.
Using the versioning scheme described in the previous section, the SC environment provides  ne-grained content change management that allows Web developers to track the history of any structural unit (i.e. document node) in a Web document and to compare two arbitrary versions of Web content at levels: 1) structural unit, 2) Web document (except for binary data), and 3) the Web system in both structured and line-oriented manners.
In Figure 1, depending on the current version, the shape of a subtree rooted at a document node is exposed.
For example, if the current version is set to v2, the subtree at node 2 contains only itself and the child node 5 whose  content  slot contains the new value.
Based on this mechanism, the SC environment manages the evolution of Web content at a  ne granularity.
Web developers can select any structural unit in any type of structured document (XML, HTML, Java, SVG, UML) displayed in the SC editor and to view its state in different versions.
Figure 3 shows a past version of a section in an XML document.
When users move the cursor to a different version, the correct content of that section is shown in the lower window.
Note that the section has not been created at the version v1, therefore, it is  disabled .
Figure 4 shows the history of the loadDelta method of a Java program.
If developers select the root node of a document tree, the history of the document as a whole will be displayed in the same manner.
Tracking the history of a Web system as a whole will be discussed in Section 6.
In order to track the  ne-grained changes between two arbitrary versions, the SC environment employs a  dirty bit  mechanism in Fluid version engine, called the Versioned Unit Slot Information (VUSI).
With the VUSI mechanism, SC can tell whether there is a change in one or many attributes of a node between any two arbitrary versions.
It can also determine whether the structure of the subtree rooted at a node has been modi ed between any two arbitrary versions.
VUSI has  boolean  versioned slots attached to nodes in a tree.
The values of slots are set to false initially, indicating nothing has changed.
When the values of attributes associated with a node or the tree structure at the node are changed, the value of the associated VUSI slot of the node will be set to true.
Since a VUSI slot is versioned, the mechanism works for any two arbitrary versions (not necessarily predecessor or successor of each other).
The VUSI mechanism is also  exible enough to enable the creation of many VUSI slot types for any set of attributes (including children and parent attributes) and to support a variety of behaviors for marking the  dirty bits  for nodes.
For example, a VUSI slot type can be de ned to track changes occurring to the href attribute, while another type keeps an eye on bgcolor and fgcolor of a table.
Another example is that when an attribute of a node is modi ed, a behavior can be de ned such that it marks not only the VUSI slot associated with the node, but also the VUSI slots of its ancestor nodes.
This behavior allows for the detection of changes occurring in a subtree under a node.
Based on this mechanism, the SC environment includes a comparison (i.e. diff ) tool which can show the differences between two arbitrary versions of a document node, of a Web document, and of the Web application as a whole.
SC visually displays the differences in both structural and line-oriented manners.
Figure 5 shows structural changes in a Java program.
A small icon is attached to a document node icon, showing its changing status from version v7 to version v8: either it has been modi ed (a tree icon), inserted (an  i  icon), deleted (an eraser icon), or moved (a  truck  icon).
For example, the methods  getRoot  and  setRoot  have been deleted (see the left window), the methods  numChildren  and  parent  have been added at version v8 (see the right window), while the body of the method  doAnalysis  has been modi ed to add a new expression (see the right window).
Developers can also select a structural unit and choose an option to display changes of a text node in line-by-line fashion similar to ViewCVS [58].
A structural comparison between two versions of an HTML document is shown
 Figure 6: HTML document comparison in Figure 6.
Some of document nodes have been modi ed in terms of both their attributes and structures, for example, the  body  of the document (an  a  icon and a tree icon are both attached to the node icon).
Meanwhile, the  table  node icon has only an  a  icon since only the color attribute of the table has been changed.
Figure 7 shows the changes in the structure of a Web project between two versions.
As in the document comparison tool, the icon next to a document s entry shows the change in its status from one version to another.
With this tool, developers are able to track changes in Web documents and program source code in a  ne-grained manner.
Therefore, it helps them to maintain better their Web applications.
Also, incremental program analyses can take advantages of this  ne-grained change tracking mechanism to optimize processes.
It is very cumbersome for existing SCM systems that heavily depend on line-by-line comparison between versions to build this sort of  ne-grained Web content change management.
Since Web documents are interrelated and connected to each other via hyperlinks to form a Web application, version control Figure 7: Project structure comparison for Web content as individuals is not suf cient.
A con guration management system is needed to manage the evolution of a Web application as a whole.
The SCM system of the SC environment, Molhado, is built on top the Fluid version model to provide con g-uration management services for developers to manage their Web projects.
This section describes the Molhado SCM system and how a Web project can be logically structured and versioned.
Molhado s three main abstractions are components, projects, and con gurations.
A component is a logical unit that is named, can be saved and loaded, and exists within the version space of a Web application project (Web project for short).
A component may be a document, a class, a package, a module, a  le, or a directory depending on the development framework being used.
In SC, the Web documents described earlier are components whose internal structure is versioned at a  ne granularity.
A project is a named entity that represents the version history of a Web project.
It is not a version of the project, but rather is used to retrieve the correct project version (including both structure and components).
The project contains within itself a tree to represent the project structure.
Each node in the tree is associated with a slot that contains a reference to a component.
The project structure is versioned using the same tree-based versioning scheme described in Section 4.
A con guration is a particular version of a project.
Since a slot associated with a node in a project tree can contain a reference to any component, the Web project and its components can be organized logically.
Figure 8 shows an example of a logical structure of a Web project.
Each node in the project s tree has a slot referencing to a component.
In this example (the University of Wisconsin (UW) s Web site), there are directory components, Java class components, and HTML document components.
The  root  directory component of this Web project consists of directory component  code  and two HTML document components  index.html  and  UW.html .
Nodes in the subtree at the  code  directory component are associated with slots containing references to Java class components A,B, C, D, and E. This forms a class hierarchy under the  code  directory component.
On the right hand side part of Figure 8, the Web pages of this Web project are logically structured according to the UW s campuses in the  rst level and then to colleges and schools in the second level.
&')(*+,& -.
(+%/10 onent &+,+ t +,#' #%$ &')(*+,&2-3(4+,/10 onent (4+,# e class (4+,/10 onent




 <>=

 Legend:
 slot assN"Q)R ation betwPKP>MSMN)O)P and slot index.html
 (4+,/10 onent UW.html wisc.html uwgb.html uwm.html eng.html bus.html math.html ...
EGFH?GFL<>B y
 logD slot holding P,MQPVULN a P fP a T

 abc

 Figure 8: Logical organizations in a Web project The directory-document hierarchy and components themselves are all logical.
This means that directories and documents do not necessarily correspond to any directories and  les on a  le system.
Therefore, in Figure 8, the class component  A  (not a document or a  le) can be contained within directory component  code .
This physical-independent organization of Web documents allows for accessing to Web content without having to know the actual physical address of the  les.
This ability is very important for large-scale Web applications whose documents may be distributed across many servers.
Figure 8 also shows that Molhado has the ability to support multiple logical organizations of a single Web project.
For example, program source code can be structured according to the developers  choice of design and implementation methodologies.
Meanwhile, HTML documents can be organized into either a normal directory-document hierarchy based on a  le system, or a logical hierarchy depending on the chosen development model such as OOHDM [45] or RMM [28].
Figure 9 shows the structure of the Web project of our research in which Java programs are structured as a package-class hierarchy and HTML documents are organized into a directory-document hierarchy.
New component types can be easily added into Molhado to support different logical structures.
Our project versioning approach, where a Web project is ver-sioned as a whole, implies that versioning of a component is subsidiary to that of the project to which the component belongs.
This is in contrast to the composition model [17] in most of existing SCM systems, where the project version (i.e. con guration) is dependent on the versions of each of its components.
This project versioning approach always assures the construction of a consistent con guration since when a project version is chosen as the current, the project s tree will be correctly retrieved and versioned slots associated with nodes in the tree will refer to appropriate components at the current version as well.
Then, the internal structure of each component and contents of slots will also be determined at the current version as mentioned in Section 4.
This approach also avoids the complexity of using version selection rules in composition-based SCM systems and traditional versioned hypermedia systems [61], which are used to select the correct versions of components to be included in a version of a Web project.
Figure 9: Project structure window
 This section discusses the operational model for a user during a transaction.
Via GUIs, the user can open an existing Web project.
The user can view the history of the Web project in a project history window.
After selecting the working version, the SC system displays the project s structure and its components in a project structure window (see Figure 9).
The version that is initially displayed in the project structure window is called the base version.
Via this window, the user can manipulate the project structure.
If any modi cation is made to the project structure or its components at this base version, a new internal version in Fluid is temporarily created as a branch from the base version (the word  modi ed  will be attached to the base version s name), and the project structure window will now show information about this derived version.
The user can choose to discard any derived version (i.e. any changes to the base version), or to issue a command to capture the project s state in a particular version.
Intermediate internal versions from the base version to the newly captured version are discarded.
A unique name within the Web project version space is assigned to the newly captured version either by the user or by the system.
Bookkeeping

 information such as dates, authors, and descriptions can be attached to the new version for later retrieval.
The captured version plays the role of a checkpoint version which the user can retrieve and refer to and becomes the new base version of the project structure window.
However, no data is saved after a capture.
While working on one version of a Web project, the user can always switch to work on any other version.
Switching to work or to view a different version can be done explicitly or implicitly, whether or not the current working version has been captured.
If the user moves the mouse focus to a component editing window, or to a project structure window, the working version is automatically set to the version that the window is displaying.
The user can also explicitly select a different version from the project history window and open it.
Any windows showing the old version are still available should the user want to do additional work on that version.
It implies that there may exist many windows displaying different versions (captured or uncaptured) in the same editing session.
The user is not only allowed to view, but also to modify the new working version.
In this case, an additional derived version will be branched off from the new working version.
This switching feature allows the user to work on many versions at the same time during one session.
The user may commit changes to the project at any time.
Commit is the command with which the user saves all changes made during an editing session since the previous commitment.
Upon issuing this command, the user is asked which uncaptured versions should be saved and the chosen versions are then saved to a  le system.
Only the differences are stored.
The user may also save complete version snapshots, which can improve version access time.
In current system, each user can store his/her own data  les for a Web project anywhere in a  le system.
Each user does not see changes from others.
Therefore, no locking mechanism is needed.
Users can share the data  les and using merging tools to collaborate.
A better collaboration mechanism is being implemented using a central versioning repository similar to CVS [38] with an  of cial  version graph.
To branch from a version, the user just needs to copy data  les for that version to his/her own workspace.
The user can create many  private  versions.
Finally, the user can copy meaningful versions back to the central repository.
This section describes the details of the SC editing system for Web content.
The editing system is an integration of a structured document editor for XML, HTML, and plain text documents, a syntax-recognizing Java program editor, an SVG graphic and animation editor, and a UML editor.
The SC environment is compatible with XML-based document editing environments since it supports the integration of editors for new document types whose internal representation is XML-compatible.
For example, the Thorn UML editor [55] and DrawSWF SVG editor [14] were easily integrated into the SC editor because their document representations are XML-based.
Integration requires only that a new editor follows a simple plugin protocol.
The SC environment uses a Document Object Model (DOM) [13] parser to import XML-based documents, converts the DOM trees into the SC document tree representation, and then version controls them as described earlier.
All Web documents and their versions mentioned in Section 3 are stored according to the Fluid s persistence model [4].
In the Fluid s persistence model, a persistent entity is the basic unit of information that can be stored and then loaded.
The persistence model uses the forward direct delta technique to store differences between versions.
The data  les for versioned persistence are immutable and may be freely duplicated or distributed using any  le Figure 10: Intermixing object types sharing protocol.
At any version, developers can import and export a Web project s documents (stored in the Fluid persistence representation) including program source code, UML diagrams, SVG images, animations, and graphics from and to XML format.
This feature is obviously important since it helps users work with tools outside the SC environment.
A user edits XML, HTML and Java programs in the same manner.
The user interacts with the system using a menu bar, a tool bar, and contextual pop up menus.
When a user selects a Web document from the project structure window, an appropriate editor is invoked for the document.
To display a document, a default CSS-like style sheet is selected by the system for the document unless it has one.
The presentation of the document is built based on the document tree and the style information.
The user can choose to open a document with any appropriate style sheet.
To edit a document, the user moves the mouse and selects any structural unit of the document that needs to be edited.
Then, via the commands in the pop up menu, the user can choose to edit the content of that structural unit presented in the selected portion of the presentation, or to edit the documentation associated with that unit.
The SC editor invokes the node editor, which is a simple ASCII text editor.
The editor unparses the node and displays the resulting textual representation of the node to be edited.
The user edits the text and returns to the document window.
Depending on the type of the document that is being edited, the editor invokes either an XML, HTML parser or a Java parser to incrementally parse the modi ed text, and then creates new nodes and attaches them to the document tree.
If there exists any errors in the modi ed text, error messages are displayed and the user can  x them.
The SC editing environment also allows a user to edit image or graphic documentation, and then to associate them with any structural unit in a Java program.
This feature allows for intermixing different object types in the same document, which is very common in Web content.
Figure 10 shows a Java program intermixing with graphics, texts, and audio clips.
The user invokes an image and graphic editor.
When the user  nishes with his images, the SC
 Figure 12: SVG graphic and animation editor editor adds the resulting images into the document window.
To associate audio documentation with a structural unit, the user invokes an audio selection dialog to choose an audio  le.
Image, audio, and graphic documentation  le names are contained in special attributes of document nodes.
In addition, the user can create, edit a hyperlink, and attach it to any structural unit in a Java program using steps similar to the ones needed to edit the documentation.
The user can enter a URL or choose a  le from a selection dialog.
Similar to HTML documents, hyperlinks in programs are supported via the href attribute as described earlier.
This approach to binding multimedia annotations and hyperlinks to source code does not interfere with program compilation process since it ignores the slots that support multimedia documentation and hyperlinks.
For an HTML document, the user is also able to preview the document s appearance as if it were displayed via a Web browser.
Figure 11 displays the contents of an HTML document for two different versions.
Similarly, Figure 12 shows two versions of the SC s architecture description document in SVG format.
All graphic, image, and animation objects in SVG format are versioned in the same manner as XML documents.
To edit a UML diagram, the user invokes the UML diagram editor, which is a specialized graphic editor for class diagrams, use case diagrams, sequence diagrams, and activity diagrams.
Systematic approaches to Web engineering are becoming increasingly necessary as Web applications grow and have longer lifetimes.
The research presented here is based in the belief that managing the evolution of Web applications is a task that requires sophisticated con guration management tools.
As recently as the year 2000, it was asserted that very few companies with mission-critical Web system were using SCM tools [11], and that others were developing their own CM tools and techniques because they were not fully aware of the state of the art in SCM.
At the same time, researchers in the SCM area have paid little attention to bringing advanced technologies to Web engineering.
Most existing SCM and version control tools that are used are focused on version control of individual  les with limited supports for content change and con guration management of a Web project.
We have described a  ne-grained version control and structured con guration management system (Molhado) and discussed how it is well-suited to managing the evolution of a Web application project.
Molhado is a core part of the Software Concordance environment, which was modi ed by this research to support Web development.
Its versioning scheme supports content change management that helps Web authors manage the evolution of their Web project at the logical level and at  ne granularity.
The con guration management services help Web developers to logically structure and manage a Web project and its components.
Multiple logical organizations of a Web project can exist in the same version.
The SC editor prototype provides a GUI-based environment for browsing and editing versions of a project and its components.
A user can work on multiple versions simultaneously.
SC is  exible and extensible to support many other types of Web content.
An experimental study is being conducted to evaluate the performance, ef ciency, and usability of the system.
