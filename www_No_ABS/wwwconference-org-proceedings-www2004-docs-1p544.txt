Markup languages for speci cations of Web services are set to play an important role in enabling dynamic service discovery and composition by human users and software agents.
There is a plethora of languages proposed by academic and industrial research groups for service description, discovery and composition with XML as their backbone.
The semantic web has contributed substantially via providing ontology description languages like OWL [12].
Prominent efforts can be seen in the form of OWLS [23]: an ontology for describing pro le, process and grounding models for a service.
Related work is also being done in the form of IRS (Internet Reasoning Services) [19].
Copyright is held by the author/owner(s).
The Current Web service description languages however suffer from the lack of their ability to provide constructs and concepts that enable reasoning about runtime service behaviour.
Languages like WSDL [21] and BPEL4WS [24] do not have the provision for specifying the conditions a service provider would want to impose on its environment to guarantee a valid service execution.
Similarly there are no ways for the service provider to describe what assertions would be true once the service has been executed.
OWLS does provide concepts like preconditions and conditional effects.
The WSMF [5] de nes pre- and post-conditions for services.
These contribute to some extent towards their behavioural description.
However pre/post-conditions and effects are limited to static descriptions.
They are required to hold only at the initial and  nal states of the service execution.
In a scenario where Web services are black boxes and the client or the service requester (human/agent) has no control over the various stages of service execution, it becomes necessary to enrich the service description with certain properties which would enable reasoning about service behaviour while it is in execution.
The need for such rich speci cations becomes evident while reasoning about the composition of services and veri cation of the composition.
Current composition planners/engines [25, 22] use input/out-put mapping, type characteristics of these parameters and initial,  nal state predicates to generate compositions/plans.
However, to ensure a sound composition, services need to be composed using a speci cation technique that characterizes ongoing behaviour of the service.
Further, since Web services abstract implementation details, composing agents (human/software) have no means to validate an ongoing composition and take appropriate measures in case the speci- cations cease to be satis ed.
Behavioural speci cation of services should include assertions that not only validate their initial and  -nal states, but also their intermediate states.
These states could be critical decision making stages during computation or the states at which messages are exchanged between the services.
The rationale for these additional observables become more apparent while composing services that execute concurrently as the possibility of synchronization and communication between the services make the intermediate states as important as the initial and  nal one.
Moreover with such properties in hand, veri cation of the composition at runtime is reduced to checking the assertions required to hold by every service in the composition using an engine designed to handle temporal properties.
We propose a methodology to augment the semantic description of a service with temporal properties formally called assumption
 Logic(ITL) [17, 18, 16, 2], our underlying formalism for reasoning about service behaviour over periods of time.
These assertions are speci ed using predicates in  rst order logic with temporal operators only over their observable behaviour and do not depend on any additional knowledge about the underlying execution mechanism of the services.
Further, we show that such assertional speci cations are compositional and this strategy can be effectively applied for the veri cation of a composed service on the basis of the spec-i cation of the individual services.
The formalism thus provides a powerful technique for reasoning about service composition, execution and runtime veri cation of service behaviour.
We choose OWLS: an OWL ontology as our starting point for specifying these properties.
OWLS scores highly in expressiveness over other languages.
OWL has well-de ned semantics in description logic.
OWLS has operational semantics de ned in Petri Nets [20] and subtype polymorphism [4].
Although other languages for Web service descriptions claim to have semantics de- ned in Pi-calculus/Petri nets, there are no documents supporting the same.
Recently a preliminary proposal for a rule language has been put forward to express rules and constraints [9] in the framework of the OWL language.
This allows us to express property predicates as an OWL ontology.
In this paper we show how the compositional properties of A - C can be expressed as a SWRL ontology.
This representation can be made a part of the process model in OWLS. Our approach differs from conventional approaches as we consider validation and veri cation to be an integral part of service composition.
This also makes it readily applicable to the execution monitoring model proposed in OWLS.
The paper is structured as follows: Section 2 describes the principle of Compositionality.
Section 3 discusses the  A - C  paradigm.
Section 4 describes the ITL formalization of A - C and its application to Web services.
Section 5 discusses OWLS and SWRL.
Section 6 describes how the A - C properties can be expressed as a SWRL representation.
Section 5 proposes composition rules and their proof obligations for introducing compositionality in service speci cations.
Section 8 presents an example of an auction service.
Section 9 discusses runtime veri cation techniques using AnaTem-pura.
Section 10 outlines conclusion and future work.
Compositionality [6] refers to the technical property that enables reasoning about a composed system on the basis of its constituent parts without any additional need for information about the implementation of those parts.
The notion of compositionality is very important in computer science as it facilitates modular design and maintenance of complex systems.
Compositionality is also a desired criterion for veri cation methodologies, particularly for the development and analysis of large scale systems.
The idea was  rst formulated by Edsger W. Dijkstra [7].
For reasoning satisfactorily about composed system, we only require that systems and their components are speci ed using predicates.
The principle of com-positionality can be readily applied to Web services.
Reasoning about compositions is facilitated using compositional principles, rules and their proof obligations, on the predicates derived from service descriptions stored in some repository by a preprocessor or a reasoning engine.
 
 k
 k+1   Figure 1: Assumption-Commitment


 The A - C framework is a compositional speci cation methodology.
It was  rst discovered by Jayadev Misra and Mani Chandy [13] as a proof technique for networks of processes executing concurrently via synchronous message passing.
A related technique for shared variable concurrency was proposed by Cliff Jones in [11].
The objective is to specify a process within a network.
Formally an A - C formula has the following form: (A, C) : { }P { } (1) where P denotes a process and A,  ,  , C denote predicates.
Informally an A - C formula has the following meaning: if   holds in the initial state, including the communication history in which P starts its execution then   C holds initially and C holds after every communication provided A holds after all preceding communication and   If P terminates and A holds after all previous communication (including the last one) then   holds in the  nal state including the  nal communication history An equivalent de nition for (1) using induction (ref.
Fig. 1) can be de ned as :

 then C holds up to the k + 1th point for all k   0 and,
 and P terminates, then   holds on termination.
Here A expresses an assumption describing the expected behaviour of the environment of P .
C expresses a commitment which is guaranteed by the process P as long as the environment does not violate the assumption A and   and   express pre- and post-conditions upon the state of P .
A and C are required to hold for both terminated and nonterminated computation.
ITL is a  exible notation for both propositional and  rst-order reasoning about periods of time.
Tempura: an executable subset of ITL, provides a framework for developing, analysing and experimenting with suitable ITL speci cations.
The syntax of ITL is de ned in Fig. 2 where   is an integer value, a is a static variable (doesn t change within an interval), A is a state variable (can change within an interval), v a static or state variable, g is a function symbol and p is a predicate symbol.
ITL contains conventional propositional operators such as  ,   and  rst order ones such as   and =.
There are temporal operators like  ; (chop) ,  * (chopstar)  and  skip .
Additionally in ITL,
 Formulae e ::=   | a | A | g(e1, .
.
.
, en) |  a : f f ::= p(e1, .
.
.
, en) |  f | f1   f2 |  v q f | skip | f1 ; f2 | f   Figure 2: Syntax of ITL there are temporal operators like (cid:13) and 2.
Expressions and For-mulae are evaluated relative to the beginning of an interval.
The informal semantics of the most interesting constructs are as follows:   ia : f : the value of a such that f holds.
  skip : unit interval ( length 1).
  f1; f2 : holds if the interval can be chopped into a pre x and a suf x interval such that f1 holds over the pre x and f2 over the suf x.
  f   : holds if the interval is decomposable into a number of intervals such that for each of them f holds.
Some of the frequently used abbreviations are listed in Table 1.
Table 1: Frequently used temporal abbreviations b= skip ; f (cid:13)f more b= (cid:13)true empty b=  more b=  nite ; f 3f b=  3 f 2f b= 2(empty   f )  n f (cid:13)w f b=   (cid:13) f b= f ; true 3i f b=  (3i  f ) 2i f b=  nite ; f ; true 3a f b=  (3a  f ) 2a f next nonempty interval empty interval sometimes always  nal state weak next some initial subinterval all initial subintervals some subinterval all subintervals
 Composed Web services are independently executing components communicating via message passing to yield the desired be-haviour.
Since the A - C paradigm offers compositional proof techniques for specifying and verifying composed system, communicating via message passing, it lends itself readily for application in the domain of Web services.
For our purpose we need to use a variant of the formalism which is somewhat different in spirit from the classical compositional reasoning.
We rede ne the paradigm as below: TheAssumption-Commitmentparadigmisacomposi-tionalspeci cationandveri cationtechniquethatcan be applied to services or networks of services, composed to execute sequentially or concurrently.
The paradigm provides compositional rules whose proof obligationsensuressoundnessofthecomposition.
The validityof theproofobligations orveri cationcondi-tionscanbecheckedatthedesignstageforstaticanal-ysisofthecomposedsystem,andcanalsobechecked atruntime using atheorem prover withactualparam-eters.
The Assumption-Commitment paradigm thus providesapowerfultechniqueforreasoningaboutser-vices that can be composed and once they are composed, it helps in validating the integrity of the com-positionatruntime.
The assertions required for formulating A - C in this scenario are quite general.
Conventionally, assumptions are predicates required to be true by the environment of a service.
For a service executing as part of a network, the environment is composed of all other services executing in the network.
In the original formalism, assumptions are predicates over the channel variables.
We relax this notion and require assumption to be an ongoing temporal property including constraints on the input parameters that a service provider demands to be true as long as his service is in execution.
The assertions for the commitment can be any temporal property of the service which the provider wishes to expose as a guarantee to the assumption.
Commitment A Service, S in ITL is expressed as a quadruple ( , As, Co,     ) where,   As Co     : state formula about initial state : a temporal formula specifying properties about the environment : a temporal formula specifying properties about the service : state formula about  nal state Validity of an AC formula, |= (As, Co) : { }S{    } inductively de ned in ITL, has the following intuitive meaning:   if   holds in the initial state, in which S starts its execution then Co holds initially in S.
  if   holds initially in S and, As holds upto the  kth state in S, then Co holds upto the  k+1th state for all k   0.
  if   holds initially in S and, As holds at all previous states, before S terminates then     holds on termination.
k+1 k                  w   w                         As   Co skip Figure 3: ITL representation of Assumption-Commitment Co Formally in ITL, the validity of the A - C representation (ref.
Fig.
3) has the following form : (As, Co) : { }S{  }   def
     2i ((As   Co) ; skip   Co)    n    

 OWLS is an OWL ontology for the speci cation of services.
It is structured to provide three types of information about a service.
The service pro le provides a representation of properties and capabilities that can be used by a service requester to specify their needs and service providers to advertise their services for  what  it does.
The process model describes  how  the service  serves .
It provides concepts for specifying the functional attributes of a service in the form of Inputs, (Conditional)Outputs, Preconditions and (Conditional)Effects.
It also provides constructs for service composition.
The Grounding maps process parameters to corresponding WSDL representation of inter-service communication aspects of the service, in terms of the message formats, protocols and communication ports.
Our interest lies in augmenting the Process model with A - C properties.
Since assumptions and commitments are temporal for-mulae, we need an extension to the core ontology that allows us to express them.
SWRL [9] is a preliminary proposal for a rule language designed to express rules and constraints in the framework of the OWL language.
Related work for specifying rules within the domain of Semantic web are initiatives like RuleML [3] and DRS [8].
However SWRL gives us the  exibility to remain within the domain of OWL.
A Concrete XML and RDF syntax are part of the current speci cation of the language.
In this paper we present our example using the RDF/XML encoding.
It must be noted that SWRL is evolving and signi cant changes can be expected in the near future.
SWRL is based on a combination of the OWL DL and OWL Lite sublanguages of the OWL Web Ontology Language with the Unary/Binary Datalog RuleML sublanguages of the Rule Markup Language.
It proposes the speci cation of rules in the form of an implication.
The Atoms within the body and the head of the implication can be Class Predicates C(x) or Property Predicates P (x, y).
Within the body or head, multiple atoms are treated as a conjunction.
Here is a primitive way of how one could express a rule or a condition for a book buying service,  BBS .
Semantically, the rule can be de ned as, if a buyer has a valid Account and a valid Credit Card, he can buy a book from BBS.
We have the following variables as inputs to the book buying service,   Account ID   Password   Creditcard number   Expiry date   ISBN number The variables can be de ned in SWRL as: <V a r i a b l e <V a r i a b l e <V a r i a b l e <V a r i a b l e <V a r i a b l e r d f : I D =  a c c t I D   /> r d f : I D =  p a s s w o r d   /> r d f : I D =  c r e d i t C a r d N u m b e r   /> r d f : I D =  expDate   /> r d f : I D =  ISBNNumber  /> The rule can now be stated as: <Imp> <body r d f : p a r s e T y p e =  C o l l e c t i o n  > <i n d i v i d u a l P r o p e r t y A t o m> <p r o p e r t y P r e d i c a t e r d f : r e s o u r c e =  # a c c o u n t E x i s t s   /> <argument1 r d f : r e s o u r c e =  # a c c t I D   /> <argument2 r d f : r e s o u r c e =  # p a s s w o r d   /> <i n d i v i d u a l P r o p e r t y A t o m> <i n d i v i d u a l P r o p e r t y A t o m> <p r o p e r t y P r e d i c a t e r d f : r e s o u r c e =  # c r e d i t E x i s t s   /> <argument1 r d f : r e s o u r c e =  # c r e d i t C a r d N u m b e r   /> <argument2 r d f : r e s o u r c e =  # e x p d a t e   /> <i n d i v i d u a l P r o p e r t y A t o m> <body> <head r d f : p a r s e T y p e =  C o l l e c t i o n  > <i n d i v i d u a l P r o p e r t y A t o m> <p r o p e r t y P r e d i c a t e r d f : r e s o u r c e =  # allowedToBuy   /> <argument1 r d f : r e s o u r c e =  # a c c t I D   /> <argument2 r d f : r e s o u r c e =  #ISBNNumber  /> <i n d i v i d u a l P r o p e r t y A t o m> <head> <Imp> Many times it may be the case that we do not want to express an implication, but simply a predicate or a conjunction of predicates [15].
This is the case for expressing  Condition - which is used in many places within the Process model.
Within the framework of OWLS, Conditions are required to be logical formulae.
They are part of the de nition for  Precondition  - a kind of Condition and also for Conditional outputs and effects.
Currently SWRL does not specify any such constructs.
Several proposals have been discussed for expressing Conditions in this format [15].
The common factor in all these proposals is having a top-level concept called  Formula  and de ning  Condition  to be of rdf:type Formula.
Eventually,  Formula  is expected to be de ned as a part of SWRL.
However for practical purposes it can be de ned within the Process model or DRS representation of the same can be used.
In this paper we abstract the top level representation of  Formula , as we believe that this is a matter of namespace representation and express temporal properties as Property Predicates using SWRL.
A - C properties are Temporal formulae2.
<o w l : C l a s s r d f : I D =  T emporalFormula  > <r d f : s u b C l a s s O f r d f : r e s o u r c e =  # Formula  > </ o w l : C l a s s> <o w l : C l a s s <r d f : t y p e r d f : I D =  Assumption  > r d f : r e s o u r c e =  # T emporalFormula  > </ o w l : C l a s s> <o w l : C l a s s <r d f : t y p e r d f : I D =  Commitment  > r d f : r e s o u r c e =  # T emporalFormula  > </ o w l : C l a s s> From the aspect of ontological representation, A - C can be regarded as  rst-order logical formulae analogous to Conditions and augmented with temporal operators.
We have modelled a basic ontology for expressing various temporal operators in ITL [1].
When the representation of Conditions is standardized, assumption and commitments can be easily expressed by using the two ontologies.
As an example consider the following temporal formula:
 Informally it means that always the name of the book should correspond to the given ISBN number.
The ontological representation of the above is, <i n d i v i d u a l P r o p e r t y A t o m> <p r e f i x O p e r a t o r r d f : r e s o u r c e = & i t l ; Always   /> <p r o p e r t y P r e d i c a t e r d f : r e s o u r c e = <argument1 r d f : r e s o u r c e =  # b o o k T i t l e   />   # validISBNNumber   />
 TemporalFormula at this stage.
specify not do namespaces of Formula and
 </ i n d i v i d u a l P r o p e r t y A t o m> where, prefixOperator is a Class, representing temporal operators like 2, 2i , 2a , 3 and  .
The (cid:13) operator can be applied to both formulae and variables.
In this section, we explain how A - C can be used to composi-tionally reason about integrated services.
Web services compositions can be realised using several programming language control constructs.
Predominantly there are two forms of compositions: sequential and parallel.
Other forms of compositions can be derived from these two forms using constructs like if-then-else, iterate, repeat-until, while-do and choice [14].
We de ne compositional rules using A - C for the most intuitive form of composition i.e sequential and parallel composition.
We provide the ontological representation for pre/post conditions and A - C predicates using SWRL.
In following subsections: 1.  ,     represent pre/post conditions respectively.
position.
 1    
    2    
 Figure 4: Sequential Composition We consider the sequential composition (ref.
Fig. 4) of two services.
Services S1 and S2.
In case of sequential composition we (As, Co) (As, Co) : : { 1}S1{  { 2}S2{  As   2a As Co   Co    1    2    

   (As, Co) : { 1}S1; S2{  (1) (2) (3) (4) (5) (6)  
 require that As and Co are respective  xpoints3of the ITL operators 2a and chopstar.
For the commitment to hold over the interval de ned by S1; S2, we  rst require the assumption to hold over that interval.
Hence, if the assumption holds and if it is a  xpoint of 2a , it guarantees to holds over the individual subintervals i.e intervals de ned by S1 and S2 as well (semantics of 2a ).
Now in response to this assumption, if the services guarantee some commitments, they hold on the individual subintervals for S1 and S2.
If we choose these commitments such that they are  xpoints of chopstar(i.e a
 A function may have any number of  xed points from none (e.g.
f x = x+1) to in nitely many (e.g.
f x = x).
singular commitment), we can easily collapse the commitment to hold for the interval de ned by S1; S2.
The advantage of these restrictions are ease in implementation and reduced complexity in validating the composition.
We take an example of a global book searching service composed in sequence with a book buying and shipping service.
The composition engine requires all necessary user inputs, i.e ISBN number of the book, credit card details and shipping details to be supplied to the composite service before engaging into the composition.
Pre/post conditions can be de ned as:   b= valid(ISBN )   validCreditCard(cardN umber)     b= cardBilled(cardN umber)   bookShipped(shippingAddress) When expressed as a property predicate in SWRL, the Precondition: can be de ned as: <c o n j u n c t s r d f : p a r s e T y p e =  C o l l e c t i o n  > <i n d i v i d u a l P r o p e r t y A t o m> <p r o p e r t y P r e d i c a t e r d f : r e s o u r c e =  # validISBNNumber   /> <argument1 r d f : r e s o u r c e =  # b o o k T i t l e   /> <argument2 r d f : r e s o u r c e =  #ISBN  /> </ i n d i v i d u a l P r o p e r t y A t o m> <i n d i v i d u a l P r o p e r t y A t o m> <p r o p e r t y P r e d i c a t e r d f : r e s o u r c e =  # v a l i d C r e d i t C a r d   /> <argument1 r d f : r e s o u r c e =  # cardNumber   /> <argument2 r d f : r e s o u r c e =  # expDate   /> </ i n d i v i d u a l P r o p e r t y A t o m> </ c o n j u n c t s> The post-condition can be expressed accordingly.
However, it can be observed that these assertions do not make any statements about the credit card validity by the requester throughout the composition and the assurance that the card will not be billed till the transaction is complete by the service provider.
A - C assertions are required to increase trustworthiness of the service and to take corrective measures in case of any unexpected be-haviour.
For e.g., it is likely that the requester s credit card ceases to be valid during an ongoing transaction.
Therefore the following temporal assertions are required to be made part of the speci cation.
As Co b= 2a validCreditCard(cardN umber) b= ( cardBilled(amount, cardN umber))  The commitment can be expressed as: <i n d i v i d u a l P r o p e r t y A t o m> <s u f f i x O p e r a t o r <p r e f i x O p e r a t o r r d f : r e s o u r c e = & i t l ; C h o p s t a r   /> r d f : r e s o u r c e = & i t l ; Negate   /> <p r o p e r t y P r e d i c a t e <argument1 r d f : r e s o u r c e =  # amonut   /> <argument2 r d f : r e s o u r c e =  # cardNumber   /> r d f : r e s o u r c e =  # c a r d B i l l e d   /> </ i n d i v i d u a l P r o p e r t y A t o m> The assumption can be expressed accordingly.
A network of services executing concurrently consists of a set of services and a set of shared objects such as channels, through which the services communicate via message passing.
The speci- cation, proof obligations and the compositional rule for services executing in parallel are as de ned below: For services executing concurrently, the environment of each service is governed by the environment of every other service in the network and by the overall environment of the composition.
Hence the proof obligation
 (As2, Co2) : : { 1}S1{  { 2}S2{  As   Co1   As2 As   Co2   As1  

   (As, Co1   Co2) : ( 1    2)S1 k S2(    1      
 (1) (2) (3) (4) (5) for parallel composition, relates the environment (As1) of a service ((S1) with commitment (Co2) of the other service, (part of the environment of (S1)) as the observable in uence and with the assumption (As) of the overall composition.
An example of parallel composition is presented in the following section.
An Auction service (ref.
Fig. 5) is presented as an example of a composite service.
The Auction service is a composition between several buying services, a selling service and the auction house, executing in parallel with each other.
Buyers and seller are classi ed   Beat-the-Quote: At any time, the buyer cannot lower the current highest amount.
  Unique Bid: At any time, a buyer has only one active bid.
  Winning Bid: At any time, only the winning bid is sent back to the buyer.
  Dominant Bid: At any time, the latest bid submitted by a buyer has to be higher than the last bid submitted by him.
  Unique Winner: The auction house guarantees a unique winner once the auction is over.
Registration for the auction is a precondition for every buying/selling service.
The postcondition is that the auction declares a unique winner.
The remaining rules are constraints on bids and are required to hold while the auction is in progress.
They can be considered as the  assumption  of the auction house or  commitments  by the buying service.
As long as these assumptions are satis ed, the auction house guarantees to admit the bidder for the next round and consider the bid as a valid bid.
The auction spans over an interval (ref.
Fig. 6) de ned by a sequence of n states.
The ask price is submitted at state 0 and the winning bid is declared at state n. Bids are submitted and the auction is cleared at all intermediate states i.e between states 1. .
.
n 1.
The number of buyers registered for auction is k. Communication between the buying services and the auction house takes place via channels.
ask
 winBid = max(bid1 , bid2 , bid5 )

 winBid n bid1 bid5 bid2 Figure 6: Observable States of the Auction House Figure 5: Composition of an Auction Service We de ne observable variables for the auction service in Table 2 below.
as bidders in the auction process.
Seller submits an ask price to the auction house, buyers submit bids as per the rules of the auction, the auction house validates the incoming bids and clears the auction, declaring the winning bid for each clearance.
Finally the winner is announced and the auction is closed.
The auction process spans over an interval with intermediate states being de ned at the instants where communication between the partners take place.
The execution of the composed service takes place concurrently as buyers can submit bids while other bids are being processed by the auction house.
The Seller can also change his ask price while the auction progresses, depending on the market situation.
However for simplicity we do not consider that case here and model the composition only between the Auction house and the buying services.
In our design we assume the selling and buying services to be thin clients of the auction house.
The auction house itself is a thick computational server.
It validates rules of the auction and properties of the incoming bids.
Some of these properties can be de ned informally as below:   Registration: To trade via the Auction house bidders (sell-er/buyers) have to register with the Auction house as members.
Table 2: Observable variables Ask price Bidder, i s bid list of bids at any state b= ask b= bidi : 0 < i   k b= bidList b= {bidi|0 < i   k} Winning Bid at any state b= max(bidList) Bid received by a buyer b= bidrec b= winBid
 The initial nal state properties required to be validated by the auction house can now be de ned as,   b= winBid = ask    i : 0 < i   k : isRegistered(i)     b=  i : 0 < i   k : isW inner(i) where, isRegistered(i) and isW inner(i) are pre/postcondition predicates, respectively.
The assumption (Asah) for any bid submitted to the auction house by a bidder and the corresponding commitment by the auction house Coah can be formally expressed as, 549 i : 0 < i   k Asah Coah b= 2(((cid:13)bidi   bidi)   ((cid:13)bidi   winBid)) b= 2(bidrec = winBid) We express the Assumption predicate in SWRL as below: <V a r i a b l e <V a r i a b l e <V a r i a b l e r d f : I D =  b i d   /> r d f : I D =  winBid   /> r d f : I D =  b i d r e c   /> <c o n j u n c t s r d f : p a r s e T y p e =  C o l l e c t i o n  > <i n d i v i d u a l P r o p e r t y A t o m> <p r e f i x O p e r a t o r <p r o p e r t y P r e d i c a t e r d f : r e s o u r c e = & i t l ; Always   /> r d f : r e s o u r c e =  # isGEQNext   /> <argument1 r d f : r e s o u r c e =  # b i d   > <p r e f i x O p e r a t o r r d f : r e s o u r c e = & i t l ; Next   /> </ argument1> <argument2 r d f : r e s o u r c e =  # b i d   /> </ i n d i v i d u a l P r o p e r t y A t o m> <i n d i v i d u a l P r o p e r t y A t o m> <p r e f i x O p e r a t o r <p r o p e r t y P r e d i c a t e r d f : r e s o u r c e = & i t l ; Always   /> r d f : r e s o u r c e =  # isGEQWinBid   /> <argument1 r d f : r e s o u r c e =  # b i d   /> <p r e f i x O p e r a t o r r d f : r e s o u r c e = & i t l ; Next   /> <argument2 r d f : r e s o u r c e =  # winBid   /> </ i n d i v i d u a l P r o p e r t y A t o m> </ c o n j u n c t s > Applying the AC formalism for these compositional properties,
 to the auction house service speci cation, we have the following compositional ITL formula that is required to be validated while the auction is in progress.
(bidrec = winBid)) ; skip   2(bidrec = winBid))
 We focus on the AC properties of the buying service.
These are informally described below.
The compositional property of assumption for any bid received by the buying service, from the auction house, and the corresponding commitment by the buying service, can be formally expressed as,  i : 0 < i   k Asi Coi b= 2(bidrec = winBid) b= 2(((cid:13)bidi   bidi)   ((cid:13)bidi   bidrec)) We express the Assumption predicate in SWRL as below: <V a r i a b l e <V a r i a b l e <V a r i a b l e r d f : I D =  b i d   /> r d f : I D =  winBid   /> r d f : I D =  b i d r e c   /> <i n d i v i d u a l P r o p e r t y A t o m> <p r e f i x O p e r a t o r <p r o p e r t y P r e d i c a t e r d f : r e s o u r c e = & i t l ; Always   /> r d f : r e s o u r c e =  # isEQ   /> <argument1 r d f : r e s o u r c e =  # b i d r e c   /> <argument2 r d f : r e s o u r c e =  # winBid   /> </ i n d i v i d u a l P r o p e r t y A t o m> Analogous to the auction house service we apply the AC formal-ism,
 ((cid:13)bidi   bidrec)) ; skip   2(((cid:13)bidi   bidi)  ((cid:13)bidi   bidrec)))
 The auction house, buying service and selling service execute concurrently.
We simplify the scenario by considering composition only between the buying service and the auction house.
The environment of the overall composition, i.e As does not impose any constraints on the composition and defaults to true.
The proof obligations for services composed in parallel are recalled from Section 7.2.
Co2   As1, Co1   As2 The proof obligations for the auction service can now be speci ed as,  i : 0 < i   k, Coah   Asi Coi   Asah The validity of above proof obligations can be proved from Section 8.2 and 8.3.
An important area where compositional speci cations could provide valuable assistance is veri cation of service composition.
Traditional methods of verifying a composed system are noncomposi-tional and require a global examination of the entire system.
Approaches such as model checking also fail to scale up well since the global state space that has to be explored grows exponentially as components are added to the system.
However, application of these methods to verify the composition of web services is problematic because the actual binding between various components is dynamic and therefore there is no global system available a priori for applying these veri cation techniques.
Compositional veri cation, however, shifts the burden of veri cation from the global level to the local component level.
Hence global properties of the composition can be established by composing together independently veri ed component properties.
The assumption-commitment paradigm, a deductive (proof - theoretic) technique can be effectively applied as a compositional ver-i cation technique for Web services composition.
The idea is to prove the validity of the proof obligation for the composition using the assertional speci cation of each service in the network.
The veri cation can be undertaken at two stages during service composition: (a) At the design stage where decisions regarding which services can be composed are to be made.
Here the veri cation can be automated using a theorem prover;(b) At runtime, when services are actually wired with each other at the ports.
We are more interested in veri cations of the second kind.
The motivation for that stems from the fact that at runtime service composition can be in uenced by several factors like network conditions, synchronization and availability of individual services in the network.
Dynamic coordination can thus give rise to an emergent behaviour which may not be desired.
The purpose of veri cation at runtime is therefore to gauge such unwanted behaviour, that may lead to a  chaotic  composition.
Since the assertions we propose are temporal properties of services and their environment, the proof obligations for the speci cation of the composition have to be validated by an engine capable of handling temporal properties AnaTempura [2] (ref.
Fig 7) is a tool for the runtime veri cation of systems.
It is an interpreter for executable Interval Temporal Logic speci cations written in Tempura: a subset of ITL.
AnaTempura generates a state-by-state analysis of the system behaviour as the computation progresses.
At any state during the computation if the
 System to analyse Server Result Properties & Check Tempura Interpreter Figure 7: Runtime veri cation using Anatempura variable values cease to satisfy the Tempura formula, AnaTempura throws up an exception for that state.
For veri cation, the proof obligations that encode the temporal assertions are speci ed in Tempura.
At runtime, the assertions are validated, by passing the actual parameter values to the Tempura Program (ref.
Fig. 8) at the initial state and at each critical state de ned by the service provider.
AnaTempura validates the proof obligations at these states.
If the proof obligations cease to hold, it implies that some form of unwanted or chaotic behaviour has occurred.
This kind of veri cation serves two purposes: (a) It assists in identifying the errors in service description as the speci cation emerges from there.
Conventional ways of verifying compositions work at the implementation level using techniques like exception handling;(b) Third party arbitration services can use the mechanism for monitoring quality-of-service parameters.
This is because the veri cation mechanism still works at the interface level and therefore no implementation details are required.
We have developed a preliminary implementation of the auction example using this technique which is currently in the testing phase.
In this paper we provide the much needed theoretical background for applying compositionality to the domain of Semantic Web services.
We believe that both speci cation and veri cation should be highly compositional allowing modular validation and veri cation to be performed.
We have shown how Semantic Web service speci cations written as OWL ontologies, can be reinforced with temporal properties - Assumption and Commitment.
We have chosen OWLS as it has an inbuilt provision for accommodating logical formulae, which is missing in other languages.
We have argued that apart from state predicates ongoing assertions are also required to fully capture the behaviour of a service, speci ed as a black box.
We have shown how assumption and commitment can be speci ed for compositional reasoning about semantic Web service composition, using OWLS and SWRL.
We also show how the theory can be applied in practice to the composition of an auction service.
We have done a preliminary implementation of the auction service which will be presented in a future paper.
Little work has been done in the area of compositional speci cation and veri cation of services as revealed from the literature review done so far in the domain of semantic web services, both in academia and industry.
Semantics for the process model has been de ned by Narayan and McIlraith [20] using axioms in situation calculus, which are then mapped to Petri-net representation.
An alternative Concurrent Execution semantics for the same has also been proposed by Ankolekar et al [4].
However, these do not discuss compositionality and veri cation techniques that are impera-Figure 8: Framework for service composition using Anatempura tive while composing services on-the- y.
Several industrial efforts to create service composition standards like BPEL4WS [24] and WSCI [10] provide syntactical means of describing and composing services.
They however, lack the formal framework needed for veri cation of services composed using such speci cations.
As part of our future goal, we aim to build a pre-processor (ref.
Fig. 8) that converts assumption - commitment speci cation within an OWLS ontology into executable Tempura speci cation.
The tool would be part of a larger framework for service composition.
We have already designed the framework for the implementation of such a tool.
We also plan to extend our work on veri cation of services using AnaTempura.
