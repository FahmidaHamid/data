The semantic Web [3] is an extension of the World Wide Web in which both data and its semantic de nition can be processed by computer programs.
The next generation of the Web will combine existing Web technologies with knowledge representation for-malisms in order to provide an infrastructure allowing data to be processed, discovered and  ltered more effectively on the Web.
A set of new languages organized in a layered architecture will allow users and applications to write and share information in a machine-readable way, and will enable the development of a new generation of technologies and toolkits.
In the semantic Web architecture, Web ontology languages are built on top of RDF(S).
However, serious dif culties have arisen when trying to layer expressive ontology languages, like OWL, on top of RDF-Schema [10][17].
Although these problems can  The author also works at the Institute of Robotics, Department of Computer Science, University of Valencia (Spain) Copyright is held by the author/owner(s).
be avoided, OWL (and the whole semantic Web architecture) becomes much more complex than it should be.
In this paper, a possible simpli cation of the semantic Web architecture is suggested.
The paper is organized as follows: Section 2 reviews the main features of RDF(S) model theory and of standard description logics formalisms.
In Section 3 the main design principles followed in the design of the semantic Web languages are enumerated.
Section
 summarizes other proposals for layering the semantic Web.
Finally, in Section 6, a possible simpli cation of the semantic Web layering is suggested and its main features and advantages are discussed.
RDF [6] and RDF-Schema [4][6] are at the base of the semantic Web.
All the languages in the upper layers are built on top of them.
RDF(S) de nes both the syntax and semantics of the subsequent layers.
However, RDF(S) is built upon a nonstandard thesis of representation [9].
The syntactic and semantic characterization underlying RDF(S) differ signi cantly from the syntax and semantics of most  rst-order logical languages [10].
The syntax of RDF is based on triples, atomic chunks of information composed of three different elements < S, P, O >.
Each RDF triple:   Is composed of a subject, a property and an object   Represents a single fact, with a well-de ned meaning   Is the minimum piece of knowledge that can be represented in RDF Every RDF(S) document is equivalent to an (unordered) set of triples.
However, although all these triples appear together in the document, each one is given a meaning, which is independent of the meaning of other triples.
RDF has a very limited set of syntactic constructs.
No other syntactic construct except for triples is allowed, neither in RDF(S), nor in the remaining languages of the semantic Web architecture.
Moreover, the meaning of the triple syntax must be retained in higher layers, i.e. all the triples in RDF are assigned the same basic meaning.
Richer languages are not allowed to modify this basic meaning and can only re ne it.
RDF has been given a model-theoretic semantics, which provides formal meaning to its abstract syntax [6].
All the interpretations in RDF(S) model theory are relative to a set of names (URIrefs), called the vocabulary of the interpretation.
An RDF(S) interpretation is de ned as a tuple I = {IR, IP, IEXT, IS, IL, LV }, composed of three sets and three mappings:
   IR is a nonempty set, called the domain of the interpretation   IP   IR is the set of properties.
  LV   IR is the set of literal values   Mappings   IEXT is a mapping IEXT : IP   IR   IR from IP into the set of pairs < x, y >, with x, y   IR   IS is a mapping IS : U RIref s in V   IR   IL is a mapping from typed literals in V into IR In RDF model theory all resources (individuals, classes, properties, and even the language primitives) are elements of the domain of the interpretation.
The function IS maps every name (URI) of the vocabulary to an element of the domain.
All the names of a RDF vocabulary, even the names contained in the reserved vocabulary (language primitives) can appear at any position of a triple.
This means that triples like: rdf : type rdf : type rdf : P roperty.
rdf s : range rdf s : domain rdf : P roperty.
rdf s : Class rdf : type rdf s : Class.
are allowed in RDF(S).
These triples, composed of language primitives, de ne the metamodeling architecture of RDF(S), and can lead to unwanted consequences, especially when layering more expressive languages like OWL on top of RDF(S) [15].
In RDF(S) all the names are mapped to a resource using IS.
Thus, a resource is de ned in RDF(S) as everything that has an identity, i.e, everything that can be referred to by a URI.
Names that occur in a RDF document in a property position of any triple are mapped by IS to a special subset of IR, called IP.
The elements of IP are then mapped to a set of ordered pairs of elements of the domain by the function IEXT.
The set of ordered pairs corresponding to a property resource form the extension of the property.
RDF(S) semantics distinguishes objects from their extensions.
Objects representing individuals are de ned to have empty extensions.
Property objects are  special  in RDF because they have nonempty extensions.
Class primitives are not fundamental primitives in RDF(S).
The extension of a resource representing a class is de ned through the property extension of IS(rdf:type) The distinction between objects and their extensions allows for a certain  syntactic freedom  in RDF(S):   The extension of a resource can contain the resource itself without violating the axioms of set theory.
The extensions of a resource is a set that, although it contains the resource, it does not contain itself.
  Two properties or two classes can have the same instances and still be different entities.
In the case of ordinary sets, equality is de ned through the principle of extensionality: two sets are equal in axiomatic set theory iff they contain the same elements.
However, there are three main nonstandard features in the  free  syntax of RDF:   The resources representing the language primitives can appear at any position inside a triple   There is no separation of vocabularies.
Classes, properties and individuals do not form disjoint collections in RDF(S).
Therefore, the same element of a vocabulary can be used to denote, for example, a class and an individual, or even a class, a property and an individual at the same time   Self-referential syntactic constructs are allowed RDF and RDF-Schema are at the basis of the semantic Web.
All the languages in the upper layers have been designed to use the triple syntax in all their constructs, and to extend the meaning assigned to triples by RDF model theory adding new semantic conditions to interpretations.
Description logics (DL) [2][12] are a set of knowledge representation formalisms, whose semantic characterization is based on standard  rst-order logics.
Meaning is provided by interpretations, which de ne the formal semantics of the logic.
An interpretation in DL is a mathematical structure I = { I , .I} consisting of:   A nonempty set  I, called the domain of the interpretation.
The domain is divided into two disjoint sets:   The abstract domain is the set of all the individuals   The concrete domain is composed of data values and is used to integrate datatypes in description logics   An interpretation function .I that maps:   Every concept (class) name to a subset of  I   Every role (property) name to a subset of  I    I   Every individual to an element of  I The interpretation function can be extended to complex concepts and roles and can be used to provide meaning to axioms in the knowledge base.
OWL semantics is based on DL, so that an OWL ontology corresponds to a DL knowledge base.
However, standard DL semantics differs signi cantly from the semantics of RDF(S).
The main differences between both formalisms, which make RDF(S) model theory nonstandard, are the following: [9]   The interpretation function maps individual names to elements of the domain.
Names used in other ways do not denote an element of the domain.
Class and property names are not mapped to resources: they are directly mapped to sets of resources and sets of ordered pairs of resources respectively.
In DL, a resource is no longer  everything that can be referred to by a URI : Only objects are considered as part of the domain.
Consequently, elements of the domain in DL do not have extensions, as in RDF(S)   In DL, class primitives are as fundamental as property primitives.
Classes are not de ned in terms of properties, as in RDF(S).
In RDF(S) all the semantic relationships are reducible to properties.
  In RDF(S), the type membership and the subclass relationships are not distinguished from other predicates, and can occur at any position in RDF triples (i.e., they can be arguments for other predicates).
As a consequence, the special meaning of these predicates must be expressed explicitly through axioms.
For example, in order to make rdfs:subClassOf transitive, the axiom:
 subClassOf (y, z)   rdf s : subClassOf (x, z) must be added to the RDF(S) model theory [9].
This axiom-atization works well for RDFS, but has serious consequences when trying to extend it to OWL.
In OWL, new axioms are required to specify the meaning of new constructs, like value or cardinality restrictions, which makes the axiomatization very complex to handle and understand.
In DL, however, the meaning of these relationships is embedded in the formalism: the  type  relationship is unambiguously de ned as  instance of , while the  subclass  predicate is interpreted as  subset of .
Hence, no axiomatization is required.
  In DL, the vocabulary to which the interpretation refers is divided into disjoint sets.
This means, for example, that classes cannot be properties or objects at the same time.
In RDF(S), however, a resource can be both an individual and a class or even an individual, a class and a property


 The semantic Web has been designed according to the following principles [6] [16]:   A resource is considered to be everything that has an identity, i.e., everything that can be referred to with a URI   RDF and RDF-Schema semantics is largely based on SKIF semantics, a nonstandard logical representation formalism   RDF(S) syntax is based on triples, and the way names of different kinds are introduced in those triples is rather free   Every piece of knowledge representable in a semantic Web document should be written (or translated) to triples   All the triples share a common basic meaning.
A document is an unordered set of triples and the meaning of each triple is independent from the others.
Triples containing  special  URIrefs are given an extra meaning by adding semantic constraints to the interpretations whose vocabulary contains that particular URI   All semantic Web languages are forced to use RDF syntax only, and the meaning of RDF triples in all semantic Web languages must be compatible with the meaning given to them in RDFS Model Theory   The semantics of the languages of the ontology layer is based on very expressive description logics (standard FOL formal-ism)


 Serious dif culties have arisen when trying to layer expressive ontology languages, like OWL on top of RDF(S) using these design premises.
Languages based on very expressive DLs include powerful modeling primitives like concept constructors, restrictions and complex axioms.
OWL richer theory of classes clashes with the underlying principles of RDF(S) in the same syntax and extended semantics layering [17][10][15].
Semantic integration problems arise when trying to make compatible the semantics derived from very expressive DLs with the triple syntax and the semantics already associated to those triples by RDF(S) model theory.
Although these semantic problems and paradoxes can be avoided, OWL becomes consequently much more complex than it should be.
Nonstandard techniques (like the de nition of comprehension principles [16]) must be used in order to make the DL semantics compatible with the RDF(S) semantics resulting from the translation of OWL to triples [16].
Ontology Working Group OWL combines features from different representation languages:   Its semantics is largely based on very expressive description logics   Its modeling syntax and surface structure have been in u-enced by frame-based systems   OWL has been designed to keep the maximum upward compatibility with RDF and RDF-Schema in both syntax and semantics The multiple in uences underlying OWL speci cation led to many dif cult trade-offs.
It has been especially con ictive to bring together satisfactorily the  rst and the third features.
The W3C Web Ontology working group decided to:   Provide OWL with a RDF-based syntax.
This means that any OWL ontology can be written as a RDF graph, made of triples   Ensure that the semantics of OWL ontologies is consistent with the semantics of RDF.
This particular requirement implies two conditions:   On one hand, any OWL ontology written in abstract syntax notation is given a direct DL-like model-theoretic semantics; on the other hand, the same ontology can be written in terms of RDF triples and is assigned a RDF-compatible model-theoretic semantics.
Both encodings of the same ontology must be semantically equivalent.
As RDF triples have RDF meaning, this meaning together with the special conditions added to OWL interpretations in the OWL RDF-compatible semantics must be equivalent to the meaning assigned to the ontology by the direct model-theoretic semantics   If OWL is designed as a semantic extension of RDF(S), then any RDF(S) document must be a valid OWL ontology.
In other words, the free syntax of RDF(S) and its corresponding semantics is  exported  to OWL.
This means, for example, that it would be possible to add number restrictions to the  subClassOf  relationship, because this relationship is considered syntactically as an  ordinary  property and can be used as the subject of RDF triples.
These kinds of assertions provide the language with an expressive power that goes beyond standard description logics semantics It was proved to be insurmountably dif cult to de ne OWL as a true  same syntax, semantic extension  of RDF(S), while keeping the reasoning services (OWL entailment) decidable.
The Web Ontology working group de ned three sublanguages of OWL [16], each of which satis es most (but not all) the requirements:
 RDF(S) so that all RDF graphs are allowed.
As a consequence, its semantics is beyond the standard DL framework and the language happens to be undecidable.
Moreover, it has yet to be proved that the RDF MT compatible semantics for OWL Full gives a coherent meaning to OWL Full.
  In OWL-DL and OWL-Lite, however, some constraints are applied in order to keep the language in a standard DL framework, and to keep the decidability of the reasoning services [16][10]:   Only certain RDF triples and certain combinations of those triples are allowed.
  The vocabulary of the interpretations is divided into disjoint sets, so that the same URI cannot be used, for example, as an individual and a property name at the same time.
  An abstract syntax is de ned for the language, so that OWL-Lite and OWL-DL can be de ned as the subset of RDF graphs generated by the translation of their respective abstract syntaxes to triples.
With these restrictions, the direct model-theoretic and the RDF-complatible semantics for OWL-DL and OWL-Lite are equivalent (OWL-full has neither a direct model-theoretic semantics, nor an abstract syntax).
In the author s opinion this layering of OWL on top of RDF(S) is not truly satisfactory, for several reasons:
 ogy layer (e.g.
rules languages) will probably not be layered on top of OWL Full.
OWL Full is too expressive (namely undecidable), and its semantic formalization is rather complex, cumbersome and nonstandard.
As a result, OWL Full happens to be both dif cult to implement and to understand and it is foreseeable that it won t be integrated in many applications.
Consequently, OWL-full is not the best language to stay at the basis of future and probably more expressive semantic Web languages.
[16][10] description logic.
Although OWL-DL is decidable, the entailment problem is computationally intractable in the worst-case.
Currently there exists no  practical  (easy to implement and with a good computational behavior in average) reasoning algorithm to solve the satis ability problem for the (whole) SHOIN(D) logic.
The design of ef -cient tableau-based reasoning algorithms, combining nomi-nals, inverse roles, number restrictions, transitive roles and role hierarchies remains an open problem in description log-ics.
Therefore, the only OWL sublanguage that could be easily implemented and optimized happens to be OWL-Lite.
(Ontology Inference Layer) the different sublanguages were layered according exclusively to their expressive power, in OWL there are two different kinds of layering criteria:   The relationship between OWL-Lite and OWL-DL is similar to the relationship between OIL dialects: OWL-DL is more expressive than OWL-Lite and they both share the same underlying semantic formalism   The relationship between OWL-DL and OWL-Full is far more complex and unclear
 semantic Web forces OWL speci cations to be far more complex than they would be otherwise (e.g.
comprehension prin-ciples)
 the semantics of the semantic Web languages.
RDF and RDF-Schema are largely (but not completely) based on the SKIF semantics [7][9], while OWL has been given a standard description logics (direct) model-theoretic semantics.
The compatibility requirements between both formalisms force the semantic Web to be complex and dif cult to understand


 The current layering of OWL on top of RDF(S) has been considered by several authors [17][9][15] to be rather unclear and non-satisfactory.
Other approaches for layering the semantic Web have been recently suggested.
There are mainly two ways to improve the layering of the semantic Web:
 to leave the RDF(S) speci cations unaltered.
This approach is based on the idea that some decisions made during the early development of OWL and, in general, of the semantic Web layer cake, have proved to be bad design decisions up to a certain extent.
Particularly, in the semantic Web architecture, all the languages are forced to use RDF syntax so that they are not allowed, either to extend it, or to change the basic meaning assigned to triples by RDF(S) model theory.
them more compatible with the underlying description log-ics formalism of OWL-DL.
In the semantic Web two different formalisms have been used to de ne the semantics of the languages; RDF(S) is based on an unusual model-theoretic semantics, while OWL (direct) model-theoretic semantics is based on standard description logics.
The layering of the semantic Web could be made clearer and simpler if the whole semantic Web architecture was based on a standard  rst order logic formalism.
Syntax and semantic extension In this approach, both the syntax and semantics of OWL are de- ned to be an extension of RDF(S) syntax and semantics respectively [17].
This solution is based on the idea that most of the problems and semantic paradoxes that occur when trying to layer OWL on top of RDF(S) in the  same-syntax, semantic extension  approach could be easily avoided if some of the OWL syntactic constructs (e.g.
restrictions) could be written using non RDF/XML syntax.
If some  con ictive  constructs of OWL are not translated to triples, then these constructs wouldn t be given a RDF meaning and their semantics would be completely de ned by the OWL model theory.
In this proposed layering, each new language would share a common syntactic and semantic core with RDF, but would be allowed to include new syntactic constructs and to de ne their meaning.
RDFS(FA) (RDF-Schema Fixed Layer Metamodeling Architecture) [13][15][14] is a sublanguage of RDF-Schema, which has been assigned a (quite) standard description logics semantics.
The main design goal of RDFS(FA) has been to de ne a language for the schema layer with both a standard  rst-order logic semantics and a clear metamodeling architecture.
Moreover, the designers of RDFS(FA) have tried to minimize the changes made to RDFS in order to achieve a maximum reuse of existing RDFS documents and tools.
An interpretation in RDFS(FA) is a pair I = {IR, IE} where IR is the domain and IE the interpretation function.
In RDFS(FA) interpretations, the universe of discourse is divided into four several strata or layers, so that each individual, user-de ned class or property, and each language primitive are mapped into a certain stratum of the interpretation domain.
ual name in the vocabulary is mapped to an element of the domain corresponding to this layer
 (user-de ned classes) and sets of ordered pairs of objects (user-de ned properties).
tologies
 layer The ontology and the instance strata de ne the modeling capabilities of the language, while the two upper layers de ne its meta-modeling architecture.
It is not the purpose of this paper to analyze in detail the spec-i cation of RDFS(FA).
A full discussion of the language can be found in [13][15][14].
Nevertheless, as the simpli cation of the semantic Web architecture suggested in this paper is largely based on the RDFS(FA) approach, it is particularly interesting to discuss the main similarities and differences between RDFS(FA) and both RDF(S) model theory and standard description logics formalism.
Although RDFS(FA) has been designed with the purpose of introducing as few changes as possible in the speci cation of RDF-Schema, the semantic characterization of RDFS(FA) alters significantly some of the basic assumptions of RDF(S) model theory.
RDFS(FA) not only simpli es the metamodeling architecture of RDF(S), but also changes the very basics of RDF(S) data model and formal semantics.
In this section, we will consider separately the new features introduced in RDFS(FA).
First of all, we will consider the changes introduced in the basics of RDF(S) model theory and then the consequent simpli cation of the metamodeling architecture of the language will be analyzed.
With respect to the basics of the data model and formal semantics, there are several important differences between RDF(S) and

 tations is partitioned into disjoint sets, as in OWL-DL.
As a consequence of this particular design decision, the free syntax of RDF(S) is explicitly constrained in the RDFS(FA) speci cation.
The set of RDFS(FA) graphs can be mapped to a subset of RDF(S) graphs; however, not every valid RDF(S) graph can be mapped to a syntactically correct RDFS(FA) graph.
The constraints introduced by RDFS(FA) do alter sig-ni cantly the syntax and data model of RDF(S) in several important ways:   If a URI is used in a property position inside a triple, it cannot be used in the subject position of another triple.
The same URI cannot be used at the same time as a class, property or individual   Self-referential constructs are suppressed in RDFS(FA)
 erty or class symbols to sets of pairs of elements and sets of elements respectively.
In RDFS(FA) class and property primitives are fundamental primitives.
Classes and properties are not objects of the domain: they are mapped directly to sets of resources and to sets of pairs of resources respectively in the adjacent lower stratum.
In RDF model theory, classes and properties are  rst mapped via IS to objects in the domain and then mapped by either ICEXT or IEXT to their extensions.
Thus, in RDFS(FA) a class or property is not different from its extension.
Consequently, the principle of extensionality in set theory applies in a standard way, i.e., two classes are equal if and only if they contain exactly the same instances (in RDF(S) two classes and properties with identical extensions could be mapped vis IS to different objects in the domain)
 be used to link resources belonging to different layers.
Specifically, a  property  can only be used in RDFS(FA) to state that an element or a set belonging to a certain layer is a member of a set in the adjacent upper layer
 i cation of RDFS(FA).
In RDF(S) all the triples share a common basic meaning.
Triples containing certain language primitives are assigned an extended meaning through the addition of semantic constraints to interpretations.
However, in RDFS(FA), as in DL, each triple is given a particular meaning depending on the kind of URIs included in it.
There is no basic shared meaning between all the valid triples of the data model.
With respect to the language primitives and their relationships, RDFS(FA) simpli es the metamodeling of RDF(S) suppressing some of its most confusing aspects.
Note that some of the features of RDFS(FA) metamodeling architecture arise as a direct consequence of the general design decisions of the language, discussed above.
  RDFS(FA) disallows the arbitrary use of builtin language primitives, i.e. some of the (metamodeling) triples containing two or more language primitives that were valid in RDF(S) have been suppressed in RDFS(FA).
The metamodeling architecture in RDF(S) is thus much richer than in RDFS(FA)   A language primitive in RDF(S) might correspond to several language primitives in RDFS(FA) (contained in different strata).
  Language primitives are not instances of themselves   As in RDF-Schema, the language primitives are interpreted either as classes or as properties, but:
 are mapped directly into sets of resources in stratum  i-
  Language primitives interpreted as properties are also mapped directly into sets of resources in the adjacent lower stratum The relationships among different language primitives are de ned in such a way that that language primitives can only be linked with other primitives layered in a different stratum using an  instance of  (type) relationship.
RDFS(FA) semantics is largely embedded in a standard description logics framework.
RDFS(FA) semantics has been conceived to be compatible with OWL-DL and OWL-Lite direct model-theoretic semantics.
However, there are two important features in which RDFS(FA) and OWL differ:
 from standard description logics.
In RDFS(FA) interpretations not only sets of objects and pairs of objects are considered, but also sets of sets of objects and sets of sets of pairs of objects, etc.
each other as in RDFS(FA).
OWL does not have a metamod-eling architecture where the language primitives are treated as meta-classes and meta-properties respectively.
The use of RDFS(FA) instead of RDF(S) implies several important advantages.
First, OWL can be much more easily layered on top of RDFS(FA) than on top of RDF(S).
If RDFS were replaced by RDFS(FA) the semantics of OWL could be greatly simpli ed.
Second, the organization of the semantic Web architecture would become clearer as a whole; all the languages of the semantic Web would be based on a single, clear standard formalism.
The price to pay when replacing RDF(S) by RDFS(FA) is a loss of expressive power.
RDFS(FA) is less expressive than RDF-Schema.
The layering suggested in this paper is largely based on the RDFS (FA) approach, but represents a further simpli cation of RDFS(FA), in the same way as RDFS(FA) can be seen as a restricted sublan-guage of RDF-Schema.
The solution discussed here is motivated by the following ideas:
 layer of the semantic Web, the RDF syntactic and semantic speci cations should also be modi ed.
RDFS(FA) cannot be easily layered on top of RDF, given the way both RDFS(FA) and RDF have been designed.
In order to properly layer RDFS(FA) on top of the metadata layer, a sublanguage of RDF must be de ned
 provides additional expressive power to RDFS(FA).
In the way RDFS(FA) has been speci ed, there is no plausible reason, apart from the (apparent) compatibility with RDFS, to de ne a metamodeling architecture for the language.
Meta-modeling doesn t seem to enhance the inference capabilities of the language.
As far as we know no  interesting  entail-ments have been suggested as a proof of the utility of the metamodeling structure of RDFS(FA).
Moreover it is also unclear:   What kind of reasoning algorithms could be de ned for
   If standard DL reasoning algorithms are used, how meta-modeling could be integrated in the algorithms to provide new interesting inference capabilities
 and scope.
The main difference between both layers is the semantic formalism they are based on.
In the current semantic Web, RDF-Schema can be considered, both as a simple ontology language, and as a bridge between RDF and the ontology layer.
However, in the layering suggested in this paper, there is no plausible reason for the schema layer to exist.
The methodology followed in this paper is composed of the following steps:
 and its correspondence to a simple description logic is estab-lished
 without a signi cant loss of expressivity
 architecture and the language RDFS(DL) is promoted to the ontology layer as the simplest ontology language for the semantic Web
 portant ways:   OWL-Full is suppressed   OWL-Lite is layered on top of RDFS(DL)
 then layered on top of it
 RDF-Schema(DL) is a sublanguage of RDFS(FA) where:   The relationships between language primitives have been suppressed   Its semantics covers the strata 0 and 1 and the language itself exists in stratum 2   The language primitives are not strati ed into different strata of the language.
This implies that there are no different  versions  of the same modeling primitive in different strata.
RDF-Schema(DL) is the result of suppressing the metamodel-ing architecture of RDFS(FA).
This design decision is motivated by the fact that metamodeling in RDFS(FA) doesn t seem to increase the expressivity and the inference capabilities of the language.
Metamodeling in RDFS(FA) can be thought as a way to
 ever, the fundamental assumptions of RDFS(FA), like the explicit division of vocabularies and the constraints applied to the free syntax of RDF(S) do change the language completely.
In this new framework, metamodeling reveals itself as a rather  arti cial  feature of the language.
In this particular sense, RDFS(DL) is clearer than RDFS(FA).
RDFS(DL) Syntax and Semantics A RDFS(DL) vocabulary V is a set of URIrefs (a vocabulary) composed of the following disjoint sets:   VC is the set of concept (class) names   VD is the set of datatype names   VRA is the set of (object) property names   VRD is the set of datatype property names   VI is the set of individual names As in RDF, a datatype  d  is de ned by two sets and one mapping: L(d) (lexical space), V(d) (value space) and L2V(d) the mapping from the lexical space to the value space.
In this context a datatype theory T is a partial mapping from URIrefs to datatypes.
A RDF-Schema(DL) interpretation with respect to T with vocabulary VC , VD, VRA, VRD, VI is a tuple I = {R, EC, ER, L, S, LV } where:   R is a nonempty set representing the (abstract) domain of I   LV   R is the distinguished subset representing the literal values of I   EC: VC   P (O), and VD   P (LV ) is a mapping from class names in the vocabulary to subsets of the abstract domain and from datatype names in the vocabulary to subsets of the datatype domain LV.
  ER maps object property names to a set of ordered pairs of elements in the abstract domain VRA   P (O   O) and datatype property names to ordered pairs, whose  rst element is a member of the abstract domain, and whose second component is a datatype value VRD   P (O   LV )   L maps typed literals to elements of the datatype domain L : T L   LV .
Let T be a datatype theory, d a datatype and d  a datatype name (a URIref), then:   If T (d0) = d then EC(d0) = V (d)   LV   If T (d0) = d then L(0v0, d0)   V (d), where  v  is a string   If T (d0) = d and v   L(d) then L(v, d0) = L2V (d)(v), where v is a string   If T (d0) = d and v   L(d) then L(v, d0)   R   V (d)   S maps individual names to objects in the abstract domain of the interpretation.
S : VI   O The abstract syntax and semantics of RDFS(DL) are summarized in Tables 1 and 2.
SubClassOf (A1 A2)
 ObjectProperty(R) dom(A1) ... dom (Am) range(A1) ... range(An) subP ropertyOf (R1R2) DatatypeProperty(U) dom(D1) ... dom (Dm) range(D1) ... rangle(Dn) subP ropertyOf (U1U2)
 Individual(o type(C1)...type(Cn) value(R1o1)...value(Rnon) value(U1v1)...value(Unvn)
 A1 v A2





   1R v Ai, ER(R)   EC(Ai)   R  i   [1, n] > v  R.Ai ER(R)   R   EC(Ai)
 R1 v R2



   1R v Di, ER(U )   EC(Di)   R  i   [1, n] > v  U.Di ER(U )   R   EC(Di) U1 v U2

 S(o)   EC(Ci) [S(o), S(oi)]   ER(Ri) [S(o), S(vi)]   ER(Ui) o   Ci [o, oi]  
 [o, vi]   EC(Ui) Table 1: RDFS(DL) Axioms

 A (URIref) owl:Thing
 > d 

 o d
 (None)
 (None)
 d  (URIref)
 R (URIref)
 U (URIref)
 o (URIref) DATA VALUES (d) d (Literal)

 EC(owl : T hing)
 EC(d0) = V (d)


 oI   R S(d)   LV Table 2: RDFS(DL) semantics
 The core reasoning service in the semantic Web languages is entailment.
We say that a RDFS(DL) (or an OWL) ontology O1 entails O2 if and only if all the interpretations that satisfy O1 also satisfy O2.
However, entailment is not a standard DL reasoning service.
The standard DL tableaux-based and structural reasoning algorithms have been conceived to solve the subsumption and the satis ability problems.
DL inference algorithms do not directly deal with ontology entailment.
Therefore, in order to use these algorithms for reasoning in the semantic Web languages, entailment has to be reduced to DL knowledge base satis ability [8].
In [8], it was shown that both ontology entailment in OWL-DL and OWL-Lite can be reduced to the knowledge base satis ability problem in the SHOIN(D) and SHIF(D) logics respectively.
Unfortunately, a similar reduction cannot be accomplished for RDFS(DL) entailment.
A RDFS(DL) ontology is composed of a set of concept inclusion axioms A v B, a set of role inclusion axioms R v S, a set of datatype role inclusion axioms U v V and a set of facts, where A,B are atomic concepts, R and S atomic roles, U and V datatype properties and where cycles might occur in the terminology.
Let O1 and O2 be two RDFS(DL) ontologies and assume we want to check if O1 entails O2.
It can be shown that O1 entails O2 if and only if O1 entails every axiom Aj in O2.
Then [8]:   If Aj is of the form A v B, entailment checking is equivalent to checking the unsatis ability of O1   {(A u  B)}.
Therefore, in order to reduce entailment to satis ability for this kind of axioms, RDFS(DL) should include atomic negation   If Aj is of the form R v S, then entailment checking is equivalent to verify the unsatis ability of: O1   {(B u  R( S . B)} where B is a new atomic concept and S  is the inverse role of S. Thus, in order to reduce entailment to satis ability for these axioms RDFS(DL) should include full existential restrictions, value restrictions, concept negation and role inversion   If Aj is a fact, then RDFS(DL) would need to include negation and value restrictions   If Aj is a datatype role inclusion axiom, then nominals would be required in order to reduce entailment to satis ability.
It is worth pointing out here that this speci c aspect, which would also affect the reduction of OWL-Lite entailment, is not considered in [8] when dealing with OWL-Lite.
In that case, OWL-Lite entailment would be reduced to SHOIF(D) KB satis ability (not to SHIF(D)).
Therefore, if datatype role inclusions are considered, the logics corresponding to OWL-Lite does not differ signi cantly from SHOIN(D).
In that case, there would be, for example, no reason to avoid nomi-nals ( one-of  constructor) in OWL-Lite and, most importat, there would be no plausible reason for OWL-Lite to exist separately from OWL-DL .
Hence, the following aspects should be considered for RDFS(DL) (and also for RDFS(FA)!
):   If entailment is taken as the core reasoning service then, in order to use standard DL reasoning algorithms for RDFS(DL), the language would need to be extended up to the ALCHOI logic, which is computationally intractable in the worst case.
  If entailment is taken as the main reasoning service, then new DL algorithms could be designed for solving directly the entailment problem.
These algorithms might have polynomial complexity (RDFS(DL) does not contain restrictions and concept union, which are considered as the main sources of complexity)   If satis ability or subsumption of concepts with respect to a knowledge base are considered as the core inference services, then standard DL algorithms could be used to reason in RDFS(DL)   The main source of complexity in RDFS(DL) is the role hierarchy.
The possibility of replacing the role hierarchy by other constructors could be reconsidered.
If, for example, RDFS(DL) is made equivalent to the ALC description log-ics and if the concept inclusion axioms are constrained to be acyclic, then entailment could be reduced to knowledge base satis ability, which is in PSPACE under these speci c conditions.
This would make possible to have a polynomial logic in the bottom of the ontology layer and to use standard tableaux-based reasoning algorithms.
Instead of using tableaux-based algorithms, an interesting approach for reasoning in RDFS(DL) would be to use logic programming (LP) inference engines.
RDFS(DL) can be mapped to equality-free Datalog Horn Logic [5] (the logical language composed of Horn rules not including, either functions with arity greater than zero, nor the equality predicate) .
In [5] the equality-free Datalog LP (def-LP) is also de ned.
The difference between this logic and the equality-free Datalog Horn Logic (def-Horn) is subtle, but important.
The entailments in def-LP are limited to facts, while in def-Horn also rules can be entailed.
Therefore, def-LP is a subset of def-Horn.
In return to this loss of expressivity, the inference happens to be polynomial in the worst case.
However, RDFS(DL) must be mapped to def-Horn and not to def-LP, because the entailments de ned in RDFS(DL) are not restricted to simple facts.
RDFS(DL) is de ned as a subset of both OWL-Lite and OWL-DL, and is equivalent to a simple (though non-conventional) DL.
Instead of replacing RDF-Schema by RDFS(DL) in the schema layer, it is suggested in this paper to promote RDFS(DL) to the ontology layer and then suppress the schema layer from the semantic Web tower.
In this context, the layering of OWL becomes similar to the layering of OIL.
In this new framework, all the OWL dialects correspond to a particular description logic.
OWL-Lite is de ned as a subset of OWL-DL and RDFS(DL) as a subset of OWL-Lite.
The semantic Web developer could choose one of these languages for creating an ontology depending on the expressive power required by his/her application.
In this layering framework, RDFS(DL) would be layered directly on top of the metadata layer and both the remaining layers (like the rule level) and other OWL extensions would be based on OWL-DL.
RDFS(DL) cannot be de ned as an extension of RDF, in the way RDF has been speci ed.
RDF allows the programmer to use a free syntax, so that:   A resource can appear both in a subject/object or in a property position.
  A URI belonging to RDF reserved vocabulary can appear as the subject of a RDF triple
 We suggest a sublanguage of RDF, called RDF(DL), based on a standard model-theoretic semantics.
In order to carry out this task vocabularies in RDF are divided into three different parts, namely classes, properties and individuals.
The domain of RDF(DL) interpretations is the set of all individuals, like in DL.
A RDF vocabulary V consists of  ve disjoint sets of URI references, VC, VD, VI, VRA and VRD, where:   VC is the set of concept (class) names   VD is the set of datatype names   VRA is the set of (object) property names   VRD is the set of datatype property names   VI is the set of individual names The syntax of RDF(DL) is also based on triples, but some constraints are introduced so that the way triples can be written is no longer completely free.
In RDF(DL) close attention must be paid to which names belong to which part of the RDF vocabulary.
  Class URI references can only appear in the object position of the triples where rdf:type appears in the property position   URIrefs belonging either to VRA or to VRD can only appear in property positions   Individuals (names in VI) can appear both in subject and object positions, but never in property positions.
  Literal values can only appear at the object position of triples where an element of VRD appears in the property position In RDF(DL) four different kinds of assertions can be used:   An assertion of the form C(a), where C is a class name and  a  an object name, states that  a  is an instance of C and is mapped to the triple [a rdf:type C]   An assertion of the form R(a,b), where R is an object property name and a,b are object names states that the objects denoted by a,b are linked by the role denoted by R and is mapped to the triples [a R b] and [R rdf:type rdf:ObjectProperty]   An assertion of the form U(v), where U is a datatype name and  v  a literal state that the value v belongs to the datatype U and is mapped to [v rdf:type D]   An assertion of the form U(a,v), where U is an datatype property name, a is an object name and v is a literal state that the object denoted by a is linked by the role denoted by U to the data value denoted by v. The assertion would be mapped to [a U v] and [U rdf:type rdf:DatatypeProperty] Only the triples resulting of this mapping are given a model-theoretic semantics in RDF(DL).
{IR, LV, .I} where, A RDF(DL) interpretation of a vocabulary V is a tuple I =   IR is a nonempty set called the domain of the interpretation   LV   IR is a distinguished subset of IR   .I is a function that:   It maps every individual name  o  to an element of IR oI   IR   It maps every object property name R to RI   IR IR   It maps every datatype property name U to U I   IR 
   It maps every class name C to C I   IR A rdf interpretation satis es:   The assertion C(a) if aI   C I   The assertion R(a,b) if < aI , bI >  RI   The assertion D(v) if vI   DI   The assertion U(a,v) if < aI , vI >  U I An RDF(DL) interpretation satis es a RDF(DL) graph if and only if it satis es all the assertions in the graph.
What have we achieved?
First, and most important the layering of the semantic Web has become clearer, easier to understand and formalize.
The layering of OWL dialects is now analogous to the organization of OIL dialects.
In this approach the ontology layer is composed of three different languages:




 These languages are organized according to their expressivity: OWL-DL, the most expressive language, is equivalent to the SHOIN(D) description logic.
Satis ability checking for this logic is known to be NEXP-TIME complete.
No  practical  tableau-based reasoning algorithm for this logic has been developed yet.
OWL-Lite provides enough expressive power for most applications and its abstract syntax can be mapped to the SHIF(D) description logic.
Reasoning services, though intractable in the worst-case, can be implemented ef ciently using highly-optimized algorithms that work fairly well in average for most applications and use cases.
Finally, RDFS(DL) stays at the bottom of the ontology layer.
Although its expressive power is rather limited it can still be useful for many applications.
In this framework, the semantics of OWL-DL and OWL-Lite would be greatly simpli ed: only a direct model-theoretic semantics would be required.
On the other hand, the schema layer is suggested to be suppressed from the semantic Web layer cake.
Two main reasons support this suggestion:   The schema layer has always been dif cult to understand and formalize.
  The semantic speci cation of RDF(S) requires nonstandard model-theoretic semantics and has nonstandard metamod-eling architecture, which make the language dif cult to understand, implement and formalize.
Its aims and scope have never been clearly distinguished from those of the ontology layer RDF-Schema can be conceived both as a simple ontology language and as a  bridge  between the metadata and the ontology layers.
However, its motivation has not been properly justi ed and supported.
There is no clear difference between the motivations and
 ways been considered in practice as a simple ontology language which shares many features with OWL.
The only important difference between RDF-Schema and OWL happens to be the underlying semantic characterization.
While OWL-Lite and OWL-DL are based on very expressive description logics, RDF-Schema has nonstandard model-theoretic semantics.
In this approach, the metadata and the ontology layers share a standard description logics semantics, with RDF(DL) corresponding to an assertional (ABox) formalism, while OWL and RDFS(DL) would correspond to a terminological (TBox) language.
In this new framework the semantic Web documents directly correspond to sets of TBox axioms (OWL documents) and ABox facts (RDF(DL)) in a DL knowledge base.
With this approach, the layers at the bottom of the semantic Web could be nicely integrated in a common and coherent formalism.
In this paper an alternative layering for the semantic Web is de- ned.
This approach has several advantages with respect to the layering accepted by the Web Ontology Working Group:   The semantic Web tower has become clearer, easier to understand and formalise   The remaining layers of the semantic Web and the extensions of OWL can be more easily de ned using this approach.
  The semantic Web could bene t from 15 years of description logics research in both the metadata and the ontology layer   In the new layering paradigm RDF(DL) would correspond to a Abox formalism in DL, while RDFS(DL) and OWL would be used to de ne the TBox.
  Some expressive power is lost in the lower layers of the semantic Web when using this approach.
However:   The languages on top of the ontology layer will be as expressive as they would be following the standard approach.
New languages and extensions would hardly be layered on top of OWL-full, which means that the additional expressive power provided by RDF(S) model theory will probably not be used in the languages built on top of the ontology layer   The additional capabilities of RDF and RDF-Schema have not been widely used so far by modelers.
For example, the only modeling capability of RDF not provided by RDF(DL) is the ability to use properties in subject position of triples.
Nevertheless it is hard to  nd any examples of RDF graphs that use this speci c feature of the language.
  The semantic speci cation of OWL would be greatly simpli- ed.
Thus, for example, no RDF-compatible model theoretic semantics would be required.
All the languages in this solution would be given a direct model-theoretic semantics.
This makes OWL tools easier to implement   Users can choose to use RDF(DL) and RDFS(DL) on one hand or full RDF(S) on the other.
The author would like to thank Bijan Parsia for insightful comments and discussions.
