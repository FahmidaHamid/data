A Web service is a process that interacts with the client and other services to achieve a certain goal.
A requirements analysis in the emerging  eld of Semantic Web Services (SWS)1 has identi ed four major areas of research: intelligent service discovery, automated contracting of services, process modeling, and service enactment.
It is generally agreed that Semantic Web Services should be based on a formalism with a well-de ned model-theoretic semantics, i.e., on some sort of a logic.
In this paper we propose a logic, called CT RS, which captures the dynamics of contracting for services   M. Kifer and I.V.
Ramakrishnan were supported in part by the NSF grants CCR-0311512 and IIS-0072927.
Copyright is held by the author/owner(s).
and thus is in the intersection of the areas of contracting and process modeling.
Since CT RS is an extension of the classical  rst-order logic, it is well-suited for modeling of the static aspects of contracting as well.
If object-oriented representation is desired, F-logic [14] (and an adaptation of CT RS) can be used instead.
The idea of using a logic to model processes is not new [12, 2,
 sical  rst-order logic, temporal logic [9], and Concurrent Transaction Logic [5].
A distinctive aspect of contracting in Web services, which is not captured by these formalisms, is that contracting involves multiparty processes, which can be adversarial in nature.
One approach to deal with this situation could be to try and extend a multi-modal logic of knowledge [10].
However, we found it more expedient to extend Concurrent Transaction Logic [5] (or CT R), which has been proven a valuable tool for modeling and reasoning about processes [8, 4, 17].
The extension is called CT RS and is designed to model the adversarial situation that arises in service contracting.
This is achieved by extending the model theory of CT R with certain concepts borrowed from the Game Theory [18,
 and illustrate the use of this logic for modeling and reasoning about Web service contracts.
A typical situation in contracting where different parties may sometimes have con icting goals is when a buyer interacts with a seller and a delivery service.
The buyer needs to be assured that the goods will either be delivered (using a delivery service) or money will be returned.
The seller might need assurance that if the buyer breaks the contract then part of the down-payment can be kept as compensation.
We thus see that services can be adversarial to an extent.
Reasoning about such services is an unexplored research area and is the topic of this paper.
Overview and summary of results.
We introduce game-theoretic aspects into CT R using a new connective, the opponent s conjunction.
This connective represents the choice of action that can be made by a party other than the reasoner.
The reasoner here can be the client of a Web service who needs to verify that her goals are met or a service that needs to make sure that its business rules are satis ed no matter what the other parties (the clients and other services) do.
Actors other than the reasoner are collectively referred to as the opponent.
We then develop a model theory for CT RS and show how this new logic can be used to specify executions of services that may be non-cooperating and have potentially con ict-ing goals.
We also discuss reasoning about a fairly large class of temporal and causality constraints.
In CT RS, a contract is modeled as a work ow that represents the various possibilities for the service and the outside actors (or the
 all possible outcomes of a formula W that represents such a work ow.
A constraint,  , represents executions of the contract with certain desirable properties.
For instance, from the client s point of view, a desirable property might be that either the good is delivered or the payment is refunded.
The formula W  characterizes those executions of the contract that satisfy the constraint  .
If W     is satis able, i.e., there is at least one execution in its model, then we say that the constraint   is enforcible in the work ow formula W.
We describe a synthesis algorithm that converts declarative spec-i cations, such as W    , into equivalent CT RS formulas that can be executed more ef ciently and without backtracking.
The transformation also detects unsatis able speci cations, which are contracts that the reasoner cannot force to execute with desirable outcomes.
In game-theoretic terms, the result of such a transformation can be thought of as a concise representation of all winning strategies, i.e., all the ways for the reasoner to achieve the desired outcome, regardless of what the rest of the system does, if all the parties obey the terms of the contract.
Finally, since CT RS is a natural generalization of CT R, a pleasing aspect of this work is that our earlier results in [8] become special cases of the new results.
The rest of the paper is organized as follows.
In Section 2, we introduce CT RS and discuss its use for modeling work ows and contracts.
In Section 3, we introduce the model theory of CT RS.
Section 4 discusses the proof theory.
Section 5 introduces causal and temporal work ow constraints that can be used to specify goals of the participants in a contract.
In Section 6, we present an algorithm for solving these constraints and discuss its complexity.
Section 7 concludes with a discussion of related formalisms.
Familiarity with CT R [5] can help understanding of CT RS and its relationship to work ows and contracts.
However, this paper is self-contained and includes all the necessary de nitions.
We  rst describe the syntax of CT RS and then supply intuition to help the reader make sense out of the formal de nitions that follow.
The atomic f ormulas of CT RS are expressions of the form p(t1, ..., tn), where p is a predicate symbol and ti are terms, i.e., they are the same as in classical logic.
Complex formulas are built with the help of connectives and quanti ers: if   and   are CT RS formulas, then so are      ,      ,      ,   |  ,  ,   (cid:4)  , ( X) , and ( X) , where X is a variable.
Intuitively, the formula       means: execute   and then execute  .
The connective   is called serial conjunction.
The formula   |   denotes an interleaved execution of two games   and  .
The connective | is called concurrent conjunction.
The formula   (cid:4)   means that the opponent chooses whether to execute   or  , and therefore (cid:4) is called opponent (cid:1) s conjunction.
The meaning of       is similar, except the reasoner makes the decision.
In CT R this connective is called classical disjunction but because of its interpretation as reasoner s choice we will also s disjunction.
Finally, the formula refer to it as reasoner       denotes execution of   constrained by   (or   constraint by  ).
It is called classical conjunction.2 As in classical logic, we introduce   as an abbreviation for
 inition looks very much like that of a conjunction in predicate calculus.
This similarity is the main reason for the name.
(cid:1)  .
The usual dualities      ( ) and         also hold.
The opponent s conjunction has a dual connective, (cid:9), but we will not discuss it in this paper.
As mentioned in the introduction, we model the dynamics of service contracts using the abstraction of a 2-party work ow, where the  rst party is the reasoner and the other represents the rest of the players involved in the contract.
In general, if several parties need to be able to reason about the same contract, the contract can be represented as several 2-party work ows, each representing the contract from the point of view of a different reasoner.
De nition 1.
(Work ows) A CT RS goal is recursively de- ned as either an atomic formula or an expression of the form  ,   |  ,      , or   (cid:4)  , where   and   are CT RS goals.
A rule is of the form head body, where head is an atomic formula and body a CT RS goal.
A workf low control specif ication consists of a CT RS goal and a (possibly empty) set of rules.
Note that the connective   is not allowed in work ow control spec-i cations, but is used to specify constraints.
Example 1.
(Procurement Contract) Consider a procurement application that consists of a buyer interacting with three services, sell, f inance, and deliver.
We assume that the buyer is the reasoner in this example.
Services are modeled in terms of their signif icant events.
For instance, the buy service begins when the signi cant event pay escrow occurs.
When pay escrow is  nished, a concurrent execution of the sell and f inance services begins.
Thus, at a high level, the buy service can be represented as: pay escrow   (f inance | sell) The connective   represents succession of events or actions: when the above expression  executes,  the underlying database state is  rst changed by the execution of the formula pay escrow and then by the execution of f inance | sell.
The connective | represents concurrent, interleaved execution of the two sequences of actions.
Intuitively, this means that a legal execution of (f inance | sell) is a sequence of database states where the initial subsequence corresponds, say, to a partial execution of the subformula f inance; the next subsequence of states corresponds to an execution of sell; the following subsequence is a continuation of the execution of f inance; and so on.
The overall execution sequence of (f inance | sell) is a merge of an execution sequence for the left subformula and an execution sequence for the right subformula.
Execution has precise meaning in the model and proof theories of CT R. Truth of CT R formulas is established not over database states, as in classical logic, but over sequences of states; it is interpreted as an execution of that formula in which the initial database state of the sequence is successively changed to the second, third, etc., state.
The database ends up in the  nal state of the sequence when the execution terminates.3 Work ow formulas can be modularized with the help of rules.
The intuitive meaning of a rule, head body, where head is an atomic formula and body is a CT RS goal, is that head is an invocation interface to body, where body is viewed as a subroutine.
This is because according to the semantics described in Section 3,
 logics that on the surface might appear to address the same issues (e.g., temporal logics, process and dynamic logics, the situation calculus, etc.).
We refer the reader to the extensive comparisons provided in [5, 6].
145such a rule is true if every legal execution of body must also be a legal execution of head.
Combined with the minimal model semantics this gives the desired effect [6].
With this in mind, we can now express the above procurement work ow as follows: buy   pay escrow   (sell | f inance) Next, we search for matching services for the sell service using a service directory to discover the following rules.
sell   reserve item   (deliver   keep escrow) deliver   insured   uninsured The   connective in the de nition of sell represents alternative executions.
For instance, a legal execution of insured   uninsured is either a legal execution of insured or of uninsured.
Similarly, a legal execution of sell involves the execution of reserve item and then, an execution of either deliver or recv escrow.
The above de nition of sell also requires compliance with the following contract requirements between the buyer and the seller:   if buyer cancels, then seller keeps the escrow   if buyer pays, then seller must deliver Thus, the connective   represents a choice.
The question is whose choice is it: the reasoner s or that of the opponent?
In an environment where work ow activities might not always cooperate, we need a way to distinguish these two kinds of choices.
For instance, the contract may say that the outcomes of the actions of the delivery agent are that the goods might be delivered or lost.
This alternative is clearly not under the control of the buyer, who is the reasoner here.
On the other hand, the choice of whether to use insured or uninsured delivery is made by the buyer, i.e., the reasoner.
With this understanding, the insured and uninsured services can be de ned as follows: insured   (delivered   satisf ied) (cid:4) (lost   satisf ied) uninsured   (delivered   satisf ied) (cid:4) lost The connective (cid:4) here represents the choice made by the actors other than the reasoner (the buyer).
If the buyer uses insured delivery then she is guaranteed satisfaction if the item is delivered or lost (in the latter case the buyer presumably gets the money back).
If the buyer uses uninsured delivery then she can get satisfaction only if the item is delivered.
Whether the item is delivered or lost is outside of the control of the buyer.
Next, we identify the following matching service for f inance: f inance   (approve   (make payment   cancel)) (cid:4) (reject   cancel) Note that approval or rejection of the  nancing request is an opponent s (the servicing agent s) choice.
However, if  nancing is approved the choice of whether to proceed and make payment or to cancel depends on the reasoner (the buyer).
In addition, the  nancing agent might require the following clause in the contract:   if  nancing is approved and buyer does not cancel then delivery should satisfy Details of how to express the above contract requirement in CT RS will be given in Section 5.
The buyer and the services involved might have speci c goals with respect to the above contract.
For instance, the buyer wants that if  nancing is approved then she has a strategy to ensure that she is satis ed (either by receiving the goods or by getting the money back).
The seller might want to have the peace of mind knowing that if the buyer cancels the contract after receiving  -nancing then the seller can keep the escrow.
In Section 6 we will show how such goals can be represented and that they can be enforced under this contract even in adversarial situations.
We shall see that a large class of temporal and causality constraints can be represented as CT RS formulas.
If   represents such a formula for the above example, then  nding a strategy to enforce the constraints under the rules of the contract is tantamount to checking whether buy     is satis able in CT RS.
Before going on, we should clear up one possible doubt: why is there only one opponent?
The answer is that this is suf cient for a vast majority of practical cases, especially those that arise in Web services.
Indeed, even when multiple independent actors are involved, we can view each one of them (or any group that decides to cooperate) as the reasoner and all the rest as the opponent.
Any such actor or a group can then use CT RS to verify that its goals (speci ed as a condition  ) are indeed enforcible.
In this section we de ne a model theory for our logic.
The importance of a model theory is that it provides the exact semantics for the behavioral aspects of service contracts and thus serves as a yardstick of correctness for the algorithms in Section 6.
A path is a sequence of database states, d1...dn.
Informally, a database state can be a collection of facts or even more complex formulas, but for this paper we can think of them as simply symbolic identi ers for various collections of facts.
In CT R [5], which allows concurrent, interleaved execution, the semantics is based on sequences of paths,   = (cid:10)p1, ..., pm(cid:11), where each pi is a path.
Such a sequence is called a multipath, or an m-path [5].
For example, (cid:10)d1d2, d3d4d5(cid:11) is an m-path that consists of two paths: one having two database states and the other three (note that a comma separates paths, not states in a path).
As explained in Example 1, multipaths capture the idea of an execution of a transaction that interleaves with executions of other transactions.
Thus, an m-path can be viewed as an execution that is broken into segments, such that other transactions could execute in-between the segments.
CT RS further extends this idea by recognizing that in the presence of other parties, the reasoner cannot be certain which execution (or  play ) will actually take place, due to the lack of information about the actual moves that the opponent will make.
However, the reasoner can have a strategy to ensure that regardless of what the opponent does the resulting execution will be contained within a certain set of plays.
If every play in the set satis es the properties that the reasoner wants, then the strategy will achieve the reasoner s objectives.
Such a set of plays is called an outcome of the game.
Thus, while truth values of formulas in CT R are determined on m-paths, CT RS formulas get their truth values on sets of m-paths.
Each such set, S, is interpreted as an outcome of the game in the above sense, and saying that a CT RS formula,  , is true on S is tantamount to saying that S is an outcome of  .
In particular, two games are considered to be equivalent if and only if they have the same sets of outcomes.
The following de nitions make the above discussion precise.
De nition 2.
(m-Path An m-path structure is a triple of the form (cid:10)U, IF , Ipath(cid:11), where U is the domain, IF is an interpretation function for constants and function symbols (exactly like in classical logic), and Ipath is a Structure [5])
 semantic structure (as commonly used in classical predicate logic).
For a CT R formula,  , and an m-path,  , the truth of   on   with respect to an m-path structure is determined by the truth values of the components of   on the appropriate sub-m-paths of  .
In a well-de ned sense, establishing the truth of a formula,  , over an m-path,   = (cid:10)p1, ..., pn(cid:11), corresponds to the possibility of executing   along   where the gaps between p1, ..., pn are  lled with executions of other formulas [5].
The present paper extends this notion to CT RS by de ning truth of a formula   over sets of m-paths, where each such set represents a possible outcome of the game corresponding to  .
The new de -nition reduces to CT R s for formulas that have no (cid:4) s.
De nition 3.
(Satisfaction) Let I = (cid:10)U, IF , Ipath(cid:11) be an m-path structure,   be an arbitrary m-path.
Let S, T , S1, S2, etc., denote nonempty sets of m-path, and let   be a variable assignment, which assigns an element of U to each variable.
We de ne the notion of satisf action of a formula,  , in I on S by structural induction on  :
   |=  p(t1, .
.
.
, tn) I, { } iff p(t1, .
.
.
, tn).
Here { } is a set of m-Ipath( ) |=classic paths that contains only one m-path,  , and p(t1, .
.
.
, tn) is an atomic formula.
Recall that Ipath( ) is a usual  rst-order semantic structure, so |=classic here denotes the usual, classical  rst-order entailment.
Typically, p(t1, ..., tn) is either de ned via rules (as in Example 1) or is a  builtin,  such as insert(q(a, b)), with a  xed meaning.
For instance, in case of insert(q(a, b)) the meaning would be that I,{ } |=  insert(q(a, b)) iff   is an m-path of the form (cid:10)d1 d2(cid:11), which consists of a single path, and d2 = d1   {q(a, b)}.4 These built-ins are called elementary updates and constitute the basic building blocks from which more complex actions, such as those at the end of Example 1, are constructed.
I, S |=   .
We de ne     as a shorthand for  ( ).
I, S |=    (cid:4)   iff S = S1   S2, for some pair of m-path sets, such that I, S1 |=    , and I, S2 |=   .
The dual connective, (cid:9), also exists, but is not used in this paper.
I, S |=        iff there is a set R  R     T , of m-paths, such that S can be represented as where each T  is a set of m-paths, I, R |=    , and for each T , I, T  |=   .
Here  T = {      |     T}, where       is an m-path obtained by appending the m-path   to the end of the m-path  .
(For instance, if   = (cid:10)d1d2, d3d4(cid:11) and   = (cid:10)d5d6, d7d8d9(cid:11) then       = (cid:10)d1d2, d3d4, d5d6, d7d8d9(cid:11).)
In other words, R is a set of pre xes of the m-paths in S.
I, S |=    |   iff there is a set R of m-paths, such that S can be represented as
  R  (cid:15)T , where each T  is a set of m-paths, and   either I, R |=    and for all T , I, T  |=   ;
 tion of the transition oracle [6].
  or I, R |=    and for all T , I, T  |=    Here  (cid:15)T  denotes the set of all m-paths that are obtained by interleaving   with some m-path in T .
For instance, if   = (cid:10)d1d2, d3d4(cid:11) and (cid:10)d5d6, d7d8d9(cid:11)   T  then one interleaving is (cid:10)d1d2, d5d6, d3d4, d7d8d9(cid:11), another is (cid:10)d1d2, d5d6, d7d8d9, d3d4(cid:11), etc.
I,   |=   X.  if and only if I,   |=    for every variable assignment   that assigns the same value as   to all variables except X. Existential quanti cation,  X. , is a shorthand for  X .
Example 2.
(Database Transactions) Consider the following formula, where st means  start,  ab means  abort,  cm is  commit,  cp means  compensate,  and no stands for a noop.
Further assume that each elementary update em in the following formula denotes an insert(em) operation which satis es {(cid:10)d d   {em}(cid:11)} |= insert(em) where d is a set of ground atomic formulas.
  = st   (ab (cid:4) cm)   (cp   no) Then the possible outcomes for   can be computed from the outcomes of its components as follows:
 and {(cid:10)  {no}(cid:11)} |= (cp   no)

 {(cid:10)  {st} {st, ab}(cid:11), (cid:10)  {st} {st, cm}(cid:11)} |= st   (ab (cid:4) cm)
 outcomes for  ; {(cid:10) {st}{st, ab}{st, ab, cp}(cid:11), (cid:10) {st}{st, cm}{st, cm, cp}(cid:11)} {(cid:10) {st}{st, ab}{st, ab, cp}(cid:11), (cid:10) {st}{st, cm}{st, cm, no}(cid:11)} {(cid:10) {st}{st, ab}{st, ab, no}(cid:11), (cid:10) {st}{st, cm}{st, cm, cp}(cid:11)} {(cid:10) {st}{st, ab}{st, ab, no}(cid:11), (cid:10) {st}{st, cm}{st, cm, no}(cid:11)} De nition 4.
(Playset) As in classical logic,       is a tautology for any  , i.e., it is true on every set of m-paths.
We denote this tautology with a special proposition Playset, an analogue of true in classical logic.
By de nition, I, S |= Playset for any m-path structure and any set of m-paths.
Therefore,  Playset is unsatis able.
Intuitively, Playset is the game in which all outcomes are possible, while  Playset is a game with no outcomes.
We now de ne executional entailment, a concept that connects model theory with the execution of a certain strategy of the reasoner.
De nition 5.
(Executional Entailment) Let   be a CT RS goal and W a set of rules that de ne services (see De nition 1).
Let D0, ..., Dn be a sequence of database states.
A path tree with a shared pref ix D0, ..., Dn is a set of paths where each begins with this sequence of states.
We de ne D0, ..., Dn --- |= ( )  (4.1) to mean that for every model M of   there is a path tree T such that M, T |= ( )  and (cid:10)D0, ..., Dn(cid:11) is a shared pre x of T .
Here ( ) indicates that all variables in   are quanti ed existentially.
ensure that the execution will begin with the database state D0 and continue with D1, ..., Dn.
Observe that executional entailment is de ned over path trees, not over arbitrary outcomes.
Hence, when we talk about execution of a game we are only interested in enforcible outcomes that can reduce to a path tree.
We call these executable outcomes.
We are interested in these outcomes because ultimately we want to obtain strategires that contain complete plays plays that represent movements of all the players involved.
Such a play must be represented by a path, not m-path, because m-paths are incomplete plays they contain gaps, which must be  lled by external players.
The plays in an outcome that represents a strategy must form a path tree because all the plays in an outcome of a real game start with the same initial state D0.
Thus,  nding out if a winning strategy exists in state D0 is tantamount to proving W, D0 --- |= ( ) .
We now develop an inference system for proving statements of the form W, D0 --- |= ( ) , where W is a set of rules and   is a CT RS goal.
The system manipulates expressions of the form W, D0 --- (cid:17)  , called sequents.
First we need the notion of the hot component of a formula; it is a generalization of a similar notion from [5]: hot( ) is a set of subformulas of  , de ned by induction on the structure of   as follows: 1. hot( ) = { }, if   is an atomic formula 2. hot(     ) = hot( ) 3. hot(  |  ) = hot( )   hot( ) 4. hot(     ) = {     } 5. hot(  (cid:4)  ) = {  (cid:4)  }.
Note that in cases of   and (cid:4), the hot component is a singleton set that contains the very formula that is used as an argument to hot.
Here are some examples of hot components: a   b   c (a   b) | (c   d) (a (cid:4) b)   c (a (cid:4) b) | (c   d) ((a (cid:4) b)   c)   ((f | g)   h) {a} {a, c} {a (cid:4) b} {a (cid:4) b, c   d} {((a (cid:4) b)   c)   ((f | g)   h)} Note that a hot component represents a particular occurrence of a subformula in a bigger formula.
For instance, hot(a   b   a) is {a}, where a corresponds to the  rst occurrence of this subfor-mula in a   b   a and not the second one.
This point is important because in the inference rules, below, we will sometime say that (cid:3) is obtained from   by deleting a hot occurrence of a (or some   other subformula).
Thus, in the above, deleting the hot component a leaves us with b   a, not a   b.
The inference rules are as follows: Axiom: P, D --- (cid:17) ( ), for any D.
Here ( ) is the empty CT RS goal; it represents a game that starts and stops in the same state without making any moves.
The axiom says that such a game can be played in any state.
Inference Rules: In Rules 1 4 below,   is a substitution,   and are concurrent serial conjunctions, and a is a formula in (cid:3)   hot( ).
(cid:3) (cid:3) (cid:3) (cid:3) (cid:3)   where   is obtained from  
 P, and assume that its variables have been renamed so that none are shared with  .
If a and b unify with mgu (most general uni er)   then P, D --- (cid:17) ( )   P, D --- (cid:17) ( )   currence of a is replaced by  .
For instance, if   = (c (cid:4) e) | (a   f ) | (d   h) and the hot component in question is a in the middle sub-formula, then  
 (cid:3) = (c (cid:4) e) | (    f ) | (d   h).
is   where a hot oc-where       share no variables, then
 (cid:3)   share no variables; then   P, D --- (cid:17) ( )   P, D --- (cid:17) ( )   by deleting a hot occurrence of a.
For instance, if   = (c (cid:4) e) | (a   f ) | (d   h) and the hot component is a in the middle subformula, then (cid:3) = (c (cid:4) e) | f | (d   h).
  If Ot(D1, D2) |=c ( )a ; a  and   P, D2 --- (cid:17) ( )   P, D1 --- (cid:17) ( )     by deleting a hot occurrence of a.
For instance, if   = (c (cid:4) e) | (a   f ) | (d   h) and the hot component is a in the middle subformula, then (cid:3) = (c (cid:4) e) | f | (d   h).
  Note that in this rule the current state changes from D2 to D1.
ponent   of the form  .
Then we have the following pair of inference rules, which can lead to two independent possible derivations.
P, D --- (cid:17) ( )   P, D --- (cid:17) ( )   is obtained from   by replacing the hot compo-Here   is obtained from   by replacing nent   with   and     with  .
For instance, if   = (c(cid:4) e) | (a  f ) | (d  h) and the (cid:3) = (c(cid:4)e) | (a f ) | d hot component   is d h, then   (cid:3)(cid:3) = (c (cid:4) e) | (a   f ) | h.
and  
 component,   , of the form   (cid:4)  .
Then we have the following inference rule: P, D --- (cid:17) ( )   P, D --- (cid:17) ( )   P, D --- (cid:17) ( )   and P, D --- (cid:17) ( )   where   is obtained from (cid:3)   (cid:3) (cid:3) (cid:3)(cid:3) (cid:3)(cid:3) (cid:3)(cid:3) P, D --- (cid:17) ( )   (cid:3) (cid:3)(cid:3) is obtained from   by replacing the hot com-where   ponent   with   and   is obtained from   by replacing   with  .
For instance, if   = (c(cid:4) e) | (a  f ) | (d  h) and the (cid:3) = c | (a f ) | (d h) hot component   is c(cid:4)e, then   (cid:3)(cid:3) = e | (a   f ) | (d   h).
and   Note that unlike in the reasoner s case when we have two inference rules, the opponent s case is a single inference rule.
It says that in order to prove P, D --- (cid:17) ( )   (i.e., to execute   on a set S of (cid:3) (cid:3) 148(cid:3) (cid:3)(cid:3) on a set S1 of paths emanating from D and   paths emanating from D) we need to be able to execute on   another (possibly the same) set S2 of paths emanating from D such that S = S1   S2.
(SOUNDNESS OF INFERENCE SYSTEM).
Un-|= ( )   holds der the Horn conditions, the entailment P, D if there is a deduction of the sequent P, D --- (cid:17)   in the above inference system.
We conjecture that the above proof theory is also complete for work ow control speci cations.
The importance of the proof theory in CT RS is that it can be used to execute work ow speci cations.
When these speci cations represent a service contract, the inference system will be able to execute the contract.
In [8], we have shown how a large class of constraints on work ow execution can be expressed in CT R. In CT RS we are interested in  nding a similar class of constraints, which could be used to denote the desirable properties of a contract, as explained at the end of Sections 1 and 2.2.
In this context, veri cation of a constraint against a contract means that the reasoner has a way of executing the contract so that the constraint will hold no matter what the other parties do (for instance, that the goods are delivered or the payment is refunded regardless).
Our veri cation algorithm requires that behavioral speci cations of contracts have no loops in them and that they have the unique event property de ned be-low.5 The no-loops requirement is captured by the restriction that the work ow rules are non-recursive (so having rules is just a matter of convenience, which does not increase the expressive power).
We assume that there is a subset of propositions, E VENT , which represents the  interesting  events that occur in the course of work ow execution.
These events are the building blocks of both work ows and constraints.
In terms of De nition 3, these propositions would be de ned as builtin elementary updates.
De nition 6.
(Unique-event property) A CT RS work ow W has the unique event property if and only if every proposition in E VENT can execute at most once in any execution of W.
Formally, this can be de ned both model-theoretically and syntactically.
The syntactic de nition is that for every proposition e   E VENT : If W is W1   W2 or W1 | W2 and e occurs in W1 then it cannot occur in W2, and vice versa.
For work ows with no loops, we can always rename different occurrences of the same type of event to satisfy the above property.
We shall call such work ows unique event workf lows.
De nition 7.
(Constraints) Let   be a (cid:4)-free formula.
Then   denotes a formula that is true on a set of m-paths, S, if and only if   is true on every m-path in S. The operator   can be expressed using the basic machinery of CT RS.
Our constraints on work ow execution, de ned below, will all be of the form   because, intuitively, the most common thing that a reasoner wants is to make sure that every execution in the outcome has certain desirable properties.
Items 1 3 de ne primitive
 work ow modeling (e.g., [2, 22]) and even such speci cation languages as WSFL   IBM s proposal for a Web service speci cation language that was one of the inputs to BPEL4WS [15].
constraints, denoted PRIMIT IVE.
Item 4 de nes the set CONST R of all constraints.
event, then  e and  ( e) are primitive constraints.
Informally, the constraint  e is true on a set S of m-paths in an m-path structure I = (U, IF , Ipath) iff e occurs on every m-path in S. Similarly,  ( e) is true on S iff e does not occur on any m-path in S.
Formally,  e says that every execution of the contract, i.e., every m-path (cid:10)p1, ..., pi, ..., pn(cid:11)   S, includes a path, pi, of the form d1...dkdk+1...dm, such that for some pair of adjacent states, dk and dk+1, the event e occurs at dk and causes a state transition to dk+1, i.e., Ipath((cid:10)dkdk+1(cid:11)) |=classic e (see De nition 3).
The constraint  ( e) means that e does not occur on any m-path in S.
 ,  , or   combination of propositions from E VENT is allowed under the scope of  .
For instance,  (e1   e2) and  (e1    e2) are allowed.
The former is true on a set of m-paths, S, if either e1 or e2 occurs on every m-path in S. The latter is true if, for every m-path in S, the occurrence of e1 on the m-path implies that e2 occurs on the same m-path.
For  (e1    e2), we will use the abbreviation  (e2   e1).
 (e1   ...   en) is a primitive constraint.
It is true on a set of m-paths S iff e1 occurs before e2 before ... before en on every path in S.
consists of all Boolean combinations of primitive constraints (i.e., constraints de ned by Items 1 3) using the connectives   and  :       (resp.
     ) is satis ed by a set of m-paths S iff S satis es   and (resp.
or)  .
It can be shown that under the unique event assumption any serial primitive constraint can be decomposed into a conjunction of binary serial constraints.
For instance,  (e1   e2   e3) is equivalent to  (e1   e2)    (e2   e3).
Here are some typical constraints in CONST R and their real-world meaning:  e   event e should always eventually happen;  e    f   events e and f must always both occur (in some order);  (e   f )   always either event e or event f or both must occur;  e    f   either always event e occurs or always event f occurs;  ( e    f )   it is not possible for e and f to happen together;  (e   f )   if event e occurs, then f must also occur.
Example 3.
(Contract Goals) The actors in the procurement work ow of Example 1 may want to ensure that they have a way to reach their goals within the scope of the contract.
We express these goals using the following set of constraints:  (approve    cancel   satisf ied) if  nancing is approved and buyer does not cancel then she wants to be satis ed  (cancel   keep escrow)  (make payment   deliver) if buyer cancels, then seller keeps the escrow if buyer pays, then seller must deliver


 Given a contract represented as a CT RS work ow, W, and a reasoner s goal speci ed as a constraint,     CONST R, we would like to construct another work ow, W , that represents a class of strategies that enforce   within the rules of the contract.
 Enforcement  here means that as long as the opponent plays by the rules of the contract (i.e., chooses only the alternatives speci ed by the (cid:4)-connective), the reasoner can still ensure that all the plays belong to an outcome that satis es the constraints.
In CT RS this amounts to computing W       the formula that represents the collection of all reasoner s strategies for  nding the outcomes of W that satisfy the constraint  .
We must clarify what we mean by  computing  W    .
After all, W     already is a representation of all the winning strategies for the reasoner and all outcomes of W     satisfy  .
However, this formula is not an explicit set of instructions to the work ow scheduler.
In fact, it is not even a work ow speci cation in the sense of De nition 1.
In contrast, the formula W  that we are after is a work ow speci cation.
It does not contain the  connective, and it can be directly executed by the CT RS proof theory.
This means that the proof theory can be used to execute the contract W in such a way that the reasoner s objectives   will be satis ed.
The precise relationship between W     and W  will be established in De nition 8.
Informally speaking, the two formulas are equivalent in the sense that they have exactly the same executions modulo certain synchronization acts.
We now develop an algorithm for computing W  through a series of transformations.
Enforcing complex constraints.
Let  C1, C2   CONST R, W be a CT RS work ow, then

 Thus, we can compute W( C1 C2) as W C1   W C2 and W( C1 C2) as W C1   W C2 .
Enforcing elementary constraints.
The following transformation takes an elementary primitive constraint   of the form   or   and a CT RS unique-event work ow W, and returns a CT RS work ow that is equivalent to W    .
Let  ,     E VENT and W1,W2 be CT RS work ows.
Then:                    Playset     (W1   W2)   (    W1)   W2   W1   (    W2)     (W1   W2)   (    W1)   (    W2)     (W1 | W2)   (    W1) | W2   W1 | (    W2)     (W1 | W2)   (    W1) | (    W2) (Recall that Playset was introduced in De nition 4.)
These logical equivalences are identical to those used for work ows of cooperating tasks in [8].
The  rst equivalence below is speci c to CT RS.
Here we use   to denote   or  :          Playset           if   (cid:20)=       (W1 (cid:4) W2)   (    W1) (cid:4) (    W2)
 For example, if W is abort(cid:4) prepare  (abort  commit), then:  abort   W   abort (cid:4) (prepare   abort)  abort   W    Playset The above equivalences enable us to decompose the problem of computing W  into simpler problems.
For instance, ( )  =  , and to compute (W1 (cid:4) W2)  it suf ces to compute (W1)  (cid:4) (W2) .
Enforcing serial constraints.
Next we deal with constraints of the form  (     ).
Let  ,     E VENT and let W be a CT RS work ow.
We de ne W ( ) as sync(  <  , (    (    W))) where sync is a transformation that synchronizes events in the It uses elementary updates send( ) and receive( ) right order.
and is de ned as follows: sync(  <  ,W) = W(cid:3) , where W(cid:3) is like W, except that every occurrence of event   is replaced with  send( ) and every occurrence of   with receive( ) , where   is a new constant.
The primitives can be de ned as insert(channel( )) and channel( )   delete(channel( )), respectively, where   is a new proposition symbol.
The point here is that these two primitives can be used to provide synchronization: receive( ) can become true if and only if send( ) has been executed previously.
In this way,   cannot start before   is done.
The following examples illustrate the de nition of W ( ): and receive send (     ) ( ) = receive( )           send( ) (  |   |  1 | ... |  n) ( ) = (    send( )) | (receive( )    ) |  1 | ... |  n) Note that W ( ) is not logically equivalent to W    (     ), but these two formulas are behaviorally equivalent as de ned next.
De nition 8.
(Behavioral Equivalence) A CT RS formula   behaviorally entails   iff for every m-path structure I = (U, IF , Ipath) and a set on m-paths S, if I, S |=   then there is another set S and S are congruent modulo synchronization; namely, these sets of m-paths reduce to the same set of m-paths under the following operations: (cid:3) |=  , where S such that I, S (cid:3) (cid:3)   Remove all synchronization messages inserted by the send and receive primitives (i.e., the atoms of the form channel( )) from all database states in S and S.
(cid:3)   Eliminate adjacent duplicate states from all m-paths (i.e., if   is an m-path of the form (cid:10)..., d1...dkdk+1..., ...(cid:11) and dk is the same state as dk+1 then delete dk+1 from  .
(After the previous step, such adjacent duplicate states normally correspond to state transitions that occur due to the execution of send and receive.)
  and   are behaviorally equivalent if each behaviorally entails the other.
Proposition 1.
(Enforcing Elementary and Serial Constraints) The above transformations compute a CT RS work ow that is behaviorally equivalent to W    , where   is an elementary or serial constraint and W is a unique event work ow.
Enforcing conjunctive primitive constraints.
To enforce a primitive constraint of the form  ( 1   ...    m), where all  i are elementary, we utilize the logical equivalence  ( 1   ...    m)      1   ... m (and the earlier equivalences for enforcing complex constraints).
Enforcing disjunctive primitive constraints.
These constraints have the form  ( 1   ...    n), where all  i are elementary constraints.
Enforcement of such constraints relies on the following lemma.
mentary constraints.
Then  ( 1   ...    n)   ( 2   ...    n    1) (cid:4) ...
(cid:4) ( 1   ...    i 1    i+1   ...    n    i) (cid:4) ...
(cid:4) ( 1   ...    n 1    n) This equivalence allows us to decompose the set of all plays in an outcome into subsets that satisfy the different implications shown in the lemma.
Unfortunately, enforcing such implications is still not easy.
Unlike the other constraints in this section, enforcement of the implicational constraints cannot be described by a series of simple equivalences.
Instead, we have to resort to equivalence transformations de ned with the help of parse trees of CT RS formulas that represent unique event work ows.
De nition 9.
(Maximal guarantee for an event) Let   be an elementary constraint (i.e.,   is e or  e), W be a formula for a unique event work ow, and   be a subformula of W. Then   is said to be a maximal guarantee for   iff

 Intuitively, a maximal guarantee for  e is any maximal subformula,  , of W such that e occurs in every execution of  .
A maximal guarantee for  e is such a maximal subformula,  , of W that e does not occur in any execution of  .
The set of all maximal guarantees for an elementary event   is denoted by GS (W).
De nition 10.
(Co-executing sub-formulas) Let W be a formula for a unique event work ow and  ,   be a pair of subfor-mulas of W. We say that   coexecutes with   in W, denoted     coExec(W,  ), iff


 following Intuitively members of coExec(W,  ) correspond to maximal sub-formulas of W that must be executed whenever   executes as part of the work ow W.
procedures compute GS (W) Proposition 2.
(Computing GS (W) and coExec(W,  )) and The coExec(W,  ).
They operate on the parse tree of W, which is de ned as usual: the inner nodes correspond to composite subformulas and the leaves to atomic subformulas.
Thus, the leaves are labeled with their corresponding atomic subformulas, while the inner nodes are labeled with the main connective of the corresponding composite subformula.
GS e(W): The set of subformulas that correspond to the nodes in the parse tree of W that are closest to the root of the tree and can be reached by the following marking procedure: (i) mark all the leaves labeled with e; (ii) mark any node corresponding to a subformula of W of the form (     ) or (  |  ) if either the node for   or for   is marked; (iii) mark any node corresponding to a subformula of the form ( ) or ( (cid:4) ) if both the node for   and the node for   are marked.
coExec(W,  ): Consider a subformula of W of the form  1 |  2,  2 |  1,  1    2, or  2    1, where   is a subformula of  1.
Suppose that  2 is a maximal subformula with such a 1 |   property, i.e., W has no subformula of the form   (cid:3) (cid:3)
 2     1     2 |   (cid:3) (cid:3) (cid:3) (cid:3) (cid:3) 2, or   1, respectively, such that   is a   2 (cid:20)=  2).
(cid:3) (cid:3) 1 and  2 is a subformula of   subformula of   Then,  2   coExec(W,  ).
(cid:3) 2 (  (cid:3) 1,   buy n3 pay_escrow finance n1 n2 sell n4 n6 approve n5 make_payment reserve reject cancel n8 keep_escrow deliver n7 n10 cancel n11 insured delivered lost satisfied satisfied uninsured n9 lost delivered satisfied Figure 1: Work ow parse tree and work ow graph for Example 3 GS e(W): Let T be the set of nodes in the parse tree of W that belong to any of the subformulas     GS e(W) or     coExec(W,  ).
Then,     GS e(W) iff it is a subformula of W such that its subtree contains no nodes in T and   is a maximal subformula with such a property.
Example 4.
(Computation of maximal guarantees and co-execution) The work ow parse tree for Example 3 is shown in Figure 1.
For the event approve, the highest node that can be reached by the aforesaid marking procedure is n1 and there are no other such nodes.
Therefore, GS approve(W) is {approve   (make payment cancel)}.
The set of co-executing subformulas for n1, coExec(W, n1), consists of two formulas that correspond to the nodes n3 and n4 in the  gure.
The only maximal guarantee for  approve is the subformula reject   cancel, which corresponds to node n2.
if W |=  1   ...    n then Compute W  for each i such that W (cid:20)|=    i do for each f   GS i (W) do procedure Compute W( 1 ... n )











 for each g   subf ormulas(W) do if Guard(g) (cid:20)=   then for every g   GS (h) set Guard(g) := Guard(g)   {receive( )} if  h   coExec(W, f ) and (h    ) is satis able then Rewrite f to send( )   f and receive( ) Guard(g) receive( ))   g else Compute sibling(f )( 1 ... n ) rewrite g to (
 Figure 2: Computation of W( 1 ... n ) Recall that, according to Lemma 1, in order to enforce a disjunctive constraint we need to learn how to enforce implicational constraints of the form  1   ...    n    , where   and the  is are elementary.
This is done using the algorithm in Figure 2, which computes a work ow that is equivalent to ( 1   ...    n  
 execution, then (in line 1)   must be enforced on W. Otherwise, for every  i that is not true everywhere, we identify the subfor-mulas f   GS i (lines 2-3).
Note that, whenever subformulas in GS i are executed the constraint  1   ...    n     is vacuously true.
In lines 4-6, we identify the subformulas h of W that co-execute with the formulas f   GS i.
If   is enforcible in any of these subformulas h, i.e., h     is satis ed (there can be at most one such subformula h per f, due to the unique event property, De nition 6), then we enforce the above constraint by delaying executions of those subformulas in h that violate   (these are exactly the g s in line 7) until it is guaranteed that the execution moves into f   GS i, because once f is executed our constraint becomes satis ed.
This delay is achieved by synchronizing the executions of f to occur before the executions of g by rewriting f into send( )   f (in line 6) and by adding receive( ) to the guard for g (in line 8).
Otherwise, if no such h exists, in line 9, we explicitly enforce the constraint on the sibling nodes (in the parse tree of W) of the formulas f   GS i (because an outcome that satis es  i might exist in a sibling).
Finally, in lines 10-12, we make sure that the execution of every g that has a nonempty guard is conditioned on receiving of a message from at least one f with which g is synchronized.
Example 5.
(Procurement Work ow, contd.)
The algorithm in Figure 2 creates the following work ow by applying the constraints in Example 3 to the procurement work ow in Example 1.
Refer to the parse tree for that work ow in Figure 1.
  To enforce ( cancel    keep escrow) we  rst compute GS cancel(buy) = {n5}, and coExec(buy, n5) = {n3, n4, n6}.
Of these, n4 (substituted for h) satis es the conditions on line 5 of the algorithm in Figure 2.
Since GS keep escrow(n4) = {n7}, we insert a synchronization from node n5 to n7 shown in Figure 1 as a dotted line.
This ensures that if the buyer cancels the procurement work ow, the seller collects the escrow.
  To enforce ( approve      cancel    satisf ied), we compute GS approve(buy) = {n2} and notice that n4   coExec(buy, n2)} satis es the conditions in line 5 of the algorithm in Figure 2.
Since GS satisf ied(n4) = {n8, n9}, we insert a synchronization from node n2 to n8 and n9 which yields the dotted edges in Figure 1.
We also compute GS cancel(buy) = {n10, n2} and notice that n4   coExec(buy, n2)}, n4   coExec(buy, n10)}, and n4 satis es the conditions in line 5 of the algorithm.
Since GS satisf ied(n4) = {n8, n9}, we insert a synchronization from the nodes n10 and n2 to n8 and n9, which yields the dotted edges in Figure 1.
This synchronization ensures that if buyer s  nancing is approved and he chooses to make the payment and buy the item then delivery must use the insured method.
Also, once the constraint ( make payment    deliver) is enforced too, the seller can no longer pocket the escrow.
The resulting strategy is: ((send( 3)   cancel))) (cid:4) (send( 2)   (reject   cancel)) buy   pay escrow   (f inance | sell) f inance   (approve   ((send( 1)   make payment)   sell   reserve item   ((receive( 1)   deliver) deliver   insured   ((receive( 2)   receive( 3))   uninsured) insured   (delivered   satisf ied) (cid:4) (lost   satisf ied) uninsured   (delivered   satisf ied) (cid:4) lost   ((receive( 2)   receive( 3))   keep escrow)) Proposition 3.
(Enforcing disjunctive primitive constraints) The above algorithm for enforcing disjunctive primitive constraints computes a CT RS work ow W  that is behaviorally equivalent to W    ( 1   ...    n) where  i are elementary constraints.
(DISJUNCTIVE CONSTRAINTS).
Let W be a control  ow graph and     PRIMIT IVE be a disjunctive primitive constraint.
Let |W| denote the size of W, and d be the number of elementary disjuncts in  .
Then the worst-case size of W  is O(d   |W|), and the time complexity is O(d   |W|2).
( jP rim) Enforcement of arbitrary constraints.
If   = where P rim   PRIMIT IVE, we compute W  by applying the above transformations for complex and elementary constraints.
Each transformation is either a logical equivalence or a behavioral equivalence.
Therefore, W  is behaviorally equivalent to W    .
(ARBITRARY CONSTRAINTS).
Let W be a control  ow graph W and     CONST R be a set of global ( jP rim) where constraints in the conjunctive normal form P rim   PRIMIT IVE.
Let |W| denote the size of W, N be the number of constraints in  , and d be the largest number of disjuncts in a primitive constraint in  .
Then the worst-case size of W  is O(dN |W|), and the time complexity is O(dN |W|2).
Cycle detection and removal.
We can still improve the above transformation by eliminating certain  useless  parts of W the parts that will never be executed.
The problem is that even though W  is an executable work ow speci cation, W  may have sub-formulas where the send/receive primitives cause a cyclic wait.
This means that those parts of W  can never be involved in an execution.
Fortunately, we can show that all cyclic waits can be removed from W in time O(|W|3).
Example 6.
(Cyclic Wait Removal) Let W be (a  b)  (c(cid:4) d) and   be ( c    a).
Our algorithm transforms W     into (a   receive( ) b) (c(cid:4)(send( ) d)).
Now, if the reasoner chooses b, a deadlock occurs.
However, we can rewrite this formula into a behaviorally equivalent formula a  (c(cid:4) d) and avoid the problem.
We presented a novel formalism, CT RS, for modeling the dynamics of service contracts.
CT RS is a logic in which service contracts are represented as formulas that specify the various choices that are allowed for the parties to the contracts.
The logic permits the reasoner to state the desired outcomes of the contract execution and verify that a desired outcome can be achived no matter what the other parties do as long as they obey the rules of the contract.
There is a body of preliminary work trying to formalize the representation of Web service contracts [20, 11], but none deals with the dynamics of such contracts, which is the main subject of this paper.
Technically, the works closest to ours come from the  elds of model checking and game logics.
Process algebras and alternating temporal logic [7, 1] have been used for modeling open systems with game semantics.
Model checking is a standard mechanism for verifying temporal properties of such systems and deriving automata for scheduling.
In [16], the complexity and size of computing the winning strategies for in nite games played on  nite graphs are explored.
A result analogous to ours is obtained for in nite games: assuming the size of the graph is Q and the size of the winning condition is W , the complexity of computing winning strategies is exponential in the size of W and polynomial in the size of the set Q.
 cation algorithm than what one would get using model checking.
Indeed, standard model checking techniques [7, 1] are worst-case exponential in the size of the entire formula and the corresponding scheduling automata are also exponential.
This is often referred to as the state-explosion problem.
In contrast, the size of our solver is linear in the size of the original work ow speci cation and exponential only in the size of the constraint set (Theorem 3), which is a much smaller object.
In a sense, our solver can be viewed as a specialized and more ef cient model checker for the problem at hand.
It accepts high level speci cations of work ows and yields strategies and schedulers in the same high level language.
Logic games have been proposed before in other contexts [13,
 that the reasoner has a winning strategy against the opponent.
In CT RS however, games, winning conditions, and strategies are themselves logical formulas (rather than modal operators).
Logical equivalence in CT RS is a basis for constructive algorithms for solving games and synthesizing strategies, which are in turn executable by the proof theory of CT RS. Related game logic for-malisms, such as [13, 19], only deal with assertions about games and their winning strategies.
In these logics, games are modalities rather than executable speci cations, so they can only be used for reasoning about Web service contracts, but not for modeling and executing them.
Related work in planning, where goals are expressed as temporal formulas, includes [3].
In [3], plans are generated using a forward chaining engine that generates  nite linear sequences of actions.
As these linear sequences are generated, the paths are incrementally checked against the temporal goals.
This approach is sound and complete.
However, in the worst case it performs an exhaustive search of the model similar to the model checking approaches.
For the future work, we are planning to extend our results to allow contracts that include iterative behaviour.
Such contracts can already be speci ed in CT RS.
However, iteration requires new veri cation algorithms to enable reasoning about the desired outcomes of such contracts.
