In the peer-to-peer (p2p) model, systems are composed of an open-ended and dynamic network of peers, which share data, computational resources, etc; peers are usually autonomous or semi-autonomous, and may cooperate together in the execution of tasks or in the hosting and querying of data.
In the  eld of database research, p2p systems a rmed as an interesting evolution of past distributed and integration systems.
Several ongoing projects focus on the design of p2p database systems, mostly for XML data.
One missing point in the current research about p2p XML databases is the de nition of a proper query algebra.
Existing query algebras, most notably the o cial algebra by W3C [2], have been de ned in the context of static and centralized database systems, and cover issues ranging from query result analysis and query type-checking to the rigorous de nition of the statical and dynamic semantics of XML query languages.
As a consequence, they lack support for key issues in p2p database systems, such as: the dissemination of data over multiple peers, which may appear and disappear unpredictably; the replication of data in multiple copies, which have a limited time validity; and the dynamic nature of data distribution and replication.
This paper shortly describes a query algebra for XML p2p databases.
The proposed algebra supports the FLWR core of XQuery, and, unlike existing query algebras for XML data, provides explicit mechanisms for modeling data dissemination and replication constraints: in particular, the algebra data model incorporates the notion of locations, which model peer content, as well as the notion of data freshness; moreover, the algebra provides operators for manipulating locations, and for expressing replication constraints.
Copyright is held by the author/owner(s).
Data in the system are represented as unordered forests of node-labeled trees.
According to the term grammar shown below, each node (n) has a unique object identi er (oid) that can be accessed by the special-purpose function oid, and is augmented with the indication of the hosting peer (location in the following) as well as with a freshness parameter f r, which indicates when the last update on the node was performed (  indicates that the freshness is unde ned).
| n t ::= t1, .
.
.
, tn | n[t] n ::= (oid, loc, f r)label loc : (dbname   t, (dbname, loc)   t) where label    , f r   N   { }, and loc1 and loc2 are partial functions.
trees nodes locations Locations model the content of peers, hence they are represented as a pair of partial functions: the  rst function (loc1) returns, for each database identi er, the trees contributed to the database by the given peer, if any; the second function (loc2), instead, describes the replication services offered by a given peer, i.e., it returns, for each database iden-ti er and location, the replicated trees for such database and location, if any.
Replicas are further described by a (distributed) set replicas, which contains dynamic replication constraints.
A replication constraint has the form (loc1, loc2, db,  1,  2), and it states that loc2 replicates the content of loc1 for the database db from time  1 to time  2 ( 2 may assume the special value  , which indicates that the replica is always kept up to date); given the dynamic nature of the system, we expect replication constraints to evolve over time.
The set of locations containing data relevant for a given database db is returned by the function Locs.
We expect Locs to be computed during the generation of the query plan; as usual in p2p systems, the computed set Locs will be a subset of the set of all relevant locations, or, even worst, a partially overlapping set.
The algebra exploits relational-like intermediate structures, called Env, to accumulate variable bindings collected during query evaluation.
Env structures, represented as node-labeled trees conforming to the algebra data model, are manipulated by quite traditional operators, such as Selection, P rojection, T upJoin, DJoin, M ap, and GroupBy.
In addition to these operators, the algebra features location operators, used for manipulating locations, and border operators, used for performing conversions from data model instances to Env structures, and vice versa.
that each query has two time parameters: the query issuing time  0, and the maximum replica time  0 , which indicates that replication constraints of the form (loc1, loc2, db,  1,  2) with  2 >  0    0 can be considered during query plan generation.
path and return The main task of the path operator is to extract information from the database, and to build variable bindings.
The way information is extracted is described by an input  lter ; a  lter is a tree, describing the paths to follow into the database (and the way to traverse these paths), the variables to bind and the binding style, as well as the way to combine results coming from di erent paths.
While the path operator extracts information from existing XML documents, the return operator uses the variable bindings of an Env to produce new XML documents.
return takes as input an Env structure and an output  lter, i.e., a skeleton of the XML document being produced, and returns a data model instance (i.e., a well-formed XML document) conforming to the  lter.
This instance is built up by  ll-ing the XML skeleton with variable values taken from the Env structure: this substitution is performed once per each tuple contained in the Env, hence producing one skeleton instance per tuple.
Operators on locations are crucial for retrieving data coming from multiple peers, and for exploiting, if necessary, replicas of the content of some location.
The query algebra o ers two location operators: LocU nion, and Choice.
LocU nion ( ) takes as input two locations loc1 and loc2, and it returns a new location obtained by uniting the content and the replica functions of the arguments.
LocU nion is primarily used for expressing queries retrieving data from multiple peers, as shown by the following Example.
Example 1.
Consider a real-estate market database, and assume that locations loc1, loc11, loc13, and loc17 share data about buildings.
Suppose that you want to retrieve the price and the description of each building in the database, as shown below: for $b in input()//building, $d in $b/desc, $p in $b/price return <entry> {$d, $p} </entry> This query can be expressed by the following algebraic expression: returnentry[ $d, $p]( path(//,$b,in)building[(/,$d,in)desc[ ]](( i=1,11,13,17loci)1(db1))) The Choice (|  sulate replication constraints into query plans.
loc1 |  indicates that loc2 replicates loc1 permitted, it can serve requests for data in loc1 consequence, loc1 |  tions concerning db) as loc1 or as loc2 example shows the use of Choice.
db) operator is a convenient way to encap-db loc2 1(db) until time  , so, if
 db loc2 can be rewritten (in path opera-
Example 2.
Consider the query of the previous example, and assume that loc11(db1) is replicated at loc17 till time  ; furthermore, assume that the query was submitted at time  0 so that  0 <  .
Then, the query can be expressed by the following algebraic expression: returnentry[ $d, $p]( path(//,$b,in)building[(/,$d,in)desc[ ],(/,$p,in)price[ ]]( (loc1   (loc11 |  db1 loc17)   loc13   loc17)1(db1)))

 Four main classes of algebraic rewriting rules can be applied to the XPeer query algebra: classical equivalences inherited from relational and OO algebras; path decomposition rules, which allows the query optimizer to break complex input  lters into simpler ones; equivalences for query unnesting; and,  nally, rewriting rules for location operators.
For the sake of brevity, only the rules for location operators will be shown in this paper.
Three main rewriting rules can be applied to location operators: extrusion of LocU nion operations from path operations; simpli cation of Choice operators; and introduction of Choice operations.
and loc2, it holds that: Proposition 1.
Given a database db disseminated on loc1 pathf ((loc1 loc2)1(db)) = pathf ((loc1)1(db)) pathf ((loc2)1(db)) This property states that LocU nion operations inside path operations can be split and distributed across the query; this, in turn, allows the system to more easily decompose a query in single-location subqueries.
Proposition 2.
Given a database db hosted at loc1 and replicated at loc2, it holds that: db loc2)1(db)) = pathf (loc1 db loc2)1(db)) = pathf (loc2 pathf ((loc1 |  pathf ((loc1 |  This property shows how a Choice operation inside a path operation can be rewritten; we expect that this rewriting will be guided by additional information about network conditions, peer computing power, etc.
1(db)) 2(loc1)(db)) Proposition 3.
Given a database db, if (loc1, loc2, db,  1,  2)   replicas, and  2 >  0    0 , then loc1 loc2)1(db) 1(db)   (loc1 | 2 db   replicas, and  2 >  0    0 , then Corollary 1.
Given a database db, if (loci, locj, db,  1,  2) pathf ((loc1 loci)1(db))   pathf ((loc1 (loci | 2 db locj))1(db)) These properties back the introduction of Choice operations in query plans.
This paper presented a query algebra for XML p2p databases.
The query algebra features mechanisms for modeling data dissemination and replication, and for incorporating replication constraints into query plans.
The proposed algebra can be used for expressing query plans, as well as for formally reasoning about query semantics in a p2p environment, and, in particular, for investigating correctness and completeness properties of query results.
