With an increasing number of organizations putting their business competencies as a collection of web services, it is conceivable that other users could integrate them to create new value-added services in ways that were not anticipated by their original developers.
The assembly of services currently requires considerable manual intervention, including examination of the API descriptions of services, and writing of specific code to chain a sequences of services using attributes in the I/O descriptions of services.
Semantic schema matching used earlier for data schemas [4,6] can also be applied to APIs allowing automatic orchestration relieving the burden of programming by end users.
It can also enable automatic service composition when augmented with service discovery techniques [1,3,5,8].
In this paper, we focus on the automatic matching of API descriptions of services.
This is a difficult problem, in general, as the relationship between attributes may not be obvious from their names, types and structural grouping of attributes.
Furthermore, a source attribute may be split across multiple destination attributes & vice versa.
We now formulate the problem of semantic match of the APIs of a set of services.
The source and target attributes can be regarded as the nodes of a bipartite graph.
Their correspondence is then a matching in the bipartite graph.
If the weights on the edges of the bipartite graph reflect the similarity of the attributes, the optimal matching is a matching of maximum cardinality and maximum weight.
The semantic schema matching approach, therefore, is to reflect the knowledge of API variables in determining similarity of attributes and use a conventional maximum matching algorithm.
Specifically, we used the algorithm of Goldberg and Kennedy[2].
In this algorithm, the matching is computed by setting up a flow network with weights such that the maximum flow corresponds to a maximum matching [2].
We derive the similarity between attributes using four sets of cues, namely, (1) lexical name matching, (2) semantic name matching, (3) type matching, and (4) structural matching.
Due to space limitations, we will expand on semantic similarity while briefly describing other similarity metrics used.
The lexical similarity measure captures the similarity in the spelling of names used in APIs (eg. lname, lastname) and is measured as L(A,B) = 2 * Length(LCS(A,B))/(Length(A) + Length(B)) (1) Where A,B are the attributes, and LCS(A,B) is longest common subsequence of A and B.
Type matching: For APIs the type of attributes is a strong cue in matching, for without proper type casting, the service cannot be launched.
The type similarity measure is given by: Type(A,B) = 1.0 (lossless conversion), = 0.5 (lossy), = 0 (otherwise) (2) Where the lossless conversion is determined by navigating the reference type hierarchy of a language (eg. int to float is lossless, while float to int is lossy).
The existence of an explicit type casting function (eg. 2d array to 1d vector converter code) is also a case of lossless conversion.
Structural matching: Using the rationale that the grouping of attributes under a node of a particular height in the API schema denotes a concept abstraction used by programmers, the structural similarity is measured by Struct(A,B) = 1 - (|D(A) -D(B)|)/max{D(Gi), D(Gj)} (4) where D(A) and D(B) are the height of the attributes in their respective schema trees Gi and Gj and D(Gi) and D(Gj) are the heights of the trees Semantic Name Similarity: The semantic name similarity is computed using a technique similar to the one in [4], in that, we parse the words to extract tokens and find ontological similarity in the tokens.
The parsing uses and abbreviation expansion to generate list of candidate words.
Thus CustomerPurchase will be separated into Customer and Purchase.
The tokenization uses font changes, underscores, spaces and other separating characters.
Abbreviations such as CustPurch will be expanded into CustomerPurchase, CustomaryPurchase, etc, using a domain-dependent abbreviation expansion dictionary generated a priori.
Filtering removes stop words and part-of-speech tagging classified words as nouns, adjectives, etc.
The resulting words are then used to index an ontology (we use Wordnet Thesaurus[7]) to obtain a list of synonyms.
Let each pair of source and destination attributes (A,B) have m and n valid tokens and let Si and Sj be their expanded lists based on ontological processing.
We consider each token i in source attribute A to match a token j in destination attribute B if i   Si or j   Si.
The candidate matches again form a small bipartite graph in which each edge has flow of unit 1 (Note this graph is different from the API match graph described earlier).
The maximum cardinality matching in this graph then denotes the best set of matching word tokens.
The semantic name similarity measure is then given as Sem(A,B) = 2*MaxMatch(A,B)/(m + n) (4) The semantic similarity allows us to match attributes such as (state,province), ClientID), (CustomerClass, ClientCategory), etc.
Th overall cost function for computing the edge cost is then tokenization, part-of-speech (CustomerIdentification, tagging, filtering 436that C(A,B)=  1 * L(A,B)+ 2 * Sem(A,B) +  3 * Type(A,B) +  4 * Struct(A,B) (5) The weights ( 1,2,3,4) are chosen to be step functions with value = 1.0 until a lower threshold is reached.
Thus  1=0.0 for L(A,B) < 0.9 (since lexical similarity is a good indication of relationship for only high-scoring matches), and  2 = 0.0 for Sem(A,B) < 0.67,  3 = 0.0 for Type(A,B) < 0.5,  4 = 0.0 for Struct(A,B) < 0.5.
The thresholds were derived by computing the similarity per cue for the actual mapping indicated by programmers for integration of candidates services used for testing and taking their average value.
We tested the performance of semantic schema matching on 240 distinct pairs of web services drawn from Crossworlds business object library.
The business objects tend to have a larger number of member attributes (over 100), so the algorithm performance could be gauged on large schemas.
We then measured the performance by comparing to a manual match of the attributes of the respective schemas.
The number of spurious (false positives) as well as missing matches (false negative), were noted in each pairwise match.
Table 1 illustrates the matching similarly, for a pair of ADTs depicted in Figure 1.
Here a web service that provides a description of an inventory item is chained with a web service that retrieves vendor information associated with the inventory item.
A match of InventoryType and StockType has been aided by semantic name matching, while abbreviation expansion has allowed match of InvLocationID to InventoryLocationID Representative performance for a sampling of web services is illustrated in Table 2.
Overall, the system erred on the side of making false positives and was able to maintain a matching accuracy in the range of 75-85%.
In this paper, we have presented an approach to semantically match two API schemas to enable the chaining of their associated services.
Building automation into this task enables scalable deployable solutions in the world of internet where the web services are being added at a rapid pace.
