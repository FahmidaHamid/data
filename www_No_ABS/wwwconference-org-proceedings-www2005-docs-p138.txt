Web services are emerging as a promising technology for automating B2B interactions.
Nowadays, enterprises are Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
able to outsource their internal business processes as services and make them accessible via the Web.
Then they can dynamically combine individual services to provide new value-added services.
A main problem that remains is how to ensure a correct composition and a reliable execution of a composite service (CS) with regards to partners transactional requirements.
Despite growing interest, Web services middleware is still rather primitive in terms of functionality, far from what current EAI middleware can provide for intra-enterprise applications [2].
The current Web services technologies ensure communication interoperability which is a part of the problem when considering the building of reliable Web services compositions [16].
Indeed, unlike activities in traditional work(cid:13)ows, services are de(cid:12)ned independently of any computing context.
Thereafter, the task of building composite Web services requires mechanisms to deal with the inherent autonomy, and heterogeneity of Web services.
Although powerful, Advanced Transaction Models (ATMs) [6] are found lacking functionality and performance when used for applications that involve dynamic composition of heterogenous services in a peer-to-peer context.
Their limitations come mainly from their in(cid:13)exibility to incorporate di(cid:11)erent transactional semantics as well as different interactions patterns into the same structured transaction [8].
In this paper, we propose a transactional approach for reliable Web services compositions by ensuring the failure atomicity required by the designers.
From a transactional point of view, we consider a CS as a structured transaction, Web services as sub transactions and interactions as inter sub transactions dependencies.
We use the Accepted Termination States (ATS) property as a correctness criteria to relax atomicity.
To the best of our knowledge, de(cid:12)ning a transaction with a particular set of properties, in particulary ATS, and ensuring that every execution will preserve these properties remains a di(cid:14)cult and open problem [18].
The paper is organized as follows.
Section 2 introduces a motivating example and gives the main points which has driven our approach.
In section 3, we explain the notion of transactional web service and show how we express its trans-actional properties.
Section 4 presents the notion of Trans-actional Composite (Web) Service (TCS) and explains our transactional point of view.
Section 5 presents the notion of Accepted Termination States (ATS) as a mean to express the required failure atomicity.
Section 6 illustrates how our approach proceeds (using a set of transactional rules) to assist designers to compose valid TCSs.
In section 7, we discuss some related work.
Section 8 concludes our paper.
Let us (cid:12)rst present a motivating example.
We consider an application dedicated to the online purchase of personal computer.
This application is carried out by a composite service as illustrated in (cid:12)gure 1.
Services involved in this application are: the Customer Requirements Speci(cid:12)-cation (CRS) service used to receive the customer order and to review the customer requirements, the Order Items (OI) service used to order the computer components if the online store does not have all of it, the Payment by Credit Card (PCC) service used to guarantee the payment by credit card, the Computer Assembly (CA) service used to ensure the computer assembly once the payment is done and the required components are available, and the Deliver Computer (DC) service used to deliver the computer to the customer (provided either by Fedex (DCF ed) or TNT
 Figure 1: A composite service for online computer purchase.
When a user designs a composite service, he expects the service execution to be reliable.
That means he particularly pays attention to failure handling.
In our example, the designer may want to be sure: that one of the two delivery services will succeed, that the service CA is sure to complete, and that it is possible for the service OI to undo its e(cid:11)ects (for instance when the payment fails).
These properties de(cid:12)ne what we call the transactional behavior of the service.
This behavior is speci(cid:12)ed using a set of transactional requirements.
Since these requirements may vary from one context to another, the transactional behavior will vary too.
For instance, a designer may accept the failure of the DCF ed service in a context, while in another one he may not tolerate such a failure at such an advanced stage.
So the mean of a reliable execution is tightly related to transactional requirements and it may vary according to designers.
In the same time, in order to ensure a reliable execution, we have to be sure that a speci(cid:12)ed transactional behavior is consistent with the set of selected services and the trans-actional requirements.
Back to our example, we can easily notice that since the OI service is not sure to complete, the payment service PCC have to be compensatable (and it must be compensated when the OI service fails).
The following points introduce our approach and its concepts for supporting this kind of scenarios.
scription for a better characterization of their transactional behavior.
This can be done by enhancing WSDL interface with transactional properties.
Second, we have to model services composition and choreography, in particular mechanisms for failure handling and recovery.
Third, we have to provide designers with a mean to express their transactional requirements, in particular their required failure atomicity level.
Finally, we have to support composite service validation with regards to designers  requirements.
In the rest of the paper we detail each of these issues and especially our set of transactional management rules for composite service validation.
A Web service is a self-contained modular program that can be discovered and invoked across the Internet.
Web services are typically built with XML, SOAP, WSDL and UDDI speci(cid:12)cations [4] [17].
A transactional Web service is a Web service that emphasizes transactional properties for its characterization and correct usage.
The main transactional properties of a Web service that we are considering are retriable, compensatable and pivot [14].
A service s is said to be retriable if it is sure to complete after several (cid:12)nite activations.
s is said to be compensatable if it o(cid:11)ers compensation policies to semantically undo its e(cid:11)ects.
Then, s is said to be pivot if once it successfully completes, its e(cid:11)ects remains for ever and cannot be semantically undone.
Naturally, a service can combine properties, and the set of all possible combinations is fr; cp; p; (r; cp); (r; p)g.
In order to model the internal behavior of a service, we have adopted a states/transitions model.
A service has a minimal set of states (initial, active, aborted, cancelled, failed and completed ), and it also includes a set of transitions (activate(), abort(), cancel(), fail(), and complete()).
The (cid:12)gure 2.a shows the internal states/transitions diagram of a pivot service.
When a service is instantiated, the state of the instance is initial.
Then this instance can be either aborted or activated.
Once it is active, the instance can normally continues its execution or it can be cancelled during its execution.
In the (cid:12)rst case, it can achieve its objective and successfully completes or it can fail.
The requested transactional properties can be expressed by extending the service states and transitions.
For instance, for a compensatable service, a new state compensated and a new transition compensate() are introduced (e.g., service in (cid:12)gure 2.b).
Figure 2 illustrates the states/transitions diagram of a retriable service ((cid:12)gure 2.c) and states/transitions diagrams of services combining di(cid:11)erent transactional properties ((cid:12)gures 2.d and 2.e).
Within a transactional service, we also distinguish between external and internal transitions.
External transitions are (cid:12)red by external entities.
Typically they allow a service to interact with the outside and to specify composite services choreographies (see next section).
The external transitions we are considering are activate(), abort(), cancel(), and compensate().
First, we believe that we must enhance Web services de-Internal transitions are (cid:12)red by the service itself (the ser-Figure 2: Services states/transitions diagrams according to di(cid:11)erent transactional properties.
vice agent).
Internal transitions we are considering are complete(), fail(), and retry().
A composite Web service is a conglomeration of existing Web services working in tandem to o(cid:11)er a new value-added service [13].
It coordinates a set of services as a cohesive unit of work to achieve common goals.
A Transactional Composite (Web) Service (TCS) emphasizes transactional properties for composition and synchronization of component Web services.
It takes advantage of services transactional properties to specify mechanisms for failure handling and recovery.
A TCS de(cid:12)nes services orchestration by specifying dependencies between services.
They specify how services are coupled and how the behavior of certain service(s) in(cid:13)uence the behavior of other service(s).
Definition 4.1 (Dependency from s1 to s2).
A dependency from s1 to s2 exists if a transition of s1 can (cid:12)re an external transition of s2.
A dependency de(cid:12)nes for each external transition of a service a precondition to be enforced before this transition can be (cid:12)red.
In our approach, we consider the following dependencies between services: Activation dependency from s1 to s2: There is an activation dependency from s1 to s2 if the completion of s1 can (cid:12)re the activation of s2.
We can tailor activation dependencies between services by specifying the activation condition, ActCond(s), of each service s. ActCond(s) de(cid:12)nes the precondition to be enforced before the service s can be activated (only after the completion of other service(s)).
There is an activation dependency from s1 to s2 if f s1:completed 2 ActCond(s2).
Reciprocally for each service s1 2 ActCond(s2), there is an activation dependency from s1 to s2 according to ActCond(s2).
For example, the composite services de(cid:12)ned in (cid:12)gure 3 de(cid:12)ne an activation dependency from OI and P CC, to CA such that CA will be activated after the completion of OI and P CC.
That means ActCond(CA) = OI:completed V P CC:completed.
Alternative dependency from s1 to s2: There is an alternative dependency from s1 to s2 if the failure of s1 can (cid:12)re the activation of s2.
We can tailor alternative dependencies between services by specifying the alternative condition, AltCond(s), of each service s. AltCond(s) de(cid:12)nes the precondition to be enforced before the service s can be activated as an alternative of other service(s).
There is an alternative dependency from s1 to s2 if f s1:f ailed 2 AltCond(s).
Reciprocally for each service s1 2 AltCond(s2), there is an alternative dependency from s1 to s2 according to AltCond(s2) For instance the composite service cs1 in (cid:12)gure 3.b de(cid:12)nes an alternative dependency from DCF ed to DCT N T such that DCT N T will be activated when DCF ed fails.
That means AltCond(DCT N T ) = DCF ed:f ailed.
Abortion dependency from s1 to s2: There is an abortion dependency from s1 to s2 if the failure, cancellation or the abortion of s1 can (cid:12)re the abortion of s2.
We can tailor abortion dependencies between services by specifying the abortion condition, AbtCond(s), of each service s. AbtCond(s) de(cid:12)nes the precondition to be enforced before the service s can be aborted.
There is an abortion dependency from s1 to s2 if f s1:aborted 2 AbtCond(s2)) W s1:f ailed 2 AbtCond(s2) W s1:cancelled 2 AbtCond(s2).
Reciprocally for each service s1 2 AbtCond(s2), there is an abortion dependency from s1 to s2 according to AbtCond(s2).
Compensation dependency from s1 to s2: There is Figure 3: Two composite services de(cid:12)ned according to the same skeleton.
a compensation dependency from s1 to s2 if the the failure or the compensation of s1 can (cid:12)re the compensation of s2.
We can tailor compensation dependencies between services by specifying the compensation condition, CpsCond(s), of each service s. CpsCond(s) de(cid:12)nes the precondition to be enforced before the service s can be compensated.
There is a compensation dependency from s1 to s2 if f s1:f ailed 2 CpsCond(s2) W s1:compensated 2 CpsCond(s2).
Reciprocally for each service s1 2 CpsCond(S2), there is a compensation dependency from s1 to s2 according to CpsCond(s2).
Composite services in (cid:12)gure 3 de(cid:12)ne a compensation dependency from P CC to OI such that OI will be compensated when P CC fails.
That means CpsCond(OI) = PCC.failed.
Cancellation dependency from s1 to s2: There is a cancellation dependency from s1 to s2 if the failure of s1 can (cid:12)re the cancellation of s2.
We can tailor cancellation dependencies between services by specifying the cancellation condition, CnlCond(s), of each service s. CnlCond(s) de(cid:12)nes the precondition to be enforced before the service s can be cancelled.
There is a cancellation dependency from s1 to s2 if f s1:f ailed 2 CnlCond(s2).
Reciprocally for each service s1 2 CnlCond(s2), there is from s1 to s2 according to a cancellation dependency CnlCond(s2).
Composite services in (cid:12)gure 3 de(cid:12)ne a cancellation dependency from P CC to OI such that OI will be cancelled when P CC fails.
That means CnlCond(OI) = P CC:f ailed.
For clarity reasons, we do not deal with abortion dependencies.
We call transactional dependencies the compensation, cancellation and alternative dependencies.
Dependencies speci(cid:12)cation must respect some semantic restrictions.
Indeed, transactional dependencies depend on activation dependencies according to the following relations: R1 : An abortion dependency from s1 to s2 can exist only if there is an activation dependency from s1 to s2.
R2 : A compensation dependency from s1 to s2 can exist only if there is an activation dependency from s2 to s1, or s1 and s2 execute in parallel and are synchronized.
R3 : A cancellation dependency from s1 to s2 can exist only if s1 and s2 execute in parallel and are synchronized.
R4 : An alternative dependency from s1 to s2 can exist only if s1 and s2 are exclusive.
Section 4.4 shows how these relations de(cid:12)ne potential dependencies induced by given activation dependencies.
Within a transactional composite service, we distinguish between the TCS control (cid:13)ow and the TCS transactional (cid:13)ow.
Control (cid:13)ow: The control (cid:13)ow (or skeleton) of a TCS speci(cid:12)es the partial ordering of component services activa-tions.
Activation dependencies between component services de(cid:12)ne the corresponding TCS control (cid:13)ow.
We use (work(cid:13)ow-like) patterns to de(cid:12)ne a composite service skeleton.
As de(cid:12)ned in [7], a pattern \is the abstraction from a concrete form which keeps recurring in speci(cid:12)c non arbitrary contexts".
A work(cid:13)ow pattern can be seen as an abstract description of a recurrent class of interactions based on (primitive) activation dependency.
For example, the AND-join pattern [21] (see (cid:12)gure 3.a) describes an abstract services choreography by specifying services interactions as following: a service is activated after the completion of several other services.
Example: Figure 3.a illustrates a TCS skeleton de(cid:12)ned using an AND-split, an AND-join and an XOR-split patterns.
Transactional (cid:13)ow: The transactional (cid:13)ow of a TCS speci(cid:12)es mechanisms for failures handling and recovery.
Transactional dependencies (like compensation, cancellation and alternative) de(cid:12)ne the TCS transactional (cid:13)ow.
Several TCSs can be de(cid:12)ned based on a skeleton.
Each TCS adopts the activation dependencies de(cid:12)ned by the skeleton s patterns and may extend them by specifying additional transactional dependencies.
Example: Figure 3 shows two TCSs, cs1 and cs2, de-(cid:12)ned using the same skeleton.
Each of these TCSs adopts this skeleton ((cid:12)gure 3.a) and re(cid:12)nes it with an additional transactional (cid:13)ow.
Additional transactional dependencies are a subset of potential transactional dependencies de(cid:12)ned by the skeleton s patterns.
Indeed, a pattern de(cid:12)nes in addition to the default activation dependencies, a set of potential transactional dependencies.
A potential dependency is a dependency that is not initially de(cid:12)ned by the pattern but that can be added by TCSs using this pattern.
Potential dependencies are directly related to the pattern s activation dependencies according to the relations we have introduced in section 4.2.
We have shown above that dependencies between services can be tailored by specifying preconditions on services  external transitions.
And potential transactional dependencies are not an exception to this fact.
So a TCS skeleton de(cid:12)nes for each service the potential conditions corresponding to the potential dependencies.
A pattern de(cid:12)nes for each service s it is connected with: (cid:15) ptCpsCond(s): its potential compensation condition, (cid:15) ptAltCond(s): its potential alternative condition, (cid:15) ptCnlCond(s): its potential cancellation condition.
We can write each of these conditions in exclusive disjunctive normal form.
For instance, we can write the potential compensation condition of a service s as follows: ptCpsCond(s) = Li ptCpsCondi(s).
Then ptCpsCondi(s) is one potential compensation condition of s.
Example: The TCS skeleton illustrated in (cid:12)gure 3.a uses an AND-join pattern to de(cid:12)ne activation dependencies between services OI, P CC and CA.
According to the relation R2 given in section 4.2, a TCS based on this skeleton can eventually speci(cid:12)es the following compensation dependencies: from CA to OI and from CA to P CC.
Similarly, according to the relation R3, this pattern de(cid:12)nes the following potential cancellation dependencies: from OI to P CC, and from P CC to OI.
That means, among other, that ptCp-sCond(PCC)=OI.failed L CA.failed L CA.compensated and ptCnlCond(OI)=PCC.failed.
from OI to P CC, from P CC to OI, In the same way, according to the relation R4, the XOR-split pattern connecting CA, DCF ed and DCT N T de(cid:12)nes the following potential alternative dependencies: from DCT N T to DCF ed and from DCF ed to DCT N T .
That means that ptAltCond(DCT N T ) =DCF ed:f ailed and that DCT N T :f ailed = ptAltCond(DCF ed).
Finally, note that both TCSs cs1 and cs2 de(cid:12)ne their transactional (cid:13)ow as a subset of the potential transactional (cid:13)ow presented above.
Both de(cid:12)ne compensation and cancellation dependencies from P CC to OI.
cs1 de(cid:12)nes an alternative dependency from DCF ed to DCT N T .
Several executions can be instantiated according to the same TCS.
The state of an instance of a TCS composed of n services is the tuple (x1, x2, ..., xn), where xi is the state of service si at a given time.
The set of termination states of a TCS cs, ST S(cs), is the set of all possible termination states of its instances.
Back to our motivating example limited to the three services CRS, OI and P CC, we can have the following set of termination states: (CRS.completed, OI.completed, PCC.co-mpleted ); (CRS.completed, OI.failed, PCC.completed ); (CRS.completed, OI.completed, PCC.failed ); (CRS.compen-sated, OI.failed, PCC.initial ); (CRS.compensated, OI.initial, PCC.failed ); (CRS.compensated, OI.failed, PCC.failed ).
In order to express the designer s requirements for failure atomicity, we use the notion of Accepted Termination States ([18]).
In other word, the concept of ATS represents our notion of correction.
Definition 5.1 (Accepted Termination States).
An accepted termination state, ats, of a composite service cs is a state for which designers accept the termination of cs.
We de(cid:12)ne AT S the set of all Accepted Termination States required by designers.
An execution is correct if f it leads the CS into an accepted termination state.
A CS reaches an ats if (i) it completes successfully or (ii) it fails and undoes all undesirable e(cid:11)ects of partial execution in accordance with designer failure-atomicity requirements [18].
Back to our example, a designer may choose the following ATS: ATS(CS)=f(CRS.completed, OI.completed, PCC.co-mpleted); (CRS.compensated, OI.failed, PCC.failed)g that means that an execution is correct when all of the services complete, or when CRS is compensated (given the failure of OI and P CC).
Obviously, we note that a composite service transactional behavior may vary according to the required


 To explain the rules and to illustrate how they are working, we go back to our motivating example of personal computer online purchase.
We suppose in addition that designers specify the AT S illustrated in the (cid:12)gure 5 to express their required failure atomicity.
Intuitively, the execution of a composite service can generate various termination states.
A composite service is not valid if it exists some termination states that do not belong to the ATS speci(cid:12)ed by the designers.
Definition 6.1 (Validity according to an AT S).
A CS cs is said to be valid according to AT S i(cid:11) its set of termination states is included in AT S, written ST S(cs) (cid:18)
 Example: The composite service cs1 (illustrated in (cid:12)gure
 ing the composite service cs2 (illustrated in (cid:12)gure 3.c), we Initial TCS definition Designers Transactional properties computing Computer Valid TCS composition Pick up some services Compose them using pattern Extend pattern with additional dependencies Specify the required ATS ATS = {A.completed, } We use(cid:201) Transactional validity rules to compute(cid:201) Transactional properties to ensure The appropriate transactional behavior for valid TCSs No Is the initial TCS valid ?
Yes Select new services An engine dynamically ensures the compliance with the generated transactional properties Specify new additional dependencies Execution engine Execution of the TCS with the appropriate transactional behavior Figure 4: Objective and overview of our approach.
Figure 5: ATS used in our example of PC online purchase.
note that ST S(cs2) contains the following termination state, (CRS:completed; OI:f ailed; P CC:completed; CA:aborted; DCF ed:aborted; DCT N T :aborted), which is not an accepted termination state.
Thereafter cs2 is not valid.
As illustrated in (cid:12)gure 4, our approach applies in a top-down manner.
De(cid:12)nition of an initial TCS: First, designers dynamically choose some available services and combine them to o(cid:11)er a new value added service.
They compose the new service using a set of interactions patterns (sequence, AND-split, AND-join,...).
They can augment this skeleton by new dependencies selected from the potential dependencies.
Then they express their required failure atomicity by specifying the required
 Compute validity transactional properties: We use a set of rules, independent from skeletons and designers  ATS, to compute from the TCS skeleton and the required ATS a set of transactional properties.
These transactional properties tailor the appropriate trans-actional behavior for valid TCSs.
A TCS must satisfy these transactional properties to be valid.
De(cid:12)nition of a valid TCS: If the initial TCS is not valid, designers can (i) select new services (with eventually new transactional properties) and (ii) augment the same skeleton with new dependencies.
During this phase an engine assist designers to compose a valid TCS by respecting the generated transactional properties.
Once a valid TCS is reached, it can be deployed and executed.
Tailoring the appropriate transactional behavior for valid composite services is equivalent to identify the appropriate is the only ats in which OI is cancelled.
Furthermore, the potential cancellation condition of OI, P CC:f ailed is sat-is(cid:12)ed in ats5.
Then we can deduce that atsCnlCond(s) = P CC:f ailed.
Finally, we can deduce in the same way, from ats6 and ptAltCond(DCT N T ), that atsAltCond(DCT N T ) = DCF ed:f ailed.
It is important to note that the ATS speci(cid:12)ed by the designers must be consistent with the pattern semantics.
An ATS is consistent if it satis(cid:12)es the following two conditions.
First, each of its ats must be well-formed.
An ats 2 AT S is not well-formed if it exists a service s such that none of its potential (or activation) conditions (corresponding to its state in ats) is satis(cid:12)ed (in ats).
We can easily modify the previous algorithm to detect if it exists a not well-formed ats 2 AT S.
Second, the set of all ats must be consistent.
Such inconsistency can be detected after the generation of transactional properties ensuring CSs validity.
For instance given the following termination state (limited to the three services OI, P CC and CA) ts = (OI.completed, PCC.compensated, CA.aborted), we note, among other, that none of the service P CC potential conditions (OI:f ailed, CA:f ailed and CA:compensated) is satis(cid:12)ed in ts.
So we can deduce that ts is not well-formed.
To illustrate an ATS inconsistency, let us consider the following ATS=fats1 = (OI.completed, PCC.completed, CA.co-mpleted); ats2 = (OI.completed, PCC.failed, CA.aborted); ats3 = (OI.compensated, PCC.failed, CA.aborted)g. Note that ats1 and ats2 are contradictory because the service OI once it is completed (in ats2) and once it is compensated (in ats3) for the same condition (P CC:f ailed V CA:aborted).
Thereafter the given ATS is not consistent although each of its ats is well-formed.
An AT S also de(cid:12)nes the accepted termination states of each component service.
We denote AT S(s) the set of accepted termination states of a component service s. Regarding our illustrative example, we can deduce, for instance, that ATS(PCC) = fcompleted, failed, compensatedg and ATS(CA) = fcompleted, abortedg.
We can now introduce validity rules we are using to generate transactional properties that ensure validity (we suppose that 3F means that F is eventually true):

 actional property T P r s : s must be retriable
 s : there is no need for s to transactional property T P p be compensatable
 lowing transactional property T P cpi
 s : (a) s must be compensatable and (b) atsCpsCondi(s) 2 CpsCond(s).
lowing transactional property T P cli
 atsCnlCondi(s) 2 CnlCond(s).
s : Figure 6: The algorithm for extracting ATS compensation conditions of a service s from the speci(cid:12)ed ATS and the TCS skeleton.
dependencies between services.
We can deduce from the speci(cid:12)ed AT S and the TCS skeleton the services  conditions corresponding to these dependencies.
For each service s we distinguish (i) atsCpsCond(s), the AT S compensation condition deduced from AT S, (ii) the AT S cancellation condition, atsCnlCond(s), deduced from AT S, and (iii) atsAltCond(s), the AT S alternative condition deduced from AT S. Below, we explain how we can deduce these conditions.
The algorithm given in (cid:12)gure 6 allows to extract the ATS compensation condition for a given service s from the composite service skeleton and the required ATS.
The principle is: a potential compensation condition of s becomes an AT S compensation condition if it is satis(cid:12)ed in an ats 2 AT S such that the state of s in ats is compensated.
We proceed similarly to deduce AT S alternative and cancellation conditions of each service.
For instance in our example, the potential compensation condition of P CC, OI:f ailed, becomes an AT S compensation condition because it is satis(cid:12)ed in ats4 (in which the state of P CC is compensated).
And since ats4 is the only ats in which P CC is compensated then we can deduce that atsCpsCond(P CC) = OI:f ailed.
Similarly we can extract the AT S cancellation condition for OI.
ats5
 lowing transactional property T P ati
 : s The (cid:12)rst rule postulates that if the state failed does not belong to the AT S of s, then it exists a transactional property saying that s must be retriable.
The second rule postulates that if the state compensated does not belong to the AT S of s, then it exists a trans-actional property saying that there is no need for s to be compensatable.
The third rule postulates that for each ATS compensa-it exists a transaction condition of s, atsCpsCondi(s), tional property saying that: if this condition is eventually true then s must be compensatable and atsCpsCond(s) becomes a compensation condition of s. That means 8s0 2 atsCpsCondi(s) add a compensation dependency from s0 to s according to atsCpsCondi(s).
The fourth rule postulates that for each ATS cancellation condition of s, atsCnlCondi(s), it exists a transactional property saying that: if this condition is eventually true then atsCnlCond(s) becomes a cancellation condition of s. That means 8s0 2 atsCnlCondi(s) add a cancellation dependency from s0 to s according to atsCnlCondi(s).
The (cid:12)fth rule postulates that for each ATS alternative condition of s, atsAltCondi(s), it exists a transactional property saying that: if this condition is eventually true then atsAltCond(s) becomes an alternative condition of s. That means 8s0 2 atsAltCondi(s) add an alternative dependency from s0 to s according to atsAltCondi(s).
Example Back to our example, we can compute the following transactional properties: T P V (AT S; CSskeleton) = fTPr TP p DCT N T ; TP p OI ; TP cl1 CA; TP r P CC ; TP cp1 CA; TP p OI ; TP at1 CRS; TP p CRS; TP r ; TP cp1 DCF ed
 DCT N T g (cid:15) By applying the (cid:12)rst rule and since the state failed does not belong to AT S(CRS) we get the transac-tional property TPr CRS : CRS must be retriable.
Similarly, we can compute the following transactional properties: TPr
 DCT N T must be retriable.
CA : CA must be retriable and TPr (cid:15) By applying the second rule and since the state compensated does not belong to AT S(CA) we get the transactional property TP p CA : there is no need for CA to be compensatable.
Similarly we can compute the following transactional properties:TP p
 and TP p there is no need for CRS, DCT N T , DCF ed to be compensatable.
CRS, TP p DCF ed : (cid:15) By applying the third rule and since atsCpsCond(PCC)
 = OI.failed we get the transactional property TP cp1
 (a) P CC must be compensatable and (b) P CC must be compensated when OI fails.
(cid:15) By applying the third rule and since atsCpsCond(OI) = PCC.failed we get the transactional property TP cp1

 =) (a) OI must be compensatable and (b) OI must be compensated when P CC fails.
(cid:15) By applying the fourth rule and since atsCnlCond(OI) = PCC.failed we get the transactional property TP cl1

 =) OI must be cancelled when P CC fails.
(cid:15) By applying the (cid:12)fth rule and since DCF ed.failed = atsAltCond(DCT N T ) we get the transactional property TP At1 P CC : 3(DCF ed:f ailed) (means that DCF ed is not retriable) =) DCT N T must be activated when DCF ED fails.
The composite service cs1 veri(cid:12)es all the validity rules and thereafter it is valid.
However the composite service cs2 veri(cid:12)es all the validity rules except the Rcp1 P CC rule.
This rule postulates that if the compensation condition of P CC (which is the failure of OI) is eventually true (which is the case in cs2) then P CC must be compensatable and must be compensated when OI fails (which is not the case in cs2).
The composite service cs1 respects this rule since OI is sure to complete and thereafter never fails.
We use the following lemma (the proof is not shown due to lack of space).
Lemma A TCS termination state ts is not an accepted termination state if f 9 a service s such that (cid:15) the termination state of s in ts =2 AT S(s) or (cid:15) none of its ATS potential conditions (corresponding to its state in ts) is satis(cid:12)ed (in ts).
Proving that: (cs satis(cid:12)es all validity rules () cs is valid) is equivalent to proof that: (cs is not valid () 9 a rule such thats cs does not satisfy this rule).
1) =): cs is not valid means that it has a not valid termina- tion state.
That means (using the lemma above) either (a) it exists a service s which terminates in a not valid state or (b) it exists a service s which terminates in a valid state but without satisfying one of its ATS conditions corresponding to this termination state.
(a) means that cs does not verify the validity rules 1 or 2.
(b) means that cs does not verify one of the validity rules 3, 4 or 5.
1 or 2 then it exists a service s which will terminate in a non valid termination state.
(b) if cs does not verify one of the validity rules 3, 4 or 5 then it exists a service s which will terminate in a valid state without satisfying none of its corresponding ATS conditions.
(a) and (b) means that (using the lemma above) cs is not valid.
We are currently developing a prototype that supports this work.
Our prototype is written in Java.
The (cid:12)rst part of the prototype is the transactional engine.
It allows the user to select the services (with transactional properties), to de(cid:12)ne the TCS skeleton using patterns, and to specify the required ATS.
The engine uses the transac-tional rules to compute the appropriate transactional properties for valid TCSs.
Then, it assists designers to compose a valid TCS by respecting these transactional properties.
Window 1 of (cid:12)gure 7 shows how designers can choose services from the \Web services" scroll panel.
It typically shows the transactional properties of the chosen service.
Figure 7: A screen shot illustrating the application of our transactional approach.
Window 2 of (cid:12)gure 7 illustrates how designers can specify the TCS skeleton using patterns from the \operators" panel.
Finally, window 3 of (cid:12)gure 7 illustrates how the transac-tional engine computes the appropriate transactional properties from the required ATS.
The second part of the prototype is a work(cid:13)ow engine that is able to execute the composite service.
Our work-(cid:13)ow engine is Bonita, a work(cid:13)ow engine supported by the Object Web consortium ([20]).
Bonita is a cooperative work-(cid:13)ow system supporting the speci(cid:12)cation, the execution, the monitoring, and the coordination of the processes.
The main features of Bonita are: a third-generation work(cid:13)ow engine that can be parameterized by an activity model, a web interface to control work(cid:13)ow processes (accessing work(cid:13)ow methods as J2EE-based web services), an implementation using J2EE Enterprise Java Beans, the possibility to execute code in the server side for di(cid:11)erent events (e.g., start and cancel activities) by means of hooks (hooks can be for instance Java programs, and may be assigned to process and node events), and the availability of a graphical user interface to design and control work(cid:13)ow processes, based on Java JFC/Swing.
Of course, for our concern, the most interesting feature is related to the ability to de(cid:12)ne a speci(cid:12)c model of services, including transactional states.
Advanced Transaction Models (ATMs) have been proposed to support new database applications by relaxing transaction isolation and atomicity to better match the new requirements.
As work(cid:13)ows in the past, services composition requirements either exceed or signi(cid:12)cantly di(cid:11)er from those of ATMs [6] in terms of modelling, coordination [22] and transactional requirements.
Their limitations come mainly from their in(cid:13)exibility to incorporate di(cid:11)erent transactional semantics as well as di(cid:11)erent behavioral patterns into the same structured transaction [8].
To overcome these limitations, [18] proposed a transactional Work(cid:13)ows system supporting multitask, multisystem activities where: (a) di(cid:11)er-ent tasks may have di(cid:11)erent execution behaviors or properties, (b) application or user de(cid:12)ned coordination of the di(cid:11)erent tasks, and (c) application or user de(cid:12)ned failure and execution atomicity are supported.
In this approach, failure atomicity requirement is de(cid:12)ned by specifying a set of ATS.
Unfortunately, no transaction management support is provided to ensure this correctness criteria.
Accepted termination states as a mean to relax atomicity has been discussed in many previous works [1, 5, 18].
In fact, ATS property has been always implicitly included in most of transac-tional models.
For example, atomicity property implicitly de(cid:12)nes ATS for traditional transactions; all (success state) and nothing (correct failure state).
Also, when an advanced transaction model speci(cid:12)es global transaction structure, sub transactions properties, inter sub transaction dependencies, mechanisms of handing-over, success and failure criteria, and so on, it implicitly de(cid:12)nes its ATS.
In the same way, when [19, 23] de(cid:12)ne rules to form a well de(cid:12)ned (cid:13)exible transaction, they implicitly de(cid:12)ne the appropriate ATS for (cid:13)exible transaction model.
Emerging standards such as BTP [15], WS-transaction (WS-AtomicTransaction and WS-BusinessActivity [11, 12]), and WS-TXM (Acid, BP, LRA)[3] de(cid:12)ne models to support a two-phase coordination of web services.
These proposals are based on a set of extended transactional models to specify coordinations between services.
Participants agree to a speci(cid:12)c model before starting interactions.
Then the corresponding coordination layer technologies support the appropriate messages exchange according to the chosen trans-actional model.
These propositions inherit the extended transactional models rigidity.
Besides, there is a potentiel problem of transactional interoperability between services implemented with di(cid:11)erent approaches.
Our approach can complement these e(cid:11)orts and overcome these two gaps.
Indeed, our approach allows for reliable, more complex, and more (cid:13)exible compositions.
In addition, it can coordinate services implemented with di(cid:11)erent technologies since we use only services transactional features (and not interested in how they are implemented).
So, we can use our approach to specify (cid:13)exible and reliable composite services, while component services can be implemented by one of the above technologies.
Once a valid TCS is reached, it can be considered as a coordination protocol and can be plugged in one of the existing coordination technology to be executed.
In this paper, we have proposed a transactional approach for reliable Web services compositions by ensuring the failure atomicity required by the designers.
Contrary to ATMs, our approach follows the opposite direction by starting from designers requirements to provide correctness rules.
Like in [9, 18] (for transactions), designers de(cid:12)ne the global composite service structure, using patterns, and speci(cid:12)es required ATS as a correctness criteria.
Then, we use a set of transactional rules to assist designers to compose a valid CS with regards to the speci(cid:12)ed ATS.
The main contribution of our approach is that is able to incorporate di(cid:11)erent interactions patterns into the same structured transaction, and besides it can validate CSs according to designers transactional requirements.
Acknowledgment: We would like to thank Laura Lozano for her implementation e(cid:11)orts.
