As the largest document repository ever, the Web is becoming the environment where work is done.
With this shift, the need for proper support of collaborative work has become pressing, leading to standards such as the HTTP extension WebDAV [10].
WebDAV enables authors to upload, lock, annotate and version resources residing on Web servers, thus facilitating remote collaboration.
However, while a marked improvement over the existing HTTP protocol, WebDAV is still lacking in a number of areas crucial for CSCW applications.
Most important of these is shared awareness through event noti cation.
Collaborators must in order to smoothly coordinate their work continually be aware of each others  activities.
This cannot be handled satisfactorily with the basic WebDAV constructs.
Locking is an essential mechanism to ensure that collaborators do not accidently overwrite each others  changes, but as implemented in WebDAV it still relies on an out-of-channel mechanism (or simple polling) to alert coworkers that a resource has become available again.
This goes for the rest of WebDAV the essential functionality for collaboration is present, but all require Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
participants to actively monitor a site or resource in order to discover changes as they occur.
A more elegant approach would be to have the WebDAV server alert the users to relevant changes as they occurred.
This is known as a noti cation service, and this paper focuses on the lack of a proper noti cation mechanism and proposes AwareDAV, an extension to WebDAV, providing an extensible set of awareness services.
The paper is structured as follows: Section 2 describes related work in the  eld of CSCW; Section 3 describes WebDAV and the work done within the WebDAV community; Section 4 details the proposed WebDAV extensions to facilitate noti cations; Section 5 describes the detailed design at message and XML level; Section 6 provides two API level examples of use of AwareDAV; our experiences with the implementation of the AwareDAV framework is described in Section 7; Section 8 compares AwareDAV with two existing WebDAV noti cation frameworks, and the paper is concluded in Section 9.
Work is rarely done exclusively by the individual; there is usually a social context within an organization that determines why work is done, what work is done, and how it is carried out.
This social context necessitates cooperation and coordination between workers, be it on the same level of the organization or between levels.
The purpose of computer supported cooperative work (CSCW) is to investigate and understand this cooperation, and to support it with computers.
Cooperation requires coordination, and coordination requires a level of shared awareness of what coworkers are doing.
As described by Heath and Luff [11] in their analysis of work done by traf c controllers in the London Underground, maintaining shared awareness between coworkers can be crucial.
This need lends itself naturally to noti cation services.
Many systems have endeavored to support this: The GroupDesk system [9], the NESSIE system [14], the Elvin system [7], the AREA system [8], and the BABBLE system [3] to mention a few.
These systems seek to support shared awareness through means such as messaging, chat, and event noti cation.
Some aspects of awareness support require explicit actions by the user, such as sending a message to another user, while others are implicit.
The latter form is, for instance, the action of updating a  le in a CVS repository, which results in a broadcast to all users of an Elvin system, or joining a topic in BABBLE, which shows other users that you are active.
Some systems, notably AREA and Elvin, attempt to integrate with other applications, so that actions in these applications are broadcast to other users.
In recent years, event noti cation systems have been extended to explore issues related to events across wide-area networks [4].
The Web was designed with a client/server architecture with transient connections and no client state residing on servers.
This made it well suited for large scale distribution of documents.
Transparent connections were later introduced to speed up transfer of complex Web pages.
Even though the  rst Web browser was also an editor, most popular browsers were and still are just viewers, thereby avoiding the complexities of collaborative remote editing of Web pages.
The only support for remote authoring in HTTP was the PUT method facilitating upload of a document.
However, without any knowledge of the actions of other clients, such updates could easily cause a recent update (from another client) to be overwritten.
Thus, HTTP had two major weaknesses: Document control and awareness support.
WebDAV [10] tried to address the authoring problems of the Web, especially the document control problem.
It ensured that documents were arranged into hierarchies, which could be manipulated through moving and copying resources from one location to another.
It introduced locks to prevent accidental lost updates.
Finally, it introduced properties, which could contain arbitrary meta-data about the resources, e.g., owner or date of creation.
This provided some awareness support, as clients could now gain insight into the age and ownership of documents.
The Versioning Extensions to WebDAV ( V [5]) enriched document control to version control, also a well known method to avoid data loss.
Due to its complexity, this extension was divided into several features, allowing servers to choose a sensible and functional subset.
This implies that a client has to query the server about its abilities in order to use its version extensions.
This division was necessary to accommodate the different versioning scenarios while still maintaining a common protocol.
Privacy issues on the Web have hitherto been handled through authentication and encryption, but the introduction of distributed authoring raises the need for assigning different access rights for different operations, e.g., read or write.
The Access Control Protocol [6] de nes both a set of access rights and the properties to examine and change them.
As servers may have different access rights depending on the underlying platform, the access right scheme has been somewhat loosely de ned, and an inclusion ordering between access rights introduced (e.g., if a client has been granted write access, that might include property modify access as well).
A client can then after querying the scheme choose the access rights it is familiar with.
Until the introduction of WebDAV Search [15], the only way of locating a certain resource, based on its property values, was to retrieve the properties from the resource hierarchy and search locally on the client.
The WebDAV Search protocol introduces the SEARCH request enabling server-side searching.
It provides a basic search grammar, which can be used for searching, but a server could also support other grammars as the mechanism is extensible.
WebDAV has been implemented for several Web server platforms, and used in many clients in more or less compatible ways.
Some of these are Apache/mod dav, Oracle Internet File System, Jigsaw, Xythos Storage Server, Microsoft IIS 5/6 and Microsoft Exchange.
Microsoft Exchange s WebDAV [13] implementation already includes noti cation support through both pushing and polling of no-ti cations.
Polling is done through its HTTP extension and a push mechanism is implemented through UDP datagrams.
As datagrams are inherently unreliable, an acknowledgment through polling is required.
Noti cations state only that something has occurred rather than providing all the details (as opposed to WebDAV-notify).
This requires only small amounts of information to be sent.
However, if full knowledge is required at least 3 messages have to be sent to the client: the noti cation, the acknowledge, and  nally a GET or/and PROPFIND request, and even then the client has only the latest state of the resource, not what changed, The requests SUBSCRIBE and UNSUBSCRIBE are used to manage subscriptions.
Noti cation is polled with the POLL request.
Events are matched with subscriptions based on type and resource URI with depth.
Supported types are update, update/newmember, delete, move, and newmail.
WebDAV-notify [12] is a work in progress from the Jabber Software Foundation, which seeks to create an event noti cation system for WebDAV.
This is done by extending the XMPP-PubSub protocol (an extension of XMPP-CORE), which is a XML pub-lish/subscribe protocol.
The main focus is to create a near real time and secure noti cation mechanism.
This is accomplished by:   Mapping the WebDAV service to the noti cation service, collections to collection-nodes, and resources to leaf-nodes, i.e., WebDAV s resource model to XMPP-PubSub s node model.
  Making a persistent connection (currently only through TCP sockets) from the client to the noti cation service, which is used both for subscriptions and noti cations.
  Re ecting the corresponding nodes in resources, allows clients to subscribe for resource-change noti cations and node-creation noti cations at nodes.
WebDAV-notify supports both keeping end users aware of changes as well as enabling co-servers (e.g., caches or mirrors) to keep track of changes.
In order to do this without requiring the co-servers to request extra information, a set of event payloads for basic WebDAV request are de ned, including a diff element, which makes it possible to keep mirrored resources in sync.
Microsoft Exchange and WebDAV-notify have been designed to suit their speci c needs.
However, neither are fully general and each make demands on implementors that may be unreasonable.
See Section 8 for a more detailed discussion on these two systems and a comparison with AwareDAV.
A Web client can, due to the disconnected nature of the Web, exert only a limited amount of control over a server s resources.
Locking and versioning in WebDAV have yielded some control to the client, but locks are still coarse grained, and versioning cannot always avoid unresolvable con icts.
Awareness is supported through explicit polling.
The Exchange extension and the WebDAV-notify draft support different noti cations mechanisms.
Exchange uses unconnected communication, and does not provide much information in the noti cation.
WebDAV-notify requires a  xed connection or gateways and uses two different and not quite compatible resource models.
They are both somewhat in exible and not for general use.
Having established the limitations of WebDAV standards and implementations, we present AwareDAV, a generic extension of Web-DAV for awareness support.
This is accomplished by three awareness features, each extending the area of awareness.
(a) Event awareness (b) Subject awareness (c) Intersubjectivity Figure 1: AwareDAV event  ow models
 This section describes the level of awareness supported by the AwareDAV framework.
Event awareness, as seen in Figure 1(a), enables a server to notify clients about events occurring in the data model (i.e., the resource hierarchy).
Whenever a successful WebDAV request is issued, the server performs the corresponding actions in a more or less atomic way with each action generating an event.
If a client is interested in certain resources, it must subscribe for events at these resources.
The subscription will catch desired events and notify the client accordingly.
The subscription determines whether to keep the noti cation in its noti cation queue waiting for the client to look at the queue or to dispatch it immediately to the channel.
A channel could be an email address, a TCP socket, or something else.
A crucial element of shared awareness is knowing who is doing what.
Subscriptions as formulated in AwareDAV have an owner and a channel, but these may just be URIs, and does not necessarily divulge who is doing what.
Subject awareness, as shown in Figure 1(b), introduces sessions and session-channels, which provide a framework for structuring work into sessions, and to announce current work and interest in a certain session by logging-in to it.
Session-channels come in three  avors: independent, session-members, and attached.
A session-member represents an active user (or actor) similar to ACL [6].
Therefore each client should use the session-channel header to identify the acting session-channel.
As only active members can receive noti cations, a system supporting offline noti cations should use session-channels attached to the session-member to represent a single session-member.
A session-channel can represent channels, as all session channels have a default channel, as shown in Figure 1(b).
The channel (its queue, and its lifetime) is then be shared between subscriptions using the same session-channel.
A session channel is a  special  resource which should be inside a session (a collection type resource).
As sessions are hierarchical organized, all sessions will be related to its parent (either the session-root or another session).
Each session may have a data-collection, which may be controlled by the session limiting access from non-session-channels.
Intersubjectivity Awareness With the mechanisms described above, we can be kept aware of what is going on and who is doing what, but it would be even better if we also knew what others knew.
This feature enables a client to  hear  what others are being told about it.
Intersubjectivity as described in the iScent framework [1] is the feature that you could be noti ed when others were noti ed about your actions.
This is desirable in a tight cooperative setting, because if you know what others already have been noti ed about, you can work with them based on that knowledge.
This can be generalized to catching  noti ed  events on a session-channel as shown in Figure 1(c).
These noti cations work by having a spying subscription on a session-channel or by setting the Mutual-Notify header requesting a noti ed noti cation from all generated noti cations.
The last option is not only the most useful but also the way to catch noti cations for  anonymous  channels.
While the three awareness mechanisms described above will cover many use scenarios, AwareDAV also has a mechanism for extensions, which extends the subscription with computational power, so that it can act upon successful event matches.
The subscription could, e.g., grab a lock to a highly requested resource when it is unlocked.
The event matching mechanism should therefore ensure fairness in the order it process subscriptions: The subscriptions eldest and closest to the event should be matched  rst.
The engine is also used in the where-expression, granting detailed matching capabilities.
It is very similar to the SEARCH request from DASL [15].
Our design should be architecturally independent.
The protocol should be usable both in a small of ce running Microsoft Exchange, and on a large multi server con guration.
We must therefore consider channels and server setup: Channels: The channel is a communication conduit to the client given by a XML representation.
This could be email, a TCP socket, or something else.
Internally, the server setup can use any protocol.
The possible channel types of a noti cation server should, of course, be obtainable.
Connected communication like sockets will probably only be used in tight and relatively small groups.
Email could be used with low-rate noti cation scenarios where the user want to be noti ed even when offline.
A third alternative would be to use an IM service, such as Jabber.
Servers: In a reasonably sized setting, it would be natural to offload the noti cation job from the document server to a dedicated noti cation server.
In a large scale scenario, we might even need more noti cation servers, as well as many document servers.
The document server would then route the relevant requests to the noti cation server.
This should work well, as long as a client does not need to inquire for existing subscriptions, or to refresh it subscriptions very often.
In these cases we could reuse a request redirection.
Namely, the response 300 MULTIPLE CHOICES, which uses the Location headers to give a list of URL s referring to the noti cation server.
It would additionally use the Allow header to specify the set of methods which should be redirected.
A simple client, having only limited traf c to the noti cation server, could, of course, just send everything to the primary Web server, and be redirected every time.
Requests can be redirected if they address a subscription (by URI and subscription ID) or/and a session-channel (identi ed by the URI), which are the two entities it makes sense to of oad.
Both events and subscriptions are tied to the resource hierarchy.
Subscriptions are sub-objects of resources in the same way as locks are, and are inherited to a speci ed depth just like locks.
Events emerge at those resources, which are affected by the corresponding actions.
These resources are called the event origin.
So event processing begins with matching and, if successful, continues like this:
 (a) The event-origin must match the coverage of the subscription (i.e., have a resource in common).
(b) The event types of the event must match the subscription (i.e., the subscription must listen for at least one of the types of the event).
(c) The event must match the where-expression of the subscription.
(The where-expression must evaluate to true.
It works like the search-expression of DASL [15])
 (a) Event-property  ltering: The subscription will select the needed event-properties and insert them into the no-ti cation.
(This to avoid huge noti cations).
(b) The actions expression (if any) is evaluated/run and the result added to the noti cation.
(c) The properties, which are requested from the subscription, are fetched from the resource and added to the no-ti cation.
(Note: Even if a event-property is mirrored in a resource-property the action could change it).
patch it according to its nature.
Some channels has queues which holds the noti cation until it is polled or packed in a delayed noti cation-set.
Most event matching can be accomplished with the two  rst match mechanism.
The event types scheme is analogous to access rights from ACL [6] and designed to be extensible.
Due to the extensibility, events will often have more types.
An simple client may not recognize new event types on an special event but can still recognize the basic types within it and therefore work with more advanced servers.
The type scheme consists of the following: created-x, deleted-x, updated-x, modi ed-x, refreshed-x, read-x, moved-x, and failed.
Objects that x may span over are: Resources, contents, properties, bindings, locks, subscriptions, noti cations, and session-channels.
This can, of course, be extended by other protocols, maybe with sessions, versions, version-histories, etc.
The failed event is not differentiated based on its object.
The refreshed-x event types may be omitted if the server guarantees that the delete-x event is sent when the objects timeout.
The actual names used can be seen in Table 1.
Extensions are required to extend the event system in a consistent way in regard to the scheme described here.
An example could be VERSION-CONTROL: This request (from  V [5]) puts a resource under version control.
This really ought to be invisible for version agnostic clients, so it should not use any of the basic event types.
The CHECKOUT of a version creates a new (version controlled) resource and should therefore emit a created event.
Every event carries some extra information in its properties.
This is an extensible mechanism just like resource properties, and each property is an XML element.
Basic properties include the method and resource type.
This is why we do not have event types like created-collection and created-session, and why there is only one failed event.
See Section 5.5 for other event properties.
A subscription can match against these properties if the where expression is supported.
And to avoid transmitting more than necessary, a subscription may select the interesting properties using its  ltering mechanism.
In this section we list the AwareDAV protocol method and XML-syntax, and discuss its interoperability with DASL [15] and ACL [6].
Throughout all XML examples and de nition we use the pre x d: for the namespace DAV: and the pre x a: for the namespace http://www.daimi.au.dk/AwareDAV.
We have extended the WebDAV protocol with seven new request methods: SUBSCRIBE, UNSUBSCRIBE, POLL, NOTIFY, LOGIN, LOGOUT, and SESSION-CONTROL.
The  rst four are inspired by Microsoft Exchange [13], and the rest enable subject awareness.
A SUBSCRIBE request is used to subscribe to events occurring at the resource or in the collection hierarchy (the coverage of the subscription) speci ed by the request URL and the optional Depth header, or to refresh existing subscriptions.
  A refresh SUBSCRIBE request has no body and must have at least one Subscription-ID header.
  A create SUBSCRIBE request has no Subscription-ID headers and the body must be a a:subscribeinfo XML element.
This element speci es who owns the subscription, which events it will listen to, and how it will respond to these events.
The Action create delete update modify read/copy move Resources created deleted updated copied moved Contents --updated-content -read-content Properties ---modi ed-properties read-properties Bindings bound unbound Subscription Locks locked unlocked subscribed unsubscribed --------Noti cation noti eda polled -server-channel Active logged-in logged-out ----aNoti ed is a special event type generated by the NOTIFY method or intersubjectivity.
Noti ed-type noti cations do not generate additional noti ed-type events.
Table 1: Basic event types request may fail if the request-URL is an unmapped request-URL.
The Subscription-ID is returned in the header.
SUBSCRIBE, UNSUBSCRIBE, and POLL requests may fail, if the request-URL is not within the coverage of the subscription(s).
The Timeout header may be used to urge a certain lifetime upon the channel, and should be used to pass the resulting lifetime in the response.
The a:subscribeinfo XML element is de ned in Section 5.2.
An UNSUBSCRIBE request is used to remove subscriptions made with SUBSCRIBE requests.
  An UNSUBSCRIBE request has no body and must have at least one Subscription-ID header.
The POLL request is used to poll the noti cation queue of a subscription in the cases where server-to-client communication is unavailable or unreliable.
  A POLL request has no body and must have at least one Subscription-ID header.
  The successful POLL response must have a a:noti cation-set body.
The a:noti cation-set XML element is de ned in Section 5.3.
The NOTIFY method simply generates a user de ned noti cation, which is transmitted to the speci ed recipient.
This is similar to email or IM functionality, but has the advantage of being observable by others.
  A NOTIFY request must have a a:notify body.
The request-URL must specify a session-channel, which receives the no-ti cation generated from the body.
The a:noti ed-type event must be generated at the session-channel upon successful completion.
The a:notify XML element is de ned in Section 5.3.
The LOGIN method is used to login (and activate) a session-channel resource in a session.
It is also used to refresh the login.
  A refreshing LOGIN request has no body and the request-URL refers to an existing active session-channel.
This channel and its subscriptions will be refreshed according to the Timeout header.
  An activating (and creating) LOGIN request has a a:login body and the request-URL refers to either an inactive session-channel or a session.
  A activating LOGIN response has a a:login-response body with an list of resubscribed subscriptions if any.
The Location response-header indicates whether a session-channel was created.
<!element a:login (a:channel, d:displayname?, a:session-member?, a:channel-type?, a:mutual-notify?
)> <!element a:session-member (d:href)?> <!element a:channel-type (a:online-channel, a:offline-channel)> <!element a:login-response (a:subscription-list?
)> The optional a:session-member element speci es the type of the created session-channel.
If a:session-member is not present it is independent; if it is empty it is a session-member; and if it contains a d:href it is attached to the session-member given by the that URL.
The lifetime of active session-channels is inherited by all subscriptions using them.
If the speci ed communication channel is another session-channel a copy is made including associations to attached session-channels.
Intersubjectivity may be forced upon every request made by the active session-channel (a:mutual-notify).
The LOGOUT method is used to logout (and deactivate) a session-channel resource.
  A LOGOUT request has a a:logout body.
  A LOGOUT response has a a:logout-response body with an list of auto-unsubscribed (and auto-subscribe capable) subscriptions if any.
<!element a:logout ()> <!element a:logout-response (a:subscription-list?
)> All subscriptions owned by the session-channel must be automatically unsubscribed upon successful completion.
The SESSION-CONTROL method is used to create sessions or change the control options of an existing session.
If the request-URL is unmapped a new session should be created, and if it represents an existing session it should alter the options of the session.
A session must logically reside in another session or in a session-root.
  A SESSION-CONTROL request has a a:session-control body specifying the session-parent, the data collection, and control options.
  A SESSION-CONTROL response has a a:session-control-re-sponse body and uses a Location header for a newly created session.
<!element a:session-control (a:session?, d:displayname?, a:data-url?,a:data-control?,a:mutual-notify?
)> <!element a:session (d:href)> <!element a:data-url (d:href)> <!element a:data-control (a:auto-login?,a:subscribe?, d:read?,d:write?
)> <!element a:session-control-response ()> Implementations may allow a session to control the data collection by requiring users to be logged-in in order to read, write, or subscribe to resources in the data collection.
They may even support auto-login when it is required.
Intersubjectivity may also be forced upon session-channels within the session.
These seven request-methods form the AwareDAV API, together with the XML-structures de ned in the following sections.
A subscription is a sub-object of a resource, and is identi ed by the resource-URL and a subscription-identi er.
Even so the identi- er of a subscription should be unique.
It may have both a user supplied owner (i.e., d:owner), a formal owner (i.e., a session-channel), and optionally an attached session-channel.
The main content of subscriptions is speci ed by the a:subscribe-info XML element below: The events it is listening for is determined by event-types (a:what) and the optional match-expression (a:where); the content of noti cations is speci ed by event-property names (d:select) and resource-property names (d:prop nd); the side-effect of notifying is speci ed by a small program (a:action); and how noti cation should be dispatched is determined by the channel (a:channel).
Supported channels may include TCP (a:tcp), email (a:email), HTTP connection polling (a:polling), and session-channels (speci ed with d:href).
<!element a:subscribeinfo (d:owner?, a:what, a:where?, d:select?, d:propfind?, a:action?, a:channel)> <!element a:what (ANY)> ; any event-type <!element a:where (ANY)> ; any match-grammar <!element d:select (d:allprop | d:prop)> <!element a:action (ANY)> ; any action-grammar <!element a:channel (ANY)> ; any channel-description <!element a:polling (EMPTY)> <!element a:email (d:href, a:delayed?, a:transform?
)> <!element a:tcp (d:href, a:port?
)> <!element a:subscription (d:href?, a:subscription-id?, d:owned-by?, d:owner?, a:what?, a:channel?
)> The following resource-properties exist in order to help use subscriptions:   The a:eventtype-discovery property contains the supported event-types for this resource.
Any SUBSCRIBE request with unknown event-types must fail; unsupported but known event-types should be silently ignored.
  The a:channel-discovery property contains a list of supported channels.
E.g., TCP, email, or something else.
A session-channel is supported if the default channel of it is supported.
  The optional a:subscription-discovery property contains a list a a:subscription elements, representing the subscriptions at the resource and their owners.
It may collapse more subscriptions into one a:subscription not discarding any a:owned-by value.
As the XML de nitions show, AwareDAV is extensible both in regard to event-types, matching, server-side programming, and communication protocols.
When noti cations are received, more noti cations may have been packed together in a a:noti cation-set either because we are polling, or because the channel-speci cation allows for noti cation-delays.
Each noti cation contains a subscription part, an event part and a noti cation computing part.
The subscription part contains identity and owner of the subscription.
The event part (a:event) contains event-types (a:what) and event-properties (d:prop see also Section 5.5).
The computing part may consist of the result of the computed side-effect (a:action-result and retrieved properties from the resource of the subscription (d:prop).
<!element a:notification-set (a:notification*)> <!element a:notification (d:href?, a:subscription-id?, d:owner?, a:owned-by?, a:event, a:action-result?, d:prop?
)> <!element a:event (a:what, d:prop)> <!element a:action-result (ANY)> <!element a:notify (d:prop)> <!element a:message (ANY)> The client may ignore unknown event-types in a noti cation and will not receive any unknown event-properties that it did not explicitly ask for.
Noti cations may be due to an explicit subscription, or inter-subjectivity using the Mutual-Notify header, or an intersubjectivity-enabled session-channel.
User initiated noti cations (or messages), which are sent with the NOTIFY request, generate a a:noti ed event with the provided event-properties.
The event-property a:message should be used as a general message for clients not understanding specialized properties.
The event-type scheme (a:what) is already described in Table 1, but here we will specify the method-to-event relations and discuss the design choices.
The events can be seen in Table 2 and Table 3.
The multiple type scheme was introduced as AwareDAV should be easy to extend with new event types, while maintaining compatibility with older clients.
It also makes the choice between focusing on bindings or resources easy, as we choose both.
ACL [6] had to make that choice as it would be troublesome to have different rights for creating and binding the chosen bindings (i.e., if you can move a resource somewhere, you should presumably be able to create a resource there as well).
The modi ed-x types are an union of created-x, deleted-x, and updated-x, which should be used when deletion is similar to assigning an empty value.
The modi ed-properties is therefore the only event being generated from a PROPPATCH request.
Though refreshing (locks, subscriptions, session-channels, etc.)
often updates some resource-properties, the a:modi ed-properti-es should not be used, as no signi cant changes occur.
Instead the optional refreshed-x event-types may be used.
If the server guarantees that unlocked, unsubscribed, or logged-out events are generated upon timeout, refreshed-x events may be omitted entirely.
Having listed the required event-types that should be supported, we now proceed with the properties of events.
Event-properties are unrelated with resource-properties (though they use the same d:prop XML element).
Properties of events explain who caused it, when it was done, and what happened.
Noti-Method


 (create?)
(update?)
(source:) (destination-create?)
(destination-update?)
Event type read-content (read-content) created, bound updated-content ?
deleted, unbound -read-properties modi ed-properties created, bound copied created, bound updated
 (delete-destination?)
(source:) moved, unbound deleted, unbound (destination) moved, bound


 (create?)
(refresh?)
locked (refreshed-lock) unlocked (read-properties) Table 2: Mandatory Events for WebDAV Methods Method Required events
 (create?)
(refresh?)
(create?)
(refresh?)
(update?)
subscribed (refreshed-subscription) unsubscribed (polled) noti ed logged-in, created, bound (refreshed-channel) logged-in logged-out, (deleted, unbound) Table 3: Mandatory Events for AwareDAV Methods  cations will receive the actual properties  ltered by the d:select property names.
The supported event-properties will vary depending on the purpose of the noti cation mechanism.
Some clients need to know everything that changed, others may need to know some basic event-properties even if they did not change.
Standard event-properties are: <!element d:owner (href?
)> <!element a:owned-by (href)> <!element a:date (#PCDATA)> <!element a:method (#PCDATA)> <!element a:origin (d:href, d:etag?, d:depth?, d:multistatus?
)> <!element d:resourcetype (#PCDATA)> <!element a:unknown (#PCDATA)> <!element a:src-origin (a:origin)> <!element a:dest-origin (a:origin)> <!element d:response (...)> ; from WebDAV <!element d:activelock (...)> ; from WebDAV <!element a:subscription-id ()> <!element a:what (ANY)> <!element a:message (ANY)> <!element a:report (ANY)> While the d:owner of locks and subscriptions is an arbitrary client-supplied element, the d:owner of events and resources is an ACL [6] principal.
The a:origin of an event is speci ed by the root of its (d:href) and its d:depth; if the event failed on a subpart of the resource-hierarchy, the failed subbranches are named in the d:multistatus.
For a singleton origin, the d:etag may be present as well.
The d:resourcetype may be a:unknown if it cannot be derived without extra resource-property retrieval.
The d:response property indicates affected resource-properties, and the a:report property about used reports.
A server may support the propertyupdate property for PROP-PATCH and diff property for PUT, as WebDAV-notify [12] does.
In many cases, some event-properties do not make sense and will be omitted, e.g., d:resourcetype only makes sense on singleton origins.
The d:owner property will be derived from authentication, and a:owned-by property will be determined by the used session-channel (i.e., by the session-channel header).
If a d:select of a SUBSCRIBE request lists unknown event-pro-perties it must fail, with a DAV-error describing which event-pro-perties are unsupported.
We have here described the extensible event-property mechanism.
Similar to resource-properties the d:allprop  lter will not return all event-properties, and it should only return the standard event-properties listed above.
Computations are used two places in AwareDAV, in the a:where-expression and in the a:action.
These two expression vary much in their required vocabulary.
The  rst must evaluate to a truth-value based upon the event-properties; the other perform some side-effect.
The a:where-expression may contain a d:where element from the basic search grammar of [15], where d:prop is interpreted as event-properties, or a server may implement other match-grammars.
The a:action may contain a a:simple-action element or another root element of an supported server-side languages.
The a:simple-action language consists of a list of statements described below.
Server may support other server-side languages as well, which may be discovered using the a:supported-... properties similarly to WebDAV Search [15].
<!element a:simple-action (ANY)> ; any statement below <!element a:unsubscribe (EMPTY)> <!element a:lock (EMPTY)> <!element a:if (ANY)> <!element a:supported-match-grammar-set (d:grammar*)> <!element a:supported-comp-grammar-set (d:grammar*)> This very simple language allows a subscription to unsubscribe itself and lock the associated resource.
The language could easily be extended when other uses beyond  <if> <lock/> <unsub-scribe/> </if>  are discovered.
Even though these two simple approaches handle the job, a more ideal approach may be to create a common language for a:where-expressions, a:action s, and searches (from DASL [15]).
The ACL protocol [6] introduced principals as representatives for actors and assigns to these actors access rights or speci c resources.
If an implementation supports both AwareDAV and ACL, we have to contemplate two issues: The relation between principals and session-members, and how access-rights affect noti cations.
A session-channel is de ned as a resource with a a:session-chan-nel and an ad:active property, so a principal may well be a session-channel.
But often a principal wants to use more session-channels.
In these cases, a server may use a new resource type a:session-channel.
These resources should be associated with a principal through the d:owner and d:principal-url property as de ned in
 This is so because users may want to join more sessions (creating session-channels) without having the possibility of adding principals.
Sessions could then be created using the SESSION-CONTROL method, and session-channels with the LOGIN method.
Another option for implementors is to prohibit session creation, only allowing the sessions (or collections) containing the principals, and in that case, principals and session-channels could be the same.
In general, if an actor has read access, he should also have subscribe access.
But the coverage of a subscription may extend to resource and sub-objects that the actor has not access to, and he must be prevented from access to anything beyond his access level.
Thus, events will have to carry the access rights information of their origin, and match it with the access rights of the principals of the subscriptions.
In case of multiple origins, a server could choose to restrict event-properties to inform about the origin root.
Some requests like SEARCH [15] may contain indirect information, which reveals too much (e.g., searching for  secret deals with Ted , which states that the actor and  Ted  has something going on).
The events should therefore not contain such information.
As can be seen, combining ACL and AwareDAV raises some potential problems that must be addressed to make access rights control safe and ef cient.
We describe two examples to illustrate the utility of AwareDAV.
One simple with a browser client using event awareness, and a second more complex using all three features.
Simple client The simple client can connect to an AwareDAV server, browse the resource hierarchy, lock resources and view/edit documents (see Figure 2(a)).
The interactions involved are   Connecting involves opening a TCP socket, and sending the OPTION request to verify that the server is indeed an Aware-DAV server.
The DAV response header of the OPTION request will contain the keywords: events, sessions, and intersubjectivity depending on the level of Aware-DAV support.
  Browsing the resource hierarchy involves opening and closing folders.
For each open folder, a PROPFIND request with depth 1 is issued to retrieve the children, and a SUBSCRIBE request (also with depth 1) ensures that the client is informed of any changes to the displayed resource tree.
The subscription will listen for created, deleted, copied, moved, bound, unbound, locked, and unlocked events.
When the folder is closed, it should be unsubscribed.
  The client will then receive noti cations in its model about changes and locks, and can re ect this in an explorer view.
  When viewing a resource, it is made read only (in the client) if it is locked.
Otherwise, the user can be asked whether the resource should be locked for editing.
Advanced client The advanced client extends the simple one with sessions and inter-subjectivity.
The user may choose a session to display and login to.
Each time a intersubjectivity noti cation is received, the client can visualize it with a  sending message  animation on the session-member that was noti ed.
The animation may differ depending on the kind of event-type that was caught by the session-channel.
Thus, the user will immediately see who received noti cation of the user s actions, e.g., if they had the browser open at the same resource or maybe another type of client (see Figure 2(b)).
The interactions involved are:   The session-tree report is issued to  nd sessions, and the session-channel-list report is used to  nd session-members in them.
  Logging in or out should be re ected in the session view, so there will be a subscription for every open session.
  All requests should use the Mutual-Notify header in order to receive the intersubjectivity noti cations.
This can be done when the client has logged into the session-channel.
These noti cations will all be received by the session-channels  default channel.
  All other operations occur as before, perhaps with the slight modi cation that all events could arrive at the session-channel (assuming the client requires login).
The following illustrates some of the messages sent: LOGIN request: LOGIN /gold session/ HTTP/1.1 Host: <a:login xmlns:a="http://www.daimi.au.dk/AwareDAV" test.daimi.au.dk xmlns:d="DAV:"> <a:channel><a:tcp> <d:href>teds-computer.daimi.au.dk</d:href> <a:port>8001</a:port> </a:tcp></a:channel> <d:displayname>ted</d:displayname> <a:session-member/> </a:login> LOGIN response (creating a new session-channel): HTTP/1.1 201 Created Location: <a:login-response test.daimi.au.dk/gold session/ted xmlns:a="http://www.daimi.au.dk/awaredav"/> Open folder (PROPFIND and SUBSCRIBE requests): PROPFIND /test HTTP/1.1 Host: test.daimi.au.dk Depth: Session-channel: ...
<d:propfind xmlns:d="DAV:">
 <d:prop><d:resourcetype/></prop> </d:propfind> test.daimi.au.dk/gold session/ted test.daimi.au.dk SUBSCRIBE /test HTTP/1.1 Host: Depth: Session-channel: ...
<a:subscribeinfo xmlns:a="..." xmlns:d="DAV:"> test.daimi.au.dk/gold session/ted
 <a:what> <a:created/><a:deleted/><a:updated/><a:copied/><a:moved/> <a:bound/><a:unbound/><a:locked/><a:unlocked/> </a:what> <d:select><a:method/><d:resourcetype/></d:select> <a:channel> <d:href>test.daimi.au.dk/gold session/ted</d:href> </a:channel> </a:subscribeinfo> SUBSCRIBE response: HTTP/1.1 201 Created Subscription-ID: 1051 And  nally a noti cation (same as the body of a POLL response): <a:notification-set><a:notification> <d:href>test.daimi.au.dk/gold session/ted</d:href> <a:subscription-id>1051</a:subscription-id> <a:owned-by>test.daimi.au.dk/gold session/ted</a:owned-by> <a:event> <a:what><a:created/><a:bound/></a:what> <d:prop> <a:method>MKCOL</a:method> <d:resourcetype>collection</d:resourcetype> </d:prop> </a:event> </a:notification></a:notification-set> Having seen a few examples of client interactions, we describe our server implementation.
(a) Simple client (b) Advanced client (c) The AwareDAV prototype Figure 2: API Usage Examples

 Any protocol or design must be validated through implementation.
When faced with the implementation of AwareDAV, we decided to extend an Apache Web server (complete with mod dav) with an AwareDAV module.
This choice makes the extensibility of AwareDAV dependent upon the extensibility of Apache and the mod dav module.
Other choices could have been to build a server from scratch, or to choose a different Web server as platform.
Using the  lter mechanism of Apache, we monitor all requests arriving and all responses departing.
Upon departure, we generate an event based on the information gathered and compares with known subscriptions.
Matches cause a noti cation to be dispatched to the channel.
Seven method handlers have been made to deal with the seven new request methods.
Sessions-channels are just normal resources with the a:session-channel property, and a reference to the noti cation queue.
The protected properties (including a:session-channel) are implemented through a hook mechanism in mod dav; apart from this, both the Apache Core and mod dav are left untouched.
This approach gives some problems with the accuracy of the event information: either we have to make sub-requests, impairing ef ciency, or we must accept that the events cannot provide full knowledge about what happened.
E.g., the request/response of a PUT does not give enough information to return the diff element.
Such a scenario is one of the reasons behind AwareDAV s differentiation between event-properties and resource-properties in the noti cation.
Resource-Properties are explicitly retrieved after matching, while event-properties should be low cost and directly derivable from the event.
Modifying mod dav or using its hooks more extensively may alleviate this problem.
As mentioned in Section 3.2, AwareDAV is not the only framework for noti cation support in WebDAV.
Notable are the support found in Microsoft Exchange and WebDAV-notify.
These systems were sources of inspiration during development, and this section details the similarities and differences between AwareDAV and the two systems.
There is some common ground between AwareDAV and Microsoft Exchange [13]: Some of the request methods names (SUBSCRIBE, UNSUBSCRIBE, POLL) and their basic functionality, the unique subscription ID (which together with an URI identi es the subscription), inheritance of subscriptions, and a noti cation queue to hold the noti cation until polled.
However, there are also some key differences: There are only a few specialized event types in Microsoft Exchange, events use headers for all information, and that information can only be obtained through the POLL request.
Our noti cations are contained entirely in a XML body, so the only requirement to the notifying mechanism is that it is capable of delivering XML.
Our design is far more  exible in these aspects, whereas the Microsoft solution has been adapted speci cally to the mail server domain.
There are at least three major differences between AwareDAV and WebDAV-notify [12]: The data models, the event scheme and the server-gateway architecture.
  WebDAV-notify maps the WebDAV resource model unto XM-PP-PubSub s node model.
These two models differ in that collections in WebDAV may have both content and properties, while PubSub s collection are pure bindings.
Especially in the more advanced WebDAV extensions (e.g.,  V ) the missing events for collection operations may be irritating.
  Clients can subscribe to node creation and item change events, and may therefore receive noti cations that it should ignore.
WebDAV-notify change noti cations are categorized by request method and payload elements to distinguish between the noti cations.
Though we could envision different methods having the same payload signaling similar behavior, this makes for a less adaptable design with regard to new extensions that use the same payload but should not be associated with existing methods.
As our design supports human noti cation (like email), we sometimes need our  ner grained matching mechanism.
Even though it is possible to match for request names, it is not recommended in our design.
  WebDAV-notify has one primary communication conduit: XMPP.
This has the advantage of encouraging both servers and clients to be more secure.
Our design could probably also be adapted to XMPP-CORE, by simply having the server redirecting the subscription requests, as long as we are able to dispatch headers and XML bodies.
AwareDAV encourages gateways to make their existence known through WebDAV-properties along with all builtin channel communication types, while Webdav-notify assumes that the problem is handled by gateways and clients themselves.
These similarities and differences highlight the different design goals of the three projects.
AwareDAV has the advantage of having a higher degree of  exibility and extensibility.
The introduction of WebDAV was an important conceptual shift on the Web, whereby the realization of the  inter-creative Web  came closer.
WebDAV provides a widespread standard for basic collaboration support in the areas of uploading, locking, annotating, and versioning resources on Web servers.
The common user will never directly come into contact with WebDAV, but will experience it as an enabling technology enabling work with remote colleagues.
AwareDAV supplements WebDAV in the important area of noti- cation support, as this cannot be handled directly within the Web s strictly stateless client/server model.
Staying within this model is a design feature of WebDAV, but constrains the ease with which collaborative systems can be built upon Web servers.
We have introduced AwareDAV as a new framework to support shared awareness through event noti cations in a WebDAV based context.
This allows for the creation of a new class of collaboration systems on the Web.
We have in this paper discussed two existing frameworks for noti cation support in WebDAV, namely WebDAV-notify and Microsoft Exchange.
Both systems  t their niche well (and have indeed informed the design of AwareDAV), but are ultimately too restrictive for a general design.
Microsoft Exchange can only push noti cations through UDP and cannot provide users with exact information of what has changed; WebDAV-notify relies on XMPP for noti cation delivery, which may not  t all purposes, and in contrast to Microsoft Exchange provides the user with full change information (which may not always be necessary).
The AwareDAV approach is the more  exible as it allows for a range of delivery mechanisms, and provides a  ne grained event subscription mechanism with an extensible event scheme to support future development.
Any scheme related to collaborative work should be forward compatible to allow for new systems and innovative uses.
We have discussed our experiences with the initial implementation of AwareDAV on an Apache/mod dav Web server.
Our initial results are promising and the extensible approach taken by Aware-DAV should allow for future growth and enable collaboration across the Web through the merging of WebDAV and noti cation systems.
Acknowledgment This work has been supported by Center for Interactive Spaces, ISIS Katrinebjerg, University of Aarhus, Denmark.
We wish to express our thanks to E. James Whitehead, Jr. for his helpful comments during the preparations of this paper.
