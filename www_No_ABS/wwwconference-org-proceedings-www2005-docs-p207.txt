The interoperability among distributed and autonomous systems is the ultimate challenge facing the semantic web.
The open issue is how to preserve the requirement of locality for representations, while at the same time enabling an e ective interaction among autonomous peers.
The heterogeneity of autonomous representations is the source of the problem.
Strong e ort is usually spent ar-Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
Marco Cova ITC-irst via Sommarive 18
 cova@itc.it ranging well de ned ontologies whilst neglecting the issues related to their wide spread use.
In our work we conceive the problem of interoperability as the problem of supporting the emergence of a common lexicon among a community of peers.
A shared lexicon enables a common denotation that allows di erent peers to refer to the same object using the same label.
Building a shared lexicon does not necessarily require peers to share the underlying schemas designed to represent objects.
Recent studies in language evolution have developed the notion of language games.
A language game is a computational model that allows convergence on a shared lexicon in a fully distributed framework.
The key idea behind this model is that a shared lexicon emerges from adaptive pairwise interactions between language users and continues to evolve and adapt through repeated interactions.
Di erently from the usual solution promoted by the semantic web where the o cial vocabulary or lexicon is preserved by a third party, usually a consortium for standard preservation, in the language game model the shared lexicon is fully distributed amongst all the peers.
The main advantage is a distributed system without a single point of failure.
The original contribution of this paper is concerned with a proof of concept that language games can be an e ective solution to the interoperability problem among heterogeneous and autonomous systems.
In particular, we address a spe-ci c application problem that occurs in distributed annotation systems.
As an example of such applications we refer to a real world case study in the domain of ski mountaineering.
The paper includes a discussion of related works, a brief introduction to the language games, a service oriented architecture to enable the interoperability among distributed annotation systems and  nally the empirical results of a case study based on three real world web sites devoted to ski mountaineering.
Ski mountaineering is a very exciting outdoor activity.
In ski mountaineering, both the ascent and descent of a peak are made entirely on skis, using climbing skins and perhaps ski crampons for traction on the ascent, and then descending a continuous ski route back down to the base.
This sport can be very risky.
Avalanches represent an ubiquitous hazard that may arise from an erroneous situation assessment.
To prevent or reduce the avalanches hazard, it is a common practice for ski mountaineers to share their experiences on the web.
The typical behaviour of ski mountaineers is to collect, the day before a ski trip, all the annotations from online diaries on the ski routes of interest.
When the ski route is accomplished, the ski mountaineers note in their diaries the up-to-date conditions of the route.
For ski mountaineering in the Alps there are many web sites, among them skirando1, gulliver2, moleskiing3.
These are all organized along the same pattern: a catalog of ski routes and a collection of individual diaries of ski trips where a diary entry describes a ski trip that refers to a ski route in the catalog.
In such a way, given a ski route, it is straightforward to retrieve the most recent annotations, i.e.
the related diary entries.
The scenario above is much more e ective as many ski trips reports are collected.
However, although it may appear counterintuitive, the proliferation of web sites devoted to ski mountaineering doesn t necessarily increase the accessibility of ski trip diaries.
This is because a side e ect of the increasing number of web sites is the partition of the ski mountaineers into smaller communities that refer to het-erogenous ski route catalogs.
The example above is a particular instance of a more general scenario that can be referred to as distributed annotations.
The habit of allowing end users to provide their opinions of a given item as annotations, e.g., about books, movies, hardware, is ubiquitous.
Blog oriented architectures for annotations introduce the notion of aggregation services, third party servers in charge of indexing all the annotations with respect to a given category of items.
Such services allow a user to obtain all the recent blog annotations about a given item on demand.
Of course the tacit assumption of aggregation services is that the annotated items have to be indexed using a common reference system.
While for books ISBN provides a straightforward solution, more often an agreement on a common reference system does not exist.
Catalogs are usually distributed and autonomously designed.
Even though they are concerned with the same category of items the heterogeneity of representations is pervasive.
For this reason aggregation services need to be paired with alignment services that enable the mapping among different catalogs.
Catalogs alignment can be conceived as a typical problem of interoperability that precludes having a fully distributed annotation system.
In the remaining part of the paper we will refer to the domain of ski mountaineering but it is worthwhile to note that the pattern of solution is independent from the speci c application scenario.
The problem of catalog alignment has been approached by many initiatives in the context of the Semantic Web.
The usual strategy of these e orts consists in establishing a relationship between the local representations and a common reference encoding, namely a shared ontology.
This approach requires two steps: (1) the de nition of an ontology for the speci c domain, (2) the de nition of a mapping between a local representation and the shared ontology.
While 1http://www.skirando.ch/ 2http://www.gulliver.it/ 3http://www.moleskiing.it intuitive, this approach is often not e ective in practice.
In fact, the  rst step raises the question of who is in charge of managing the shared ontology and also, the mapping step is generally far from being trivial and too often requires manual intervention.
Designed around this general schema, a number of initiatives have arisen, fostered by the availability of machine processable semantics expressed in meta-models such as [14,
 Harmonise [9, 10].
In Harmonise, a mediator is in charge of managing a shared representation of tourism concepts, while subscribers have to map their local encodings with respect to the prede ned ontology.
To con rm the drawbacks of this approach, it is interesting to note that Harmonise, after the conclusion of the project, is currently dealing with the problem of establishing a consortium and the related sustainability plan.
Furthermore, the mapping task is at present performed manually.
Recently research is focused on the issues speci cally related to the mapping between schemas [4, 11, 12, 13] or shallow representations like taxonomies [7, 22].
The automation of the mapping process would enable pervasive interoper-ability without the constraint of a mediator [6], that in distributed applications becomes the  single point of failure .
In such a scenario, each peer would manage autonomously the mapping with respect to the other peers.
Unfortunately, automatic schema matching has proven to be a complex problem and a general solution is still not available.
A further problem lies in the fact that this approach does not scale well when applied to a fully distributed environment.
In fact, while in centralized approaches like Harmonise only one lexicon is needed to map the local reference denotation with respect to a global one, a strategy based on pairwise mappings has a quadratic complexity with respect to the number of peers.
Gossiping algorithms [1] have been proposed to reduce the scaling problem.
In this approach a (partial) solution to the schema mapping is provided only for a small portion of the complete peers set.
The unde ned mappings are derived through a transitive exploration of a peer s neighborhood.
Although this strategy is promising, the drawback of providing manual mappings prevents a full automation of the process of interoperability.
Alternative solutions have been proposed that aim to reduce the complexity of the mapping problem by moving from the schema to the object level [21].
Object mapping di ers from schema mapping.
In object mapping the assessment is performed looking at attribute values of the objects.
Of course, such an approach is less general than schema mapping.
A good schema mapping makes possible to derive all the correct mappings for all the objects.
On the contrary, the performance of an algorithm working at the object level is a ected by the speci c attribute value distribution.
A  nal research trend that is receiving increasing interest looks at the problem of interoperability in terms of a shared lexicon.
A W3C initiative, SKOS [16], has been organized to explicitly manage a shared vocabulary for concepts denotation.
Similarly to Harmonise, SKOS relies on the restrictive hypothesis that autonomous peers will subscribe to such a common vocabulary.
The fundamental question, then, is how to exploit the bene ts of a single lexicon for each peer without incurring the restrictions of a centralized global reference that is con-object label actuation encoding hearer
 speaker decoding assessment label object Figure 1: The pairwise roles of a language game.
trolled by a third party.
We give a solution to this question by leveraging the approach of language games.
With language games [19, 17], the language (or the ontology, the lexicon) of a community of peers is considered a system that emerges from adaptive interactions among peers.
Thus, in contrast with the techniques we have described before, each peer starts with a preliminary hypothesis of lexicon and the challenge is to enable a process of interactions that brings the peers  lexica to converge on a single common denotation system.
The language games approach has been validated by simulations in di erent domains, e.g., bookmark taxonomies [2], robot communications [18].
In the following we will show how language games can be exploited to deal with the problem of supporting the emergence of a distributed common lexicon without the constraint of a centralized third party mediator.
We  rst introduce the basic notions of language games with reference to the ski mountaineering domain and then we describe a service oriented architecture developed to enable the inter-operability among the ski mountaineering web sites of the Alps.
There are many variations of language games.
In the following we will focus our attention on a speci c model known as naming games [20].
A naming games is de ned by a set of peers P (the game players), a set of objects O (the heterogeneous representations of the ski routes), and a set of labels L (the candidate names to denote the ski routes).
A peer p   P is then de ned as a pair p =< Lp, Op >.
Each peer p   P has its own lexicon drawn from the Cartesian product Lp = Op   Lp   N   N , where Op are the objects referenced by p, Lp is the local vocabulary of p, and N are the natural numbers used to represent the strength of the association between Op and Lp.
The lexicon may include synonymous labels, where two labels are associated to the same objects, and homonymous labels, where the same label is associated with two di erent objects.
The following table illustrates a sample lexicon.
From the table, for example, we can see that the association between object o1 and label l1 has been successfully used 8 times in 10 di erent language games, while the association between o1 and label l2 has been successful only once in 8 games.
The ultimate goal of the game is to bring the local lexica of the peers towards the same association structure.
If all the peers converge to the same label to denote the same object the lexica will enable e ective communication among peers.
Op Lp Times used, u o1 o1 o2 o3 l1 l2 l1 l3



 success-Times fully used, a



 A naming game involves an iterative process based on pairwise sessions.
The basic interaction involves two peers with di erent roles: speaker and hearer, and so a session of communication is not symmetric.
Nevertheless each peer can play di erent roles in di erent sessions.
The interaction proceeds as follows (see Figure 1).
First the speaker ps selects an object os   Os from its set of objects, and encodes os using a label lj.
The label is chosen according to the preferences expressed in the current version of the local lexicon Ls (local to speaker ps).
The encoding of object os is obtained by looking at the most successful label.
A label lj is more successful than a label lk i  hos, lj, uj, aji   Ls, hos, lk, uk, aki   Ls, uj   uk and either aj/uj > ak/uk or aj/uj = ak/uk and uj > uk, where uj represents how many times the label lj has been used and aj represents how many times there was an agreement on label lj with other peers.
In case of a tie, a random choice is performed.
The hearer ph decodes the label lj and retrieves the associated object, oh   Oh, by looking at its own lexicon Lh.
The actuation step is in charge of sending the object oh to the speaker ps.
The last step is concerned with assessment.
The speaker has to verify that the object received from the hearer is the same as that selected at the beginning of the communication session.
If the object referred to by the hearer is the same as selected by the speaker, both of them positively reinforce their lexica by updating the corresponding label-object association as follows: hos, lj, uj + 1, aj + 1i   Ls and hoh, lj, uj +
 os 6= oh, it means that the communication failed and the peers  lexica is negatively reinforced by only increasing the counters of lexical relation (while the counters of agreements on the lexical relation remain the same): hos, lj, uj + 1, aji   Ls and hoh, lj, uj + 1, aji   Lh.
The critical point of the game is the assessment step.
Objects can refer to heterogeneous representations of the same concept and therefore the assessment step needs to be carefully implemented.
Looking at our example, objects can be di erent instances of di erent schemas that refer to the same ski route.
An assessment strategy could exploit the mapping between the two schemas, but as we have seen before this task is too complex.
An alternative strategy is to assess the equivalence by looking directly at the data.
In Section 7 we will provide the details of the implementation choice for our case study on ski mountaineering.
In the previous sections we have de ned the problem space that we are exploring and the language games-based approach we leverage.
In this section, we will illustrate the software component that we have designed and implemented to concretely realize our technique.
We defer to the next section the discussion of how this component is used in a speci c scenario, namely the domain of ski mountaineering.
The reference scenario that drove the design task is similar to the one presented in section 2.
Precisely, we assume that our solution is to complement a network of web applications each providing a legacy catalog system and an annotation service.
The catalog system is a repository of representations of items (objects in the terminology of section 5), e.g., books, ski routes, bookmarks.
The annotation service collects users  reviews on cataloged objects.
While the systems we are targeting appear to be fairly distinct, they are instances of a more general type of application that has a private catalog of objects and can share references to these objects.
Such systems are indeed very common on today s Web, with Amazon and Epinions being typical examples.
The main functional goals of our component are to allow the alignment of catalogs and to support the distributed aggregation of annotations created by related applications.
The basic requirements that we identi ed consist in preserving the heterogeneity, the autonomy and the robustness to evolution of these applications.
To support heterogeneity, we require only the minimal set of architectural constraints and allow for alternative implementations of various parts of our component.
We guarantee autonomy by avoiding strong or centralized coordination among individual systems.
Finally, we explicitly take into account that the system is inherently dynamic and subject to change.
In order to employ the language games technique in this scenario, we needed to realize and integrate a distributed implementation of the language games model.
Some implementations of language games already exist, e.g., McIntyre in [15] describes a testbed to set up, control and visualize language games simulations.
However, to our knowledge, all the available implementations consist of standalone simulators that lack the distributed nature of the model and do not allow it to be deployed in a real world setting.
We further require that the implementation of the language games be  exible, to easily implement possible variants to the model, and easy to program and test.
Lastly, we wanted to minimize the cost of augmenting existing solutions with our component.
This requirement translates into realizing a component that can be transparently plugged into an existing system, requiring as few mod-i cations as possible to its legacy parts.
Figure 2 represents the architecture of our component as it was shaped by the requirements described above.
The Application Server represents the generic legacy systems we are focusing on; DiAGRA (Distributed AGgRegator of Annota-Application Server Catalog DiAGRA Public Lexicon Label Concept DiAGRA (remote) Annotation Service DiCA DiCA (remote) Private Lexicon Label Concept Used Hits Figure 2: The architecture of the component.
tions) is the module in charge of implementing the aggregation functionalities; DiCA (Distributed Catalog Alignment) realizes the catalogs alignment feature.
The DiAGRA module decouples inter-peer communications from the details of how each peer s catalog is organized.
To do so, it maintains the current public lexicon, a dictionary that maps local objects to labels.
All the communication is proxied through DiAGRA which performs this mapping task.
DiAGRA uses this lexicon to enhance the aggregation primitives of trackbacking and crawling.
Track-backing refers to the broadcasting of new local annotations to all peers in the federation: it is used to  push  annotations to remote sites.
Conversely, the crawling facility allows a peer to  pull  annotations from remote peers.
Figure 3 describes the  ow of operations performed when a new annotation is inserted by a local user.
Figure 4 represents how remote annotations are retrieved.
Note how the translation operations performed by DiAGRA are transparent to the Application Server.
Figure 3: Sequence diagram for the trackback operation.
In the trackback scenario, when a user posts a new comment with respect to a local item, the Application Server noti es DiAGRA of the new annotation available.
DiAGRA looks up its lexicon and retrieves the label associated with the annotated object.
It substitutes this label for all the ref-Figure 4: Sequence diagram for the crawling operation.
erences to the local item in the annotation and then sends the annotation to the other peers in the federation.
A peer receiving the annotation performs the opposite translation, from the label to the local item.
The translated annotation, now containing only local references, is made available to local users as if it was produced locally.
In the crawling scenario, a peer asks remote peers to provide the most recent annotations inserted by their users.
At the remote peer, the crawling request is handled by the DiAGRA component.
It fetches the annotations from the Annotation Server, translates references to local objects to the associated labels de ned in the lexicon, and sends back the translated annotations.
The  rst peer is now able to perform the opposite translation and presents the received annotations to local users.
The translation processes that we have described may fail in two cases: when there is no mapping available for an object - meaning that it is not shared by other peers of the federation - or when a received label has no mapping that is, it is encoding an unknown object.
In both cases, DiAGRA simply drops the faulty annotations.
In summary, DiAGRA makes possible to dynamically pa-rametrize communication with a desired lexicon.
Therefore, it solves the problem of how an Application Server, given a lexicon common to a community of peers, can start using the lexicon in its communications without modifying the legacy catalog.
Next we will see how such a common lexicon can be provided.
This is the task of the DiCA module, described in the following section.
The DiCA module encapsulates the language games technique by implementing the model outlined in section 5.
DiCA s primary task is to use the language games approach to adaptively build and re ne a common lexicon.
Speci cally, its responsibilities are threefold.
Firstly, it de- nes the choreography of the distributed system, by specifying the possible inter-peer communication methods.
This is achieved by providing primitives to send a peer a label, a label and a set of objects, a set of objects or a feedback message.
Secondly, it stores a variety of implementations Figure 5: A language game.
for each step of a language game.
For instance, it contains di erent primitives to select the next peer to play with, such as randomly selected or in a round robin fashion.
Finally, it provides the mechanisms to create and run game strategies, i.e., to express how the communication and game primitives should be combined to play a language game.
Figure 5 shows two DiCA components engaged in a language game interaction.
In this case, the choreography consists of the exchange of three messages: the speaker sends the hearer a label; the hearer sends an object to the speaker; the speaker sends the result of the game to the hearer.
Each self-message in the diagram represents the invocation of a primitive operation.
By selecting di erent primitives one can de ne new strategies.
For example, a strategy where peers are contacted in a round robin fashion can be obtained by substituting the invocation of the PickPeerRandom primitive with the PickPeerRoundRobin.
A complete description of the DiCA module is out of scope of this paper.
We invite the interested reader to refer to [3] for further details.
The decomposition of the system into DiAGRA and DiCA allows us to keep clearly separated the tasks of building a common lexicon, which is performed by DiCA, and the task of using the lexicon, performed by DiAGRA, to provide interoperable services.
The main functional e ect of this separation is that the stable lexicon is less sensitive to  uctuations in the process of agreeing on a common lexicon.
From the technological point of view, the interfaces between the Annotation Server, DiAGRA and DiCA are REST interfaces.
Communication between peers is performed using web services technology.
The architecture we have presented in the previous section is general enough to  t many di erent scenarios.
However, in order to practically assess it, we grounded the architecture in the ski routing scenario presented in section 2.
The web applications we are targeting are gulliver, ski-rando and moleskiing.
Each of these web sites is the center of a ski mountaineering community to which it o ers the services of a ski route catalog and a ski trip annotation list.
This scenario constitutes a  ne example of the semantic interoperability problem: because these communities are completely autonomous and heterogeneous, they use di er-ent schemas to describe ski routes and denote the same routes using di erent names.
As a consequence, annotations on trips performed along the same routes cannot be shared among communities.
Furthermore, in the ski mountaineering domain there is currently no e ort leading to the formation of a shared ontology nor is it foreseeable in the future.
Thus, it represents an ideal scenario for the application of the language games approach.
Let us, then, examine how the advertising model maps to the ski mountaineering domain.
Ski mountaineering web sites play the role of peers and ski routes map to objects.
They are private to each peer, in the sense that a peer is free to model a route according to the schema it prefers.
The role of objects is played by concrete representations of ski route models.
A convenient way to represent a ski route is to provide an XML linearization of the information available for the route.
The following are the linearizations for the same route as modeled by two di erent ski mountaineering web sites: <route> <id_route>3002</id_route> <top>Altissimo di Nago</top> <route>da S.Giacomo</route> <area>Trentino</area> <municipality>MORI</municipality> <valley> Valle dell Adige (Alto Garda - Baldo) </valley> <difficulty>MS</difficulty> <exposure>SE</exposure> <start_height>1150</start_height> <top_height>2078</top_height> <gap>930</gap> <start_point>S.
Giacomo</start_point> </route> <route> <id>3940</id> <top>Altissimo di Nago</top> <region>Adamello</region> <title>Da San Giacomo</title> <global_difficulty>AD</global_difficulty> <ski_difficulty>S4</ski_difficulty> <base_height>1194</base_height> <top_height>2079</top_height> <gap>900</gap> <exposure>E</exposure> </route> A typical use case scenario is the following.
The DiCA module on moleskiing is activated and starts playing language games with gulliver and skirando.
When the shared lexicon starts emerging, a snapshot of the lexicon is provided to DiAGRA.
At this point, DiAGRA holds a mapping for some of the routes that are common to other web sites.
For these route, moleskiing can retrieve and present to its users annotations inserted on gulliver or skirando, and conversely share annotations produced locally.
The current prototype uses Tomcat and the axis toolkit to support the SOAP protocol, and Java for the DiAGRA and DiCA implementations.
The language used to de ne game strategies is BPEL4WS, a composition language normally used to perform web service orchestration.
We chose it for its builtin coordination features, relatively high level of abstraction and the availability of tools to do quick, graphical programming.
We are currently testing the system locally before deploying it on the real web sites.
A number of factors in uence the outcome of a game.
Previous works on language game simulations show that the number of peers, the cardinality of the object and label sets of each peer, the mutual overlapping of the object sets and the particular strategy adopted to play a game are critical factors.
Our test bed has the following setup.
It reproduces the federation composed of the skirando, gulliver and moleski-ing web sites.
The following table summarizes the main characteristics of the datasets we are using: Total items gulliver overlap moleskiing overlap skirando overlap Complete overlap gulliver moleskiing

 -


-


skirando


 -
The overlapping objects in the test datasets were found manually.
In regards to the details of peers interactions, we are experimenting with a number of basic language game strategies.
An especially critical step in the game is the assessment task, in charge of evaluating whether two route lineariza-tions represent the same ski route.
In the current setup, the DiCA primitive that performs this step uses a string comparison technique based on a bipartite matching algorithm.
It works as follows: The linearizations are divided in tokens and schema information is dropped.
This leaves two sets of tokens, in our example {3002, Altissimo di Nago, da S.Giacomo, Trentino, MORI, Valle dell Adige (Alto Garda -Baldo), MS, SE, 1150, 2078, 930, S. Giacomo} and {3940, Altissimo di Nago, Adamello, Da San Giacomo, AD, S4,
 is then used, given a distance function, to  nd the optimal matching of tokens.
Working on attribute values overcomes the drawback of high variance in schema design by taking advantage of the redundancy of the data values.
The fundamental assumption underlying this assessment method is that di erent representations of the same object share a signi cant part of their textual content and that, on the contrary, the contents of di erent objects are signi cantly di erent.
For example, in our sample routes, the tokens  Altissimo di Nago  and  Giacomo  are present in both representations.
Of course, this method is not applicable where the assumption does not hold.
It is important to stress, however, that the assessment primitive, like all the other game primitives, is a parameter of a peer s strategy.
In other words, peers are free to choose the assessment method that best suits the characteristics of objects representation.
The primitive then, given an object, ranks local routes according to the matching weight.
On our data, this simple method e ectively detects the correct matching, if one exists.
If a matching does not exist, it still provides an answer, which can be interpreted as the best approximation for the given example route, i.e., the  nearest  ski route, according to some distance metrics.
We tested the system running various game sessions.
In every game, either two or three peers were employed, playing the roles of gulliver, skirando and moleskiing.
Every peer contained the routes in common with all the other peers participating in the game.
Dynamic modi cations to the federation or to individual peers  object sets will be included in future trials.
Figure 6 shows the plot of four sample game sessions.
It shows the percentage of lexica convergence as a function of the number of games played by peers.
0% convergence means that there is no common associations among the peers: every peer is using di erent labels to encode the same object.
Thus, the common lexicon is empty and inter-peer communication will fail.
Conversely, 100% convergence indicates that all peers have reached an agreement on how to reference all shared objects.
The common lexicon contains one entry for each shared object and thus inter-peer communication is always successful.
Translating these  nd-ings into our application, 0% convergence implies that no ski routes contained on remote sites have been associated to local routes.
Therefore, no annotation produced on a remote site is available on the local site.
100% convergence means that all remote routes have a local correspondent and that all annotations produced in the federations are available to all web sites, independently of the production site.
Some observations are possible about these results.
Firstly, all games end in a 100% convergence state.
This happens because there is a complete overlapping of the object sets of all playing peers.
In a more realistic situation there would be peers equipped with objects that are not common to other peers.
In this case, the convergence process would stop before reaching 100%.
Secondly, the increase in the convergence rate is not strictly monotonic.
This can be explained as follows: As a result of a series of games among a subset of all peers, an association between an object and a label might be chosen that maximizes communicative success in this subset.
However, this association might represent a suboptimal choice at the level of the whole federation.
Hence the decrease in the overall convergence percentage.
Manual checking has shown that the routes that end up being denoted by the same label in the shared lexicon are actually the same.
However, this result depends essentially on the e cacy of the assessment module: in this case, it was able to correctly identify matching routes.
In tests, the convergence speed is most strongly dependent on the object sets cardinality.
The smaller the cardinality, the lower the number of matchings to be established and, consequently, the faster the convergence.
With regard to the peer numbers, it is worth remarking that in the test setup, we deal with a very limited federation, composed of either e c n e g r e v n o c n o c x e i l f o %






 Game sessions gulliver-skirando gulliver-moleskiing skirando-moleskiing gulliver-skirando-moleskiing







 Number of games Figure 6: Evolution of common lexicon formation.
two or three peers.
Therefore, it is impossible to meaningfully assess the impact of this factor on the lexicon formation.
Nonetheless, on the basis of previous simulations, we expect the peers number to also be a key factor in the convergence speed.
In this paper we investigated the problem of building the distributed common reference systems needed to enrich current web applications and allow for their meaningful inter-operability.
We introduced a novel approach to this problem based on the language games technique.
To our knowledge, this paper is the  rst to describe a general architecture that can be used to deploy the technique in real applications on the web.
Lastly, we presented our experience with a concrete example of both the technique and the architecture in the  eld of ski mountaineering.
There is wide scope for future work.
The model underlying the language games technique is still fairly unsophisticated and we plan to use the experience gained from practical experimentation to improve it.
Along the same line, we expect to design more re ned strategies to guide the games, in order to improve the lexicon building process.
The use case we have shown here has some limitations.
In particular, there is a one-to-one mapping between objects and their linearization.
We plan to test our approach on other, more complete, domains, e.g., the blogosphere.
Finally, it is interesting to observe that the problem we considered in this paper is only one small subpart of the larger problem of providing an extension of the current web so that  information is given well-de ned meaning, better enabling computers and people to work in cooperation  [5].
It is our hope that the approach we present here, although orthogonal to the ones employed by the mainstream Semantic Web initiative, can be a useful piece in the solution to this larger problem.
We are encouraged by the results we present in this paper, since they show that this research trend, even at its beginning, can successfully be applied to real problems in real world scenarios.
We would like to thank Roberto Tiella and Arun Sharma for their collaboration to implement the work presented here.
Andrew Webb helped us to revise this paper.
This work was partially funded by the DiCA project, thanks to a grant of INRM (Istituto Nazionale Ricerca Mon-tagna) and PAT (Provincia Autonoma di Trento).
