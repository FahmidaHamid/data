Let there be no misunderstanding.
In this paper, we will try to sell you yet another query language for XML.
Our language has a catchy name, but more importantly we think it solves a real problem, in the current web services architecture, that is not properly addressed by the existing query languages for XML.
XML is about trees, and people are rather familiar with tree structures: genealogical trees, tree hierarchy in  le systems or bookmarks, etc.
Yet, the current query infrastructure for XML does not support a simple operation that consists of taking a document and return a sub-document.
As we will show, this is a quite natural operation, that happens to be very useful in a lot of application domains.
Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
Ecole Nationale Sup erieure des T el ecoms Bogdan Alexe

 bogdan.alexe@enst.fr But let s start by de ning what we mean by sub-document.
The notion of a sub-document is a totally natural concept when you think about it.
This is nothing more than the counterpart of the result of a select-project (SP) in the relational model.
The relational model deals with tables.
SP operations remove rows and columns to produce sub-tables.
XML deals with documents and we want to remove sub-trees to produce sub-documents.
Note that sub-documents are not properly captured by existing query languages.
XPath consumes a document to produce a node-set.
XQuery creates new node ids.
We will elaborate more in the next section.
An XML document is a tree de ned by D = (N, V,  , <d) where: (i) N is the set of nodes in the document with n0 a designated node which is the document s root; (ii) V   N  N is the parent/child relationship between nodes; (iii)   is a function that associates each node with a label; and (iv) <d is an ordering relation on the nodes of the document.
(cid:1) d) of an XML docu-(cid:1) ment D = (N, V,  , <d) is de ned as follows: (i) D and D have the same root; (ii) N =   and (v) < , < (cid:1)   N ; (iii) V (cid:1)   V ; (iv)   (cid:1) A sub-document D

 ,   (cid:1) d=<d.
(cid:1) (cid:1) (cid:1) (cid:1) Another way to look at it is to consider a document as the set of root-to-leaf paths.
In the example of Fig. 1, the set is:

 A sub-document corresponds exactly to a subset.
For our example, the subset is:

 Yet another way is to say that a sub-document is the original document where some sub-trees (down to the leaves) have been removed.
There are many uses for sub-documents.
Sub-documents can be used to de ne XML views.
Sub-documents correspond to join-free queries.
This is natural for data integration.
For instance, one can de ne views over XML sources, each view being a sub-document of the actual source.
These views can then be joined to produce another document.
Sub-documents can also be used to de ne access control over XML data.
A sub-document corresponds to the data that can be seen.
Sub-documents are also very useful for data merging and synchronization because the structure of the original document is preserved.
Algorithms like the deep union [8] require such information.
Finally, we think that sub-documents can also be used for distributed query processing of XML data.
First, they permit to ship around only the relevant parts of the document.
Given the verbosity of XML, this can be a huge save in bandwidth-conscious environments.
Second, they permit to ship enough structure (path to the root) to conduct semi-join [19] like algorithms over XML.
user pro le management in GUP ster We now describe how the notion of sub-document naturally came into play for the privacy conscious management of user pro le information.
In today s networks, user pro le information (e.g.
address book, presence, location, calendar, etc.)
is scattered all over.
Various initiatives [1, 14] are standardizing XML-based solutions to o er a web service single point of access for this information.
The GUP project [22, 2, 13, 21] at Bell Labs goes in the same direction, with a dual emphasis on integration and access control.
In this context, we are looking to: (1) integrate, into a common schema and on a per user basis, XML data coming from various sources; (2) permit users to de ne access control rules over the integrated data; and (3) let applications query the data while enforcing user privacy.
This yields the need for the following concepts:   a query, de ning what portion of the user pro le is   a mapping rule, de ning where a portion of the user   an access control rule, de ning under what condition a portion of the user pro le can be accessed (mapping to boolean function).
pro le is stored (mapping to a data source).
ster requested.
Quite naturally, a portion of the user pro le corresponds to a sub-document of the user pro le.
One question we have to answer is how we can express sub-documents.
Moreover, for e ciency, we want to avoid to retrieve data that is not needed in the  nal answer either because it is not part of the query or because it not visible due to access control rules.
Therefore, we envision the processing of an incoming query Q as follows.
Given a user pro le D, a set of mappings {Mi}, a set of access control rules {ACRj}, we want to = f ({Mi}, {ACRj}, Q, D).
Or maybe even bet-compute D = g({Mi}, {ACRj}, Q, )(D).
ter, we would like to compute D This way, instead of having to send the query and apply the access control on the result that is sent back, we send to each source a query compatible with the access control.
This is much more e cient.
(cid:1) (cid:1) The rest of the paper is organized as follows.
In Section 2, we explain why currently available query languages are not appropriate for this new kind of queries.
We then present the language itself, with its syntax, semantics and operators (union and composition).
In Section 5, we describe various strategies to evaluate XSQuirrel queries over XML documents by translating expressions into other query languages: XPath, XQuery and XSLT.
We then present some experimental results that (1) compare the various evaluation strategies and (2) show the bene t of composition operator, for queries and data over some XMark [23] dataset.
Some














 Figure 1: Original document D and sub-document D(cid:1) de ned by q1(D) (grey marking).
related work is discussed in Section 6, before we o er our conclusions and some future work.
In this section we argue that we need a new language because the existing ones do not address the issue of sub-document queries properly.
We explain the shortcomings of XPath, XQuery and XSLT and list some requirements for the design of our new language.
The XPath 1.0 [10] has been designed mostly as a navigation language that returns a subset of the nodes of a document.
For instance, XSLT uses XPath heavily to match patterns that need transformation.
When applied on a document, XPath returns a nodeset and not a sub-document.
From the nodes, it is always possible to reconstruct the document (using the context to  nd the ancestors of the current node up to the root), but this is not the default behavior and the application using XPath needs to perform this reconstruction.
Moreover, when the context is lost (e.g.
data shipped from a remote site), this information is lost.
The main problem with XPath is that the input and the output of the query are not the same domain and therefore queries cannot be composed.
Even though XSLT has the notion of document builtin in its semantics with templates being applied to the current document, it is a language hard to reason about because of its rule-based nature.
Moreover, the output of an XSLT transformation is not necessarily a document.
XQuery [9] is the general purpose query language for XML.
The problem with XQuery is threefold.
First, in our setting, this is like a hammer to kill a  y, since sub-document queries are restricted in nature (remember the analogy with select-project in the relational algebra).
Moreover, XQuery does not know about the sub-document semantics.
Second, XQuery processes a document by  rst deconstructing it into FLWR bindings and then reconstructing it.
Not only does this imply a lot of syntax, it also requires the creation of new node ids.
When the sub-document consists of only a few nodes removed from the original document, this is a lot of overhead.
Third, XQuery is so rich and powerful that it is very hard to reason about.
XQuery is by nature composable.
For two queries Q1 and Q2 over document D, you can always represent the composed query as let $x:=Q1(D) return Q2($x).
But it might be hard to optimize such an expression.
Based on the previous considerations, we decided to go for a new domain speci c language that would  t our needs and ful ll the following requirements:   builtin sub-document semantics   composability of queries   expressive enough to be useful   simple enough to be reasoned about and optimized   concise syntax   friendly with other XML languages (e.g.
reuse of syntax, translation to other languages for evaluation)
 In this section we present the XSQuirrel language.
It is based on XPath 1.0 and therefore XSQuirrel is rather a family of languages, depending on which fragment of XPath 1.0 we decide to use.
All these languages   of course   share the same semantics but the details of some of the algorithms may be di erent, depending on the expressive power of the fragment we use.
For a detailed study of these issues and a more theoretical presentation of XSQuirrel, we refer the reader to [5].
ster In the rest of the section, we will consider a very limited fragment of XPath1.
This is the one we are using in the context of GUP and it has shown so far to be expressive enough for our application domain of privacy conscious integration of XML data.
XSQuirrel expressions are built from a  nite set of labels (e.g., tags, names)   of an XML schema S. The fragment of the language that we consider in this paper is syntactically de ned as follows: p :=  | l | p/p | p/(p   p) | p[q] where , l denote the empty path ( .  in XPath) and a name in   respectively;   stands for union;  /  stands for XPath concatenation but here is also used as the XPath child axis.
q in p[q] is called a quali er and is de ned by: q := p | label = v | not(q).
From XPath 1.0, we have kept the child and attribute axis and a restricted form of value-based predicates.
EXAMPLE We give below some examples of XSQuirrel expressions.
q1 : q2 : q3 : q4 : Query q1 for instance returns D and H nodes, that are children of B nodes, themselves children of A nodes.
Along with these nodes, their descendants, and ancestors up to the root node of the document on which q1 is evaluated are returned.
results and conclusions we present here might be di erent for larger fragments of the language that are still under study.
Intuitively, the result of the evaluation of an XSQuir-rel expression q on a document D is document q(D) (sub-document of D) obtained as follows:
 2. for each node n obtained from the previous step, get its descendant nodes, and its ancestor nodes up to the root of D
 D that are not in the set of nodes from the previous step (note that the resulting document q(D) is a sub-document of D).
EXAMPLE Consider the XML document D illustrated in Fig. 1 (ignore the grey marking for now) and query q1 given in Example 3.1.
The result of evaluating q1 over D is sub-document q1(D) where the nodes have been marked in grey.
More speci cally, this document is de ned by the D and H nodes returned when evaluating q1 as an XPath expression on D, their descendants and ancestors up to the root node of D.
More formally: (cid:1) the result of evaluating an XSQuirrel expression q against a document D(N, V,  , <d) is a sub-(cid:1) document D is de ned as: (cid:1) d) of D such that: (i) N
 (cid:1)
 ,   , < (cid:1) (cid:1) (cid:1)
 = [[D]]q (cid:0) n [[D]]q n[[D]]  ::  (cid:0) n [[D]]q n[[D]]  ::  (cid:1)} .
where n[[D]]p denotes the set of nodes returned by evaluating XPath expression p on the node n of document D (n is omitted when it is the root),   and   are the XPath descendant and ancestor axis respectively.
and (ii) V = {(n1, n2)   V | n1, n2   N
 At the level of the language we de ne two language (i.e.
syntactic) operators   union ( ) and composition ( )   such that:  D, (Q1   Q2)(D) = Q1(D)   Q2(D) and  D, (Q1   Q2)(D) = Q1 (Q2(D)).
Here the union of two sub-documents corresponds to the union of their nodes.
(cid:1) For lack of space, we only provide the intuition for the algorithms of union and composition.
We refer the reader to [5] for a more formal presentation.
This operator is pretty straightforward.
For both XSQuir-rel expressions, we can naturally derive two sets of XPath expressions by distributing over  .
We can then take the union (as sets) of the two, recombine them as an XSQuirrel expression and normalize them.
We provide an example below.
The evaluation of the queries over a document is presented in Fig. 2.
q2: /A/B[H]/(D/DD   F) q3: /A/(B[C]   B[H]/(D/II   F/FF)) q2  xq q3: /A/(B[C]   B[H]/(D/(DD   II)   F))
 This operator is more complicated because it is not symmetric.
We distinguish between the inner (Qi) and the outer expression (Qo).
The core of the composition algorithm must ensure two things.
First, that the  nal expression is as selective as












































 Figure 2: Union: q2(D) (left), q3(D) (middle) and (q2  xq q3)(D) (right).
the more selective of the two: /A/B composed with /A/B/C is /A/B/C.
Second, that the predicates from the outer expression correspond to paths that are de ned in the inner expression.
This makes perfect sense when you think of the inner query as the one de ning an access control view for instance.
EXAMPLE Here is an example.
Qo Qi Qo   Qi


 We see that node B[C] of Qo does not appear in the composed query (the path /A/B/C for node B[C] is not satis- ed by the inner query).
Node B[H][D/EE] is created from nodes B[H] and B[D/EE] of the outer and inner queries, respectively.
Node D (and its children) disappears from the resulting query since the outer query (Qo) requests II nodes but the inner query Qi returns only DD nodes.
Finally, node FF requested by the outer query is added below node F (the inner query returns the subtree of F but the outer query requests only its FF sub-nodes).
The evaluation of the queries over a document is presented in Fig. 3.
In Section 3, our description of the semantics of the XSQuir-rel language already implies one way to evaluate expressions using XPath.
In this section, we present three evaluations strategies that translate expressions into another query language, mainly XPath, XQuery and XSLT.
We provide in Fig. 11 a detailed example of the three translations.
The XSQuirrel language is more expressive than the subset of XPath it relies on, because of the union operator and the sub-document semantics.
Therefore we cannot translate XSQuirrel expressions into XPath expressions, but rather into XPath programs.
The algorithm is presented below.
Algorithm 1: XPath evaluation program : D, xsq Input markedNodes := {} xpathList := expand(xsq) foreach e in xpathList do nodeset := XPath(D, e) foreach n in nodeset do markedNodes += {n} markedNodes += descendant-of(n) markedNodes += ancestor-of(n)








 D  := trimNodes(D, markedNodes) Output : D(cid:1) The intuition is to expand (using the expand function) the XSQuirrel expression into a set of XPath expressions, by distributing over the union operator.
For each XPath expression, we evaluate the query over the document.
We mark the nodes from the result nodeset by putting them in markedNodes.
For each marked node, we also mark its descendants and its ancestors up to the root.
Finally, we remove from the original document all the nodes that have not been marked.
The good news with XQuery is that because of the expressive power of the language, we can translate any XSQuirrel expression into a single XQuery expression.
The bad news is that XQuery requires to deconstruct the document (by binding to FLWR expressions)  rst and then reconstruct it.
XQuery can easily take care of the union using node-set concatenation.
We need however to enforce the sub-document semantics.
For instance, a/(b   c) cannot be translated as {for $x in a/b return $x, for $x in a/c return $x} because it forces b to appear before c, which is not necessarily the case in the original document.
The right way to do it is to iterate over the children (thus preserving the document order) and check the nature of the child, using an if statement and a predicate such as [self::b] or [self::c].
This is not going to work either because an expression may contain a union of overlapping paths, such as a/( b[p1]   b[p2]).
To avoid some subtrees to be added more than once, we need to make sure that the if statements are exclusive of each other.
For our toy example, this leads to: for $x in a/* return if $x[self::b[p1]] then $x else if $x[self::b[p2]][not(self::b[p1])] then $x else {} We describe the translation from XSQuirrel to XQuery using two functions T (for translation) and P (for predicates) de ned as follows.
For simplicity, we will ignore expressions with attributes.
Each function is described in terms of production rules that consume the structure of the XSQuirrel expression.
For the predicate function Pred, a step with no children simply returns itself.
In the presence of children, the predicate consists of the recursive concatenation (using boolean or) of the predicates of the children.
For instance /a[p]/(b   c/d) will return a[p][b | c[d]].
Pred:     a[p] a[p] a[p]/(a1[p1] .
.
.
  an[pn]) a[p][ Pred(a1[p1]) .
.
.
| Pred(an[pn]) ] Figure 4: Translating XSQuirrel to XQuery












































 Figure 3: Composition: D (left), qi(D) (middle) and qo   qi(D) = qo(qi(D)) (right) The translation function T takes three parameters: the location step of the XSQuirrel expression, the current binding (used by the FLWR expression) and a list of predicates.
The list of predicates is used to ensure that each if statement is exclusive of the others.
The XQuery generation proceeds as follows:  the binding provides the current node to process the list of the predicates step by applying the predicate self::Pred(a[p])   we check that the node satis es the current location   we make sure that the if case is unique by applying   if the location step has no children, we return the node   if the location step has children, we output the tag name of the current node, we iterate over all its children via a FLWR expression and we close the tag name or nothing
   for $x in /* return T(a/path, $x, {})   if $x[self::Pred(a[p])][not(self::P1 )].
.
.
/a/path , $$, {} a[p], $x, {P1,...Pm} .
.
.
[not(self::Pm )] then $x else {} a[p]/(a1[p1] .
.
.
  an[pn]), $x, {P1 .
.
.
Pm}   if $x[self::Pred(a[p]/(a1 [p1] .
.
.
  an[pn])] and $x[not(self::P1 )].
.
.
[not(self::Pm )] then <a> for $x+1 in $x/* return T(a1, $x+1, {} ) T(an, $x+1, {Pred(a1) .
.
.
Pred(an 1)} ) .
.
.
</a> else {} Figure 5: Translating XSQuirrel to XQuery The FLWR expression generates a new unique binding (noted by $x+1).
For each child, we call T, with the following parameters: the corresponding location step ai, the new binding $x+1 and a new list of predicates.
For each child, the list of predicates corresponds to the predicates from the previous children (Pred(a1), ..., Pred(an 1)).
It turns out that XSLT is a much more natural language for sub-document queries.
The notion of document is somehow builtin in the semantics of the language itself because of its rule/template system.
The union operator of XSQuirrel can naturally be translated into XSLT templates that will be applied following the structure of the document.
Unlike with XQuery, we don t have to worry about deconstructing the document and then reconstructing it by taking good care of the order.
The XSLT ruleset we generate consists of 3 modes of operations: default, regular and leaf.
For default and regular, we de ne default templates that don t do anything.
For leaf, the template calls recursively templates for the content of the subtree.
From the navigation step of the XSQuirrel expression, we derive a rule that consumes the root (in mode default) and calls a rule for this step.
The other rules are derived from the XSQuirrel expression as follows, using translation function T  de ned in Fig. 6.
For sake of clarity, we do not show the exact XSLT rules being generated but abbreviate them using their key components: for the outer template, its mode and match; for the inner template, its mode and its select (the nodes for which the inner template must be applied).
Rule 1: For the  rst navigation step of the XSQuirrel expression, we generate a template that consumes the  rst element in mode default and calls for a template over the same element in mode regular.
Rule 2: We translate the last location path of an XSQuir-rel expression (a[p]) by generating a template that matches the current node and calls for a template over the same node but in mode leaf in order to return as is the entire subtree.
Rule 3: The last translation rule generates a template that matches the current node with the predicates corresponding to its child nodes (we reuse the Pred function we de ned for XQuery).
It calls for a template that matches any of the children.
We translate recursively each child element of current location step.
/a/path
   template:
 apply: T (a/path)   template: a[p]
 mode="default", match="/" mode="regular", select="a" mode="regular", match="a[p]"
   template: apply: mode="regular", mode="leaf", select="."
a[p]/(a1[p1]   .
.
.
  an[pn]) match="Pred(a[p]/(a1 [p1]  .
.
.  an[pn]))" apply: select="Pred(a1[p1]) |.
.
.
| Pred(an[pn])" T (a1[p1]) .
.
.
T (an[pn]) mode="regular", Figure 6: Translating XSQuirrel to XSLT Note: We are aware that we do not provide any formal proof of the correctness of the translations, except for the XPath translation that corresponds exactly to the semantics of the language.
This is left for further study.
For all the experiments we ran (see next section), we have checked that the results provided are all equivalent.
We are aware of some pathological cases of XSQuirrel expressions that get improperly translated into XSLT because of ambiguities.
A proper characterization of such cases is also left for further study.
In this section, we want to answer two questions: (1) which is the better way to evaluate XSQuirrel expressions; (2) what is the runtime bene t of query composition, if any.
For this experiment, we consider various queries over some XMark [23] generated data and compare their execution time in  ve di erent con gurations:   XPath: we use the Apache Xerces implementation because it o ers access to node index information.
We use the index value as a way to mark the nodes returned by the evaluation of the XPath expressions.
The document is parsed once and built in main memory.
The nodes not part of the  nal result are removed.
  XSLT (Xalan): query translated into XSLT and ap-  XSLT (Saxon8): query translated into XSLT and ap-  XQuery (Saxon8): query translated into XQuery and   XQuery (GALAX): query translated into XQuery and applied using the Java JAXP API.
plied using the Java JAXP API.
plied using the Java JAXP API.
applied using the command-line.
We have created  ve representative queries that demonstrate various features of the language (see Fig. 9).
To avoid comparing apples and oranges, we stream the  nal result into a SAX content handler that computes the normalized hash of the result document.
This permits to check that (1) all the evaluators provide the exact same result and that (2) all content is accessed (some implementations sometimes perform lazy evaluation).
The results are presented in Fig. 7.
The XPath evaluation should be looked at as the base strategy since it does things in a straightforward and naive manner, with no room for optimization (XPath expressions applied sequentially).
Also note that Xalan and GALAX are clearly not as competitive as Saxon8.
Overall, both translations to XQuery and XSLT are better than the naive XPath program.
The XQuery translation seems to be a bit more e cient, due probably to the builtin optimizations and the deterministic nature of the evaluation.
XSLT rules can be inherently ambiguous and the engine tries to pick the best match (most restrictive rule).
Note also that the way we translate into XSLT introduces some redundant checks (in the select and in the match) that are probably not optimized (e.g.
keep track that the check was successful for a given node).
Some preliminary experiments (not reported here) with an early native evaluator for XSQuirrel show on par performance with XSLT and XQuery.
The skeptical will argue that native evaluation does not make sense and that resources should be focused on general purpose query engines.
The optimistic will counter argue that being on par with XQuery and XSLT is a very good start and that with more work, evaluation time should be improved signi cantly and maybe reach the high-level performance shown by native XPath engines [7, 4].
The second thing we want to measure is the bene t (if any) of our language-based composition for our fragment of the language2.
Using XSQuirrel, we can replace the sequential evaluation of two queries with the evaluation of just one.
(cid:1) For pairs of queries Q and Q , we compare the evaluation of the composed query Q   Q (cid:1) (computed using our algorithm) with the evaluation of the sequential queries.
For XSLT, we can chain the two transformation using XMLFilters from the JAXP API.
Note that this does not permit any optimization between the two rulesets.
For XQuery, we represent the chained queries using the following XQuery expression: let D := Q(D) return Q (D ).
The six queries we use for our experiments are detailed in Fig. 10.
The results are presented below: s e i r e u











 Composed / Sequential
 XSLT (Saxon8) XQuery (Saxon8) XPath




















 Figure 8: Composed vs sequential evaluation.
The  rst thing to note is that there is no groundbreaking bene t when using composition.
Depending on the queries and the evaluators, improvements are around 10-20%.
In a web services environment, with millions of queries a day, this makes a nice di erence at the end of the day though.
Composition is a clear winner when the composed query is empty (e.g.
Q6), a very frequent case when one query is used to de ne access control view.
Knowing that the query is empty ahead of time not only saves a lot of processing times, it also saves on communication costs in a distributed environment.
Both aspects can be extremely valuable.
There is a lot of ongoing work in both research and industry community around the already existing query languages (XPath, XQuery and XSLT).
See for instance [16].
The idea of returning subtrees appears in the context of distribution and replication of XML documents in [3]: the fact that a subtree of a node should be returned has to be explicitly de ned in the XPath expression and is not inherent in the semantics of the language as for XSQuirrel.
the limited fragment of the language.
For larger fragments, we expect the bene ts to be larger.
Evaluation Times (22MB document) Evaluation Times (11MB document) Evaluation Times (small document)




































 XPath (Xalan)
 (Xalan)
 (Saxon8) XQuery (Saxon8) XQuery
 XPath (Xalan)
 (Xalan)
 (Saxon8) XQuery (Saxon8) XQuery
 XPath (Xalan)
 (Xalan)
 (Saxon8) XQuery (Saxon8) XQuery
 Figure 7: Comparison of the various evaluation strategies.
[18] follow a similar approach to [3] where XPath expressions return documents instead of sets of nodes.
But the semantics of the language is not de ned formally.
The idea of having a project operator for XQuery was proposed in [17], but this is an internal algebraic operator.
Some domain speci c languages for XML have been proposed for various contexts such as integration with relational sources ([12]), or access control ([11, 6]).
The industry is also pushing for some new languages.
In Liberty Alliance, a data service template [15] can de ne its own query language  avor (the suggested ones are subset of XPath).
In XCAP[20] (proposed standard for next generation of telecom application), resources can be accessed using a restricted  avor of XPath.
The work on e cient XML processing over streams is also relevant here.
Our early implementation of a native XSQuir-rel evaluator is inspired by [7, 4], even though the di erent semantics of XSQuirrel does not make these results directly applicable.
In this paper, we argue that more and more applications will need to consider sub-document queries, where the result of the query is a sub-document of the original document.
Synchronization, access control, distributed query processing are such examples.
The current query languages for XML do not address this speci c issue: XPath returns nodes instead of a sub-document; XSLT and XQuery are too expressive and it is hard to guarantee statically what will be returned.
To address this issue, we introduce the XSQuirrel language.
Following the XPath syntax, XSQuirrel o ers a sub-document semantics where the result of a query is always a sub-document of the original document, which makes it possible to compose queries.
One strength of the language is that queries can be composed at the language level.
For two XSQuirrel queries Q1 and Q2, we can syntactically compute Q1 Q2.
Thus, instead of evaluating two consecutive queries, we can simply evaluate the composed query.
We have shown the runtime bene ts of this approach for various queries ran against the XMark dataset.
Another strength of the language is that it is possible to translate XSQuirrel expression into other XML query languages.
Already existing high-performance query engines can therefore be reused and there is no need to build XSQuir-rel speci c ones.
In the paper, we have described the translation algorithms and shown how the translated queries perform on the XMark data set.
There is still a lot of work to be done.
Finding the right expressive power for the language (i.e. which fragment of XPath to choose from) is not easy, and new features added to the language may require to modify the rewriting, translating and evaluating algorithms.
We also want to build a high-performance native evaluator that can reach the performance of stream-based XPath evaluators.
Investigating the bene ts of composition for larger fragments of the language is important too.
People have and will argue legitimately about the need for yet another XML query language.
For our application domain (privacy conscious user pro le management), we needed to combine integration and access control of XML pro le data and the available query languages were simply not good enough for our needs.
We engineered XSQuir-rel to  ll this gap.
By making it close to XPath in syntax and by providing translators to XPath, XQuery and XSLT, XSQuirrel can be seen as some kind of syntactic sugar that can be really handy for our application domain.
We think that XSQuirrel can also be useful in a broader context and we hope that this paper will convince more people to give it a chance.
Acknowledgments: Irini Fundulaki, Michael Benedikt, Nicola Onose, Guillaume Giraud, Nicolas Pombourcq, the members of the 3GPP GUP working group.
