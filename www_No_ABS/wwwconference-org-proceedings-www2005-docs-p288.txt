Due to its fundamental role in many database applications such as query optimization and information integration [16], the problem of query containment has received considerable attention over the past few decades.
With the initial focus on relational queries, researchers have recently begun to study the containment problem for various fragments of XPath [13, 1, 22, 12] and XQuery [9, 18, 10].
The key technique of containment mapping for relational queries [4] has been extended in the new contexts to derive mappings between navigation pattern trees and nested XQuery Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
constructs.
It has been commonly recognized that extended containment mapping is central for minimizing XML queries [23, 9], and for reformulating queries in a mediator system [9] or a peer-to-peer environment [18].
This work is motivated by the promising application of semantic caching for answering XML queries using cached XML views [6, 8].
The idea of semantic caching is that the (mobile) client maintains both the semantic descriptions and associated answers of previous queries in its cache, in the hope of being able to reuse them to speed up the processing of subsequent queries.
An XQuery-based semantic caching system named ACE-XQ has been proposed [6, 7] for facilitating XQuery processing in the Web environment.
The main techniques exploited by ACE-XQ include the containment mapping approach for nested XQuery, XQuery rewriting, and a multi-granularity replacement strategy.
With [8] focussed on the proposed replacement strategy and the cache performance evaluation, we introduce, in this paper, the fundamental query containment technique underlining ACE-XQ which is the (cid:12)rst comprehensive practical semantic cache solution for handling nested conjunctive XQuery.
In the XML setting, extensive research has focussed on the query containment problem for regular path expressions on general cyclic graph databases [3], tree pattern queries and XPath queries over XML data [13, 1, 22, 12].
Especially the containment problem for XPath and tree pattern queries has attracted a lot of attention recently due to the fundamental role they play in many XML query languages.
Di(cid:11)erent fragments of XPath have been targeted by di(cid:11)er-ent works.
A well recognized core XPath fragment includes child axis  / , descendant axis \//", branching \[ ]", and wildcard  * .
It is shown in [13] that query containment for this fragment, denoted XP f(cid:3);==;[ ]g, is coNP-complete.
If any of the three constructs \//", \[ ]", and  *  is dropped, query containment is PTIME.
The essence of their containment mapping technique is the polynomial-time tree homo-morphism algorithm1, which serves as a su(cid:14)cient but not necessary condition for containment of XP f(cid:3);==;[ ]g in general.
On the other hand, if tag variables and equality testing are allowed, query containment is NP-complete.
The complexity increases to (cid:5)p

 the readers to [1, 22, 12] for discussions of the containment complexity results under di(cid:11)erent XPath fragments.
However, research on the containment problem for XQuery is still in its infancy.
Besides using XPath expressions as the navigation mechanism, XQuery also employs other query constructs such as FLWR expressions and the nesting of query blocks.
These features make XQuery more expressive than XPath.
On the other hand, they also impose new di(cid:14)culties on the containment problem.
Speci(cid:12)cally, di(cid:14)-culties arise since an XQuery cannot simply be represented by a navigation tree pattern.
Hence containment mapping based on tree homomorphism alone is no longer su(cid:14)cient for determining XQuery containment.
To our best knowledge, the containment of nested XQuery has so far been studied only in [9], [18], and [10].
[9] exploits XQuery containment for query optimization.
It utilizes containment mapping for identifying redundant navigation patterns in a query and later for collapsing them to minimize the query.
In [18], the containment of nested XQuery is researched for the purpose of rewriting queries posted on one peer to be answered by another peer.
[10] studies the complexity of the problem regarding completeness.
Targeting di(cid:11)erent goals, these three works exploit di(cid:11)er-ent approaches.
The containment mapping technique proposed in [9] essentially extends tree homomorphism between navigation patterns with additional requirements for mapping the equality-based where-conditions, groupby id and groupby value variables.
In [18], two types of mappings, i.e., a query-head embedding Ehead(Q1; Q2) and a query-body embedding Ebody(Q2; Q1), are employed as the su(cid:14)cient conditions for deriving Q1 v Q2 (assuming Q1 and Q2 are two nested XQueries).
Ehead embeds the block structure of Q1 into that of Q2 while Ebody embeds the navigation pattern of Q2 into that of Q1.
In [10], containment of nested XQuery is de(cid:12)ned based on XML instance containment.
The theoretical complexity result for methods that ensure completeness is established.
Among these three works, [10] presents an approach that guarantees completeness (i.e., no false negative answers).
In answering-queries-using-views scenarios, it is commonly considered more crucial to guarantee the soundness while the completeness is often ignored to avoid the high complexity.
For example, the containment of nested XQuery in general is coNEXPTIME when ensuring completeness [10].
In contrast, [9] and [18] attempt to provide more practical containment mapping techniques by extending tree ho-momorphism with additional mapping conditions.
In [9], a technique is proposed for identifying redundant navigation within one query.
It considers the mapping of equality-based where-conditions and that of variables distinguished by the set or bag semantics they each represent.
However, all return expressions are considered as black-box functions and ignored in the containment mapping process.
This containment mapping technique is hence a not suitable foundation for determining the containment relationship between two queries.
This is obvious considering the fact that whether the direct bindings of variable v or subelements obtained from further navigation of v s bindings are returned does make a major di(cid:11)erence in the query result.
Furthermore, neither of the two techniques considers the e(cid:11)ect of dependencies among variable bindings on the query result and consequently on the containment result.
In Section 1.3, we give examples of subtle di(cid:11)erences in XQuery semantics caused by di(cid:11)erent dependencies among the spec-i(cid:12)ed variables.
Since these two techniques have failed to address the critical e(cid:11)ect of such di(cid:11)erences on the query containment result, we propose our containment mapping approach which provides su(cid:14)cient mapping conditions for correctly deriving the containment decision.
In this work, we target the containment problem for nested XQuery.
We consider a core fragment of XQuery that allows nested blocks, conjunctive equality-based conditions, set and bag semantics.
Disjunctions, negations, universal quanti(cid:12)er and tag variables are not considered.
This XQuery fragment is the same as that being studied in [9].
[18] and [10] study a subset of this fragment as they exclude the bag semantics.
for $t in document(``bib.xml'')//book/title, $a in document(``bib.xml'')//book/author return <pairQ1> $t, $a </pairQ1> for $b in document(..)//book, $t in $b/title, $a in $b/author where some $p in $b/price satisfies $p=30
 return <pairQ2> $t,$a/last </pairQ2> Q2 for $b in document(..)//book return <pairQ3> for $b in document(..)//book return <pairQ4> {for $t in $b/title, $a in $b/author return $t, $a} </pairQ3>
 {for $t in $b/title return $t}, {for $a in $b/author return $a} </pairQ4> Q4 Figure 1: Example Queries Now let us consider the example queries in Figure 1.
All four queries Qi (i=1..4) specify $t and $a and return their bindings in the results.
Suppose the input document bib.xml is shown at the left top corner in Figure 2, we can see that their results RQi (i=1..4) (also shown in Figure 2) are all different due to the subtle di(cid:11)erences in their variable speci(cid:12)ca-tions and nested block structures.
Suppose that the DTD for bib.xml speci(cid:12)es <!Element book(title; author(cid:3); publisher?
; price?)>.
RQ1 contains six title and author pairs derived from all combinations of the $t and $a bindings document-wide regardless of whether the paired title and author elements belong to the same book.
In contrast, the $t and $a bindings in Q2 are speci(cid:12)ed based on $b.
Therefore, the title and author elements corresponding to di(cid:11)erent book parents do not appear in the same pair in RQ2.
For example, t2 is paired with a1 and a2 but not with a3 in RQ2.
bib .
.
book book book author author title .
a2 t3.
bib.xml .b1 .t1 .title a1 t2 title pr1 price .
b2 .
.
..pairQ2 .. .
.
pairQ2 results author title p2 p1 a1 a2 t2
 title t2 pairQ1 .p1 .
.
p2 .
.
author a1 t1 a2 .title t1 pu1 .
publisher.b3 .
.
pairQ3 .
a1 pairQ3 .b1 .
t2 results b2 b3 .pairQ3 .
a2
 results p3 p4   .
.
.
.
t2 a1
 .
a2 t3 t3 t2 a2 p5 a1 .
.
.
.
p6.
.
..
.
.
.pairQ4 t3.
.
b3 title pairQ4 results author author a2 a1
 pairQ4 .b1 .
b2 .t1 .
title title t2 author title author author Figure 2: bib.xml and Example Query Results The di(cid:11)erences in the structure of RQ1 versus that of RQ2 can be intuitively explained by the di(cid:11)erences in specifying variable dependencies in Q1 and Q2.
That is, the variables $t in Q2 (denoted by $tQ2) and $aQ2 are de(cid:12)ned based on $bQ2, while $tQ1 and $aQ1 are based on $r (i.e., the default root variable bound to the root element of document(\bib.xml")).
We (cid:12)rst explain the e(cid:11)ect of variable dependencies on the resulting query result for Q2.
When constructing the result RQ2, since $tQ2 and $aQ2 are de(cid:12)ned in the same query block, the corresponding new element hpairQ2i is produced for each tuple in the cartesian product of the bindings of $tQ2 and $aQ2.
Due to the way how $tQ2 and $aQ2 are spec-i(cid:12)ed, the bindings of $tQ2 and $aQ2 derived from the same binding of $bQ2 preserve the sibling htitlei(cid:0)hauthori element associations under the same parent book element.
Such hierarchical data dependencies in the source XML are preserved in the intermediate variable bindings based on which the query result is constructed.
In this case, each pairQ2 element in RQ2 combines bindings of $tQ2 and bindings of $aQ2 only if they share the same parent binding of $bQ2.
In contrast, the sibling htitlei(cid:0) hauthori associations are not kept in the bindings of $tQ1 and $aQ1.
Q1 hence produces hpairQ1i elements based on the cartesian product of all the bindings of $t and $a regardless of their respective parent book elements.
Q2 hence preserves a (cid:12)ner hierarchy of element dependencies among its intermediate variable bindings than Q1 does.
We now analyze the e(cid:11)ect of such preserved dependencies on the containment result.
Suppose that the containment mapping technique proposed in [18] is applied to Q1 and Q2 in Figure 2.
Q2 v Q1 would be derived since both Ehead(Q2; Q1) and Ebody(Q1; Q2) can be established as illustrated in Figure 32.
To derive Q2 v Q1, this approach utilizes not only the navigation pattern based mapping represented by Ebody, but also Ehead for checking if the variables returned by Q2 are a subset of those returned by Q1.
However, whether such dependencies among variable bindings in(cid:13)uence the query containment result has not been studied in either [18] or [9].
bib .
book author $a .
.
$r book title $t .
.
{$t} {$a} <pairQ1> Ebody Ehead book
 bib .$r ..
<pairQ2>.
title $t {$t} {$a} $b author $a .
.
Figure 3: Illustration of Containment Mapping via Ehead and Ebody Assume Q2 is answered using RQ1 based on the containment result Q2 v Q1.
Then there is no way to regroup the returned bindings of $t and $a in RQ1 by their respec-
the nested block structure of Q2 into that of Q2.
The dashed arrows denote the mappings between blocks within which the corresponding returned variables match.
Ebody(Q1; Q2) embeds the navigation patterns (denoted by the bold tree edges) speci(cid:12)ed in Q1 into those in Q2.
Ebody(Q2; Q1) but not Ehead(Q1; Q2) can be established.
Hence Q1 6v Q2.
tive book parent elements as required by Q2.
Ignoring this requirement, the produced result of Q2 would contain su-per(cid:13)uous pairs, namely, t1(cid:0)a1, t1(cid:0)a2, t3(cid:0)a1 and t3(cid:0)a2.
First, we address the problem of producing super(cid:13)uous answers based on the query containment result when ignoring the e(cid:11)ect of variable binding dependencies in the containment mapping process.
Correspondingly we identify some important concepts and their connections, as illustrated in Figure 4, to this problem.
element dependecies (formally HMVDs) preserved in variable binding dep.
(VarTree) XQuery Containment concerns query result structure (TagTree) reduced to utilizes essential variable binding dep.
(minimal VarTree) Figure 4: Connection between Preserving of Element Dependencies and XQuery Containment The left hand side (cid:13)ow illustrates the preservation of data dependencies in the source XML in the intermediate bindings via the speci(cid:12)cation of variables.
The right hand side (cid:13)ow represents the fact that XQuery containment needs to take the query result structure constructed based on the binding dependencies into consideration.
Terms enclosed in the parentheses in Figure 4 will be introduced in Section 2.
Also, we realize that not all the intermediate binding dependencies preserved by a query are necessarily utilized in constructing the (cid:12)nal result.
Thus we call a subset of variable binding dependencies being utilized the essential ones via which both (cid:13)ows are connected.
Second, based on our problem analysis, we propose a containment mapping technique that considers the containment of the utilized binding dependencies in the query result.
For this, we (cid:12)rst decompose the input query and represent the two parts of its semantics, i.e., variable binding and result construction, by respective tree structures.
Then we identify the binding dependencies that are preserved by the former and utilized by the latter.
We call it variable minimization.
Next we propose to employ three types of containment mappings for deriving the containment decision.
In sum, we will show that our containment mapping approach is more comprehensive than the prior works [9, 18, 10] in that it deals with the e(cid:11)ect of variable binding depen- dencies on the query containment result.
In other words, it avoids deriving the query containment decision which may lead to producing super(cid:13)uous answers for the contained query by using the result of the containing query.
Like [9] and [18], our approach does not necessarily ensure completeness.
The rest of the paper is organized as follows.
In Section 2, we de(cid:12)ne the problem of XQuery containment in the presence of variable binding dependencies.
Section 3 gives the overview of our approach.
We describe the pre-step of query decomposition and minimization in Section 4.
This is followed by our containment mapping technique in Section 5.
We show the query performance gains achieved by applying the proposed technique in a semantic caching system in Section 6 and conclude in Section 7.
In this section, we (cid:12)rst introduce the notion of hierarchical multivalued dependencies (HMVDs) which represent a typical type of data dependencies in the source XML.
Also, we de(cid:12)ne variable binding dependencies as the HMVDs being preserved by the query in the intermediate variable bindings.
We then de(cid:12)ne the problem of nested XQuery containment in the presence of variable binding dependencies.
It has been recently recognized that studying the extension of the traditional integrity constraints in the XML setting is both theoretically and practically meaningful.
Several classes of integrity constraints including key constraints, path constraints, functional constraints, and inclusion constraints have been de(cid:12)ned for XML [11].
The more advanced constraints such as the multivalued dependencies (aka tuple generating dependencies) have also been studied in [19, 2] with the goal to develop a normalization theory for XML and in [15] for mapping XML DTDs to relational schemas.
XPath containment in the presence of DTD constraints such as sibling constraints and functional constraints has been investigated in [11].
The semantics of an XPath query can be captured by a unary pattern tree in which only one node has its bindings returned as the result while others are matched but not returned.
However in XQuery, even a single for clause may specify multiple variables which correspond to an nary (n(cid:21)1) pattern tree.
This is where the challenges arise for XQuery containment.
Let us (cid:12)rst analyze the semantics of a single-block XQuery for the sake of simplicity.
In a single-block XQuery that utilizes a FLWR expression, the return clause is invoked for all the cartesian product combinations of the variable bindings produced by the for clause.
These combinations are determined based on how variables are de(cid:12)ned based on others.
As far as we know, no research has studied the implication of such dependencies on XQuery containment.
This is the task of our work.
Definition 2.1.
Given a DTD, suppose " is a set of binary edge relations between element type e and its children element types, each labeled with the corresponding cardinality relationship 1, ?, * or + 3.
For any two descendant element types x and y of e, if either x or y has a multiple cardinality relationship (i.e., * or +) with e, then we call the dependency among their corresponding elements in a conforming XML a hierarchical multivalued dependency (HMVD), denoted e !!
xjy.
Recall that the notion of multivalued dependency (MVD) in relational databases de(cid:12)nes that if a relation has two or more multivalued independent attributes (e.g., x and y), every value of one attribute (e.g., x) must be repeated with every value of the other attribute (e.g., y).
HMVD extends MVD in the sense that e, x and y are not attributes in a relation but element types in a DTD.
If e, x and y are mapped to a 3-column relation and their bindings are unnested, then in each partition with an e binding, every x binding needs to be repeated with every y binding.
31, ?, * and + respectively represent the 1-1, 1-(0,1), 1-(0,m) and 1-(1,m) (m (cid:21)1) mappings.
For an XML document D, the dependencies among its elements which have multiple cardinality relationships with their respective parents can be represented by HMVDs.
A query imposed against D speci(cid:12)es a subset of HMVDs (direct or derived) to be preserved by its variable bindings.
Definition 2.2.
Suppose a given query de(cid:12)nes variable vj based on vi, e.g., for vj in vi(=j==)pj , where pj is the relative XPath expression used for deriving vj s bindings from each binding of vi.
We call this dependency of vj  s bindings on their respective vi bindings a variable binding dependency, denoted vi pj (cid:3) vj .
=title For example, $b (cid:3) $a hold for Q2(cid:24)4 in Figure 2.
They all specify their corresponding $t and $a based on $b.
(cid:3) $t and $b =author The variable binding dependency relationship satis(cid:12)es: pj (cid:3) vj , vj vi pk (cid:3) vk ) vi pjk (cid:3)(cid:3) vk (transitivity rule), where pjk is the path expression obtained by concatenating pj and pk, and (cid:3)(cid:3) denotes an induced variable binding dependency.
Given an XQuery, the direct variable binding dependencies extracted from it compose a base dependency set from which the non-direct dependencies can be derived inductively.
For example, Q2, Q3 and Q4 in Figure 2 de(cid:12)ne $b via an absolute path expression //book from the root of the source XML \bib.xml".
Suppose variable $r is used as a default root variable to be bound with the root element, then $r ==book (cid:3) $b.
Also since $b =title (cid:3) $t and $b =author (cid:3) $a, we can derive $r $a.
In contrast, Q1 in Figure 2 directly de(cid:12)nes $t and $a based $t and $r (cid:3)(cid:3) (cid:3)(cid:3) ==book=title ==book=author on the root variable $r.
Hence it has $r ==book=title (cid:3) $t and ==book=author (cid:3) $r $a.
To tackle XQuery containment in the presence of variable binding dependencies, we cannot solely utilize tree ho-momorphism between the two respective navigation pattern trees.
Additional conditions need to be asserted in the containment mapping process to deal with the e(cid:11)ect of variable binding dependencies on the query semantics.
Let us consider the containment relationship between Q1 and Q2 in Figure 2 again.
A tree embedding of the pattern tree of Q1 into that of Q2 exists, as illustrated by Ebody(Q1; Q2) in Figure 3.
As described before, if we were to use RQ1 (see Figure 2) to answer Q2 according to Q2 v Q1, then it will result in the super(cid:13)uous answer pairs t1(cid:0)a1, t1(cid:0)a2, t3(cid:0)a1 and t3(cid:0)a2.
With the new concepts introduced in this section, we can see that this is because the HMVD $b !!
$tj$a is required by Q2 but not preserved by Q1.
Suppose that Vars(Q) and Rets(Q) are the de(cid:12)ned variables and the returned expressions in a query Q respectively.
All the variables occurring in Rets(Q) must be de(cid:12)ned in Vars(Q) for Q to be safe.
On the other hand, variables occurring in Rets(Q) may be a subset of Vars(Q).
That is, not all the variable binding dependencies are utilized in the query result.
To determine query containment, we need to reason about not only the containment of the returned bindings due to Rets(Q), but also the containment of the utilized variable binding dependencies due to both Vars(Q) and Rets(Q).
Correspondingly, we now de(cid:12)ne XQuery containment in the presence of variable binding dependencies.
Definition 2.3.
Let Q1, Q2 be two XQueries.
Q1 v Q2 if and only if: 1) there exists a containment mapping from Ret(Q1) to Ret(Q2), and 2) the HMVDs preserved in Vars(Q1) and utilized by Ret(Q1) are subsumed by those preserved in Vars(Q2) and utilized by Ret(Q2).
For example, the HMVD $b !!
$tj$a is re(cid:13)ected in RQ2 in Figure 2 but not in RQ1.
That is, the bindings of $tQ1 and $aQ1 are paired document-wise in RQ1, whereas those of $tQ2 and $aQ2 are grouped by their common book elements in RQ2.
The former pairs can be derived from the latter by pairing all the $tQ1 bindings with $aQ1 bindings regardless of if they came from the same book parents.
However, there is no way to recover the dependencies of $tQ1 and $aQ1 bindings on their common book elements as required by Q2.
The main idea of our XQuery containment approach is to incorporate the checking of the containment of the utilized HMVDs in addition to the checking of the pattern tree ho-momorphism (i.e., the embedding of the containing query pattern tree into that of the contained query).
The main steps of our approach are depicted in Figure 5.
(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:4)(cid:7) XQuery Normalization & Decomposition VarTree + TagTree Variable Minimization view query TagTree Containment Mapping mappings XQuery Rewriting Figure 5: Containment Checking Flow (cid:15) XQuery decomposition.
We separate the variable de(cid:12)ni-tion part from the result construction part and represent each using a tree structure.
The former tree (i.e., VarTree) captures all the preserved HMVDs.
It is di(cid:11)erent from the navigation pattern tree used in [23], as will be explained later.
The latter tree (i.e., TagTree) is used to represent the result construction template.
The TagTree also indicates how the preserved HMVDs are utilized in the result construction.
(cid:15) Variable minimization.
We identify the variables that are neither directly nor indirectly utilized in the result construction and degrade them to navigation steps.
This way, we derive a minimal set of variable binding dependencies for which we conduct the containment checking.
This is a critical step for ensuring the correctness of the containment result.
(cid:15) Containment mapping.
We conduct three types of containment mappings.
First, we perform the minimal VarTree embedding to check the containment of the utilized HMVDs.
Second, we check the tree embedding relationship between the navigation patterns.
Lastly, we apply a mapping that deals with the e(cid:11)ects of block-structure-induced variable dependencies on the containment of XQuery.
(cid:15) XQuery rewriting.
If the new query Q1 is contained within a cached query Q2, then the mapping Mc established in the containment mapping phase can be used for rewriting Q1 against the query result structure of Q2.
The basic idea is to substitute each path expression p in Q1 for its corresponding path expression p0 in the TagTree of Q2 based on p0 = Mc(p) (cid:14)Mt, where Mt represents the mapping of path expressions from the VarTree of Q2 to its TagTree.
Namely, p0 is computed by the composition of Mc and Mt.
We skip the details of query rewriting in this paper.
The purpose of query decomposition is to separate the semantics of variable bindings from that of result construction.
However, the semantic distinction is sometimes not very easily extracted from the surface syntax.
For example, not necessarily all expressions in return clauses represent the return construction semantics.
Due to the (cid:13)exibility in composing a nested XQuery, FLWR expressions may be nested within a f or clause, e.g., for v2 in (for v1 in e1 return e2) return e3.
In this case, e2 in the nested return clause does not result in returning its bindings in the ultimate query result but only serves for specifying v2 s binding.
Therefore, we need to (cid:12)rst normalize the query to derive a form based on which this semantic distinction is made easy.
Then we represent the two semantics respectively using two tree structures, which are connected via variable bindings.
Our goal is that the normalized query can facilitate the separation of the path expressions that are to be output in the result from those that are used for specifying variable bindings, such that the later query decomposition step is made easy.
There are a number of XQuery normalization techniques [21, 17, 9] available.
They overlap in some commonly used normalization rules.
For example, unnesting the FLWR expression within a for clause (as illustrated before) is a standard rule shared by many techniques.
We adopt a set of query normalization rules including rules (R2)(cid:24)(R5), (R7)(cid:24)(R10), and (RG1) from [9].
We also apply rules (R1), (R6), (R11), and (R12), but in their reverse directions.
Rule (R13) does not apply in our context since we exclude disjunctions from our XQuery fragment.
Since we consider the XQuery fragment with no aggregations, we can also apply the rule that substitutes each let-variable with its de(cid:12)nition.
After applying these rules, the query is free of let clauses, empty sequence expressions and unit expressions.
Also, only return clauses may contain nested FWR4 expressions.
Definition 4.1.
Given a normalized XQuery Q, a tree structure named VarTree=(V, E, L) can be constructed based on the extracted variable binding dependencies.
Each de(cid:12)ned variable is denoted by a var node v 2 V .
Each
 ized query is let-clause free.
dependency vi labeled pj 2 L. We refer to e the derivation edge of vi.
pj (cid:3) vj corresponds to an edge e = (vi; vj ) 2 E The VarTree is di(cid:11)erent from the pattern tree concept referred to in other research [23].
An edge in the pattern tree corresponds to an axis step (/ or //) and the associated element type test.
In contrast, a derivation edge in VarTree denotes the navigation pattern used for deriving a child variable from its parent.
Actually this is indicated by the label on a derivation edge which is an XPath expression composed of possibly multiple steps and branches.
In this sense, the VarTree can be considered as a nested tree with each edge encapsulating the navigation pattern corresponding to the label on it.
Definition 4.2.
For a normalized XQuery Q, a tree structure conforming to its nested block structure can be constructed to represent the result construction semantics.
It is called TagTree=(N,A).
Each block node n 2 N is a quadruple [ (cid:22)V ; (cid:22)C; (cid:22)R; (cid:22)T ] and each edge a = (ni; nj ) 2 A denotes that block nj is nested within block ni.
Furthermore, (cid:15) (cid:22)V , (cid:22)C, (cid:22)R, and (cid:22)T respectively represent the variables, where-conditions, return expressions, and to-be-constructed new elements speci(cid:12)ed in the corresponding block; (cid:15) (cid:22)C is denoted by a forest of constraint pattern trees each rooted at a variable de(cid:12)ned in the local or an ancestor block.
Equality conditions are associated with the corresponding node(s); (cid:15) If unnesting of the bindings of variables in (cid:22)V results in a nonempty set and conditions (cid:22)C are satis(cid:12)ed, then the construction of a new element denoted by (cid:22)T will be invoked for each tuple in that unnested binding set; (cid:15) (cid:22)T may have either none, one, or a sequence of tag names in the form ht1iht2i : : : htni.
This means that the returns of (cid:22)R will be enclosed by an empty tag, ht1i and h=t1i, or ht1iht2i : : : htni and h=tni : : : h=t2ih=t1i.
We now extend the VarTree structure with a few more features.
Given the TagTree T TQ of a query Q, we get each return expression v=pm in a (cid:22)R of T TQ and correspondingly attach to the var node for v in the VarTree V TQ a leaf node (also referred to as ret node).
Each ret node represents the corresponding return expression.
To distinguish var nodes from ret nodes, we use solid circles to denote the former and use hollow circles for the latter.
The second extension is to shift the constraints and conditions in the (cid:22)C s of T TQ to be represented in V TQ.
Specifically, if the constraint pattern represented by the XPath expressions (with or without variables de(cid:12)ned in their respective where clauses5) is derived from v, or the equality-based conditions are a(cid:14)liated to where-variables that are dependent of v, then we move them in the (cid:12)lter \[ ]" of the XPath expression p which labels the derivation edge of v in V TQ.
Intuitively, this can be done because these constraints and conditions are, in a sense, analogous to the relational selection operations.
They hence can be pushed to be executed in the navigation pattern matching stage for deriving variable bindings.
while for-variables are those de(cid:12)ned in f or clauses.
Unless indicated otherwise, \variable" means a for-variable.
A where-variable can be removed since its life scope is refrained within the local where clause.
//book/author $a $a
 ({$r};;;<results>) ({$t,$a};;{$t,$a};<pairQ1>)
 ({$r};;;<results>)
 $r //book/title $t $t bib .. .
... .
/author $a bib $r
 $b /title $t For example, the extended VarTrees and TagTrees of example Q1 and Q2 are depicted in Figure 6 respectively.
Note that the where-condition \some $p in $b/price satis(cid:12)es $p=30" in the (cid:22)C of the bottom block in T TQ2 is serialized into \price=30" and then moved in \[ ]" as the (cid:12)lter expression for de(cid:12)ning $b in V TQ2.
//book[price=30] ({$b,$t,$a};C;{$t,$a/last};<pairQ2>) $t $a/last Figure 6: VarTrees and TagTrees of Q1 and Q2 However, we must carry out this VarTree extending process with caution.
That is, the shifting of return expressions in (cid:22)R and where-conditions in (cid:22)C would not change the query semantics only if the to-be-attached var node v is de(cid:12)ned in the same block where (cid:22)R and (cid:22)C are speci(cid:12)ed.
Some return expressions in (cid:22)R and where-conditions in (cid:22)C refer to variables that are de(cid:12)ned in ancestor blocks.
By moving them up along the nested block hierarchy to be attached to their referring variables, more or fewer bindings than desired may be returned.
For example, suppose the example query Q3 in Figure 1 also speci(cid:12)es the where-condition \some $p in $b/price satis(cid:12)es $p=30", however in the inner block.
Then attaching \[price=30]" to the de(cid:12)nition expression of $b in the outer block may cause generating fewer <pairQ3> elements due to the push-up condition.
We hence leave such return expressions and where-conditions in their original block nodes in T TQ.
The VarTree with these extensions is comprehensive enough to also represent the to-be-returned bindings and the e(cid:11)ect of where-conditions on variable bindings.
It is also noteworthy that the VarTree and TagTree of a query are connected via variables.
In particular, all variables in (cid:22)V  s and those referred to in (cid:22)R s in the TagTree must be present as var nodes in the VarTree for the query to be safe.
We explained earlier that the VarTree of a query is a nested tree with navigation patterns encapsulated in its derivation edges.
On one hand, the query semantics stays the same if we fully expand the VarTree by unnesting all the encapsulated navigation patterns and by naming each node in them with a variable.
On the other hand, it is also possible not to a(cid:11)ect the query semantics by degrading some variables into navigation pattern nodes to be encapsulated in derivation edges.
We call the latter a variable minimization process since the number of var nodes is reduced (however with more complex navigation patterns encapsulated) and the VarTree structure seems minimized.
A variable can be minimized without a(cid:11)ecting the query semantics only if it does not participate in preserving any HMVD that is utilized in the result construction, nor serve in any way as a constraint context (will be explained later) for the return expressions.
Our goal here is to explore the opportunities for variable minimization to obtain the minimal VarTree (i.e., no further minimization is possible).
This is critical since the later containment checking of utilized HMVDs can be based on the derived minimal VarTrees of two given queries.
Definition 4.3.
Given an XQuery Q, suppose D is the source XML and v is a variable de(cid:12)ned in Q.
If by substituting all occurrences of v with v s de(cid:12)nition, Q s result will not change for any XML data instance that conforms to the same DTD as D, then we say v is nonessential.
Otherwise v is essential.
Now we provide practical criteria for distinguishing essential variables from nonessential ones based on their uses.
Explicit vs.
Implicit Uses.
A variable v may either be used for de(cid:12)ning another variable or in a return expression.
We call the former case a Var use of v and the latter a Ret use of v. Both are referred to as explicit uses of v in general, regardless of where it is used (i.e., either in the local block where v is de(cid:12)ned or in descendant blocks).
Besides explicit uses, v may also be implicitly used as a \loop counter" for invoking returns.
For example, when the block where v is de(cid:12)ned encloses return expressions referring to other variables than v, then the cardinality of v s bindings is used to determine the number of times that the returns are to be invoked.
In the extreme case when the binding set is empty (i.e., cardinality is 0), no return will be invoked.
In this sense, v serves as the constraint context for the returns.
If a variable v has neither explicit nor implicit uses, we call it has no-use.
Such variables are de(cid:12)nitely nonessential and can be minimized.
Otherwise, the essentiality of v depends on the combination of di(cid:11)erent uses and the number of variable use occurrences.
One vs.
Multiple Uses.
Basically, v is essential if it has at least two explicit uses, being either Var or Ret uses, or a Ret use and an implicit use.
The detailed case studies and rationale are depicted in Figure 7.
Essential Variable Identification Procedure if v has no explicit use if v has no implicit use either then v is nonessential else v is essential # since removing v would cause the lost of ``loop counter' .
else if v has more than one explicit use (Var or Ret) case 2: multiple uses case 1: no-use then v is essential # since it is necessary for preserving the HMVDs among its bindings and those of its dependent variablesor return expressions.
else (i.e., exactly one explicit use) if v has no implicit use then v is nonessential # since no two variables or return expressions have co-dependencies with v, minimizing v causes no lost of HMVDs or condition changes.
case 3: one use else if v has one Ret use case 4: one ret with implicit uses then v is essential # since removing v would cause lost of ``loop counter' .
else (i.e., v has one Var use) case 5: one var with implicit uses v is nonessential # since no return expression will be affected by only v but not u due to their common life scope, and v occurs only in u's definition.
Figure 7: Identifying Variable Essentiality Lemma 4.1.
All essential variables can be correctly iden-ti(cid:12)ed by our analysis in Figure 7 based on variable uses.
2 Example 4.1.
We use Q4 in Figure 2 to illustrate the minimization process.
Before minimization (as shown in Figure 8), the var node for $tQ4 (denoted by the solid circles) in V TQ4 and that for $aQ4 each have one dependent ret node (denoted by the hollow circles).
Hence $tQ4 and $aQ4 each have one Ret use.
Also, the original T TQ4 reveals that $tQ4 and $aQ4 each are speci(cid:12)ed alone in a bottom block.
Thus they have no chance to a(cid:11)ect any other return.
This means that $tQ4 and $aQ4 each have no implicit use.
Therefore, the var nodes for $tQ4 and $aQ4 in V TQ4 can be minimized according to the analysis of case 3 in Figure 7.
Correspondingly, the XPath expressions on the ret nodes are changed to $b=title and $b=author respectively by substituting the variable occurrences by their de(cid:12)nitions.
bib $r //book /author $a $a $b /title $t $t
 $r bib //book /author $b /title
 {$r};;;<results> {$b};;;<pairQ4> {$t};;{$t};<> {$a};;{$a};<> before after minimization
 {$r};;;<results> {$b};;{$b/title,$b/author};<pairQ4> Figure 8: Minimization Example

 In this section, we present our containment mapping technique which is composed of three types of mappings.
The (cid:12)rst two mappings are based on the obtained minimal VarTrees, while the last one is based on the TagTrees.
Given two queries Q1 and Q2, the (cid:12)rst mapping is to check the containment of the utilized HMVDs in two queries by conducting tree homomorphism (i.e., tree embedding) between their VarTrees.
Suppose the embedding is from V TQ1 to V TQ2.
Then the second mapping is to make sure that the navigation pattern used for deriving each var node in V TQ1 implies a more restricted constraint than that for the matched var node in V TQ2.
These two mappings are called MAC mapping and MIC mapping respectively, indicating that the former is conducted at the macroscopic level of the VarTree (i.e., mapping of var nodes) while the latter is performed at the microscopic level of the VarTree (i.e., mapping of navigation patterns encapsulated in derivation edges).
We now extend the traditional tree homomorphism (namely based on root, label, and ancestor-descendant relationship preserving) to de(cid:12)ne the MAC mapping.
Definition 5.1.
Suppose V T1 and V T2 are the minimal VarTrees of Q1 and Q2 respectively.
For determining Q1v Q2, there must be a MAC mapping from V T1 to V T2, denoted by (cid:8)(V T1) = V T2, such that the following conditions are satis(cid:12)ed: C1) roots(V T1) (cid:18) roots(V T2), C2) for any node u 2 V T1, there is a match (cid:8)(u) 2 V T2 such that T (u)=T ((cid:8)(u)) if (cid:8)(u) is a var node, and T (u) <: T ((cid:8)(u)) if (cid:8)(u) is a ret node (T returns the type of the element, and <: denotes the subtype-supertype relationship), C3) u is an ancestor of v for all u; v 2 V T1 if and only if (cid:8)(u) is an ancestor of (cid:8)(v) in V T2, and C4) if u is a var node in V T1, then (cid:8)(u) is either a var or a ret node; if u is a ret node, then (cid:8)(u) must be a ret node.
Below we explain each of these required conditions.
C1: Root inclusion6.
This condition requires that each source XML document referred to in Q1 must also be referred to in Q2.
Correspondingly in the VarTrees, roots(V T1) returns the URLs of the source XML documents involved in Q1, which should be a subset of those returned by roots(V T2).
C2: Mapping of element types.
This condition requires a total but not necessarily injective mapping from nodes in V T1 to those of V T2.
In addition, a node u in V T1 must be mapped to a node in V T2 that has either the same type or a supertype7 of u s depending on if the matched node is a var node or a ret node.
The element type of a node can be inferred from the XPath expression on its incoming derivation edge.
u can be mapped to a super-type ret node (cid:8)(u) because the associated bindings of (cid:8)(u) are all deeply returned (due to the semantics of a return expression) to enable the retrieval of u s bindings from subtrees of (cid:8)(u) s bindings in Q2 s result.
C3: Preservation of ancestorships.
In a minimal VarTree, nodes represent essential variables and the HMVDs among them are captured by their ancestor-descendant relationships.
Therefore, if all the ancestor-descendant relationships in V T1 have correspondence mappings in V T1, then it means that the to-be-utilized HMVDs required by Q1 are all preserved by Q2 and also present in Q2 s result.
C4: Correspondence of construct types.
This condition checks the correspondence between query construct types.
A var node represents a for expression while a ret node denotes a return expression.
The bindings of a ret node are de(cid:12)nitely returned whereas those of a var node may be used for constructing new elements correspondingly.
Therefore, a var node can be mapped to a ret node and still get the correct bindings, while a ret node cannot be mapped to a var node since the new elements in Q2 s result rather than the original bindings would be returned in doing so.
We can see from the above conditions that the MAC mapping ensures that all the essential variable bindings, the HMVDs among them, and their attached returns required by Q1 are preserved in the result of Q2.
XML document.
In this case, the corresponding VarTree is actually a forest of trees, which may be connected by equality conditions on variables across trees.
those in the object-oriented modeling domain.
Instead, it corresponds to the element inclusion hierarchy in the DTD.
In addition to the MAC mapping, we need to check if the binding set of each node in V T1 is indeed a subset of that of its match in V T2.
This is guaranteed by the MIC mapping, which essentially checks XPath containment.
Definition 5.2.
Let V T1 and V T2 be the minimal VarTrees of Q1 and Q2 respectively.
Suppose (cid:8)(V T1)=V T2 according to the MAC mapping.
In MIC mapping, tree homomor-phism is checked between the encapsulated navigation patterns for each pair of matched nodes.
Two steps are carried out for each node u in V T1:
 along the path from (cid:8)(parent(u)) to (cid:8)(u);
 edge of u is p1 and the one obtained from step (1) is p2.
p1 (cid:18) p2 is checked with (cid:18) denoting XPath containment (i.e., there is a tree homomorphism from the pattern tree representation of p2 to that of p1
 Note that if a pair of parent-child nodes (p; c) in V T1 maps to a pair of ancestor-descendant nodes (a; d) in V T2 by the MAC mapping, then p2 is the concatenated XPath expressions originated from a to d. This implies that, to make Q1v Q2 hold, more essential variables may be speci-(cid:12)ed in Q2 than Q1 to preserve more HMVDs in Q2 s result.
The MIC mapping makes sure that p2, the XPath expression used for deriving d s bindings from a s, imposes a less restricted pattern constraint than p1, the XPath expression used for deriving c s bindings from p s.
$r //book/title .. .
bib $t $t $a //book/author ?
$a ... .
bib $r //book[price=30] $b /title $t /author $a
 bib $r ... .
$b /title $t //book /author $a $t $a/last $t $a <: Figure 9: MAC Mapping between Minimal VarTrees Example 5.1.
Figure 9 illustrates two MAC mappings.
One is between the two VarTrees of Q1 and Q2 in Figure 1.
(cid:8)(V T2)6=V T1 as shown on the left hand side.
For one reason, the var node $b in V T2 has no match in V T1 that sat-is(cid:12)es C2.
We can hence derive Q26(cid:18)Q1.
The second mapping is between the two VarTrees of Q2 and Q3 in Figure 1.
The right hand side of Figure 1 shows (cid:8)(V T2)=V T3, i.e., (cid:8)($rQ2)=$rQ3, (cid:8)($bQ2)=$bQ3, (cid:8)($tQ2)= $tQ3, (cid:8)($aQ2)=$aQ3, (cid:8)($t0 ($t0 (cid:8)($a=last)=$a0 author, and last (cid:20): author.
Q3 are the ret nodes).
The mapping Q3 holds due to T ($a=last) = last, T ($aQ3) = Q3, and (cid:8)($a=last)=$a0 Q3, and $a0 Q2)=$t0 Q2, $t0 The MIC mapping between the navigation pattern trees encapsulated in the derivation edges of V T2 and those of V T3 is also successful.
For example, the pattern tree for the XPath expression \//book" in deriving $bQ3 can be embedded
 complexity of containment is CoNP-complete.
However, the XPath containment complexity is reduced to PTIME if only two out of the three features are included.
We refer the readers to [13] for the details of XPath containment.
into that for \//book[price=30]" in deriving $bQ2.
Note that the tree embedding direction for XPath containment p1 (cid:18) p2 is from p2 to p1.
We now address the implications of nested block structure on the containment of XQuery.
One intuitive example of such implications is the reliance of the return semantics on the emptiness of variable binding set(s).
For example, note that since Q2 in Figure 1 speci(cid:12)es both $tQ2 and $aQ2 in the outer block, the construction of a new <pairQ2> element occurs only when a book element has both title and author subelements.
In other words, if the binding set of $aQ2 is empty for a speci(cid:12)c $bQ2 binding as for example for b1 and b3 in the source XML in Figure 2, then there will be no invocation of the return to construct the new elements.
Contrary to this example, the construction of <pairQ3> elements for Q3 in Figure 2 is solely based on the bindings of $bQ3, irrelevant of the bindings $tQ3 and $aQ3.
The reason lies in the nested block structure of Q3 (i.e., Q3 has two query blocks versus that Q2 has just one).
While variables speci(cid:12)ed in Q3 are the same as those in Q2, they however are placed in di(cid:11)erent blocks (i.e., $tQ3 and $aQ3 are speci(cid:12)ed and returned in the inner block while $bQ3 is de(cid:12)ned in the outer one) as oppose to being put in the same block as those in Q2.
Consequently, Q2 v Q3.
Similarly, we have Q3 v Q4.
Recall that the TagTree structure of a query conforms to the nested block (see its de(cid:12)nition in De(cid:12)nition 4.2).
The (cid:22)V and (cid:22)C in an outer block together compose the evaluation context for those in its descendant blocks.
Also, variables in the same (cid:22)V a(cid:11)ect each other in the sense that their cartesian product would produce no tuple if any variable member in (cid:22)V has an empty binding set.
Definition 5.3.
Let T T be the TagTree of query Q and n=[ (cid:22)V ; (cid:22)C; (cid:22)R; (cid:22)T ] be a block node n in it.
Variables in (cid:22)V mutually depend on each other.
Also, they all depend on those variables de(cid:12)ned in n s ancestor block nodes.
We call such dependencies region dependencies and denote them by ,!.
Intuitively, if there is a variable binding u (cid:3) v, then v can only be de(cid:12)ned either in the same block or a descendant block of where u is de(cid:12)ned, i.e., u ,!
v. However, we cannot imply u (cid:3) v from u ,!
v. This is formally stated as below.
Lemma 5.1.
For any two variables u and v of Q, if u (cid:3) v, then u ,!
v. 2
 We now de(cid:12)ne a third mapping that complements the previously de(cid:12)ned MAC and MIC mappings.
Definition 5.4.
Let T T1 and T T2 be the TagTrees of Q1 and Q2 respectively.
The block mapping is a one-to-many mapping function (cid:18) from each block node n of T T1 to nodes of T T2, denoted by (cid:18)(T T1)=T T2, such that n = ( (cid:22)V ; (cid:22)C; (cid:22)R; (cid:22)T ) in T T1 and its image set S= (cid:18)(n) in T T2 satisfy: C10) for every variable u 2 (cid:22)V , (cid:8)(u) 2 Sni C20) for any two variables w; x 2 Sni (cid:22)Vi (ni2 S), if w ,!
x, then there must be u and v in T T1, such that (cid:8)(u) = w, (cid:8)(v) = x, u ,!
v, and (cid:22)Vi (ni2 S), C30) any ci 2 Sni dition c 2 ( (cid:22)C [ Smi node of n).
(cid:22)Ci (ni 2 S) can be implied by a con-(cid:22)C 0) (mi is an ancestor block C1 : Containment of variables.
This condition is actually used for establishing the (cid:18) mappings (i.e., (cid:12)nding for each block node n in T T1 its image node set S) based on the VarTree node matches.
Intuitively, a block node ni in T T2 is included in S if any variable in it is the match of any (cid:22)Vi denote variables in n and variable u 2 (cid:22)V in n. (cid:22)V and Sni the union of those de(cid:12)ned in n s images ni2 S respectively.
C2 : Implication of region dependencies.
If a variable w in an image node ni of T T2 is involved in a region dependency (e.g., w ,!
x), then C2  ensures that there must be a region dependency between the corresponding variables in block nodes of T T1.
In other words, the region dependencies with matched variables in T T2 involved must be a subset of those among the corresponding variables in T T1.
C3 : Implication of where-conditions.
Suppose ni in T T2 is an image node of the node block n in T T1.
C3  checks if every where-condition ci left in ni can be implied from a where-condition c either in n or an ancestor block of n (i.e., c 2 Smi (cid:22)C 0, with mi2 ancestors(n)).
In a nutshell, C10 (cid:24) C30 required by the block mapping make sure that Q1 must assert more restricted constraints, i.e., region dependencies and where-conditions, than Q2 does.
Example 5.2.
Suppose that two adjacently nested blocks n1 and n2 in T T1 de(cid:12)ne variables u and v respectively.
There is no other variable in n1 or in n2.
We also suppose that (cid:8)(u) = x and (cid:8)(v) = w, and that x and w are de(cid:12)ned in the same block n in T T2.
By condition C10, we have (cid:18)(n1) = fng and (cid:18)(n2) = fng.
We derive x ,!
w and w ,!
x due to the mutual region dependencies asserted by a block node.
Also, from the enclosing relationship between n1 and n2, we know that u ,!
v but v 6,!
u. C2  is not satis(cid:12)ed based on these facts.
Consequently, the block mapping fails and we derive Q16v Q2.
Putting all three types of containment mappings together, we now have a sound (not generally complete) solution for XQuery containment in the presence of variable binding dependencies.
Theorem 1.
Given two XQueries Q1 and Q2, Q1 v Q2 if there exist a MAC mapping (cid:8)(V T1)=V T2, a MIC mapping p1 (cid:18) p2 (i.e., the encapsulated XPath containment) for every matched node pair, and a block mapping (cid:18)(T T1)=T T2.
2

 Based on our proposed containment mapping approach for XQuery, we have designed and implemented a semantic caching system called ACE-XQ [6, 7].
The ACE-XQ system is developed using Java 1.3.
It utilizes the IPSI-XQ engine [14] installed at both the cache and the remote server sites to execute the rewritten query and the original query respectively.
Source XML documents are hosted at the server.
The (cid:12)rst set of experiments is for validating our containment mapping and rewriting methods for XQuery.
For this, we designed some query workload9 that includes queries that are similar to those W3C use cases [20] and are within the scope of our XQuery fragment.
The experiment shows that the results produced by running a query with and without
 ratio of a new query being contained in a cached one is high.
contained/non-caching contained/caching overlap/non-caching overlap/caching i ) s ( e m
 e s n o p s e
 y r e u









 Source XML Document Size (Kbytes)

 Figure 10: Query Response Times for Di(cid:11)erent Document Sizes w/o Caching the attempt of conducting containment mapping and rewriting it against a containing view result are the same.
The second set of experiments is to evaluate the query performance with and without the semantic cache.
As expected, Figure 10 shows the improved query performance by up to 10 folds for the totally contained cases in our setting.
Table 1 shows the break down of the query response time for a contained case into the computation overhead (i.e., query decomposition and minimization, containment mapping, and rewriting) and the query evaluation time.
We see that the overhead is considerably small compared to the query evaluation time.
This implies that although the complexity of our XQuery containment approach is NP-complete in general (since all three mappings are tree homomorphism extensions with additional checking of equivalence conditions, of the inclusive relationships between element types, etc.
), it is e(cid:14)cient and practical in many real scenarios.
Decomp.
& Cont.
Query Query Size Minimization Mapping Rewriting Execution 173.6ms 1068.8ms 4525.4ms 0.8ms 0.8ms 0.8ms 8.8ms 9.2ms 9.1ms 5.2ms 5.4ms 5.2ms





 Table 1: Processing Time Decomposition Extensive experimental studies can be found in [8, 5].
In this paper, we proposed a containment mapping approach that handles the e(cid:11)ects of variable binding dependencies and the nested block structure on XQuery containment.
Our approach provides su(cid:14)cient conditions for solving nested XQuery containment.
An intermediate future work would be to incorporate the XQuery logical optimization technique in [9] in our normalization step to reduce the possible navigation redundancies in the VarTree representation.
This helps to prune the space for conducting containment mapping.
However, the lack of this optimization step as of now does not impact the soundness of the approach.
The XQuery fragment de(cid:12)ned in this paper provides a good scope for us to focus on a set of important XQuery features with respect to the containment problem.
We plan to extend the proposed containment mapping approach to accommodate a broader fragment of XQuery that includes disjunctions, aggregations, and other features as well as to consider more general constraints in XML and XQuery.
