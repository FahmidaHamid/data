Contract signing plays a very important role in any business transaction, in particular in situations where the involved parties do not trust each other to some extent al-Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
ready.
In the paper-based scenario, contract signing is truly simple due to the existence of  simultaneity .
That is, both parties generally sign two hard copies of the same contract at the same place and at the same time.
After that, each party keeps one copy as a legal document that shows both of them have committed to the contract.
If one party does not abide by the contract, the other party could provide the signed contract to a judge in court.
As the electronic commerce is becoming more and more important and popular in the world, it is desirable to need a mechanism that allows two parties to sign a digital contract via the Internet.
However, the problem of contract signing becomes di cult in this setting, since there is no simultaneity any more in the scenario of computer networks.
In other words, the simultaneity has to be mimicked in order to design a digital contract signing protocol.
This requirement is essentially captured by the concept of fairness: At the end of the protocol, either both parties have valid signatures for a contract or neither does, even if one of them tries to cheat or the communication channel is out of order.
In fact, Even and Yacobi [20] proved that fairness is impossible to be achieved in a deterministic two-party contract signing protocol.
The intuitive reason could be explained as follows.
The purpose is to go from the initial fair state, in which no party has what he/she expects, to the desired fair state in which both obtain what they want.
However, information is exchanged in computer networks non-simultaneously, so an unfair state must be passed through.
From the view point of technique, the problem of digital contract signing belongs to a wide topic: fair exchange, i.e., how to enable two (or multiple) potentially mistrusted parities exchanging digital items over computer networks in a fair way, so that each party gets the other s item, or neither party does.
Actually, fair exchange includes the following di erent but related issues: contract signing protocols [20, 12, 16, 6, 2, 4, 23, 33, 7], certi ed email systems [39, 30, 5, 28, 1], non-repudiation protocols [38, 31, 27], and e payment schemes in electronic commerce [15, 34].
For more references and discussions on the relationships between those conceptions, please refer to [3, 31].
In this paper, we mainly focus on the problem of digital contract signing.
Since a party s commitment to a digital contract is usually de ned as his/her digital signature on the contract, digital contract signing is essentially implied by fair exchange of digital signatures between two potentially mistrusted parities.
There is a rich history of contract signing (i.e., fair exchange of digital signatures) because this is a fundamental problem in electronic transactions.
According to the involvement degree of a trusted third party (TTP), contract signing protocols can be divided into three types: (1) gradual exchanges without any TTP; (2) protocols with an online TTP; and (3) protocols with an o line TTP.
Early e orts [25, 19, 16] mainly focused on the  rst type protocols to meet computational fairness: Both parties exchange their commitments/secrets  bit-by-bit .
If one party stops prematurely, both parties have about the same fraction of the peer s secret, which means that they can complete the contract o line by investing about the same amount of computing work.
The major advantage of this approach is that no TTP is involved.
However, this approach is unrealistic for most real-world applications due to the following several reasons.
First of all, it is assumed that the two parties have equivalent computation resources.
Otherwise, such a protocol is favorable to the party with stronger computing power, who may conditionally force the other party to commit the contract by its own interest.
At the same time, such protocols are ine cient because the costs of computation and communication are extensive.
In addition, as pointed out in [12], this approach has the unsatisfactory property of uncertain termination.
For example, suppose two parties are signing a house-sale contract.
If the protocol stops prematurely on the side of the buyer, the seller will never be sure whether the buyer is continuing with the protocol, or has terminated - and perhaps even has engaged in another house-sale contract signing protocol with another seller.
The buyer may be in a similar situation if the protocol terminated on the side of the seller.
In the second type of fair exchange protocols [12, 17, 38], an online TTP is always involved in every exchange.
In this scenario, a TTP is essentially a mediator: (a) Each party  rst sends his/her item to the TTP; (b) Then, the TTP checks the validity of those items; (c) If all expected items are correctly received, the TTP  nally forwards each item to the party who needs it.
Generally speaking, contract signing protocols with an online TTP could be designed more easily since the TTP facilitates each step of exchanging, but may be still expensive and ine cient because the TTP needs to be paid and must be part of every execution.
In practice, the TTP is prone to become a bottleneck in the whole system, especially in the situation where many users rely on a single
 Compared with the schemes belonging to previous two types, contract signing protocols with o line TTP [2, 3, 4, 6, 34] are more appealing and practical for most applica- tions.
Because those protocols are optimistic in the sense that the TTP is not invoked in the execution of exchange unless one of the two parties misbehaves or the communication channel is out of order.
Bao et al.
[6] and Ateniese [4] constructed fair exchange protocols of digital signatures from veri ably encrypted signatures, while Asokan et al. [2,
 basic ideas behind those two cryptographic primitives are similar, as explained below.
To get the digital signature from the other party Bob, a party Alice  rst encrypts her signature under the TTP s public encryption key, and proves to Bob that the ciphertext indeed corresponds to her signature, interactively or non-interactively.
Then, Bob sends his digital signature (or some digital item) to Alice.
After receiving the expected item from Bob, Alice reveals her signature to Bob.
The point is that if Alice refuses to do so after getting Bob s item, the TTP can decrypt Alice s encrypted signature and sends the result to Bob.
The di erence between those two kinds of schemes is that in the veri able escrow based schemes, Alice, the creator of the encryption, has the ability to control the conditions under which the encryption could be decrypted by the TTP.
Though their techniques can be applied to a variety of signature schemes, the overheads of computation and communication are usually expensive.
In particular, the schemes in [2, 3, 6] are ine cient, since expensive cut-and-choose techniques [21] are used to prove the correctness of the encrypted signature.
In addition, it is noticed in [8] that the Schnorr and ElGamal signatures based fair-exchange schemes in [4] should be improved to avoid a security  aw.
In [33], Micali constructed several simple fair exchange schemes based on any secure signature and encryption algorithms.
However, Bao et al. [7] pointed his contract signing protocol is actually unfair because there is an intrinsic  aw in the dispute resolution protocol, which is the policy exploited by the TTP to settle potential disputes between the two parties involved in a contract signing.
Based on an RSA multisignature scheme, Park et al. [34] proposed a novel fair exchange protocol with an o line trusted party in PODC 2003.
Their protocol was fair and optimistic but insecure, since Dodis and Reyzin [18] broke their protocol by pointing out that an honest-but-curious TTP can easily derive a user s private key after the end of his/her registration.
Moreover, as an improvement of Park et al. s scheme, Dodis et al. even constructed a provably secure fair exchange protocol from the non-interactive two-signature of Boldyreva [13].
Their scheme works in gap Di e-Hellman (GDH) groups1.
The pairing based cryp-tosystems [14, 13] are typical examples constructed from GDH groups.
However, note that in such cryptosystems, the computation of the pairing is still time-consuming, although several papers have investigated into speeding up the pairing computation [9, 22].
Furthermore, we remark that in the essence Dodis et al. s scheme is not an improvement of Park et al. s scheme, since the security of their scheme is based on the GDH problem instead of the RSA probem or factoring problem [36].
Note that the RSA cryptosystem [36] is now the de facto industrial standard and is widely used in many applications, it is highly desirable to construct fair exchange protocols based on RSA.
Actually, as we mentioned before, several such schemes have been proposed: Asokan et al. s scheme [2, 3]
 feasible to solve the computational Di e-Hellman (CDH) problem in G, but the decisional De e-Hellman (DDH) problem in G can be solved feasibly.
We give more explanations on those problems.
Let G = hgi denote a multiplicative cyclic group.
Then, the CDH problem is to output the value of gab when g, ga, gb   Gq are given, where a and b are unknown random numbers.
In the DDH problem, it is required to determine whether gab equals gc when g, ga, gb, gc   Gq are given, where a, b and c are unknown random numbers.
Actually, another related problem is the discrete logarithm (DL) problem.
That is, given g, ga   G where a is a random number, how to solve a.
In fact, it is easy to know that the DL problem is at least as di cult as the CDH problem, and the CDH problem is at least as di cult as the DDH problem.
from veri able escrow, Ateniese s scheme [4] from veri ably encrypted signature, and Park et al. s scheme [34] from mul-tisignature.
However, all those schemes are not abuse-free [23].
That is, a party can get veri able intermediate results when the signature exchange protocol is executed unsuccessfully.
Consequently, this party may obtain some bene ts by showing such universally veri able intermediate results to a third party.
For example, if Bob is looking for a job and he has received two o ers from competing companies A and C.
Bob prefers to join company C though the o ered salary is not so much satisfactory.
In contrast, company A promises a higher salary but he does not really like to join it due to some personal reason, such as weather, culture or something else.
In this scenario, Bob may  rst pretend to sign an employment contract with company A.
Then, he terminates the execution of the contract signing protocol after he obtained the intermediate results generated by company A.
By showing such universally veri able proofs to company C, Bob may get a higher salary from company C. There exists the same problem in other similar situations.
Therefore, running contract protocols without the property of abuse-freeness is a risk for a honest party, as a possible dishonest party maybe does not really want to sign the contract with her, but only use her willingness to sign to get leverage for another contract.
Consequently, this is an important security requirement for contract signing protocols, especially in the situations where partial commitments to a contract may be bene cial to a dishonest party or an outsider.
However, except the discrete logarithm based scheme of Garay et al.
[23], all other optimistic contract signing protocols [2, 3, 4, 6, 7, 33, 34] are not abuse-free.
Motivated by the above example that shows the importance of abuse-freeness, and the question of how to improve Park et al. s scheme in a secure way, this paper proposes a new contract signing protocol for two mutually distrusted parties.
Our protocol is based on an RSA multisignature, which is formally proved to be secure by Bellare and Sandhu [11].
Like the schemes in [2, 4, 34], our protocol is fair and optimistic.
Furthermore, di erent from the above existing schemes, our protocol is abuse-free.
The reason is that we integrate an interactive protocol, proposed for con rm-ing RSA undeniable signatures by Gennaro et al. [24], into our scheme to prove the validity of the intermediate results.
Technical analysis and discussion are provided in detail to show that our scheme is secure and e cient.
More speci cally, the new protocol satis es the following desirable properties.
(1) Fairness: Our protocol guarantees the two parities involved to obtain or not obtain the other s signature simultaneously.
This property implies that even a dishonest party who tries to cheat cannot get an advantage over the other party.
(2) Optimism: The third trusted party (TTP) is involved only in the situation where one party is cheating or the communication channel is interrupted.
So it could be expected that the TTP is only involved in settling disputes between users rarely, due to the fact that fairness is always satis ed, i.e., cheating is not bene cial to the cheater.
(3) Abuse-Freeness: If the protocol is not executed successfully, any of the two parties cannot show the validity of the intermediate results generated by the other to an outsider2.
As we mentioned before, the unique known abuse-free contract signing protocol [23] is based on the discrete logarithm problem, instead of the RSA cryptosystem.
(4) Provable Security: Under the standard assumption that the RSA problem is intractable [36, 11], the protocol is provably secure in the random hash function model [10], where a hash function is treated as if it were a  black box  containing a random function.
(5) Timely Termination: The execution of a protocol instance will be terminated in a predetermined time.
This property is implemented by adding a reasonable deadline t in a contract, as suggested by Micali in [33].
If one party does not send his/her signature to the other party after the deadline t, both of them are free of liability to their partial commitments to the contract and do not need to wait any more.
(6) Compatibility: In our protocol, each party s commitment to a contract is a standard digital signature.
This means that to use the protocol in existing systems, there is no need to modify the signature scheme or message format at all.
Thus, it will be very convenient to integrate the contract signing protocol into existing softwares for electronic transactions.
(7) TTP s Statelessness: To settle potential disputes between users, the TTP is not required to maintain a database to searching or remembering the state information for each protocol instance.
So the overhead on the side of the TTP is reduced greatly, compared with the previous schemes in [2, 3, 23].
(8) High Performance: In a typical implementation, the protocol execution in a normal case requires only interaction of several rounds between two parties, transmission of about one thousand bytes of data, and computation of a few modular exponentiations by each party.
The rest of the paper is organized as follows.
Section 2 reviews Park et al. s scheme and its security.
In Section 3, we propose a new contact signing protocol based on the RSA signature.
Then, we analyze its security and e ciency in Sections 4 and 5, respectively.
Finally, Section 6 concludes the paper.
In this section, we brie y overview Park et al. s scheme and the attack on it identi ed by Dodis and Reyzin.
For more details, please refer to the original papers [34, 18].
In Park et al. s scheme, Alice sets an RSA modulus n = pq, where p and q are two k-bit safe primes, and picks her
 fully executing the protocol, it does not matter whether the intermediate results are publicly veri able or can be proved to others by one party.
Because, in this case, both parties  digital signatures, i.e., the their complete commitments to the contract, are already publicly veri able.
random public key e  R Z   (n), and calculates her private key d = e 1 mod  (n), where  (n) = (p   1)(q   1).
Then, she registers her public key with a certi cation authority (CA) to get her certi cate CA.
After that, Alice randomly splits d into d1 and d2 so that d = d1 + d2 mod  (n), where d1  R Z   (n).
To get a voucher VA from a TTP, Alice is  1 required to send (CA, e1, d2) to the TTP, where e1 = d
 mod  (n).
The voucher VA is the TTP s signature that implicitly shows two facts: (1) e1 can be used to verify a partial signature generated by using secret key d1, and (2) the TTP knows a secret d2 that matches with RSA key pairs (d1, e1) and (d, e).
When Alice and Bob want to exchange their signatures on a message m, Alice  rst computes  1 = h(m)d1 mod n, and sends (CA, VA,  1) to Bob, where h( ) is a secure hash function.
Upon receiving (CA, VA,  1), Bob checks the validity of CA and VA, and whether h(m)    e1
 veri cations go through, Bob returns his signature  B to Alice, since he is convinced that the expected  2 = h(m)d2 mod n can be revealed by Bob or the TTP.
After receiving valid  B, Alice reveals  2 = h(m)d2 mod n to Bob.
Finally, Bob obtains Alice s signature  A for message m by setting  A =  1 2 mod n, since we have h(m)    e A = h(m)(d1+d2)e = h(m)de mod n.
The security problem in Park et al. s scheme is that an honest-but-curious TTP can easily derive Alice s private key d. The reason is that with the knowledge of (n, e, e1, d2), the TTP knows that the integer e   (1   ed2)e1 is a nonzero multiple of  (n).
It is well known that knowing such a multiple of  (n), Alice s RSA modulus n can be easily factored.
Consequently, the TTP can get Alice s private key d by the extended Euclidean algorithm.
The point is that we do not want the TTP having the ability of making a user s signatures independently, though the TTP is a (partially) trusted party.
The main reason is that as the pivotal secret of any cryptosystem, the private key should not be revealed to any party, including a partially trusted party.
In addition, if there is a completely trusted TTP, the problem of fair exchange can be solved trivially as follows.
Firstly, each party gives his/her private key to the TTP before exchanging items so that the TTP can generate signatures on behalf of any party if necessary.
Then, the TTP issues a voucher for each registered party to show that it knows this party s private key.
When Alice and Bob want to exchange their signatures on a message m, they  rst exchange their vouchers issued by the TTP.
By doing so correctly, it is proved that both of them have registered with the TTP.
After that, their signatures can be delivered directly to the other side.
If one party, say Alice, does not receive Bob s signature on m, she applies the TTP s help by providing her signature and message m. After checking the correctness of this information, the TTP will generate and send Bob s signature on m to Alice by using Bob s private key.
In this section, we describe our new contract signing protocol based on the RSA signature [36].
The basic idea is that Alice  rst splits her private key d into d1 and d2 so that d = d1 + d2 mod  (n), as Park et al. did in [34].
Then, only d2 is delivered to the TTP, while Alice keeps (d, d1, d2) as secrets.
To exchange her signature  A = h(m)d mod n with Bob, Alice  rst sends partial signature  1 = h(m)d1 mod n to Bob, and proves that  1 is prepared correctly in an interactive zero-knowledge way by exploiting Gennaro et al. s protocol [24].
After that, Bob sends his signature  B on message m to Alice, since he is convinced that even if Alice refuses to reveal the second partial signature  2 = h(m)d2 mod n, the TTP can do the same thing.
As usual, we assume that the communication channel between Alice and Bob is unreliable, i.e., messages inserted into such a channel may be lost due to the failure of computer network or attacks from adversaries.
However, the TTP is linked with Alice and Bob by reliable communication channels, i.e., messages inserted into such a channel will be delivered to the recipient after a  nite delay.
To use our protocol for exchanging digital signatures, only the initiator Alice needs to register with the TTP.
That is, Alice is required to get a voucher VA from the TTP besides obtaining a certi cate CA from a certi cation authority (CA).
To this end, the following procedures are executed.
(1) Alice  rst sets an RSA modulus n = pq, where p and q are two k-bit safe primes, i.e., there exist two primes p0 and q0 such that p = 2p0 + 1 and q = 2q0 + 1.
Then, Alice selects her random public key e  R Z   (n), and calculates her private key d = e 1 mod  (n), where  (n) = (p   1)(q   1).
Finally, Alice registers her public key with a CA to get her certi cate CA, which binds her identity and the corresponding pubic key (n, e) together.
(2) Alice randomly splits d into d1 and d2 such that d = d1 + d2 mod  (n) by choosing d1  R Z   (n), and com 1 putes e1 = d
 erates a sample message-signature pair (w,  w), where n \ {1, 1}, ord(w)   p0q0, and  w = wd1 w   Z  mod n. Then, Alice sends (CA, w,  w, d2) to the TTP but keeps (d, d1, d2, e1) secret.
(3) The TTP  rst checks Alice s certi cate CA is valid.
After that, the TTP checks that the triple (w,  w, d2) is prepared correctly.
If everything is in order, the TTP stores d2 securely, and creates a voucher VA by computing VA = SignT T P (CA, w,  w).
That is, VA is the TTP s signature on message (CA, w,  w), which guarantees that the TTP can issue a valid partial signature on behalf of Alice by using the secret d2.
We give some notes on the above registration protocol.
To get her certi cate from a CA, Alice has to prove that modulus n is the product of two safe primes.
This technical issue is addressed in [24].
Of course, step (1) can be omitted if Alice has obtained such a certi cate before she registers with the TTP.
To validate the correctness of the triple (w,  w, d2), the TTP needs to do the followings.
Firstly, the TTP validates that w is an element of order at least of p0q0 by checking that w   Z  n \{1, 1}, and that both gcd(w   1, n) and gcd(w +1, n) are not prime factors of n ([24], Lemma 1).
Then, Alice is required to show that she knows the discrete logarithm of  w to the base w via a zero-knowledge protocol interactively or non-interactively (see Section 4.3 of [24]).
Finally, the TTP checks whether w   ( wwd2 )e mod n. If Bob: Responder Pick i, j  R [1, n] and w mod n.
1  j   CA, VA,  1 (1) (2a) (2b) (2c) (2d) c  set c =  2i  r  i, j  r  Alice: Initiator  1 = h(m)d1 mod n.
Set r = ce1 mod n and  r = commit(r).
Send r if c    2i 1  j w mod n.
Send  2 = h(m)d2 mod n if  B is valid.
(3) (4) If r   h(m)2iwj mod n and    r   commit(r), send  B.
  If h(m)2   ( 1 2)2e mod n,  B  2 accept  2.
Otherwise, apply the TTP s help.
Figure 1: Signature Exchange Protocol.
all those validations pass, the TTP accepts (w,  w, d2) as a valid triple and creates the voucher VA for Alice.
Though the above registration protocol is a little complicated, we remark that this stage needs to be executed only once for a su ciently long period, for example, one year.
In this period, Alice can fairly sign any number of contracts with all potential parties.
Furthermore, it seems reasonable in the real world to require users to  rst register with the TTP before they are served.
The reason is that the TTP is usually unlikely to provide free service for settling disputes between users.
Moreover, for enhancing e ciency, the sample message w can be  xed as a constant, e.g., w = 2, as pointed out by Gennaro et al. [24].
Compared with schemes based on veri ably encrypted signatures [2, 4, 6], one disadvantage of our registration protocol is that the TTP needs to keep a distinct secret d2 for each registered user.
However, this shortcoming can be eliminated by some simple techniques.
For example, the TTP can encrypt each concatenation of d2 and the corresponding user s unique identi er by exploiting a secure symmetric-key encryption algorithm, and then stores the results into its database.
To extract a user s d2 later, the TTP only needs to decrypt the corresponding record using the unique symmetric key.
We assume that a contract m has been agreed between Alice and Bob before they begin to sign it.
In addition, it is supposed that the contract explicitly contains the following information: a predetermined but reasonable deadline t, the identities of Alice, Bob, and the TTP.
Our signature exchange protocol is brie y illuminated in Figure 1, and further described in detail as follows.
(1) Firstly, the initiator Alice computes her partial signature  1 = h(m)d1 mod n, and then sends the triple (CA, VA,  1) to the responder Bob.
Here, h( ) is a cryp-tographically secure hash function.
(2) Upon receiving (CA, VA,  1), Bob  rst veri es that CA is Alice s certi cate issued by a CA, and that VA is Alice s voucher created by the TTP.
Then, Bob checks if the identities of Alice, Bob, and the TTP are correctly speci ed in the contract m.
If all those validations hold, Bob initiates the following interactive protocol with Alice to check whether  1 is Alice s valid partial signature on contact m.
(2a) Bob picks two numbers i, j  R [1, n] at random, and sends a challenge c to Alice by computing c =  2i w mod n.
1  j (2b) After getting the challenge c, Alice calculates the respondence r = ce1 mod n, and then returns her commitment  r = commit(r) to Bob, where commit( ) is a secure commitment scheme (See [35], for example).
(2c) When the commitment  r is received, Bob sends the pair (i, j) to Alice.
(2d) Alice checks whether the challenge c is prepared properly, i.e., c    2i w mod n. If the answer is positive, Alice reveals the respondence r to Bob.
With the knowledge of r, Bob accepts  1 as valid if and only if r   h(m)2iwj mod n and  r   commit(r).
1  j (3) Only if  1 is Alice s valid partial signature and the deadline t speci ed in contract m is su cient for applying dispute resolution from the TTP, Bob sends his signature  B on contract m to Alice, since he is convinced that another partial signature  2 can be released by the TTP, in case Alice refuses to do so.
(4) Upon receiving  B, Alice checks whether it is Bob s valid signature on message m. If this is correct, she sends Bob the partial signature  2 by computing  2 = h(m)d2 mod n. When Bob gets  2, he sets  A =  1 2 mod n, and accepts  2 as valid if and only if h(m)2 =  2e A mod n. In this case, Bob can recover Alice s standard RSA signature  A on message m from  A (more details are provided later).
If Bob does not receive the value of  2 or only receives an invalid  2 from Alice timely, he applies help from the TTP via the dispute resolution protocol before the deadline t expires (see Section 3.3).
The following is further explanation of our signature exchange protocol.
Firstly, the interactive protocol exploited in step (2) is exactly the con rmation protocol for RSA undeniable signatures by Gennaro et al. [24], with respect to the private key (d1, e1) and the public key (n, w,  w).
Note that similar approaches are used to construct e-payment protocol [15] and certi ed email system [5].
In [24], it is proved that a successful execution of this zero-knowledge protocol guarantees that  1 =  h(m)d1 mod n, where     {1, 1,  1,  2} and  i s (i = 1, 2) denote the two nontrivial elements of order 2.
In this case, Bob accepts  1 as valid and sends his signature  B on contract m to Alice in step (3), since he is convinced that another partial signature  2 can be revealed by either Alice or the TTP.
After that, if Alice does not reveal the value of  2 or only sends invalid  2 to Bob before the deadline t, Bob resorts to the TTP to get the correct value of  2.
If Alice honestly reveals  2 = h(m)d2 mod n to Bob in step (4), we have h(m)2    2e A mod n, i.e.,  A =  1 2 mod n is valid.
In such condition, Bob can recover the correct value of  A from  A by using the following recovery algorithm: (a) set  A =  A, (b) set  A =  A mod n, (c) get  A by factoring n, if h(m) =  e A mod n; if h(m) =  e else, i.e., h(m) 6=  e A mod n; Amod n.
We describe how Bob can factor n and then get the value A mod n but h(m) 6=  e of  A in case (c), i.e., h(m)2 =  2e
 mod n. Note that the equality h(m)2 =  2e A mod n implies that  A =  h(m)d mod n, where     {1, 1,  1,  2}.
When   =  1, corresponding to cases (a) and (b), Bob can easily  nd the value of  A.
So we conclude that case (c) means  A =  ih(m)d mod n, i = 1 or 2.
Recall that ord( i) = 2 and e is an odd number (due to e   Z   (n) and  (n) = 4p0q0), so we have  e A = ( ih(m)d)e mod n =  ih(m) mod n. Therefore, Bob can get the value of  i by Ah(m) 1 mod n. It is well known that computing  i =  e with the knowledge of such a nontrivial element of order 2, Alice s RSA modulus n can be easily factored, i.e., ( i   1) and ( i + 1) are the two prime factors of n. Consequently, Bob can get Alice s private key d by using extended Euclidean algorithm, and then obtain the value  A by computing  A = h(m)d mod n.
Based on the above discussion, we conclude that case (c) does not happen in the real world unless Alice wants to reveal her private key.
That is, if Alice reveals  1 =  ih(m)d1 mod n and  2 = h(m)d2 mod n, Bob will not only always recover her signature  A on contract m, but also could derive her private key d (and then forge signatures).
So we ignore case (c) in the discussions hereafter under an implicit assumption that any user does not want to compromise his/her own private key.
If Bob has sent his signature  B to Alice but does not receive the value of  2 or only receives an invalid  2 from Alice before the deadline t, then he sends the TTP (CA, VA, m,  1,  B) to apply dispute resolution.
Upon receiving Bob s application, the TTP performs as follows: (1) The TTP  rst veri es whether CA, VA, and  B are Alice s valid certi cate, voucher, and Bob s signature on contract m, respectively.
After that, the TTP checks whether the deadline t embedded in m expires, and whether Alice, Bob and itself are the correct parties speci ed in m. If any validation fails, the TTP sends an error message to Bob.
Otherwise, continue.
(2) Then, the TTP computes  2 = h(m)d2 mod n, and checks whether h(m)2   ( 1 2)2e mod n. If this equality holds, the TTP sends (m,  2) to Bob and forwards (m,  B) to Alice.
Otherwise, i.e., h(m)2 6= ( 1 2)2e mod n, the TTP sends an error message to Bob.
In the following, we explain why our dispute resolution protocol works.
Since the TTP sets  2 = h(m)d2 mod n, we conclude that h(m)2   ( 1 2)2e mod n if and only if  1    h(m)d1 mod n, where     {1, 1,  1,  2}.
That is, the TTP can determine whether Bob has sent a valid  1 to apply dispute resolution by checking h(m)2 =?
( 1 2)2e mod n. If this equality holds, the TTP reveals the correct value of  2 to Bob and forwards Bob s signature  B on contract m to Alice.
After getting the correct  2, Bob can recover Alice s signature  A on contract m by employing the recovery algorithm given in previous section.
In the case of h(m)2 6= ( 1 2)2e mod n, the TTP knows that Bob is a cheater, and so only sends an error message to him.
Note that if the  1 sent to the TTP is prepared as  1 =  ih(m)d1 mod n, the TTP can also get Alice s private key d as Bob does.
Remark 1.
Deadline t is a very important parameter in our protocol.
If Bob receives valid  1 at a time which is very close to the deadline t, he should not reveal his signature  B to Alice.
In this situation, Bob could have several choices to guarantee the fairness: (1) Ignore this protocol instance; (2) Get valid  2 from the TTP directly by initiating dispute resolution protocol; or (3) Require Alice use a new deadline t0 and run the signature exchange protocol again.
Based on the descriptions and discussions presented in last section, we know that in the normal situation, i.e., both involved parties are honest and the communication channel is in order, each of the two parties can get the other s signature correctly, and the TTP is not involved.
In other words, our scheme is complete and optimistic.
At the same time, if Bob shows the partial signature  1 with the proof (c,  r, i, j, r) to others, nobody (other than Alice and the TTP) believes that  1 is indeed Alice s partial signature on contract m.
Because, for any contract m, Bob himself can simulate such a proof for any (valid or invalid)  1 as follows: By choosing two random numbers i and j, then set c =  2i w mod n, r = h(m)2iwj mod n, and  r = commit(r).
Furthermore, such a simulated proof is computationally indistinguishable from the real proof generated by Alice and Bob together.
Therefore, the proposed protocol is also abuse-free.
1  j Moreover, our protocol overcomes the security  aw in Park et al. s scheme.
Namely, if Alice is honest, the TTP cannot derive Alice s private key d from d2 and other public information.
Otherwise, the RSA signature scheme can be broken as follows.
For any RSA public key (n, e), an attacker  rst chooses an even number d2, and then inquiries the signing oracle for a polynomial number of adaptively chosen messages m(i).
Then, from the corresponding an-1 =  (i)(h(m)d2 ) 1 mod swers  (i), the attacker computes  (i) n. Finally, the attacker calls the TTP as a subroutine to get the private key d. In fact, the above reduction is also valid to prove that except Alice herself, anybody (including the TTP) cannot forge a valid partial signature  1 for a new message with non-negligible probability.
Formal proofs can be obtained by straightforwardly adapting the techniques of Bellare and Sandu (see the 5th paragraph on page 5 of [11]).
In other words, under the assumption that the RSA is intractable [36], the proposed protocol is provably secure in the random oracle model [10].
In addition, the TTP is stateless in our contract signing protocol, because it does not need to keep any state information related to each protocol instance.
However, the schemes in [2, 3, 23] all require the TTP maintain a database to remember and search state information.
Otherwise, a dishonest party could cheat successfully and then breach fairness.
Namely, in those schemes, the TTP has to correctly record whether a speci c protocol instance is solved or aborted after receiving the application from a particular party.
So the TTP s workload and liability in our solution are reduced sig-ni cantly.
Hence, the cost of pay for the TTP can be cut accordingly, and performance of the TTP could be further improved.
Obviously, this property is truly meaningful for a practical system.
The compatibility is met naturally, since our basic goal is to de ne each party s commitment to a contract as his/her standard signature on the contract, instead of a signature satisfying some special structures [3, 33, 7].
As we have mentioned in Introduction, this is also an appealing property since the contract signing protocol can be conveniently integrated into existing softwares for electronic transactions.
Similar to the approach adopted by Micali in [33], a reasonable deadline t is added in each contract, hence the execution of a protocol instance will be terminated in a predetermined time limit, i.e., no later than the expiration of deadline.
The result is that each party is free of liability to his/her partial commitment to the contract after the deadline t. The key point is that after the deadline speci ed in a contract, the TTP does not accept a dispute resolution application related with that contract.
More discussion on this issue could be found in [33].
Now, we discuss the most important security property for a fair exchange protocol: fairness.
That is, we have to show that in our scheme, any of the two involved parties cannot take advantage over the other in the process of signature exchanging even if he or she behaves dishonestly.
We classi ed our discussion into two cases: (1) Alice is honest, but Bob is cheating; and (2) Bob is honest, but Alice is cheating.
For simplicity, however, the e ect of deadline on the fairness is not explained explicitly below.
Case 1: Alice is honest, but Bob is cheating.
First of all, according to the results of Gennaro et al. [24] and Bellare et al. [11], except Alice and the TTP, any adversary including Bob cannot forge signatures  1 or  2 for a new message m0 with non-negligible probability even if he has adaptively interacted with Alice and/or the TTP polynomial times (in the security parameter k).
This means that nobody can generate valid  1 except Alice, and that nobody can generate valid  2 except Alice and the TTP.
Case (1) implies that in step (1) of our signature exchange protocol, Alice  rst properly computes  1 = h(m)d1 mod n, and sends the triple (CA, VA,  1) to Bob, where CA is Alice s public key certi cate issued by a trusted CA, and VA is Alice s valid voucher created by the TTP.
The purpose of step (2) in our signature exchange protocol is that Alice interactively convinces Bob to accept valid  1 in a zero-knowledge proof way.
According to Theorem 1 in [24], we know that even if Bob cheats in any possible way, he cannot learn other information except  1 is valid, i.e.,  1 =  h(m)d1 mod n, for some     {1, 1,  1,  2}.
Actually,   must be 1 since Alice is honest in this setting.
This also implies that Bob cannot factor Alice s RSA modulus n by  rst getting a nontrivial element of order 2.
Upon receiving the valid value of  1, Bob has to make a choice whether he needs to send his signature  B on contract m to Alice.
If Bob does, honest initiator Alice returns back her second partial signature  2 = h(m)d2 mod n as Bob expects.
In such situation, Bob gets Alice s signature on contract m by setting  A =  1 2 mod n, while Alice also obtains Bob s signature  B simultaneously.
If Bob does not send  B or only sends an incorrect  B to Alice, he cannot get the value of  2 from Alice in step (4).
Furthermore, in this setting, Bob also cannot get the value of  2 from the TTP so that Alice does not obtain his signature  B.
The reason is that in our dispute resolution protocol, to get the value of  2 from the TTP Bob has to submit valid  1 and  B to the TTP.
Once those values are submitted, Bob indeed gets  2 from the TTP but Alice receives (m,  B) from the TTP, too.
Therefore, once again, Bob and Alice get the other s signature on contract m at the same time.
Case 2: Bob is honest, but Alice is cheating.
In our signature exchange protocol, Alice may cheat in any or some of the following steps: step (1), step (2) and step (4).
First of all, according to the speci cation of our signature exchange protocol, to get the signature  B on contract m from the honest responder Bob, the initiator Alice has to convince Bob accepting  1 as a valid partial signature in the step (2).
Recall that step (2) is exactly Gennaro et al. s con rmation protocol for RSA undeniable signatures, and that their protocol satis es the property of soundness (Theorem
 ice (prover), even computationally unbounded, cannot convince Bob (veri er) to accept an invalid  1 as valid with non-negligible probability.
Therefore, we conclude that to get  B from Bob, Alice has to send valid  1 (with valid CA and VA) in step (1) and perform honestly in step (2).
In other words, Alice has to send  1 =  h(m)d1 mod n to Bob unless she does not want to get Bob s signature  B, where     {1, 1,  1,  2}.
Based on our discussion in previous section, we know that Alice is not so silly by preparing and sending  1 =  ih(m)d1 mod n to Bob.
Otherwise, Bob can drive her private key d (and then computes signature  A), though he indeed gets Bob s signature  B.
Therefore, to get signature  B from Bob, Alice has to compute  1 =  h(m)d1 mod n and send it to Bob.
In this situation, Bob receives valid  1 =  h(m)d1 mod n from Alice before Alice gets valid  B from Bob.
After that, step (4) is the only one possible cheating chance for Alice, i.e., she may refuse to reveal  2 or just send an incorrect  2 to Bob.
However, this cheating behavior does not harm Bob essentially, since he can get the value of  2 from the TTP via our dispute resolution protocol.
The reason is that Bob has received valid  1 before he sends  B to Alice.
After getting the value of  2 from the TTP, Bob can recover Alice s signature  A according to the recovery algorithm speci ed in section 3.2.
Therefore, in case (b) where Bob is honest but Alice is dishonest, Alice cannot get Bob s signature such that Bob does not obtain her signature.
Based on the above analysis, we conclude that the proposed protocol is not advantageous to any dishonest party.
Table 1.
Comparison of E ciency Asokan et al. [2, 3] Ateniese [4] Park et al. [34] Our Protocol Number of Exponentiations.
Data to Be Exchanged (bytes)







 In other words, our contract signing protocol satis es the property of fairness.
Table 1 shows the comparison of e ciency between our new protocol and several other RSA-based solutions, i.e., Asokan et al. s scheme [2, 3] from veri able escrow, Ate-niese s scheme [4] from veri ably encrypted signature, and Park et al. s scheme [34] from multisignature.
In the comparison, we analyze the overheads of computation and communication in the signature exchange protocol needed by both Alice and Bob in normal case.
In other words, the operations of the dispute resolution protocol are not discussed here.
Moreover, we take the number of modular exponenti-ations as the computational cost since exponentiation is the most expensive cryptographic operation in the  nite  eld Zn.
In addition, note that a modular exponentiation in Zn requires about 1.5   |n| modular multiplications, and that exponentiation of the form ax1 2 is only equivalent to 1.167 single exponentiation by means of an exponent array (pages 618 of [32]).
1 ax2 For comparison, we make similar but di erent assumptions from [4, 34].
Namely, we assume that the length of RSA modulus n is 1200-bit, and that the hash function h( ) has 128-bit  xed output.
For simplicity, we also assume that  B could be generated and veri ed by one modular exponentiation separately, and that the voucher VA can be validated by one modular exponentiation, too.
However, the overhead related to Alice s certi cate CA is excluded as did in [4, 34], since such validation may be as simple as to check the certi cate list on CA s web site.
Some numbers listed in Table 1 are di erent from the results that appeared in [4, 34], since we take into consideration all exponentiations needed in the signature exchange protocols by both Alice and Bob, while Anteniese only concerned the amount of each signature algorithm, and Park et al.
[34] only considered the overhead required for creat-ing/verifying the fairness primitives (i.e.,  1 and VA).
For example, Anteniese did not include the overheads of creating and checking the proof for proving the equality of two discrete logarithms, while Park et al. did not estimate the overheads of generating and verifying Alice s signature  A.
Our analysis is more reasonable since it accurately re ects what happens in practice.
In addition, note that the numbers for the Asokan et al. s scheme were taken from [34] directly.
According to the results in Table 1, the computational e ciency of our scheme is in the middle between Park et al. s scheme and Ateniese s scheme, while the communication cost of our scheme increases by 103% and 33% more than that of Park et al. s scheme and Ateniese s scheme, respectively.
The overhead of communication becomes larger naturally, since our scheme exploits interactive protocol to prove the validity of  1.
The bonus in our new scheme is that Bob cannot show the validity of  1 to other parties, i.e., abuse-freeness, as we discussed before.
We believe that this cost deserves the advantage of our scheme in the situations where the intermediate results should not be revealed unfairly.
Actually, all those three schemes are suited for most applications where the cost of communication is not the main concern.
In this paper, based on the standard RSA signature scheme, we proposed a new digital contract signing protocol that allows two potentially mistrusted parties to exchange their digital signatures on a contract in an e cient and secure way.
Like the existing RSA-based solutions, the new protocol is fair and optimistic, i.e., two parties get or do not get the other s digital signature simultaneously, and the trusted third party is only needed in abnormal cases that occur occasionally.
However, di erent from all previous RSA-based contract signing protocol, the proposed protocol is further abuse-free.
That is, if the contract signing protocol is executed unsuccessfully, each of the two parties cannot show the validity of intermediate results generated by the other party to outsiders.
In other words, each party cannot convince an outsider to accept the partial commitments coming from the other party.
This is an important security property for contract signing, especially in the situations where partial commitments to a contract may be bene cial to a dishonest party or an outsider.
Technical details are provided to show that our protocol meets a number of desirable properties, not only those just mentioned.
In addition, exploiting some techniques of Park et al. [34], our protocol can be adapted to fair payments in e-commerce (though their solution has a security  aw).
In this setting, one customer purchases a digital goods from a merchant via the Internet by paying a digital check or cash.
The extended scheme could implement such an electronic transaction between two parties fairly.
That is, it is guaranteed that the customer gets the digital goods from the merchant if and only if the merchant gets the money from the customer.
Finally, using the technique of threshold RSA signature introduced by Shoup [37], the proposed protocol could be extended for the scenarios where the trust on a single TTP needs to be distributed into multiple TPPs, or a contract is required to be signed only by a given quota of members cooperatively.
The author would like to thank all  ve anonymous referees for their helpful and detailed comments on the paper, as well as Dr. Feng Bao, Prof. Robert H. Deng, and Dr. Jianying Zhou for good discussions on the topic of fair-exchange.
