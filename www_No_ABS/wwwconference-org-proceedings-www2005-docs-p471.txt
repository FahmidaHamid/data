Logging in with usernames and passwords has become one of the most ubiquitous and most reviled rituals of the Internet age.
On the web, passwords are used by publications (nytimes.com), blogs (slashdot.org), webmail providers Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
(gmail.com), e-commerce sites (amazon.com, ebay.com), and  nancial institutions (etrade.com).
Elsewhere, they serve as authentication for Internet service providers, email servers, and local and remote host accounts.
Users are asked to generate, memorize, and keep secret a growing number of passwords as they join new password-protected sites over time.
Since at least 1997 [6], this trend has been recognized as both a nuisance and a security risk.
Research has shown that typical users can be trained to select and remember a single secure password [8], but multiplying this dozens or hundreds of times is sure to push the physiological limitations of human memory.
Users face a di cult dilemma: they can either stretch their limited mental storage by choosing simpler passwords or reusing them across sites, or they can resort to memory aids, such as writing passwords down or using password management software.
Unfortunately, the inconvenience of available software has prompted many frustrated users (including, regrettably, the authors) to resort to the former, insecure strategy.
One common practice we have observed is to choose a single strong password and use it for many accounts.
The danger, of course, is that an attacker could learn the password from one account and guess other places where the user is likely to use the same login information.
Since a small number of web sites are used by a large fraction of people, sites like Amazon, EBay, Yahoo!, and large  nan-cial institutions would be very likely guesses.
There are many possible avenues for opportunistically stealing passwords, including insider attacks, remote exploits of weakly secured sites, key logging on public terminals, and web site spoo ng.
Since sites that don t store  nancial or billing information are likely to have lower security standards (such as not using SSL for authentication), passwords can be stolen and reused to compromise sites that guard more sensitive data.
Service providers can enforce policies about password strength and they can track failed logins, but this insecure password reuse behavior is very di cult to police.
Our solution avoids password reuse entirely while requiring the user to memorize only a single master password.
Rather than store passwords chosen by the user, our scheme applies a type of strengthened hash function to determinis-tically generate high-entropy passwords every time they are needed.
This approach, we will argue, is both convenient for users and highly secure, a combination not o ered by previous designs.
Convenience.
Since we use a deterministic method to calculate account passwords, users can run our software on di erent machines to access their passwords from almost any location.
We rely on very little input the user s identity (perhaps an email address), the name of the account (e.g., the server domain name), and a single master password chosen and memorized by the user.
This means users can transport in their heads all the inputs needed to regenerate their passwords.
It also ensures that passwords for di erent accounts will appear to be unrelated.
Security.
While the idea of hash-based password schemes is not new [6, 15], previous designs su ered from a potentially serious weakness.
An adversary who stole one account password could conduct an o ine brute force attack on the user s master password and thereby learn all the user s other passwords.
The attack is simple; for every potential password the attacker applies the hashing algorithm for that particular site and compares it to the known site password.
The rate of an attacker s search is limited by the time to compute the hash function, which can be as low as one microsecond in previous schemes.
In this example, a conventional machine can search a password space of size one million in under one second.
Given the low entropy of typical user passwords, this kind of attack constitutes a major threat.
To protect against such attacks, we apply techniques for  strengthening  user passwords to increase the cost of the hash computation so that it incurs an acceptably small delay for the user while substantially throttling brute force attacks.
In some attack scenarios, this increases the time required to search a password space by a factor of approximately 108 compared to other approaches.
We cache partial results on the local system so that passwords can be generated quickly after an initial computation time of about 100 seconds when our program is  rst installed.
Browser integration.
We implemented our scheme as an extension to the Mozilla Firefox web browser.
Browser integration of password management is important for multiple reasons.
First, most of a user s passwords are likely to be used for web sites.
Building our system into the browser allows it to work as conveniently and transparently as possible, minimizing the burden imposed on the user and increasing the chances that the system will be used in practice.
Second, browser integration allows our system to o er some protection against spoo ng and phishing attacks, since by default the password program will use the name of the server that will actually receive the submitted password, even if an attacker has tricked the user into believing she is connecting to a di erent site [15, 5].
Outline In Section 2 we reference prior work related to password systems and password strengthening.
We describe our novel password computation scheme in Section 3 and discuss its security.
In Section 4 we compare our approach to related proposals in terms of security and convenience.
Section 5 focuses on a prototype implementation we have developed, including discussion of the challenges we faced.
Finally, in Section 6 we conclude.
Recent years have seen a wide variety of proposed solutions to the management password problem.
One approach is to create centralized, trusted authentication services, such as Microsoft s Passport initiative [1].
Users log in to these services using a single password and are then authenticated to participating web sites.
Such systems have met limited success for two reasons.
First, they require technical changes on the part of every site that uses them for authentication, something even Microsoft has lacked the clout to achieve on a widespread scale.
Second, users have been cautious about placing so much trust and privacy-sensitive information under the control of a centralized system.
Passport s security is analyzed in [12].
Several other schemes do not rely on server-side changes or trusted third parties.
These proposals operate in two general ways: either they let users choose their own passwords and then store them somewhere safe, or they assign  xed passwords for each site or service that can be computed whenever they are needed.
The Password Safe application [16] takes the former approach.
It stores passwords and other sensitive data in an encrypted database on the user s machine, secured with a master password.
The Lucent Personal Web Assistant (LPWA) [6] applies the latter approach.
It operates as an HTTP proxy server that users access with a master username and password.
They can then tag web site password  elds to be automatically  lled in with values derived from a hash-based function of the user s master password and the domain name of the web site.
PwdHash, a recently released utility by Ross et al. [15], applies a similar hash-based technique on the client side.
It functions as a web browser plugin, seamlessly replacing values submitted via web site password  elds with hashes of those values and the site s domain name.
PwdHash is primarily intended to provide a defense against  phishing  or  spoo ng  attacks by linking site passwords to the domain name of the server to which they are actually sent.
In Section 4 we give a detailed comparison between the above schemes and our approach.
Researchers have long recognized that passwords guarded by one-way functions were vulnerable to brute force attacks, and that those functions should be made slower as a defense.
The classic example is the Unix crypt function examined in
 work was concerned with securing the password veri cation procedure.
Here we wish to strengthen the passwords themselves.
There have been two primary techniques for strengthening low-entropy keys or passwords for protection against brute force searching attacks.
Both approaches share the common goal of increasing the (average) amount of computation needed to con rm or eliminate a guess of a user s password.
In both techniques the adversary has the output of a strengthened hash function and wishes to know the master password put into it.
The  rst kind of technique, as studied by Kelsey et al. [11], derives a new password by repeatedly iterating a hash function on the original master password.
Assuming there are no shortcuts, an adversary s best attack is to apply the function to each guess herself.
Therefore, if the scheme is parameter-ized to use k iterations an adversary will need to compute k hash functions for each guess.
The second type of technique is due to Abadi et al. [3] and Manber [13].
In these approaches, the password is concatenated with a random value known as a  password supplement  before it is hashed.
When checking a password guess an attacker will need to perform a hash for each possible supplement until the space is searched.
Thus, if the password supplement space is of size k the attacker will need to perform k hashes before she can completely eliminate one guess as a possible password.
The primary drawback of this second approach is that a regular user also needs to search through the space and needs a method for determining if the password supplement is correct.
If a strengthened password is integrated into a login system, some extra data can be stored on the server and the server can perform the search.
However, if we don t want the client to carry state and we want to be compatible with an oblivious web server, then the client will have no way to test each password supplement short of attempting a login.
For these reasons we choose to build on the deterministic approach of Kelsey et al., although it is possible that other techniques could be modi ed to meet our requirements.
There has been recent interest in the subject of password-authenticated key exchange [10, 7, 4].
In these schemes we have two parties that authenticate each other only by a shared password and exchange a random session key.
(We contrast this with SSL and SSH connections where one party, typically the server, has a known public key and the client authenticates himself with a password over a secure channel established using the public key.)
The common goal of these schemes is to protect the shared password, which will typically have low entropy, from being computed by an attacker in an o ine dictionary attack.
Our ideas (as described in Section 3) can be used with password-authenticated key exchange if the password shared by a client and server is generated from a hash of the client s master password and server name.
In this case we will still want to strengthen the password hashing function.
The properties of password-authenticated key exchange protocols protect against a third party discovering the shared password.
However, the server can still execute a dictionary search for the master password using the shared password that it legitimately knows.
Master passwords in a hash-based password generation system can be particularly vulnerable to brute force attacks due both to the low-entropy of passwords memorable by humans and to the ability of an adversary to execute a low-cost o ine password guessing attack.
While there has been much e ort put into alternate password entry techniques that increase memorable entropy (such as graphical passwords [9]), common character-based passwords are still by far the dominant mechanism.
For this reason, our approach focuses on making guessing more time-intensive so as to raise the cost of a brute force attack.
A hash-based system is inherently vulnerable to an o line guessing attack of the master password by an adversary who has obtained one or more of the user s site spe-ci c passwords.
This adversary can execute a simple brute force attack by enumerating the potential master passwords (possibly trying the most likely ones  rst) and for each one executing the hash algorithm for that particular site and comparing it to a compromised site-speci c password.
The amount of time to execute this attack will be the number of passwords tested multiplied by the execution time for the hashing algorithm.
If the algorithm can be computed quickly, like SHA-1, this attack can be quite e ective.
In our construction we limit the vulnerability to such an attack by increasing the amount of time needed to compute the hash function.
In particular, we use the technique of Kelsey et al. [11] of  key-stretching  via repeated application of a hash function.
The basic concept is that a regular hash function, f(), is replaced with a new hash function, f k(), where f k() is computed by repeatedly applying the hash function k times.
For example, f 3(x) is equivalent to computing f(f(f(x))).
If P is the set of passwords the adversary wants to test and we conjecture that for all p   P the fastest way for an adversary to compute f(p) is by repeated applying the function, f(), k times, then the cost of a brute force attack will increase by a factor of k.
Of course, a regular user will have to perform the same iterated hash computation when calculating a site-speci c password.
If the delay is very long, the system will be too inconvenient for most users.
Thus, we must strike a balance between usability and security in our system design and choice of parameters.
In our scheme we use two levels of iterated hash computations.
The  rst level is executed once when a user begins to use a new machine for the  rst time.
This computation is parameterized to take a relatively long amount of time (around 100 seconds in our implementation), but its result will be cached and for future password computations by the same user.
The next level of computation is used to calculate site-speci c passwords.
It takes as input the calculation produced from the  rst level computation as well as the name of the site or account for which the user is interested in generating a password.
Let f(x) be a secure hash function, then a site password is calculated in the following two steps:
 V = f k1(username : master password) In this function the concatenation of the username and master password is iterated k1 times.
The concatenation should be performed such that it can be uniquely parsed into a username and master password pair.
site password = f k2(site name : master password : V ) In practice the raw output of the iterated hash function will be translated into an acceptable password for web sites and other accounts.
As in the  rst step, the concatenation is performed such that it parses into a unique triple.
In the  rst step the iterated hash function is calculated on the master password and username.
The username can be any unique identi er a user chooses such as an email address.
The purpose of the username is to thwart dictionary attacks where an attacker would compute and store the iterated hashes on a list of candidate passwords.
In our scheme the username serves as salt and an attacker needs to compute attacks on a per-username basis.
Since the intermediate value, V , is independent of any particular website, it can be cached and used for computations for site speci c passwords.
In practice the value k1 will O ine Hashes per Guess Time per Guess Attack Type No Information Stolen Site Password Stolen Cache Stolen Cache and Password No Yes Yes Yes
 k1 + k2 k1 k2
 100.1 s 100 s 0.1 s Table 1: Di culty of various brute force attacks against our scheme.
The times per guess are for a fast modern PC and assume the values of k1 and k2 used in our implementation.
be set to be much larger than k2.
We can set our parameters such that whenever a user begins using the scheme she will incur a relatively high delay for the  rst step to be computed, but from that point on the value V can be cached such that any per-site calculation of step two will take a small amount of time that is unnoticeable to the user.
In practice we set the parameters such that the  rst step takes around 100 seconds on a fast modern machine and the second takes around a tenth of a second.
In this manner our scheme strives for the best balance between security and usability.
We will now analyze the e ort needed by an attacker to learn a user s password for a particular site.
We characterize four di erent types of attackers by the type of information they are able to obtain prior to the attack.
The  rst attacker has no information except the user s username for the targeted site.
The second type of attacker additionally knows the user s site password for a site other than the targeted site.
The third type of attacker has the result of the  rst level of computation by a user, but does not know any site-speci c passwords.
The  nal type of attacker has both the result of the  rst level of computation and a site-speci c password.
Our analysis follows: (1) No Information The  rst type of attacker has essentially no information about a user.
This type of adversary is limited to performing an online attack against the user s password at the targeted site.
This adversary will typically be limited by a velocity control mechanism at the site which will constrain the number of login attempts allowed per unit time and might even disable the account if too many unsuccessful attempts are logged.
Since the adversary needs to mount an active attack she faces a high risk of detection.
If successful, she will only gain a site-speci c password, which cannot be directly used to attack the user s password for a second site.
However, with this site-speci c password she can then become the second type of attacker.
(2) Stolen Site Password The second type of attacker we consider has access to the targeted user s site password for at least a single site.
The adversary might obtain this information by convincing the user to log in to a malicious website using a generated password, or else she might compromise an insecure site.
The attacker can then perform an o ine attack on the user s master password.
She will need to spend p(k1 + k2) > pk1 hash computations to search for the master-password where p is the number of attempts needed to guess a password.
Since this is an o ine attack, the attacker can execute it undetected.
In practice, we believe, this is the most important adversary to guard against, because an opportunistic attacker can easily learn some site passwords without being detected.
Since our scheme forces the adversary to spend over a minute of computation time per attempted password, the attack will be rate limited.
(3) Stolen Cache In the third type of attack we assume that the attacker steals or compromises a user s machine that has an intermediate value V stored locally.
The adversary can execute an o ine attack where she searches for the master password by executing the  rst step in the algorithm for each possible password and compares its output to the stolen value.
Each guess will take k1 hash iterations to test.
Since k1 >> k2, this attack should not be signi cantly more successful than the previous one.
Moreover, if the user is able to detect that her machine was compromised or stolen, then she would likely have enough time to change the passwords on her accounts before the adversary could break into them.
(4) Stolen Cache and Site Password For the  nal attack we consider an attacker who obtains the user s cached intermediate value and at least one site password.
This could occur if the adversary who stole the machine also owned a malicious site that the user visited, or more likely, if the stolen machine also stored site-speci c passwords.
The adversary will only need to compute k2 hashes for each guess.
Since k2 will be set signi cantly lower than k1, the adversary will need less time to search through a password space.
However, the iterated hash function will still require much more adversarial e ort than a traditional hash-based system.
Our scheme provides a high level of protection for Scenarios 1 3 and a reasonable amount for the strong attack of Scenario 4.
We note that it is important for users of our scheme to prevent their site-speci c passwords from being cached locally so that an adversary who steals the machine has to execute attack Scenario 3 rather than Scenario 4.
Indeed, our scheme replaces much of the utility of locally stored passwords.
We summarize the results of our analysis in Table 1.
The security of our scheme rests upon the belief that for the adversary to search a password space of size n she must compute n  k hashes.
This assumption is heuristic in nature and is similar to viewing the underlying hash function as a Random Oracle.
There has been some evidence that compressing the iteration of hash functions is di cult.
Kelsey et al. [11] prove that if an adversary can compute a 2m iterated hash with e ort 2m/  then the adversary can  nd a hash function collision about  /2 times as fast as a naive birthday attack.
While the result of Kelsey et al. is encouraging, in practice it must hold that the adversary cannot amortize the cost of computing k iterations across all n passwords she is interested in.
Unfortunately, if we extend the Kelsey et al. proof in the natural way, the best we can show is that if an adversary can compute a set of n iterated hash functions in time 2m/  then that adversary can be used to  nd a collision about  /(2n) times as fast as a naive birthday attack.
In practice this reduction is not very strong (especially when n approaches the number of iterations).
In fact, even this weak reduction requires the stronger assumption that the adversary would be able to tell which input hashes corresponded to the output hashes, which would not necessarily be the case in practice.
Therefore, it seems we need to assume that the hash function behaves similarly to a Random Oracle from the point of view of the adversary.
We leave it as an open problem to explore the di culty of amortizing the cost of iterated hashing.
In this section we compare our approach to the client-side password manager schemes described in Section 2: Password Safe, LPWA, and PwdHash.
We focus on their ease of use and their security against various kinds of attacks.
To be widely adopted, a password manager system needs to impose a minimal burden on end users, both when creating and retrieving passwords (the typical usage case) and in less common, but potentially trickier situations, like changing passwords and migrating from unmanaged passwords.
Typical Usage PwdHash is the easiest scheme to use in the typical case.
Its operation is so seamless that were it installed in every browser since the foundation of the web, users would notice virtually no di erence aside from improved security.
The other approaches require a bit more user interaction for each password operation.
In our scheme and Password Safe a user must explicitly interact with an application, and users in LPWA must type in a special character string in a password  eld to signal the scheme to  ll in the password.
The applications also have slightly di erent usable scopes.
LPWA and PwdHash are limited to web site passwords, our approach protects user-selectable passwords in general, and Password Safe additionally secures arbitrary secrets like credit card numbers and PINs.
Password Changes and Migration All the hash-based schemes (LPWA, PwdHash, and our scheme) have di culty with the transition from unmanaged passwords.
Since these schemes generate rather than store passwords, users need to manually execute a password change for each password that will be managed.
PwdHash, LPWA, and our scheme face similar challenges dealing with password changes.
In these techniques, web passwords are deterministically computed from the site s domain name and information provided by the user (such as a master password) that is global across every site the user visits.
If this password is compromised or is required to be changed periodically as a matter of policy, the user must take additional steps to generate an alternate password.
We describe how we mitigate this problem in Section 5.
Password Safe most successfully copes with these situations.
Since it stores encrypted passwords, it can accept existing passwords rather than forcing the user to change them, and it can handle future password changes in a similarly straightforward manner.
Transportability To take the place of memorized passwords, password manager software needs to be easy to use not only in the sense of simplicity but also that of availability.
The people most likely to need such a program active Internet users with accounts on many web sites are particularly likely to demand access to their passwords from multiple locations, such as from desktops at home and at work, from laptops while traveling, and from public terminals.
The ease and reliability with which passwords can be transported and accessed from remote locations is an important criterion for these applications.
Password Safe is not designed to be particularly transportable; it can only be used where its encrypted password store is accessible.
The user is forced to carry this data with her in a storage device (which can be inconvenient and raises synchronization issues) or else to access it over a network (which introduces a host of other security risks).
In contrast, the hash-based mechanisms were designed with transportability as a central concern.
Since they compute passwords on demand rather than storing them, users can shift from one machine to another by moving only a very small amount of state typically a single secret small enough for the user to carry in her head.
The hashing schemes are distinguished by the means of accessing each software application.
LPWA, a web-based service, might be expected to be the most accessible, but in fact it has been totally unavailable since 2000, when the service was taken o ine.
Since the technology is proprietary, the scheme is e ectively no longer available to the public.
This incident highlights the need for temporal as well as spatial availability.
PwdHash and our scheme are distributed with complete source code, and they are based on simple algorithms that can be expected to outlast any particular implementation.
Both these schemes require the software to be distributed securely using trusted servers, veri ed hashes, or cryptographic signatures.
Unlike the other schemes, our design imposes an initial delay of about 100 seconds when a user runs it for the  rst time on a new machine.
While this may hinder availability in some instances, we believe it is a worthwhile trade o  for greatly increased security.
PwdHash also supports a secondary  password  that can be stored locally on the user s machine and used for all web sites.
Users can trade transportability for security by setting this value to a long secret string.
While this would make attacks on the master password much more di cult, the value would need to be explicitly stored and transfered when moving to another machine.
Since these password management schemes are intended to solve a security problem, perhaps the most important single criterion by which to evaluate them is their resistance to attacks.
At the very least, they should be more successful Stolen Password Stolen Data Stolen Data and Password Scheme Password Safe
 PwdHash Our Scheme

   45.8(9.7)




 Table 2: Bits of password entropy (or number of random lower case letters) needed to resist attack for an average of one year under three attack scenarios.
  35.2 (7.5)


   74.6 secs
 0.1 secs 2.8 hours Stolen Password Stolen Data Stolen Data and Password Scheme Password Safe
 PwdHash Our Scheme
 0.5 secs 0.1 secs 116 days 74.6 secs
 0.1 secs 116 days Table 3: Resistance to a dictionary attack under three attack scenarios Times to test 100,000 password guesses using a fast modern PC.
than a naive user who selects the same password for every account, while the best we can hope for is to approach the security of a user who memorizes and keeps secret a unique random password for each account.
We compare the schemes under the three o ine attack scenarios described in Section 3.
These are: (2) the adversary has access to a stolen site password; (3) she has access to stolen data from the user s machine; and (4) she has stolen both local data and a site password.
In each case the adversary wants to learn the target user s password for an additional site.
To quantitatively compare the schemes, we consider an example in which the adversary is willing to devote one year of computation (on a typical fast PC) to the attack, and we determine how many bits of password entropy are required to fend her o  at least half the time.
This might seem like a lot of power to devote to attacking one user, but we believe it is a realistic worst-case assumption.
An intelligent adversary would choose her targets carefully, perhaps by stealing demographic information such as income level from a compromised web site.
She might also determine ahead of time whether the potential target had accounts on the most desirable sites, such as banks.
To speed things up, she could parallelize the attack using a distributed network of compromised machines.
Breaking the password manager s security would hand the adversary the keys to a user s entire digital identity, so costly and sophisticated attacks should be expected.
Password Safe, which stores an independent password for every site, is not vulnerable in Scenario 2.
Attacks are possible in Scenarios 3 and 4, when the adversary has access to the encrypted password database.
Existing software [17] attempts to discover the master password by performing a dictionary attack against a password veri cation code stored at the beginning of the database.
The code is computed by repeated applications of the Blow sh cipher to a hash of the password.
This attack can be executed at a rate of about
 sary using this software for an average of a year, the user would need to select a password with 35.2 bits of entropy, equivalent to a randomly selected password of 7.5 lower case letters.
Even faster attacks may be possible in Scenario 4 using one or more site passwords.
LPWA computes passwords using a hash-based function and does not store any data to disk, so it is equally vulnerable in Scenarios 2 and 4, and Scenario 3 is not applicable.
Since we do not have access to the LPWA software, it is more di cult to estimate the cost of a brute force search.
However, if we assume the authors implement the pseudo-random functions in the LPWA algorithm as HMACs instantiated with the SHA-1 function, then we can  nd a simple attack that takes  ve applications of the SHA-1 function per guess (or roughly 5 microseconds per guess on a modern computer).
At this rate, an attacker could test 3.6   1012 guesses in a year, and users would need an average of 43.5 bits of entropy to remain secure.
This is equivalent to a 9.3 character password of random lower case letters.
We need to consider the security of PwdHash in two different situations.
The  rst is if the user does not use a long random string stored locally.
Then the scheme will be vulnerable to an o ine brute force attack in Scenarios 2, 3, and 4.
PwdHash uses an MD5-based HMAC computation to generate site passwords.
This takes approximately one microsecond to compute on modern machines, so the adversary could test 3.15  1013 passwords a year, and an average of 45.8 bits of entropy (or 9.7 randomly selected lower case letters) would be needed to thwart her attack.
If a long, random local string is used, then the scheme can be very secure against an attacker of Scenario 2 (but at the expense of the transportability problems mentioned above).
However, since this second  password  is stored on disk, an attacker in Scenario 3 or 4 can execute the brute force attack discussed in the previous paragraph as if no secondary password were present.
Finally, for our system, in Scenario 2 the adversary would need to run a brute force attack against the entire strengthened hash function, which takes approximately 100.1 seconds to compute on a modern PC.
That means that a brute force attacker could try at most about 316,000 passwords in a year.
To ensure that an average attack takes more than a year, a user would need to select a password with 19.2 bits of entropy, equivalent to a randomly selected pass word of 4.1 lower case letters.
In Scenario 3, the attacker could steal the cached intermediate value and use it to check the results of a brute force attack on the master password.
This would reduce the time for a single guess to 100 seconds, requiring about the same entropy as in Scenario 2.
In Scenario 4, the adversary could use the stolen intermediate value to make guesses much more quickly and could check the results against the stolen site password.
This attacker could test a password in about 100 milliseconds on a typical machine, so it would take about 25.9 bits of password entropy to fend o  her attack for an average of a year.
This is equivalent to a random password of 5.5 lower case letters.
Based on this analysis (as summarized in Tables 2 and 3), we see that users under our scheme need to memorize up to approximately 45% fewer bits of password data than Password Safe, 58% fewer bits than PwdHash users and perhaps
 tance to brute force attacks.
Since passwords chosen by typical users usually have fewer bits of entropy than random passwords of the same length, this reduction is likely to be a signi cant security bene t in practice.
With minimal training, users can easily create and remember passwords with entropy equivalent to 4 6 random characters [8], but it would be a substantial burden to handle as many as 10 random characters, as required for security in some other schemes.
As an additional security bene t, our scheme can be adjusted in the future to increase the amount of strengthening in the hash function to compensate for advances in computational power.
If the adversary s computational power doubles about every 1.5 years, users will need to add 6 2
 bits of password entropy every decade to maintain the same level of security.
Our scheme could be recalibrated every few years to keep the required password entropy within a  xed range (at the cost of requiring users to change all their site passwords).
As we have seen, our approach o ers a very high degree of security while remaining easy to use and conveniently portable.
We believe that this low cost, high bene t combination will be appealing to users.
To test our system, we implemented the construction described in Section 3 as an extension to the Mozilla Firefox web browser.
Our program, called Password Multiplier, is available online at: www.cs.princeton.edu/~jhalderm/projects/password/.
Password Multiplier uses Mozilla s cross-platform scripting tools and user interface language (XUL), which allow it to integrate neatly into the browser and to match its look and feel on each operating system.
We support Firefox s three primary platforms Windows, Linux, and Mac OS X.
One of the principal challenges we faced was achieving the proper balance between attack resistance and user convenience.
A brute force attacker would choose the fastest available hash implementation.
To make the attacker s job more di cult, we also need to choose a fast implementation so that we can perform as many hash iterations as possible within the longest delay we deem acceptable 100 seconds for the onetime initialization and 100 milliseconds for each subsequent password generation.
Mozilla s interpreted scripting language is not e cient enough to meet these performance requirements, so we implemented the iterated hash functions in compiled platform-speci c XPCOM objects.
These employ the highly-optimized SHA-1 hash Figure 1: Before using Password Multiplier for the  rst time on a new system, the user needs to  authorize  it.
This involves a onetime computation on the user s email address and master password that takes around 100 seconds.
The result is cached for future use.
function code from the OpenSSL [2] library.
After testing performance on various modern machines, we parameter-ized the system to use 108 iterations during the initialization phase (k1) and 105 during password generation (k2).
Here is how a typical user experiences Password Multiplier.
Before using the program for the  rst time on a new machine, the user needs to  authorize  it using the interface depicted in Figure 1.
This dialog box prompts the user for her email address (which serves as a unique identity) and her master password, which must be at least eight characters in length and is entered twice to guard against errors.
The program gives advice on picking a strong password to encourage users to follow good security practices.
Users who have used the application before on a di erent machine are instructed to enter the same address and password to ensure that the correct passwords are computed.
With this information, the program performs the initialization process, in which it computes the hard part of the strengthened hash function as described in Section 3.
The result is cached to disk so that this process only has to be performed once per user per system.
After it has been initialized, Password Multiplier can be invoked by double-clicking on any web site password  eld, or by highlighting a password  eld and pressing Alt+P.
It presents the Multiply Password window (shown in Figure 2), which asks the user to reenter her master password and con rm the domain name of the web site for which the password is used (we automatically  ll in the name of the server that will receive the HTML form submission).
The generated site-speci c password is copied into the site s password  eld.
Password Multiplier supports both HTML form password inputs and standard HTTP authentication prompts.
In both cases, it interacts correctly with the browser s internal saved-password manager.
The passwords computed by our pro-Figure 2: Double-clicking a password  eld (or highlighting it and pressing Alt+P) invokes the Multiply Password window shown here.
The site name is  lled in automatically.
After the user enters her master password, the program pastes her site-speci c password into the site s password  eld.
gram consist of eight case-sensitive alphanumeric characters derived by treating the output of the hash function as a 160-bit little endian number, converting it to base 62, and mapping it to the character set [0-9A-Za-z].
Passwords of this form contain about 47 bits of entropy (or about 41 bits if the case is ignored), so they will normally be at least as hard to guess as the master password itself.
A challenge faced by all generator-style password managers is the need to support account password changes.
A new password may be needed if the existing password was compromised, or system administrators may require users to change their passwords regularly as a matter of policy.
While we believe these situations are uncommon for typical usage with web site accounts, it would be helpful for implementations to provide a mechanism for handling them.
Generating an alternate password requires extra inputs in addition to the user s identity, her master secret, and the identity of the target account.
This means users must carry additional  state  when moving between machines, but implementations can be designed to minimize this inconvenience.
Users could indicate a password change by incrementing a password index presented along side the account name.
The index value could be stored with the name of the account on the local system, so there would be no need to set it again unless the user moved to a di erent machine.
The index would be appended to the account name in the generation algorithm to produce a completely di erent password.
Upon switching machines, the user would need only remember how many times she had changed her password for a particular account, rather than what her new password was.
Unlike the password itself, this information would not need to be kept secret, so the user would be free to write it down, post it online, or use other reminders.
If a particular password was required to be changed regularly, the name of the period for which the password was valid could be used instead of a numerical index.
For example, a password changed monthly might use the string
 the generation algorithm.
The password program could use an internal calendar to track when password changes were required and remind the user automatically.
The password change features in this section have not yet been added to our implementation but are planned for an upcoming release.
Many users (including those who should know better) fail to take adequate steps to protect their passwords.
Often the cause is not a failure to understand that strong passwords are important, but rather frustration with the di culty of doing the right thing.
In our study we attempted to make strong password management more convenient.
Whereas previous schemes were lacking in either transportability for mobile users or security against brute force attacks, our design achieves a balance of the two by using password strengthening techniques.
Our implementation, Password Multiplier, is available on the web.
We encourage novices and experts alike to try it.
Acknowledgment This material is based upon work supported under a National Science Foundation Graduate Research Fellowship.
