The vision of the Semantic Web [2] is to enable automatic interoperation between entities on the Web.
Such interoper-ation can be achieved through annotation of the content on Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
Dieter Fensel Digital Enterprise Research Institute (DERI) University of Innsbruck, Austria National University of Ireland, Galway, Ireland dieter.fensel@deri.org the Web with machine-processable data.
When such annotations are linked to ontologies, machines can achieve a certain degree of understanding of the data.
Ontologies [11] are formal and explicit speci cations of certain domains and are shared between large groups of stakeholders.
These properties make ontologies ideal for machine processing and enabling interoperation.
In fact, ontologies form the backbone of the Semantic Web and are the key to enable automated interoperation and collaboration.
An ontology typically consists of a number of classes, a number of relations (sometimes called properties) between these classes, a number of instances and a number of axioms.
These elements are all expressed using some logical language.
In order to allow sharing and reuse of ontologies on the Semantic Web, a common ontology language is required.
The W3C has developed two ontology languages for use on the Semantic Web.
The  rst is RDFS [3], which was developed as a lightweight ontology language.
The second language is OWL [7], which is a more expressive ontology language based on Description Logics [1].
OWL consists of three species, namely OWL Lite, OWL DL and OWL Full, which are intended to be layered according to increasing expressiveness.
OWL Lite is a notational variant of the Description Logic SHIF (D); OWL DL is a notational variant of the Description logic SHOIN (D) [17].
It turns out that OWL DL adds very little in expressiveness to OWL Lite [19].
OWL Lite and OWL DL pose several restrictions on the use of RDF and rede ne the semantics of the RDFS primitives; thus, OWL Lite and OWL DL are not properly layered on top of RDFS.
The most expressive species of OWL, OWL Full, layers on top of both RDFS and OWL DL, and because these languages are so di erent, the semantics of OWL Full are not straightforward and are not a proper extension of the OWL DL semantics (see also Section 4.1).
The lack of proper layering between RDFS and the less expressive species of OWL and the lack of proper layering between OWL DL and OWL Lite on the one side and OWL Full on the other, raises doubts about interoperability between ontologies written in these di erent languages.
For computing professionals from the areas of Software Engineering and Database Systems, there are some modeling pitfalls in OWL (see also [5]):   Behavior of cardinality restrictions (the allowed number of values for a property): equality between individuals or existence of individuals outside the knowledge base can be inferred.
The cardinality of properties is not checked, but inferred.
  Behavior of range restrictions: the type of property values can be inferred.
The type of property values is not checked, but inferred.
Some of these potential pitfalls can be eliminated by introducing the unique name assumption and asserting complete knowledge about certain descriptions.
The unique name assumption can be introduced in a Description Logic knowledge base by asserting inequality between each distinct pair of individual names.
OWL DL o ers the allDi erent operator for this purpose.
For modeling complete knowledge, the Description Logic community o ers the epistemic operator K [9].
When using the K operator as a pre x to a description, the description represents complete knowledge about the description, i.e., the knowledge base is assumed to contain all instances of this description.
In this paper we are not concerned with possible extensions of OWL or with the use of explicit assertions in order to enforce certain behavior of the modeling primitives.
We are concerned with OWL DL as it is and with the modeling constructs provided by the language.
In order to assert the unique name assumption in an OWL DL knowledge base, it is necessary to include all individuals in the knowledge base in the allDi erent statement.
This is not feasible in practice.
Clearly, OWL could be extended with a construct with the implicit meaning that all individuals are di erent and OWL could also be extended with a construct which asserts complete knowledge for a certain description.
However, we examine in this paper the OWL language as it is and the properties of the OWL modeling constructs as they are being used today.
In order to investigate these modeling pitfalls of OWL and the usability of OWL for modeling and reasoning on the Semantic Web, we describe in this paper OWL Flight [6], an ontology language based on the Logic Programming subset of OWL [5] which is inspired by the intersection of Logic Programming and Description Logic [12] with certain extensions in the area of datatypes [26], database-style constraints and meta-modeling.
Our two main motivations for creating OWL Flight were: (1) eliminate some of the pitfalls in conceptual modeling with OWL and (2) enable e cient query answering using common o -the-shelf reasoning engines which bene t from many years of research on optimizing query answering for deductive databases (e.g.
[28]).
This paper is further structured as follows.
We  rst discuss the formal and conceptual di erences between restrictions and constraints in Section 2.
Then, we brie y describe OWL DL and pitfalls in the use of this language for the Semantic Web in Sections 3 and 4, followed by the introduction of OWL Flight in Section 5.
We analyze the conceptual modeling features of OWL DL and OWL Flight in the light of potential modeling tasks on the Semantic Web in Section 6.
We contrast the reasoning tasks supported by the languages and the use cases for these reasoning tasks in Section 7.
Finally, we provide some conclusions and mention future work in Section 8.
In order to provide a better understanding of modeling and reasoning with di erent types of languages, we describe the di erence between restrictions and constraints.
The terms restriction and constraint both refer to some aspects of a property, such as the cardinality or the range of the property.
We describe the di erences  rst from a formal logical point of view and then from a conceptual modeling point of view.
For the purposes of our formal treatment of restrictions and constraints, we see an ontology as a logical theory where class de nitions, property de nitions, etc., are formulae in the theory.
From a logical point of view, a restriction applied to a class de nition can be seen as a  rst-order formula.
Thus, a restriction restricts the number of models of a logical theory.
Restrictions are thus an integral part of the logical theory.
For an ontology   and a restriction r, let M   be the set of models of   and M  r be the set of models of     r, then M     M  r.
Let cons( ) be the set of consequences of   and cons(    r) be the set of consequences of     r, then cons( )   cons( r).
Thus, restrictions allow to infer additional information, because they increase the number of consequences.
Constraints1 specify conditions which may not be violated by an interpretation of the logical theory.
Constraints are not part of the logical theory and thus they do not increase the number of consequences of the theory.
For ontology   and constraint c, if   (cid:54)|= c we say that the constraint is violated.
However, since we don t see c as part of the theory, it does not a ect the set of consequences.
In summary, constraints do not allow to infer additional information, instead, they can be used to check the knowledge base with respect to certain conditions.
From a modeling point of view, restrictions and constraints are both used to specify certain aspects of a property, namely cardinality and range.
The cardinality of a property is the number of values a particular property may have for a particular individual.
It is possible to specify a minimal bound and a maximal bound on the cardinality which we will refer to as minimal and maximal cardinality, respectively.
Both minimal and maximal cardinality can be an arbitrary positive integer.
Say we have a property P and an individual a.
In case P has a minimal cardinality restriction of n, and the number of values of P for a in the knowledge base is smaller than n, a number of unknown individuals is inferred to exist outside of the knowledge base.
In case P has a maximal cardinality restriction of n, and there are more than n values of P for a in the knowledge base, equality between property values is inferred in order to make the knowledge  t the restriction.
As for a minimal (or maximal, respectively) cardinality constraint of n on P , whenever the number of di erent values of P for a derivable from the knowledge base is smaller (or greater, respectively) than n, the constraint is violated and thus the knowledge base is erroneous.
The range of a property is the type a property value may have.
Say we have a property P with a range restriction C and a tuple (cid:104)a, b(cid:105)   P .
In case it is not known that b is of type C, it is inferred that b is of type C. In contrast, if P would have a range constraint C, then from the fact that it
 tegrity constraints in logic programming and databases.
is not known that b is of type C, the constraint is violated and the knowledge base is inconsistent.
In this paper we are mainly concerned with the most well-known and most investigated species of OWL, namely OWL DL, which can be seen as an alternate notation for the Description Logic language SHOIN (D) [17].
OWL DL has di erent syntaxes, the most prominent being the RDF/XML syntax, which is actually used in the language reference.
However, the normative syntax for OWL DL is the abstract syntax, described in [27], which we will use for the examples in the remainder of this paper for reasons of legibility.
In the remainder of this section we will explain OWL DL using Description Logic syntax.
See Tables 1 and 2 for a mapping between the OWL DL abstract syntax and the syntax of the Description Logic SHOIN (D).
OWL Abstract Syntax Class axioms Class(A partial C1 ... Cn) Class(A complete C1 ... Cn) EnumeratedClass(A o1 ... on) SubClassOf(C1 C2) EquivalentClasses(C1 ... Cn) DisjointClasses(C1 ... Cn) Property axioms DL syntax A (cid:118) Ci A   C1(cid:117).
.
.
(cid:117)Cn A   {o1, .
.
.
on} C1 (cid:118) C2 C1   .
.
.
  Cn Ci (cid:117) Cj (cid:118)   R (cid:118) Ri (cid:62) (cid:118)  R .Ci (cid:62) (cid:118)  R.Ci
  

 (cid:62) (cid:118)(cid:54) 1R (cid:62) (cid:118)(cid:54) 1R  Trans(R) ObjectProperty(R super(R1)...super(Rn) domain(C1) ... domain(Cn) range(C1) ... range(Cn) [inverseOf(R0)] [Symmetric] [Functional] [InverseFunctional] [Transitive]) Datatype(T ) DatatypeProperty(U super(U1)...super(Un) domain(C1) ... domain(Cn) range(T1) ... range(Tn) [Functional]) SubPropertyOf(Q1 Q2) EquivalentProperties(Q1 ... Qn) Q1   .
.
.
  Qn U (cid:118) Ui (cid:62) (cid:118)  U .Ci (cid:62) (cid:118)  U.Ti (cid:62) (cid:118)(cid:54) 1U Q1 (cid:118) Q2 Individual assertions Individual(o type(C1) ... type(Cn) value(R1 o1) ... value(Rm om) value(U1 t1) ... value(Un tn)) SameIndividual(o1 ... on) DifferentIndividuals(o1 ... on) o   Ci (cid:104)o, oi(cid:105)   Qi (cid:104)o, ti(cid:105)   Ui o1 = .
.
.
= on oi (cid:54)= oj, i (cid:54)= j Table 1: Axioms in OWL DL and SHOIN (D) A Description Logic knowledge base consists of two parts, namely the TBox and the ABox.
The TBox consists of a number of class and property axioms; the ABox consists of a number of individual assertions (see Table 1).
Here, C refers to a description, T refers to a concrete datatype; D refers to either a description or a datatype.
R refers to an object property name, U refers to datatype property; Q refers to an object or datatype property where several appearances of Qi, Qj in one statement always refer to either both object or both datatype properties; o and t refer to object and concrete values, respectively.
A class axiom in the TBox consists of two class descriptions, separated with the GCI (General Class Inclusion, or subsumption; (cid:118)) symbol or the equivalence symbol ( ), which is equivalent to GCI in both direction (i.e. (cid:118) and (cid:119)).
Similarly, a property axiom consists of two property names, separated with the subsumption ((cid:118)) or the equivalence ( ) symbol.
A description in the TBox is either a named class (A), an enumeration ({o1, .
.
.
on}), a property restriction ( R.D,  R.D,  R.o, (cid:62) nR, (cid:54) nR, analogously for datatype property restrictions), or an intersection (C (cid:117) D), union (C (cid:116) D) or complement ( C) of such descriptions (Table 2).
Individual assertions in the ABox are either class membership (o   Ci), property value ((cid:104)o1, o2(cid:105)   Ri, (cid:104)o1, t1(cid:105)   Ui), or individual (in)equality (o1 = o2, o1 (cid:54)= o2) assertions (Table 1).
OWL Abstract Syntax DL syntax A (URI Reference)
 (cid:62) owl:Thing   owl:Nothing C1 (cid:117) .
.
.
(cid:117) Cn intersectionOf(C1 ... Cn) C1 (cid:116) .
.
.
(cid:116) Cn unionOf(C1 ... Cn)
 complementOf(C) {o1, .
.
.
on} oneOf(o1 ... on)
 restriction(R someValuesFrom(C))
 restriction(R allValuesFrom(C))  R.o restriction(R value(o)) restriction(R minCardinality(n)) (cid:62) nR restriction(R maxCardinality(n)) (cid:54) nR
 restriction(U someValuesFrom(T ))
 restriction(U allValuesFrom(T ))  U.t restriction(U value(t)) restriction(U minCardinality(n)) (cid:62) nU restriction(U maxCardinality(n)) (cid:54) nU Table 2: Descriptions in OWL DL and SHOIN Description Logics have a set-based model-theoretic semantics.
In an interpretation I, a description C (Table 2) is mapped to a subset of the domain  I and an individual o is mapped to an object of  I using the mapping function  I.
Similarly, a datatype T is mapped to a subset of the concrete domain  I D and a literal is mapped to a value in  I D. An abstract role R is mapped to a binary relation over the abstract domain domain:  I    I.
Similarly, a concrete role R is mapped to a binary relation between the abstract and the concrete domain:  I    I D. Equivalence of descriptions is interpreted as set equivalence (C   D is interpreted as CI = DI), subsumption is interpreted as set inclusion (C (cid:118) D is interpreted as CI   DI), and so on.
We refer the interested reader to [1, Chapter 2] for a more exhaustive treatment of Description Logic semantics.
There exist several implementations for reasoning with Description Logics (e.g.
FaCT++ [30], RACER [13]) which implement di erent reasoning tasks in Description Logic languages.
Two important reasoning tasks in Description Log-ics are subsumption checking and checking class membership [1].
Subsumption checking amounts to checking whether one class is a subclass of another concept, i.e., checking whether one concept is more speci c than another concept.
The class membership inference is used to check whether an individual is a member of a speci c class.
In this section we describe a number of (potential) pitfalls of OWL with respect to interoperability on the Semantic Web and scalability of reasoning with the language.
Furthermore, we discuss the suitability of its modeling constructs and modeling style for certain domains and extensibility of the language in the direction of rules.
Problems of interoperability might occur between RDFS and OWL and between the species of OWL because of problems in the layering of the languages.
The OWL language is layered on top of RDFS.
However, only the most expressive species of OWL, namely OWL Full, is completely syntactically and semantically layered on top of RDFS.
The less expressive species of OWL, namely OWL Lite and OWL DL, pose syntactical restrictions on the use of RDF and rede ne the semantics of the RDFS modeling primitives.
The species of OWL are layered according to increasing expressiveness, where OWL Lite is the least expressive and OWL Full the most expressive.
On the one hand, OWL Lite poses many syntactical restrictions on the constructs which can be used in ontology modeling.
On the other hand, the only feature really added by OWL DL compared with OWL Lite is the use of nominals (individuals in class descriptions) [19]; all other features of OWL DL can be written down using OWL Lite through complicated syntactical constructions.
The third, and most expressive, species of OWL, namely OWL Full, is unfortunately not properly semantically layered on top of OWL DL; entailment under OWL DL semantics is not equivalent to entailment under OWL Full semantics for the same ontology: OWL Full allows additional inferences.
This discrepancy is caused by the incompatibility between the model-theoretic semantics of OWL DL and the axiomatic semantics of and syntactical freedom of RDFS.
This raises doubts about the level of interoperability between the di erent species of OWL.
Both the layering of OWL on top of RDFS and the layering of the OWL species (especially the layering of OWL Full on top of OWL DL) is, in our opinion, inappropriate.
The two less expressive species of OWL, OWL Lite and OWL DL, are only layered on top of a restricted subset of RDFS, whereas the most expressive species of OWL, OWL Full, is completely syntactically and semantically layering on top of RDFS, but not on top of OWL Lite and OWL DL.
This improper layering might hamper interoperability between agents using RDFS or OWL Full on the one side and agents using OWL Lite or OWL DL on the other.
There are doubts with respect to the scalability of certain reasoning tasks in OWL, mostly query answering.
Description Logic reasoning and optimization has so far mostly focused on the optimization of the subsumption inference; few optimizations exist for query answering.
Optimizing query answering for Description Logics is currently still very much a research issue [12, 22, 14, 16].
The satis ability problem in SHOIN , the Description Logic underlying OWL DL, has NExpTime (non-deterministic exponential time) worst-case complexity.
Most current Description Logic implementations use complex Tableaux sat-is ability checks for query answering [21].
The major problem with using Tableaux for query answering for knowledge bases with more than a few individuals is that a Tableaux check is required for each individual in the knowledge base to check whether it is in the answer to the query.
Although there exist several optimizations [14, 16], the fundamental problems are not solved.
In our opinion it is a mistake to require such complex reasoning for even the least expressive of the OWL species, since e cient ABox reasoning will most likely play a major role on the Semantic Web.
There are currently over four billion web pages indexed by Google, thus, in order for the Semantic Web to work outside of the research lab, it must be possible to reason with large collections of instances.
Some of the modeling constructs of OWL DL have a semantics which might seem odd to people not familiar with Description Logics.
These constructs concern the treatment of abstract vs. concrete values, cardinality restrictions, and value restrictions.
Furthermore, we identify limitations in the support for datatypes in OWL.
Difference in the treatment of abstract and concrete values.
The interpretation of literals (concrete values) in OWL is  xed and thus unknown equality between literals can not be derived.
Consequently, cardinality and range restrictions exhibit di erent behavior depending on whether they are concerned with object or datatype properties.
Restrictions over object properties exhibit the usual behavior of restriction as we have described in Section 2.
Restrictions over datatype properties, however, exhibit the behavior of constraints as described in Section 2.
It has been argued that the di erence in treatment of individuals and literals makes sense, because the domain of a data type is known.
We argue that from the point of view of the user of the language, this conceptual distinction is not intuitive.
Whereas restrictions involving the abstract domain are used to infer new knowledge, restrictions involving the concrete domain are used to check whether the knowledge satis es certain constraints.
Deriving Equality through Cardinality Restrictions.
In OWL, it is possible to specify a maximal cardinality restriction for a property.
When there are more instances of this property with the same domain value than the maximal car-dinality restriction prescribes, equality between individuals is inferred.
We illustrate this with an example.
Example 1.
Assume the following OWL DL knowledge base: ObjectProperty(hasPassenger domain(FlightSeat) range(Passenger)) Class(FlightSeat partial restriction(hasPassenger maxCardinality(1))) Individual(seat1 type(FlightSeat) value(hasPassenger mary) value(hasPassenger john)) FlightSeat represents the seats in a particular  ight.
The property hasPassenger associates a seat in a  ight with a passenger.
A seat may only have one passenger, which is guaranteed by the restriction maxCardinality(1).
The individual seat1 an instance of FlightSeat; seat1 has two values for the property hasPassenger, namely mary and john.
From the OWL knowledge base in Example 1 the reasoner will draw the conclusion that mary and john both refer to the same passenger.
The possibility that there was a mistake in the system (either at the ontology or at the instance level) is not taken into account.
This could lead to the booking of several passengers on a single seat, unless the unique name assumption is enforced.
Deriving Class Membership through Value Restrictions.
In OWL it is possible to restrict the range of a property P to a class description C either through a range restriction in the property de nition or through a local universal range restriction in a class de nition.
From this restriction it is inferred that every value of this property is a member of class C.
Example 2.
We take the OWL knowledge base from Example 1 and add the following assertions: Individual(seat3 type(FlightSeat)) Individual(seat2 type(FlightSeat) value(hasPassenger seat3)) The above assertions introduce two new instances of the class FlightSeat by the names of seat2 and seat3 plus a value for the property hasPassenger at seat3, namely seat3.
From Example 2 we can infer that seat3 is a Passenger.
Clearly, there is some mistake in the individual assertions, because a seat cannot occupy another seat; only a passenger can.
However, this mistake is not detected; instead the modeling mistake allows for additional (incorrect) inferences.
Although it is possible in OWL DL to express disjointness of classes, in which case an inconsistency would be derived, we argue that in many application domains it is natural to assume disjointness of classes beforehand and only deviate from this assumption when classes are known not to be disjoint.
Limited Support for Datatypes.
OWL allows for a limited treatment of datatypes.
Only unary datatypes are supported by OWL.
The three major limitations of datatype support in OWL are [26]: (1) lack of negated datatypes, which is required for most Description Logic reasoners, (2) lack of support for datatype predicates; it is only possible to refer to a single value in a datatype domain and not, e.g., to express the greater-than ( ) relation for the xsd:integer domain, and (3) lack of support for user-de ned datatypes.
OWL-E [26] is an extension of OWL with so-called datatype groups.
Datatype groups overcome the aforementioned limitations of datatype support in OWL and bridge the gap between datatypes in OWL and concrete domains as they have been investigated in the Description Logic community (see e.g.
[20]).
It has been suggested that besides an ontology language, the Semantic Web needs a rule language.
Such a rule language would provide additional expressiveness on top of the ontology language.
It was identi ed as a requirement that the rule language is an extension of the ontology language.
There have been several proposals for rule extensions of Description Logic languages (e.g., CARIN [24] and SWRL [18]).
SWRL (Semantic Web Rule Language) has been proposed as a rule language for the Semantic Web, layered on top of OWL DL.
Satis ability of an OWL DL knowledge base augmented with SWRL rules is undecidable, as was pointed out by the authors of the proposal [18].
Straightforward extension of Description Logics with rules leads to undecidability [24] and does not allow the use of existing rule systems to reason with the language.
Instead, complex new calculi need to be developed, or  rst-order theorem proving is required.
As opposed to OWL DL, in this section we will de ne a novel variant of OWL, called OWL Flight, which addresses some of the above-mentioned problems.
On the one hand, OWL Flight restricts the OWL syntax such that it falls in the Datalog fragment and thus query answering can be done using a Logic Programming implementation (cf.
[12]).
On the other hand, we take this restricted subset of OWL DL as a basis which we further extend in order to overcome some of the limitations of OWL DL.
These extensions include integrity constraints, a more elaborate treatment of datatypes than OWL based on OWL-E [26], and meta-modeling features where we make use of the meta-modeling features of the Datalog compatible variant of F-Logic [23].
The formalism underlying OWL Flight is DatalogIC,(cid:54)=,not, which is Datalog extended with integrity constraints, inequality and default negation.
OWL Flight is an extension of the so-called DLP fragment of OWL which marks the intersection of Description Logics and Datalog [12, 5].
Compared to DLP, we further add limited support for nominals, as well as a meta-modeling facility (e.g., treating classes as instances) and constraints.
Features of OWL DL not included in OWL Flight are: enumerated classes, individual (in)equality assertions, complements, property restrictions in complete class de nitions.
Furthermore, we restrict the use of property restrictions, nominals, and union on the left and right-hand-side of the
 OWL Flight adds the following distinct features to this restricted subset of OWL DL: We adopt the unique name assumption 2 and adding cardinality constraints, i.e., checking cardinalities rather than the non-intuitive inference of equality.
Property value constraints eliminate the non-intuitive inferring of class membership.
Constraints adopt the closed world assumption, allowing to check the data in the knowledge base, i.e. a single ontology (along with imported on-tologies); as mentioned above, this feature is useful in many contexts and missing in OWL DL (cf.
[15, 9]).
Meta-modeling returns modeling support lost in the transition from RDFS to OWL DL.
More elaborate treatment of datatypes, following OWL-E [26], which overcomes the limitations of the treatment of datatypes in OWL.
Mapping to F-Logic Syntactically, we base OWL Flight on a subset of the abstract syntax of OWL DL, but add distinct constructs
 RACER assumes unique names, not implementing equality reasoning, for e ciency reasons.
As pointed out above, we do not necessarily see the lack of equality reasoning as a drawback but even as an advantage, due to unintuitive e ects it might have with respect to reasoning in OWL DL.
for constraints and eliminate the separation of the vocabulary.
Table 3 shows a feature comparison of OWL DL and OWL Flight based on an extended version of the OWL abstract syntax.
The meaning of the letters in the table corresponds with the description given in Section 3; furthermore, E stands for a datatype predicate and n stands for the arity of the datatype predicate.
The terms lhs (and rhs, resp.)
in the table express that certain descriptions in OWL Flight are restricted to be used in the left-hand side (or right-hand side, resp.).
Descriptions allowed on the right-hand side are allowed in partial class de nitions and in the second argument of SubClassOf.
Descriptions allowed on the left-hand side are allowed in the  rst argument of SubClassOf.
Descriptions allowed on both sides are also allowed in complete class de nitions.
On the one hand, unrestricted usage of these features would lead us outside the expressivity of DatalogIC,(cid:54)=,not.
On the other hand, some of the unintuitive features of OWL DL like inferring equality originate precisely from this unrestricted usage.
In the lower part of Table 3 we  nd the features newly added in OWL Flight, which are constraints in partial class de n-itions and Datatype expressions.
As described in Section 2, constraints check all inferred instances of the respective class on the lhs for the condition on the rhs.
Datatype expressions follow the idea of [26], which allows to de ne nary datatype predicates which constrain the values of the tuples given by datatype properties U1, .
.
.
, Un of an object.
So, with this extension, one can express relations between datatype properties, for instance that the number of bookings for a hotel room has to be smaller than its capacity, etc.
Note that constraints are only allowed for object properties, because for datatype properties the restriction keyword in OWL DL already has a constraining semantics as discussed in Section 4.
For the sake of brevity, we refer to [6] for a complete description of the abstract syntax of OWL Flight.
We de ne the semantics of OWL Flight through a mapping to the Datalog subset of F-Logic [23].
By doing so, we gain the following bene ts: Staying within the Datalog world, we can directly use implemented engines tailored for e cient query answering.
F-Logic syntax with its origins in Frame based modeling (as opposed to pure Datalog) directly allows for meta-modeling features and provides constructs for class membership, subclassing and attributes in the language, rather than relying on predicates to axiomatize the behavior of these constructs.
The complete mapping is de- ned in [6] and we restrict ourselves to the rough idea in this paper.
Let x, y, z be variables, : stands for class membership, :: stands for the subclass relationship and a molecule of the form A[B C] stands for  object A has an attribute B with value C .
Such molecules can be combined, for instance r1 : Room[hasBooked 2], stating that r1 is an instance of the concept Room, having the value 2 for attribute hasBooked.
Over such molecules we de ne clauses of the form m   m1, .
.
.
, mn with the usual meaning from logic programming, where the body molecules of such rule may be preceded by the negation as failure symbol not.
Furthermore we allow modules of the form x (cid:54)= y, representing inequality, in the body of such clauses.
Variables in F-Logic might be used for any kind Abstract Syntax DL Fl.
Axioms and Individual Assertions Class(A partial C1 ... Cn) Class(A complete C1 ... Cn) EnumeratedClass(A o1 ... on) SubClassOf(C1 C2) EquivalentClasses(C1 ... Cn) DisjointClasses(C1 ... Cn) ObjectProperty(R ...) Datatype(T ) DatatypeProperty(U .
.
. )
SubPropertyOf(Q1 Q2) EquivalentProperties(Q1 ... Qn) Individual(o type(C1) ... type(Cn) value(R1 o1) ... value(Rn on)) SameIndividual(o1 ... on) DifferentIndividuals(o1 ... on) Descriptions A (URI Reference) owl:Thing owl:Nothing intersectionOf(C1 ... Cn) unionOf(C1 ... Cn) complementOf(C) oneOf(o1 ... on) restriction(Q someValuesFrom(D) ) restriction(Q allValuesFrom(D)) restriction(Q value(o) restriction(Q minCardinality(n)) restriction(Q maxCardinality(n)) constraint(R someValuesFrom(C)) constraint(R allValuesFrom(C)) constraint(R value(o)) constraint(R minCardinality(n)) constraint(R maxCardinality(n)) + + + + + + + + + + + + + + + + + + + + + + + + + + +           + +   + + + + + + + + + +     + + + + lhs   lhs lhs rhs +   rhs rhs rhs rhs rhs rhs Datatype Expressions and nary Datatype constraints DatatypeExpression (E/n   and/or/domain( E1/n ...Em/n) )   restriction(U1...Un someValuesFrom(E/n)) restriction(U1...Un allValuesFrom(E/n))     would be super uous because OWL Flight adopts UNA + lhs rhs Table 3: Features of OWL DL vs. OWL Flight of objects, individuals, concepts or even attributes, allowing meta-modeling with sets of such clauses (i.e., F-Logic Programs).
There exist e cient engines, such as Ontobroker [8] and FLORA-2 [32], for evaluating these kinds of programs.
Both implementations use a translation to plain Datalog in order to evaluate the program using a plain Datalog engine.
We will illustrate the mapping from OWL Flight to F-Logic with some small examples.
Simple subclass axioms or partial class de nitions for named classes, i.e., statements of the form Class(A partial C1 ... Cn) are translated to sets of statements of the form:(cid:94) A :: Ci Nested property restrictions in Ci can be handled by chaining variables, e.g.
Class(A partial restriction(R allvaluesFrom (restriction S allValuesFrom B))) is translated to: z : B   x : A, x[R y], y[S z] We translate constraints to integrity constraints, i.e., clauses with an empty head, and involve negation as failure for checking integrity on the knowledge base.
So, e.g.
Class(A partial constraint(R allValuesFrom(C))) will result in   x : A[R y], not y : C The complete translation [6] involves some particularities, but it allows us to translate all of OWL Flight to function-free F-Logic programs with integrity constraints and default negation, i.e. the DatalogIC,(cid:54)=,not fragment of F-Logic.
The Datatype-Expression facilities of OWL-E  t nicely in this translation.
Summarizing, OWL Flight on the one hand uses a maximal subset of OWL DL which is compatible with the logic programming world and on the other hand de nes slight extensions addressing some of the limitations identi ed in Section 4.
Although this new OWL  dialect  can not to be viewed as a fully edged ontology language to solve all the above-mentioned problems, we conceive it as a solid starting point for a uni ed framework of OWL based ontology languages combining the bene ts of the Description Logics and Logic Programming paradigms.
Furthermore, it serves as a good starting point to investigate the limitations of OWL and ways to overcome its limitations.
In this section we compare the modeling constructs of OWL Flight and OWL DL in the context of modeling tasks on the Semantic Web.
OWL DL has the notion of cardinality restrictions, which can be used in class de nitions.
Cardinality restrictions allow for inferring equality and/or the existence of individuals not in the knowledge (see also Section 2).
OWL Flight has an explicit notion of cardinality constraints, which are used to check the number of values for a certain property, rather than to derive equality or assume existence of individuals beyond the knowledge base.
Besides the possible non-intuitiveness of deriving equality (see also Section 4.3), we see the following pitfall for a language which allows to infer equality: The possibility to derive equality might be misleading, because not all equality on the Semantic Web can be resolved in the logical language.
Equality reasoning in OWL DL is not powerful enough to resolve all equalities between identi ers on the Semantic Web.
Only if the world would be perfectly and completely modeled in an ontology and only if all individuals on the Semantic Web are related to this ontology could all equalities on the Semantic Web be resolved.
We argue that very few equalities can actually be resolved with reasoning and that many derived equalities are actually faulty.
Thus, it makes more sense in our opinion to either resolve equalities beyond the logical language or to make strong assumptions on the available knowledge, i.e., assume that each identi er in the knowledge base uniquely identi es an individual (the unique name assumption).
OWL allows for two kinds of value restrictions, namely, existential and universal.
However, an existential value restriction merely corresponds to a quali ed minimal cardinal-ity of 1.
Therefore, and because we have already discussed cardinality restrictions in the previous section, we only treat universal value restrictions here.
When used in a class de nitions, a value restriction over an object property can be used to derive additional information about property values with members of this class as its domain (see also Section 4.3).
OWL Flight allows for the speci cation of value constraints.
A constraint is used to check whether the knowledge in the knowledge base conforms to the constraint.
Take for example the following de nition: Class(Parent partial constraint(hasChild allValuesFrom Person) This constraint does not allow any child which is not known to be a person.
We argue that the constraining approach is more intuitive to many computing professionals with Software Engineering and Database Systems backgrounds [5].
However, constraints do not allow additional inferences.
Therefore, there is a tradeo  between the ability to detect modeling mistakes and the inferencing power of the language.
OWL DL focuses more on the inferencing power of the language, whereas OWL Flight focuses more on catching modeling mistakes.
We have pointed out in Section 4.3 that in OWL DL there is an asymmetry between the treatment of datatype and abstract individuals.
From a modeling point of view, this asymmetry is most apparent in the way property restrictions and range restrictions of datatype properties are handled, as we have argued in Section 4.3.
Consider the following OWL DL knowledge base: Class(A partial restriction(Q allValuesFrom D)) Individual(a value(Q b)) Say, Q is an object property and D is an abstract class description.
By the universal value restriction, we can infer that b is an instance of D.
Now suppose Q is a datatype property and D is a datatype.
From this knowledge base, we cannot conclude that b is a data value of type D, and thus the knowledge base is inconsistent.
This asymmetry between the treatment of object and datatype properties does not occur in OWL Flight, because it allows to model constraints for object properties which are treated in the same way as constraints for datatype properties.
Meta-modeling is based on the principle that the same object can be seen as a class, an individual or a property, depending on the point of view.
An example taken from [29] is the object  Boeing747  which is an instance of the class  AircraftType  but is itself also a class whose instances are the individual aircraft.
Another example [25] is the description of the topics of individual books.
Each topic is a class and each book is an individual.
This obviates the need to use classes as property values.
Because of the heterogeneity to be expected on the Semantic Web, a conceptual modeling language for the Semantic Web should support meta-modeling.
RDFS and OWL Full allow full meta-modeling.
Each identi er can denote a class, instance and/or property.
Unfortunately, RDFS is not expressive enough for many applications and OWL Full is undecidable in general.
The decidable species of OWL, namely OWL Lite and OWL DL, unfortunately do not allow meta-modeling.
Instead, they require a strict separation between identi ers of classes, individuals and properties.
In the case of a strict separation between classes and instances, it is sometimes hard to  nd an agreement as to whether to model an object as a class or an instance.
Since an ontology is shared by its very nature, it is important to  nd this agreement.
In case inter-operation is required between di erent ontologies, this requirement becomes even more apparent, because the modelers of the di erent ontolo-gies might have di erent notions of what is an instance and what is a class.
OWL Flight allows meta-modeling while retaining decid-ability, following the meta-modeling support of F-Logic [23], which allows a limited form of meta-modeling by interpreting an identi er di erently depending on the context in which it occurs.
In this way, F-Logic stays inside the expressiveness of  rst-order logic.
OWL Flight allows meta-modeling in the same way as F-Logic and by doing this, it stays inside the (decidable) Datalog fragment.
OWL allows two types of class de nitions: partial class de nitions and complete class de nitions.
A partial class de nition corresponds with a necessary de nition, thus, it speci es all conditions (such as superclasses and property restrictions) which are necessarily ful lled (and thus inferred ) for all members of the class.
A complete class de nition speci es necessary and su cient conditions, which means that not only are these conditions inferred from class membership, but class membership is also inferred if all conditions are ful lled, i.e., if an individual is a member of all superclasses and all property restrictions are ful lled.
Complete class de nitions are allowed only to a limited extent in OWL Flight: only named classes and individual value restrictions are allowed in the de nition (see also Table
 In contrast, OWL DL allows all descriptions in both partial and complete class de nitions.
To harvest the full power of Description Logic reasoning, complete class de nitions should be used, because they allow for more powerful inference than partial de nitions.
However, it is hard to model complete de nitions correctly, especially because it is easy to miss certain aspects of a class when creating the de nition, in which case the de nition is incorrectly labeled as  complete .
Thus, there is again a tradeo  between the ability to detect modeling mistakes and the inferencing power of the language.
Correct and complete modeling cannot be guaranteed in general in such an open and distributed environment as the Web.
However, in closed and controlled sections of the Semantic Web where it is possible to guarantee a certain degree of correctness of modeling, complete class de nitions can be very useful.
Complete class de nitions are related to subsumption reasoning, to be discussed in Section 7.1.
In this section we describe the primary reasoning tasks on the Semantic Web and how there are supported by OWL DL and OWL Flight.
The primary reasoning tasks we consider are subsumption and query answering.
Subsumption corresponds with checking whether a class description subsumes (is more general than) another class description.
By doing this for all classes in the knowledge base, one can compute the subsumption hierarchy.
By checking the place in the subsumption hierarchy of a given class description, this class description is classi ed with respect to the knowledge base and hidden relationships with other classes in the knowledge base become visible.
Subsumption can be reduced to checking (un)satis ability and thus, for OWL DL, an e cient Description Logic algorithm [21] can be used to compute the subsumption for any two OWL DL descriptions.
There exist several implementations for the subset of OWL DL which excludes nominals, such as RACER [13] and FaCT++ [30].
For OWL Flight, subsumption reasoning can be performed using a Description Logic reasoner for that subset of OWL Flight which falls inside OWL DL.
There are also techniques for subsumption reasoning using Logic Programming engines, again using the same fragment of OWL Flight.
These techniques [12, 31] e ectively reduce subsumption reasoning to query answering in a deductive database.
However, Description Logic reasoners are in general more e cient for subsumption reasoning (cf.
[31]).
It is not entirely clear how constraints in OWL Flight interact with subsumption reasoning.
Presumably, they should not be taken into account when doing subsumption reasoning, because constraints are not part of the logical theory (see also Section 2).
This is a matter which requires further investigation.
Subsumption reasoning allows inferring relationships between terms which have not been explicitly stated.
On the one hand, this kind of reasoning might not be easily accepted in some areas.
We believe that businesses will want control over their business vocabularies and do not want (possibly incorrect) inferred relationships between terms.
On the other hand, some areas may greatly bene t from the additional knowledge derived in subsumption reasoning.
For example, search results in Knowledge Management applications might be improved because more relevant terms are taken into account and also other applications where 100% precision is not required or where complete and correct modeling can be assumed and where mistakes introduced through inferences can be tolerated can bene t greatly from classi cation reasoning.
There is a tradeo  between the possibilities for automation on the one hand and the requirements on the completeness and correctness of the modeling on the other hand.
If one wants to automate certain tasks on the Semantic Web, such as Web Service execution, then correct and complete modeling of goals and web services is required.
If one cannot assume correct and complete modeling of the functionality of a web service, then it is impossible to automate execution.
Figure 1: OWL DL and OWL Flight: conceptual modeling and reasoning
 There exist two di erent types of queries, namely, ground queries and open queries.
A ground query consists of a knowledge base and a ground fact.
The inference task is to check whether the ground fact is entailed by the knowledge base.
An open query is a formula with free variables.
The query answer consists of a number of substitutions for the variables with values from the knowledge base.
An open query can be reduced to a number of ground queries, namely, a ground query for each of the facts in the knowledge base.
This is clearly not e cient and thus optimizations have been (and are being) developed for answering such open queries.
As we can see from Section 7.1, the main power of Description Logics lies in subsumption reasoning.
Query answering reasoning is also possible, but is in general less investigated and very few optimizations exist to do query answering e -ciently in Description Logics, as we have argued in Section
 OWL Flight was developed with e cient query answering using deductive databases in mind.
Thus, common o -the-shelf deductive database engines (e.g.
OntoBroker [8], FLORA-2 [32]) can be used for reasoning with OWL Flight.
These deductive databases incorporate optimizations which have been developed in the database research area.
Summarizing, we can say that the expressive power, the modeling constructs and the current state-of-the-art reasoners for Description Logics (and thus OWL DL) are tuned to powerful subsumption reasoning.
The expressive power of OWL Flight takes into account current state-of-the-art deductive databases and thus allows to take advantage of e -cient query answering.
OWL DL has signi cantly more expressive power than OWL Flight, because of disjunction and existential quanti cation allowed in the language.
Therefore, even if optimizations for query answering with Description Logics are developed, these implementations cannot get around the theoretical complexity of the reasoning task.
In this paper we have introduced OWL Flight, a variant of OWL which is based on Logic Programming rather than Description Logics.
We took Description Logic Programs [12] (the intersection of Description Logics and Logic Programming) as a basis and extended it with cardinality and value constraints, meta-modeling and powerful datatype support (based on OWL-E [26]).
We have compared the modeling styles for OWL DL and OWL Flight, as well as the reasoning tasks supported by both languages.
We summarize the modeling styles and reasoning tasks for both languages in Figure 1.
With respect to the modeling styles we can conclude that OWL DL has an inferring modeling style.
Restrictions on property values and cardinalities are used by the reasoner to infer new knowledge from the existing knowledge, such as equality of individuals and class membership.
OWL Flight has a constraining modeling style; it allows expressing cardi-nality and values constraints on properties.
Such constraints are used by the reasoner to check whether the knowledge in the knowledge base corresponds with the conditions expressed in the constraints.
With respect to the supported reasoning tasks, we can conclude that OWL DL is most suited for the subsumption task and OWL Flight is most suited for the query answering task, because of the modeling styles of the languages and because of the optimized algorithms and implementations which have been developed for the respective modeling tasks.
There exists a tradeo  between the inferencing power of a language and the ability to detect modeling mistakes.
We can conclude that di erent tasks on the Semantic Web need di erent styles of modeling and di erent types of reasoning.
Therefore, we argue that it is not su cient to restrict the Semantic Web to only one style of modeling for ontologies, which is currently done by OWL, in the form of Description Logics.
Many applications on the Semantic Web would bene t from an ontology language which favors a constraining modeling style, such as OWL Flight.
Furthermore, such a language might appeal more to software engineers and database designers, so that they more easily adopt the Semantic Web.
Interoperation between Description Logic-based and Logic Programming-based languages can be achieved either through their common subset [12], through an interface between the languages [10] or through a common superset.
Such a common superset is not easy to de ne, because the default negation common in logic programming does not  t nicely in a  rst-order framework.
Nonmonotonic extensions such as the K operator [9] could help bridge the gap.
We argue that the Semantic Web requires a unifying framework for the Logic Programming and the Description Logic paradigm.
Such a unifying framework would consist of a core language, based on [12], which is the common subset of both paradigm.
The framework should have extensions in both the Logic Programming and the Description Logic directions to allow applications on the Semantic Web to take advantage of existing algorithms and implementations.
The languages would then be uni ed in a language which captures both paradigms.
This unifying language could be a  rst-order language with nonmonotonic extensions in order to capture the nonmonotonicity of negation in Logic Programming.
We are currently in the process of developing such a framework in the context of the WSML Working Group [4].
Conceptual ModelingReasoning tasksOWL DLOWL FlightQuery Answering under-developedEfficient subsumption for a significant part (SHIQ)Query Answering well-developed; many well-knownoptimization techniques and implementationsLimited expressiveness for classification; not optimizedConstraints check existing knowledgeRestrictions allow inferring new knowledgeComplete class descriptionsLimited complete class descriptionsModeling style of Knowledge RepresentationModeling style of Databases andSoftware EngineeringAcknowledgement This work has been supported by the European Commission under the projects DIP, Knowledge Web, InfraWebs, SEKT, SWWS, ASG and Esperonto; by the Science Foundation Ireland under the DERI-Lion project.
