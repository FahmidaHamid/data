As users are demanding more sophisticated Internet services, many web servers are emerging that generate dynamic web pages from databases/ les.
Examples include DBLP,  ight arrival/departure information sites, EPG (electric TV program guide) sites, and stock trading sites.
Such systems often use XPath/XSLT processors to transform the source XML data into (X)HTML  les even if XPath/XSLT processing is very expensive; a more e cient solution is required.
Two features characterize such dynamic web sites: 1) web pages access is more frequent than source data update.
2) Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
Takashi Honishi NTT CyberSpace Laboratories, NTT Corporation
 honishi.takashi@lab.ntt.co.jp the updated portion is, in each update operation, relatively small compared to the source data size.
For example, large numbers of users access the  ight arrival/departure information site FlightArrivals.com (http://FlightArrivals.com/) which stores a large amount of data, one day s  ight information;  ights are updated one by one when each  ight s status changes (boarding/expected arrival time/arrived).
Therefore, incremental maintenance for materialized XPath/XSLT views is a promising technique to improve web server performance.
Let s discuss below the di culty of incremental maintenance for materialized XPath and XSLT views.
XPath view maintenance An XPath expression is de ned as a sequence of location steps, each of which consists of axis, node-test and optional predicates.
The evaluation of each location step returns, from the set of context nodes in XML data, a set of nodes that satisfy the axis relation, node-test and optional predicates.
Since XPath permits the use of order-sensitive axes (e.g.
following), descendant and other axes, it has higher expression power than SQL.
The bad news of these XPath axes evaluations is that, unlike the SQL join evaluation, two nodes (records) are not su cient to evaluate the axis relation between them.
For example, consider the XPath expression //A//C and XML data <A><B><C>NTT Cyberspace Labs.</C></B></A> we name the node whose tag is A as a, B as b, and C as c.
The evaluation of the former part (//A) returns a and, using it as a context node, the evaluation of the remainder (//C) returns c. During the descendant axis evaluation of //C, we must access not only a and c but also b that connects a and c. This example suggests that SQL view maintenance techniques [11] are not directly applicable to the XPath view maintenance problem.
Here, we have somewhat good news.
The labeling scheme of [16, 1], which assigns a label to each node, enables us to evaluate all types of axis relations between nodes (e.g.
a and c in the above example) without accessing other nodes (e.g.
b).
Thus by applying the labeling scheme, the axis relation can be implemented by SQL join, so the XPath view maintenance problem is reduced to the SQL view maintenance problem as follows.
Let f be a location step evaluation function, r be a root node in source XML data, D be a set of all nodes, and lsk (1 k n) is a location step of the given XPath expression.
The XPath evaluation can then be expressed as follows.
f (lsn, f (lsn 1, ..., f (ls1, {r}, D), .., D), D) Let  d be a newly inserted set of nodes and D0 be D    d.
Since the location step evaluation function f can be implemented by SQL join with the labeling scheme, we obtain the following expression by applying a di erentiation step [11], f (lsn, f (lsn 1, ..., f (ls1, {r}, D0), .., D0), D0) =

 k.
n + 1.
f (lsn, f (lsn 1, ..., f (ls1, {r}, D), .., D), D)   f (lsn, f (lsn 1, ..., f (ls1, {r}, D), .., D),  d)   ...   f (lsn, ..., f (lsn k+2, ..., f (ls1, {r}, D), ...,  d), ..., D0)   ...   f (lsn, f (lsn 1, ..., f (ls1, {r},  d), .., D0), D0) Thus the XPath view can be maintained incrementally by applying the SQL view maintenance techniques.
Unfortunately, the above solution has two problems.
First, since it is based on the relational data model, the permitted update operations are node insertion/deletion, which does not e ciently support subtree insertion/deletion, common XML data update operations.
Second, it materializes the result of all location steps, so it consumes a huge amount of memory space.
For example, consider the following XPath expression to search for papers whose author works in Japan assuming its selectivity is very low.
//paper[author/country = "Japan"] Figure 1: An XPath example This example reveals that, even if the evaluated result of the whole XPath expression is small, the intermediate node-set, which is returned by the location step (//paper) evaluation, becomes quite large (all papers) and can be as large as the source XML data.
XSLT view maintenance The literature on the SQL view maintenance problem [11] categorizes the maintenance techniques from three viewpoints: view language, available data, and modi cation.
We consider the XSLT view problem from the same viewpoints.
In terms of view language, XSLT has higher functionality than SQL, and it can express a transformation that exhibits a loss of structural information, such as removing tags.
Consider a materialized view with a loss of structural information and an insertion operation on source XML data.
If only the source data and the materialized view are available, it is impossible to identify where to update the materialized view due to the missing structural information.
Therefore, from the available data viewpoint, the XSLT view maintenance algorithm requires auxiliary data in general.
From the mod-i cation viewpoint, we use subtree insertion/deletion, which is permitted by XUpdate [23], and by an XML update language [22].
Our concept is to achieve a space and time-e cient algorithm to incrementally maintain the materialized views of XPath/XSLT by storing auxiliary data and limiting the XPath to a practical subset XP {[], ,//,vars}.
The algorithm, namely XTim (X[ML] T[ransformation] I[ncremental] M[ain-tenance]) stores the dynamic execution  ow of an XSLT program (called XT-tree) which contains the context nodes used by the XSLT templates and a materialized view.
XTim is space-e cient because it does not store the intermediate node-sets returned by all location step evaluations.
XTim is also time-e cient because it incrementally maintains a materialized view in three steps: 1) locate the impacted parts in the XT-tree, 2) reevaluate the XSLT program partially and update the impacted parts, and 3) output the maintained materialized view in the XT-tree.
The detail of the  rst step is as follows.
An XT-tree, a dynamic execution  ow of an XSLT program, forms an interrelated XPath expression with their context nodes.
A single update operation updates a set of updated subtrees and we de ne update-path as the path from the root node to the updated subtree of the source XML data.
Then the impacted parts in the XT-tree are identi ed in a similar way as XML stream processing [7,
 expression and evaluates it on the incoming XML data.
But the di erence is 1) we identify the impacted XPath expressions in the XT-tree by evaluating the interrelated XPath expression on update-path, and 2) we must be aware of the context nodes stored in the XT-tree, because an identical XPath expression can be applied to di erent context nodes resulting in di erent XT-nodes in the XT-tree.
Our contributions are summarized as follows:   We investigate the features of XPath in XP {[], ,//} for incremental view maintenance in response to subtree insertion/deletion.
In addition, we present the condition under which XSLT expressions inherit the above XPath features and show how to handle those expressions otherwise.
  We develop an incremental view maintenance algorithm XTim based on those XPath/XSLT features.
  We discuss the extension of XTim to support the ordered data model and position predicates by applying the labeling scheme of [16, 1].
  We describe experiments on typical types of XSLT transformations and the subtree insertion of various sizes.
The results show that our algorithm signi cantly outperforms existing full transformation algorithms by factors of up to 500.
The rest of this paper is as follows.
We start by illustrating a motivational example in Section 2.
Section 3 de nes the fragment of XPath/XSLT speci cation, the XML update speci cation, and the incremental view maintenance problem.
We investigate the incremental view maintenance features of XPath/XSLT and present XTim in Section 4.
In Section 5, we discuss how to extend XTim to handle the ordered data model.
Section 6 reports experimental results.
Section 7 addresses related work and Section 8 concludes the paper.
We use the author search function at DBLP web site as our example.
Indeed the search results for authors are materialized and periodically updated (See the update date of the HTML  les in http://www.informatik.uni-trier.de/ ley/db/ indices/a-tree/a).
Fig. 2 shows a fragment of DBLP XML data (http://dblp.uni-trier.de/xml) and Fig. 3 shows an XSLT program that generates a simpli ed search result consisting of four XSLT templates.
We use only the child axis in the XPath expressions for simplicity.
The  rst template (line 1-9) outputs the given author name and constructs a table for each year in which the author published.
The second template (line 10-16) is applied for each year and outputs <dblp> <mastersthesis mdate="2002-01-03" key="ms/Brown92"> <author>Kurt P. Brown</author> <title>PRPL: A Database Workload Specification Language, v1.3.</title> <year>1992</year> <school>Univ.
of Wisconsin-Madison</school> </mastersthesis> <inproceedings mdate="2002-01-23" key="conf/b/Sekerinski98"> ...
Figure 2: DBLP XML data fragment  /  distinct( dblp/*[author=$author]/year )

  /dblp/*[author=$author][year=$year] 


  .  5
        ee 
  ee 
  author 
  title    Figure 4: XPath expressions part in XT-tree the year and applies the third template for each publication of the author in the year speci ed.
The third template (line
 umn is a link to the electric edition speci ed by ee tag, if the publication has an electric edition.
The second column contains the author list, title, URL, book title, publication year, and page number.
1:<xsl:template match="/"> 2: <html><h1><xsl:value-of select="$author"/></h1> 3: <table border="1"><tbody>
 <xsl:apply-templates select="set:distinct(dblp/*[author=$author]/year)"> <xsl:sort select="."
order="descending"/> </xsl:apply-templates>

 7: </tbody></table> 8:</html> 9:</xsl:template> 10:<xsl:template match="year"> 11: <xsl:variable name="year" select=".
"/> 12: <tr>
 14: </tr> 15: <xsl:apply-templates <th colSpan="3"><xsl:value-of select="$year"/></th> select="/dblp/*[author=$author][year=$year]" mode="p"/> 16:</xsl:template> <xsl:if test="ee"><A href="{ee}">EE</A></xsl:if> <td vAlign="top"> 17:<xsl:template match="*" mode="p"> 18: <tr>






 </td> <td> <xsl:apply-templates select="author"/>: <xsl:value-of select="title"/> <A href="http://www.informatik.uni-trier.de/ ~ley/{url}"> <xsl:value-of select="booktitle"/> <xsl:text> </xsl:text> <xsl:value-of select="year"/> </A>: <xsl:value-of select="pages"/>




 31: </tr> 32:</xsl:template> </td> 33:<xsl:template match="author"> ...
Figure 3: DBLP author.xsl Assume some conference is held and several papers are inserted under the dblp tag in DBLP XML data.
We need to update the materialized result, however the XSLT full transformation is very expensive because it requires evaluating the XSLT program from scratch.
An overview of the incremental maintenance is given below.
mation.
Fig. 4 depicts a simpli ed XT-tree showing only the interrelated XPath expression.
The gray circles correspond to XT-nodes generated from absolute XPath expressions (line 1,15 in Fig. 3).
Since the number of publications attributed to one author is around one hundred, the resulting XT-tree size is kept small.
Fig. 4), we process the interrelated XPath expression on the update-path (/dblp).
XPath expression  /  of the root XT-node matches to  /  of the update-path then we move to the child XT-node (node 2).
The  rst location step of  dblp/*[author=$author]/year  matches  dblp  of the update-path so we have reached the end of the update-path, i.e. the root node of newly inserted subtree.
The remainder part  *[author=$author]/year  is evaluated on the inserted subtree and returns a node-set of years.
Since the distinct function is used for the node-set, we construct XT-nodes for the resulting year nodes if the XT-tree doesn t store the corresponding XT-nodes.
For each of the constructed XT-nodes, we evaluate the second XSLT template and continue reevaluating the XSLT program partially.
the absolute XPath expressions, we follow the same procedure as for the root XT-node.
The  rst localtion step of /dblp/*[author=$author][year=$year] matches the update-path, so we have reached the root node of inserted subtree and the remainder part *[author=$author][year=$year] is evaluated on the inserted subtree.
We then continue reevaluating the XSLT program partially.
operation, so we output the materialized view stored in the XT-tree.
XP {[], ,//,vars} denotes the XPath fragment that permits predicate, wildcard, child and descendant axis, and variable references.
XP {[], ,//} consists of expressions given by the following grammar: P ::= P 0|0P | Pabsolute | Prelative Pabsolute Prelative ::= 0/0Prelative ::= step (0/0step)   step ::= axis 0::0 node test (0[0predicate0]0)   axis ::= child | descendant ::= name | @name |   | @  | text0()0 ::= P | general predicate node test predicate XPath expression (XPE) P can have disjunction (|) and be either an absolute or a relative expression.
A relative expression is a sequence of steps, each of which consists of axis, node-test, and optional predicates.
The XPath functions [6] can be used in a general predicate.
Although XP {[], ,//,vars} doesn t permit the use of order-sensitive axes, it is practical for general data-oriented XML data; Typical data-oriented XML data, including the meta data for TV program guides (MPEG7 [13], TVAnyTime [24], P/META [20]) or digitized medical records, are not sensitive to node order.
Thus, order-sensitive axes are not used for those XML data.
In addition, we assume reverse axes (parent, ancestor) are rewritten to forward axes using XPath rewrite rules [18].
We simplify XSLT 1.0 [5] from two viewpoints: functionality of XML transformations and re-writability to other equivalent XSLT expressions.
First from the viewpoint of functionality, we do not consider the following XSLT expressions since they are not essential for XML transformation: modularization (xsl:apply-import, xsl:import, xsl:include), output formatting (xsl:out-put, xsl:preserve-space, xsl:processing-instruction, xsl:strip-space, xsl:decimal-format,xsl:number), and other functions (xsl:fallback, xsl:message, xsl:namespace-alias).
Second from the viewpoint of re-writability, we do not consider the following XSLT expressions, since they can be rewritten using equivalent and more fundamental XSLT expressions.
xsl:call-template, xsl:for-each can be rewritten to xsl:apply-templates with parameters and mode.
xsl:when, xsl:otherwise, xsl:choose are equivalent to a set of xsl:if.
xsl:attribute-set is equivalent to a set of xsl:attribute.
xsl:key is equivalent to an equi-join operation expressed by a predicate of an XPE.
In addition, the match pattern of XSLT template (Remember match and select pattern are di erent in XSLT) is simpli ed to permit the use of current node test, because an XSLT template whose match pattern uses a path expression can be rewritten to two XSLT templates whose match pattern uses a current node test.
The rewriting is as follows.
step of the original XPE as the match pattern.
If the  rst step has predicates, they are rewritten to the xsl:if condition.
The remaining part of the original XPE is used as the select pattern of an xsl:apply-templates.
last step of the original XPE as the match pattern.
the mode of xsl:template and xsl:apply-templates.
For example, an XSLT template whose match pattern is A[B][C]/D[E]//F is rewritten to the following two XSLT templates.
<xsl:template match="A"> <xsl:if test="(.
)[B][C]"> <xsl:apply-templates select="D[E]//F" mode="S1"/> </xsl:if> </xsl:template> <xsl:template match="F" mode="S1"> (the content of the original XSLT template) </xsl:template> Our simpli ed XSLT also permits XPEs to use variable references (XP {[], ,//,vars}) and so is a more general speci-



data) data)
 (XT-tree)
 view update Tr (XSLT program) u (d)

 d
 view  Figure 5: Incremental view maintenance  cation of the XSLT fragment XSLT0 [4].
Appendix A of the full paper [19] shows the syntax of the simpli ed XSLT.
We modi ed the XUpdate speci cation [23] to express how the source data was updated1.
insert(p,r) expresses the inserted subtree r and its path p (called update-path).
Symmetrically delete(p,r) expresses the deleted subtree r and its path p. The update-path uniquely identi es a path from the root node of source XML data to the root node of the updated subtree and consists of a sequence of update steps, each of which is pair of nodeID and node name.
For example, Fig. 6 expresses an update expression in which the third author is inserted for the paper whose nodeID is 5.
insert(/(1,bib)/(5,paper)/(8,author), "<author role="3rd"> <name>makoto onizuka</name> <country>Japan</country> </author>" Figure 6: An XUpdate example
 Fig. 5 depicts the problem of incremental maintenance for materialized XPath/XSLT views which we express as follows:  Let D be source XML data, D be the modi ed source XML data, T r be an XSLT program, t(D, T r) be a function that evaluates T r on D, u(d) be an XUpdate expression describing how the source data was updated2, and M be auxiliary data constructed from D and T r beforehand.
Our goal is to output t(D , T r) by incrementally maintaining M for update expression u(d). 



 This section investigates the XPath/XSLT features that support incremental view maintenance (Section 4.1,4.2), then describes the auxiliary data XT-tree (Section 4.3) and the incremental view maintenance algorithm XTim (Section 4.4).
by our modi ed XUpdate expression.
2d is an updated subtree.
eval({p}, xps, p)   match(xps, p) match(xps, p)     true f alse if both xps and p are empty strings if only xps or p is empty string match(xp1|...|xpn, p)   match(xp1, p) ... match(xpn, p) match(child :: N/Rxp, H/R)     match(Rxp, R) f alse if N matches H otherwise match(descendant :: N/Rxp, H/R)     match(descendant :: N/Rxp, R)   match(Rxp, R) Figure 7: eval algorithm (XPath expression is in XP { ,//}) match(descendant :: N/Rxp, R) if N matches H otherwise (1) (2) (3) (4) (5) To identify the impacted XPath expressions in an XT-tree by update operations, we consider the XPath semantics that determines if a path matches an XPath expression.
Thus, our semantics help to identify the impacted XPath expressions by using a set of paths to nodes in an updated sub-tree.
We can easily extend the semantics to an interrelated XPath expression and XTim implements the extended semantics.
We de ne P as a set of paths from the root node to every node in the source XML data.
We de ne the XPath evaluation algorithm eval on a single path.
De nition 4.1 eval(P, xp, p) is a Boolean function that decides if the given XPath expression, xp, matches path p. The  rst parameter, P , is the scope that the eval function may refer to during the xp evaluation on p.
Accordingly, we de ne the XPath evaluation function evalc on a set of paths.
De nition 4.2 Let P 0 be a subset of P , and xp be an XPath expression.
We de ne the XPath evaluation function on P 0 as: evalc(P, xp, P 0) = {p | p   P 0, eval(P, xp, p)} Thus the evaluation of xp on P , all paths in the source XML data, is expressed by evalc(P, xp, P ).
Let s consider XPath expressions without predicates  rst and extend the coverage later.
If xps is in XP { ,//}, then eval(P, xps, p) can be implemented by  nite automata [7,
 regular expression and p is a sequence of nodes with a name.
Therefore, eval(P, xps, p) = eval({p}, xps, p) and we have the following result.
Proposition 4.3 Let xps be in XP { ,//} and P 0 be a subset of P .
The evalc function on P 0 is evaluated without reference to other paths in P .
evalc(P, xp, P 0) = evalc(P 0, xp, P 0) Fig. 7 shows an algorithm of the eval({p}, xps, p) function when xps   XP { ,//}.
Step (1) shows eval({p}, xps, p) implemented by match(xps, p).
Step (2) is a termination rule and steps (3)-(5) are recursive rules.
Step (3) shows the rule to be applied when xp is a disjunctive expression.
If one of match(xpi, p) (1 i n) is true, match(xp1|...|xpn, p) returns true.
Step (4) shows the rule to be applied when the  rst step axis of given XPE is child.
If the node-test N of the  rst step of the XPE matches the  rst step H of the given path, then continue to check that the remaining part of the XPE Rxp matches the remaining part R of the path.
Otherwise, the match function fails.
Step (5) shows the rule to be applied when the  rst step axis of XPE is descendant.
If the node-test N of the  rst step of the XPE matches the  rst step H of the given path, then non-deterministically continue to check that R is matched by the same XPE or the remaining part Rxp.
Otherwise, continue to check that R is matched by the same XPE.
After applying the match function recursively, one of the two parameters of the match becomes an empty string.
Step (2) shows the rule to be applied if either of the parameters is empty.
If both of them are empty then the match returns true, otherwise if only one them is empty then the match returns false.
Now consider XPath expressions with predicates and the scope on source XML data that may be referred to during view maintenance.
Note update-path of an XUpdate expression is the common pre x of paths to nodes in the updated subtree.
We exploit update-path to share the process of identifying impacted XPath expressions for each path.
Theorem 4.4 (scope) Let xp be in XP {[], ,//},  P be the set of paths to nodes in the updated subtree, and stepxp be the top most step with predicate in xp, and stepupdate be the top most update step in update-path that the node-test of stepxp matches.
If some path in  P matches the last location step in xp or some predicate in xp, then the eval algorithm on  P is evaluated with reference to all paths (P ) that contain the node indicated by stepupdate.
eval(P, xp,  P ) = eval(P 00, xp,  P ) Proof.
(sketch) update-path and XPath xp are processed by the eval algorithm in Fig. 7 until stepupdate, because there is no step in xp with predicate until stepxp.
The remaining part of xp starting from stepxp can then be evaluated on the subtree whose root node is indicated by stepupdate, because the permitted child and descendant axes refer only to the subtree.
For example, assume that the update operation expressed in Fig. 6 makes the paper whose nodeID is 5 match the XPath expression in Fig. 1.
In this case, stepxp is //paper and stepupdate is (5,paper), so P  becomes all paths in such sub-tree whose root nodeID is 5.
Therefore, we reevaluate //pa-per[author/country =  Japan ] on the node whose nodeID is 5 without referring to the remaining part of the source XML data.
While Theorem 4.4 explains the scope on source during view maintenance, an update operation does not always impact materialized nodes.
Theorem 4.5 (una ected) Let xp and  P be the same as above, nmat be a materialized node of xp before the update operation was commenced.
If a step stepupdate in update-path corresponds to nmat and none of the paths in  P match any predicate in xp, then the update operation does not impact nmat.
Proof.
(sketch) update-path is processed until stepupdate by the eval algorithm in Fig. 7 using XPath xp, because none of the paths in  P match any predicate in xp.
The update operation does not impact nmat, because 1) the materialization of nmat indicates all predicates in xp were evaluated as true, and that 2) none of the paths in  P match any predicate in xp.
For example, assume node n whose nodeID is 5 is materialized by //paper[year>2002] and the update operation expressed in Fig. 6 is applied to n. Theorem 4.5 is applicable to this case, so we don t need to reevaluate the XPath expression.
We present the condition under which XSLT expressions inherit the XPath features described in Section 4.1 and how to handle those expressions otherwise.
There are three types of XPath usage in XSLT expressions: xsl:apply-templates, xsl:if, view construction as xsl:value-of, and xsl:copy-of.
First we consider XSLT expressions whose XPath expression does not use variable/parameter; we then show how to handle variable/parameter.
xsl:apply-templates The evaluation of xsl:apply-temp-lates s XPE without xsl:sort inherits the XPath features, so we need to materialize just the node-set returned by the XPath evaluation.
When xsl:sort is speci ed, we need to consider how to maintain the sorted node-set e ciently.
Our approach is to materialize the sorted pairs (node, key value).
When an update operation impacts the evaluation of xsl:apply-templates s XPE, we identify the position of the impacted pair in the sorted pairs by binary search, and then insert/delete the pair to/from the position indicated.3 xsl:if Since xsl:if is evaluated with existential quanti cation, it is not su cient for incremental view maintenance to materialize the XPath result.
We apply the counting algorithm [12], which was originally designed for the incremental maintenance of SQL views with set semantics, to the xsl:if evaluation and store the number of nodes that satisfy the xsl:if condition.
When an update operation impacts the xsl:if condition evaluation, we add/subtract the number of updated nodes that satisfy/do not satisfy the xsl:if condition.
If the resulting number becomes zero (indicating xsl:if condition is evaluated as false), we delete the materialized view of the child XSLT expression.
If the resulting number that was originally zero becomes one (indicating xsl:if condition is evaluated as true), we add the materialized view of the child XSLT expression.
view construction The evaluation of the view construction s XPE inherits the XPath features, thus we need to materialize just the result.
xsl:variable/param xsl:variable/param inherits XPath features.
Fig. 8 shows an example wherein variables V1...Vn
 tinct operation to remove duplicated values in a node-set.
We can apply the counting algorithm in the same way as xsl:if processing.
are de ned by referring to the previous variable.
Since the bound value can be seen as the input XML data for the next variable, the  nal variable Vn is incrementally maintained in the same way as described above by generating the XUpdate expressions (u(d1),...,u(dn 1)) for the bound value.
              Figure 8: Variable maintenance   
 We de ne the auxiliary data XT-tree for incremental view maintenance of an XSLT program, a set of XSLT expressions.
An XT-tree is a tree of XT-nodes each of which contains a reference to the XSLT expression it was generated from.
An non-leaf XT-node commonly stores a sequence of references to child XT-nodes that expresses the dynamic execution sequence of XSLT expressions.4 There are  ve types of XT-node: XT-template, XT-param, XT-if, XT-node-set, and XT-view, each of which is constructed from its corresponding XSLT expression.
XT-template: An XT-template instance stores its context node.
XT-param An XT-param instance is constructed for either xsl:param or xsl:variable and stores the bound value.
XT-if An XT-if instance is constructed for xsl:if.
When the xsl:if condition is satis ed, a child XT-node is constructed by evaluating the child XSLT expressions of xsl:if.
XT-node-set An XT-node-set instance is constructed for xsl:apply-templates and stores a set of references to child XT-templates that are constructed by the applied XSLT templates.
The set of references are sorted by the context nodeID of the child XT-templates so as to identify, by binary search, the node position for insertion/deletion.
When xsl:sort expressions are speci ed, XT-node-set stores a list of pairs (reference to child XT-node, key value) sorted by the key value in the speci ed order (descending/ascending).
The node position for insertion/deletion is identi ed by binary search using the node s key value and nodeID.
XT-view An XT-view instance stores a materialized view and is constructed for xsl:element, xsl:attribute, xsl:text, xsl:value-of, xsl:copy, or xsl:copy-of.
For example in Fig. 9, the left part shows the source XML data and the middle part shows the XT-tree constructed by the XSLT program in the right part.
The XT-tree indicates that the four section nodes (depicted by the gray circles) are used as the context of the second XSLT template.
The XT-tree is built during the full transformation.
In addition, we build an XT-node-set candidates to store all XT-nodes, including the root XT-node, generated from the XSLT expression with an absolute XPE.
The optimized incremental view maintenance in Section 4.4 utilizes candi-
XML data XT-tree XSLT program bib book section,year title,section




 title



 <xsl:template match= / > <html><table> <xsl:apply-templates select= .//book[year>2002]//section[title= X ] /> </table></html> </xsl:template> <xsl:template match= section > <tr><td><xsl:value-of select= title/text() /></td></tr> </xsl:template> Figure 9: Incremental view maintenance example dates to avoid traversing XT-nodes that are not impacted by update operations.
Note that an XT-tree, a tree of XSLT expressions, forms an interrelated XPath expression.
XTim extends the XPath semantics in Section 4.1 so as to determine the impacted XPath expressions in the interrelated XPath expression by update operations.
The view maintenance process consists of three steps: 1) identify the impacted XPath expressions for update-path and locate the context node in the source XML data, 2) reevaluate the XSLT program partially on the located context node and maintain the impacted XT-nodes, and 3) output the maintained materialized view stored in the XT-tree.
During the 1st step, for each update-step in update-path XTim uses Fig. 7 to process XPath expressions.
When some XPath expression becomes empty, XTim locates a child XT-node whose context node is identical to update-step and continues processing the XPath expression of the child XT-node.
When XTim reaches to the end of update-path, it reaches the root nodes of impacted XT-nodes (Fig. 10) and moves to the 2nd step.
In the 2nd step, XTim evaluates the XPath expression on the context node speci ed by update-step and maintains the XT-tree.
After the 2nd step, since the XT-tree stores the maintained materialized view, the 3rd step is easy to complete.
We focus on the XT-tree maintenance algorithm for an XUpdate insert expression, since the symmetry of XUpdate insert and delete expressions makes the maintenance algorithm symmetric.
One naive method of XT-tree mainte-     !   Figure 10: XTim view maintenance ! nance is to traverse all the XT-nodes in the tree to locate XT-nodes generated from XSLT expressions with absolute XPath expressions.
This method is sound because it ensures that all impacted XT-nodes are found and that the referred variables always bind the maintained values.
How-Algorithm maintain-XT-tree(D,u-org,candidates) Input: D is the updated source XML data.
u-org is the original XUpdate expression.
candidates is a set of XT nodes.
if is-maintained(XT-node) continue; else maintain-XT-node(XT-node,u-org); Figure 11: maintain-XT-tree Algorithm maintain-XT-node(p-XT, u) Input: case XT-template: break; // continue to line 18 case XT-param: return; // deferred evaluation case XT-node-set: proceed-step(p-XT,u,get-xpath(p-XT)); return; p-XT is current XT-node.
u is an XUpdate expression.
17.
// end switch


 proceed-step(p-XT,u,get-xpath(p-XT)); break; if is-maintained(c-XT) continue; else maintain-XT-node(c-XT,u); for-each xpath in get-xpaths(p-XT) // end for-each return; case XT-view: proceed-step(p-XT,u,xpath); case XT-if: // continue to line 18 Figure 12: maintain-XT-node ever, since it may not be e cient to traverse all the XT-nodes in the XT-tree, we propose an optimized method that avoids traversing all XT-nodes.
This method utilizes candidates which store all XT-nodes, including the root XT-node, with absolute XPath expressions.
This approach is also sound because it ensures that all impacted XT-nodes are found by using the candidates and that the variable is lazily maintained when its bound value is referred to.
Fig. 11 shows the main function.
It parses the updated source XML data D to allow the reevaluation of some predicate of XPath expressions to access portions of D (line 1).
For each XT-node in candidates (line 2), if it has already been maintained then skip to the next XT-node to avoid maintaining the same XT-node twice (line 3).
Otherwise, it invokes the maintain-XT-node function for current XT-node (line 4).
Fig. 12 shows the maintain-XT-node function that maintains the current XT-node p-XT according to its type.
When Algorithm proceed-step(XT-node, u, or-xpath) Input: XT-node is current XT-node.
u is an XUpdate expression for or-xpath.
or-xpath is an XPath expression.
t-step = get-first-step(xpe); switch (get-axis-type(t-step)) 1. or-xpath-next = null; 2. u-path = get-update-path(u); 3. u-step = get-first-step(u-path); 4. for-each xpe in get-paths-from-or-expr(or-xpath)







 update-XT-node(XT-node,get-node(u-step),xpe); break; else or-xpath-next = or-expr(or-xpath-next, case descendant: if match-node-test(u-step,t-step) if is-predicate-impacted(u,t-step) get-rest-path(xpe), xpe); else or-xpath-next = or-expr(or-xpath-next,xpe);
 // end switch
 26.
// end for-each
 29. if (reached the updated subtree)
 update-XT-node(XT-node,get-node(u-step), or-xpath-next); return;



 proceed-XT-node(XT-node,u-next,get-node(u-step)); Figure 13: proceed-step p-XT s type is XT-template indicating that it was generated from an xsl:template expression (lines 2-3,18-20), all child XT-nodes of p-XT are to be maintained: for each child XT-node c-XT of p-XT, if it has already been maintained then skip to the next XT-node (line 19), otherwise the maintain-XT-node function is invoked recursively for c-XT (line 20).
When p-XT s type is XT-param (lines 4-5), maintenance is deferred until the variable/parameter is referred to.
When p-XT s type is XT-node-set (lines 6-8), the proceed-step function is invoked to check matching between the XPE of the corresponding XSLT expression and update-path of the XUpdate expression, and to maintain the descending part of p-XT.
When p-XT s type is XT-if (lines 9-13,18-20), the proceed-step function is invoked for all XPEs used in the xsl:if condition and to maintain the descending part of p-XT.
If p-XT s type is XT-view (lines 14-16,18-20), when the corresponding XSLT expression is either xsl:value-of or xsl:copy-of that uses an XPE, the proceed-step function is invoked.
The function then processes all child XT-nodes of p-XT (lines 18-20).
Fig. 13 shows the key steps of the proceed-step func-tion5; Appendix B of the full paper [19] shows the complete program.
The proceed-step function processes the  rst update step (u-step) in update-path and is recursively invoked (line 36) until it reaches one of three cases; 1) XPath match fails (line 27), 2) all update steps in update-path have been processed, indicating that we have reached the root node of the update subtree in the source XML data (lines

 XT-node.
In the 2nd case, it invokes the update-XT-node function to update the current XT-node by evaluating or-xpath-next.
Theorem 4.4 explains the scope on the source XML data during the processing of the update-XT-node
 function.
In the 3rd case, there are two tasks; one is to continue processing the unmatched part of XPath (line 36).
The other is to invoke the proceed-XT-node function for locating a child XT-node and then traversing the XT-tree.
The proceed-XT-node function implements Theorem 4.5 and locates the child XT-template whose context nodeID is identical to the nodeID of u-step.
In general, since the XPath expression or-path is disjunctive, the proceed-step function processes each subexpres-sion xpe in or-path (lines 4-26).
t-step is the  rst step of xpe (line 7).
If the node-test of t-step matches the  rst step of u-path (line 17), it continues to check that the predicates of t-step are impacted by the XUpdate expression (line 18).
Otherwise (line 22), the proceed-step function sets or-xpath-next, which corresponds to the 2nd line in (5) of the eval algorithm in Fig. 7.
If some predicate of the  rst step (t-step) of xpe is impacted by the XUpdate expression, the update-XT-node function is invoked to update current XT-node (line 19).
Otherwise (line 21), the proceed-step function sets or-xpath-next, which corresponds to the 1st line in (5) of the eval algorithm.
Consider the example depicted in Fig. 9.
The small triangle in the left part depicts a new subtree inserted into the source XML data.
The update-path is expressed as /(bib,1)/(book,2)/(section,8)/(section,9).
The triangle in the middle part shows the expected new subtree in the XT-tree.
There are two select XPath expressions in the XSLT program; .//book[year>2002]//section[title= X ] (xp1) and title/text() (xp2).
Incremental maintenance is done as follows.
(bib,1) is processed by xp1 and the XPE for the next processing (or-xpath-next) is also xp1 (line 22 in Fig. 13).
Then (book,2) is processed and or-xpath-next becomes xp1|//sec-tion[title= X ] (line 21 in Fig. 13).
Finally, (section,8) is processed and or-xpath-next becomes xp1|//section[title= X ]| (null).
The (null) indicates partial XPath matching, so p1) we continue processing the unmatched part of XPath, and p2) we locate the child XT-node whose context nodeID is identical with the current update step (section,8) and continue traversing the XT-tree.
is 9, which is the root node of the updated subtree.
For case p1 (current XT-node is the root), we evaluate xp1|//sec-tion[title= X ] on the XML node whose nodeID is 9.
The scope on the source XML data is depicted by the triangle consisting of dotted lines in Fig. 9, because we need to evaluate the predicate [year>2002] whose evaluation we have skipped up to now.
The remaining process is the same as that part of the full transformation process; construct new XT-nodes and continue processing the second XSLT template.
For case p2, the located XT-node whose nodeID is 8 is constructed from the second XSLT template, so we evaluate xp2 on the XML node whose nodeID is 9.
This case doesn t impact the XT-tree.
Since XTim stores a node-set sorted by nodeID and the labeling schemes [16, 1] can encode the node position into the nodeID (label), the labeling schemes enable XTim to support the ordered data model.
Future work includes de-depth




 data size (KB) # of elements














 description preserving structure simple  atten structure descendant descendant + sort sort simple-pred simple + predicate descendant-pred descendant + predicate selectivity




 (a) XML data (b) XSLT programs Table 1: XML data & XSLT programs termining how to update the nodeIDs stored in the XT-tree when nodeIDs in the source XML data are relabeled.
There are two approaches to maintaining the evaluation result of XPath with a position predicate; 1) reevaluation, and 2) materialization.
Consider //book[year>2002][3]/title, which extracts the title of the third book published after
 of 2003, the position predicate may be impacted by the update operation, thus we need to maintain the materialized XPath view.
The reevaluation approach evaluates the XPath expression fully, so it is not e cient w.r.t.
speed but it doesn t require additional memory space.
The materialization approach materializes the node-set returned by //book[year>2002], incrementally maintains the node-set, and evaluates [3] on the materialized node-set.
This is e -cient w.r.t.
speed but requires additional memory space.
We implemented a persistent DOM manager (PDOM) and XTim using the XML parser Xerces-J 2.6.2 and the XPath processor Jaxen 1.1.
The PDOM loads XML  les and assigns a persistent nodeID to each node.
Since our data model is not node order sensitive, a new node receives a larger nodeID than the existing nodes.
The PDOM receives an original XUpdate expression [23], updates the stored DOM, and submits rewritten XUpdate expressions (de ned in Section 3.3) to the XTim algorithm.
Our execution environment consisted of an Intel Pentium M 1.6GHz PC with 2048MB main memory, running Windows XP, and Sun Java SDK 1.4.2 06.
For each experiment, the performance result doesn t include the DOM building time nor the XSLT program parsing time.
XML data: We used nested synthetic XML data that forms a balanced 3-ranked tree as shown in (a) of Table 1.
We also conducted experiments using DBLP XML data, a typical example of shallow XML.
We omit the latter here, since the result is similar to that of the former synthetic XML data.
XSLT programs: We used four di erent types of XSLT programs as shown in (b) of Table 1. simple represents a structure preserving transformation that constructs a tree whose size is 7.8% of the input XML data.
descendant represents a  atten-structure transformation using descendant axis and constructs a tree whose size is 66.7% of the input XML data.
sort represents a  atten-structure transformation with sort.
simple-pred and descendant-pred are simple with a predicate and descendant-pred with a predicate respectively.
XML update operations: We used four di erent sub-tree sizes for insertion: 4KB, 14KB, 43KB, and 141KB.
They are also balanced 3-ranked trees with depths of 4, 5, 6, and 7 respectively.
Fig. 14 shows XT-tree size and the response time of XT-tree building.
(a) indicates that XT-tree size (the number of nodes) scales reasonably to source XML size (the number of nodes) and the selectivity of the XSLT program.
The combination of (a) and (b) indicates that the XT-tree building performance depends on the XT-tree size in general.
However, it is not true for descendant-pred transformation, because the evaluation of descendant axis requires access to all the nodes in the source XML data, which is expensive.
(c) in Fig. 146 shows the performance comparison of XTim and SAXON version 8.1 [15] (one of the fastest XSLT processors).
The experiment compared the response time of 1) the XTim incremental transformation of subtree insertion with  xed size of 4KB, and 2) the SAXON transformation of the updated XML data.
There are three observations.
First XTim outperforms SAXON s full transformation by factors of up to 500, because the updated data size is small compared to the source XML data size (2.84% in D7 to 0.02% in D11), so the XPath reevaluation of XTim is localized.
Second XTim performance of XSLT programs except sort is constant.
The reason is that the insertion position of the new sub-tree is always the last position of the XT-node-set sorted by nodeID, because the PDOM assigns larger nodeID to a new node.
In addition, XTim performance of sort is linear to log2(source XM L data size), because a binary search is done on the XT-node-set to identify the insert position.
Third, by comparing the XT-tree building time in (b) and the SAXON s transformation time in (c), the XT-tree building in descendant, descendant-pred, sort is slower than SAXON s transformation, but not in the simple and simple-pred cases.
The reason for the former is that the XT-tree building process includes the XSLT transformation process.
For the latter, we conjecture that the xsl:template lookup, which is one of the most expensive processes in XSLT transformation, is e ciently implemented in the XTim implementation due to the simpli ed XSLT spec-i cation described in Section 3.2.
(d) in Fig. 14 shows the response times of XTim with the subtree insertion of various sizes.
The source XML data is  xed at D10.
The  rst observation is the large di erence between sort and descendant performance; it indicates that the binary search cost incurred by every new XT-node insertion dominates sort performance.
The second observation is descendant-pred s performance worsens against that of





 '$"" '#"" '""" &"" %"" $"" #""



 >?
;<=>> :                                     " " (" '"" '(" #"" #(" )"" *+,-./012*34/56+7/*8'"""9 (a) XT-tree size                                        

 wx t uv t s rm q p om lmn k






  

  

    





  
  

  
    
  
    
       yz{|}~ ~y ~   y  yz{|}~ | ~ ~y ~  | ~
 \]^_`abcd\efaghij (b) XT-tree building time          



 (c) transform time (4KB subtree insertion) (d) transform time (D10 (4949KB) is the source XML) Figure 14: Scalability experiments descendant s as subtree size increases.
This re ects the impact of the scope size di erence on source XML data during XPath reevaluation; the scope size of descendant-pred is larger than that of descendant.
There are a number of related works on incremental maintenance for materialized views in the context of the relational model [11], the semi-structured data model [17, 2, 21,
 incXSLT [25] is an incremental XSLT transformation algorithm for an XML document editor through its rendered presentations.
incXSLT materializes the dynamic execution  ow of XSLT template processing and traverses the  ow in a top down manner.
Their important contribution is to clarify how to manage XSLT template precedence for incremental view maintenance.
XT-tree shares the concept of execution  ow, but XTim o ers three technical di erences since their motivation di ers from ours.
First, although in-cXSLT incrementally maintains the execution  ow of XSLT template processing, it doesn t incrementally maintain the XPath evaluation result and so reevaluates XPath expressions fully.
Second, incXSLT restricts update operations to just a single node, since they assume the update operation is done via GUI.
This does not e ciently support the inser-tion/deletion of subtrees.
Third, incXSLT requires that the XPEs whose result type is a node-set must be expressed by just child axis (not descendant axis).
Reference [14] presents a maintenance technique for materialized XML views stored in a RDBMS or an ORDBMS.
Their view de nition is limited to select-projection views and it doesn t support regular expressions (wildcard and descendant axis) on matching patterns.
Reference [9, 8] presents an incremental XQuery view maintenance algorithm based on the algebra XAT.
It constructs a materialized tree using XAT and checks matching XPEs with the update operation in a top down manner.
There are three issues with their techniques.
First, they don t consider predicates on XPath.
Second, since they store all the intermediate node-sets returned by location step evaluations, they need a large memory space.
Third, similar to incXSLT, they restrict update operations to just a single node that doesn t require descendant processing such as the eval algorithm in Fig. 7.
Reference [17] modi es the XML query language XML-QL to ensure multi-linearity.
However, it doesn t support recursive matching patterns expressed by descendant axis in XPath and XML-QL is limited since it cannot express recursive queries expressed by an XSLT template.
Reference [2] extends Lorel [3], a query language of the semi-structured data model, and presents an incremental maintenance algorithm for materialized views de ned by the extended Lorel.
It records RelevantOids that contain the object identi er of every object touched during the view evaluation and checks whether RelevantOids contain the updated object.
The views de ned by the extended Lorel are limited to a subset of the source data, so it is not applicable to the views de ned by XSLT programs which de ne more general data transformations.
In addition, it restricts insertion/deletion to just the edges and value updates on atomic objects; match patterns are limited to those equivalent to XP {[]}.
References [21, 26] present incremental maintenance algorithms on the semi-structured data model whose views are limited to return a set of nodes.
We have presented XTim, a novel algorithm for incrementally maintaining XPath/XSLT views de ned with XPath expressions in XP {[], ,//,vars}.
We investigated the XPath and XSLT features for incremental view maintenance in response to subtree insertion/deletion.
XTim implements those features and experiments show that it improves the XML transformation performance by factors of up to 500.
There are several future research directions.
XTim can be improved further with regard to restructuring transformations by considering some query containment.
For example in Section 2, if an inserted subtree triggers the application of the second template for a certain year, we need to reevaluate the XPath expression in line 15 only on the inserted subtree.
The reason is the XPath expression collects publications for that year and no existence of the materialized result of the year indicates there is no publication on the year in existing source data.
Other future work includes the e cient incremental maintenance of a large number of views and on an incremental update of the rendered presentations of HTML and SVG.
We are currently working on the incremental SVG rendering to complete the incremental process from source data to presentation.
