One of the many criticisms on Document Type De nitions (DTDs) was their restricted expressiveness.
On an abstract level, XML Schema obtains a higher expressive power by extending DTDs with a recursive typing mechanism which allows to de ne types in terms of types.
However, an investigation of the XML Schema De nitions (XSDs) occurring in practice reveals that the vast majority of them are structurally equivalent to a DTD.
More precisely, we harvested a large corpus of XSDs from the Web and investigated the use of features not present in DTDs such as namespaces, import facilities, built in basic types, keys, and also the ability to use the same element name with di erent types.
Concerning expressive power we were surprised that only
 that goes beyond the power of DTDs.
A possible explanation is that the actual modeling power of XSDs remains unclear to most users: the XML Schema speci cation is very hard to read and the e ect of constraints on typing and validation is not fully understood.
The present paper has four main contributions: (1) We give a detailed account of the features of XSDs that are actually used in practice.
(2) We try to shed some light on the actual expressive power of XSDs by discussing the impact of the Element Declarations Consistent (EDC) rule.
It turns out that there is a simple criterion to check whether a set of documents can be described by an XSD ful lling EDC.
(3) We propose a framework for pattern based speci cation of sets of documents and show that one of its simplest instantiations leads to a language with exactly the same power as XSDs with EDC, but avoiding the complexity of recursive types.
We believe that with this framework a lightweight front-end for XML Schema can be built suitable for less experienced users.
Alternatively, we discuss how XML Schema itself can be conservatively extended with contextual patterns.
Furthermore, we exemplify how the use of contextual patterns reduces duplication of de nitions.
are dvd elements; every dvd element has a title, price, and an optional discount child.
(4) Finally, we discuss the e ect of the EDC and the Unique Particle Attribution (UPA) constraints on the way XML documents can be typed.
These constraints allow e -cient validation and typing of documents by ensuring that the type of an element never depends on its content or the following elements.
Hence, the type of an element of a streaming document can be assigned when its opening tag is met.
We refer to the latter requirement as 1-pass preorder typability.
Although EDC and UPA ensure 1-pass preorder typability they are not necessary for it.
More interestingly, it turns out that 1-pass preorder typability is a very robust notion with various clean semantical and syntactical characterizations.
In particular, it can be de ned in terms of restrained competition regular expressions (introduced by Murata, Lee, and Mani [14]) and by an equivalent syntactical formalism based on contextual patterns which can serve as a lightweight front-end.
We therefore propose to replace the rather ad-hoc EDC and UPA constraints by the more robust 1-pass preorder typability requirement thereby obtaining the maximal expressiveness in terms of typing in a streaming fashion.
These contributions are based on theoretical results obtained in previous work conducted by three of us [13].
The main goal of this paper is to make these results accessible to a more practical oriented audience and discuss their implications on the design of XML Schema.
The paper is organized as follows.
In Section 2, we recall basic properties of DTDs, the notion of (single-type) specialized DTDs which correspond to XSDs respecting the EDC constraint.
In Section 3, we give a more detailed report on the structural properties of XSDs that we found on the Web.
Section 4 investigates XSDs with the EDC constraint more closely, and introduces the pattern based paradigm mentioned in (2) and its instantiation matching the expressiveness of XSDs with EDC.
Section 5 de nes the notion of 1-pass preorder typability and explains its relationship to EDC and UPA.
In Section 6, we characterize the expressive power of 1-pass preorder typability and describe a simple speci cation language based on the pattern paradigm invented before.
The paper concludes with Section


 In the present section, we provide the necessary background on the mathematical formalisms we employ as abstractions of DTDs and XSDs.
Since ordered trees serve as the logical data model for XML [31], we employ a tree based abstraction of XML documents.
We focus in this work on the structure of XML documents and disregard data values, attributes, namespaces, and linking information.
We refrain from giving a formal de- nition, but instead, give an example of an XML document and its tree representation in Figure 1.
For clarity we also displayed the data values though they will be disregarded in the rest of the paper (cf.
Example 1).
In this respect, a schema de nes a set of allowed trees (also referred to as a tree language in formal language theory).
The DTD in Figure 2, for instance, de nes the set of trees where the root is labeled with store; the children of store <store> <dvd> <title>Amelie</title> <price>17</price> </dvd> <dvd> <title>Good bye, Lenin!</title> <price>20</price> <discount>20%</discount> </dvd> </store> dvd store dvd title price title price discount  Amelie   17   Good bye, Lenin!   20   20%  Figure 1: An XML document and its abstraction as a tree.
It is customary to abstract DTDs by sets of rules of the form a   r where a is an element and r is a regular expression over the alphabet of elements.
One element name is designated as the start symbol.
For instance, the DTD of Figure 2 is represented by the set of rules: store   dvd dvd  dvd   title price (discount +  ) with start symbol store.
<!ELEMENT store <!ELEMENT dvd <!ELEMENT title <!ELEMENT price <!ELEMENT discount (dvd+)> (title, price, discount?
)>


 Figure 2: Example of a DTD describing the document in Figure 1.
Papakonstantinou and Vianu [16] provided a characterization of the structural expressive power of DTDs: a regular1 set T of trees is de nable by a DTD i  T has the following closure property: if two trees t1 and t2 are in T , and there are two nodes v1 in t1 and v2 in t2 with the same label, then the trees obtained by exchanging the subtrees rooted at v1 and v2 are also in the set T .
We refer to this property as label-guarded subtree exchange.
We illustrate this notion in Figure 3.
Because of the latter characterization, the classes of XML documents de ned by DTDs are also referred to as local classes.
The characterization can be used to prove that certain languages can not be expressed by a DTD as exempli ed in the following example.
Example 1.
Suppose that we want to put the extra constraint on the DTD of Figure 2 requiring the presence of at least one DVD on discount.
Then we get a language that is not de nable by a DTD anymore.
We can prove this by applying the above characterization.
Indeed, the trees
 t1
 a t 
 t2 a t 

  
 a t 
 t1 <xs:element name="store"> Figure 3: Label-guarded subtree exchange.
t1 := store dvd dvd title price title price discount and t2 := store dvd dvd title price discount title price are in the language, but the tree store dvd dvd title price title price which is obtained from t1 by replacing its second subtree by the second subtree of t2, is not in the language.
As discussed in the introduction, the expressive power of DTDs can be increased by adding types, as, e.g., in XML Schema and Relax NG [4].
There is a  nite set of possible types that every element can assume.
For notational simplicity, we denote types for element a by terms ai with i   N. As can be seen in Example 2, rules are now of the form ai   r, where r is a regular expression over types (also referred to as specializations).
The designated start symbol has only one type associated with it.
These specialized DTDs (SDTDs) were introduced by Papakonstantinou and Vianu [16].
Formally, a tree satis es an SDTD if there exists an assignment of types such that the typed tree is a derivation tree of the grammar.
The following example displays an alternative SDTD for the tree in Figure 1.
For clarity, types are not displayed for element names having a unique type.
Example 2.
Consider the following SDTD: store   (dvd1 + dvd2) dvd2(dvd1 + dvd2)  dvd1   title price dvd2   title price discount Intuitively, dvd1 de nes ordinary DVDs while dvd2 de nes DVDs on sale.
The  rst rule speci es that there has to be at least one DVD on discount.
The tree in Figure 1 satis es this SDTD as assigning dvd1 and dvd2 to the left and right dvd-node respectively, gives a derivation tree of the grammar.
In Figure 4, a fragment of an XSD corresponding to the rule for store is depicted.
We note that the XSD is not syntactically correct because it violates EDC as explained in the next section.
<xs:complexType> <xs:sequence> <xs:choice minOccurs="0" maxOccurs="unbounded"> <xs:element name="dvd" type="dvd1"/> <xs:element name="dvd" type="dvd2"/> </xs:choice> <xs:element name="dvd" type="dvd2"/> <xs:choice minOccurs="0" maxOccurs="unbounded"> <xs:element name="dvd" type="dvd1"/> <xs:element name="dvd" type="dvd2"/> </xs:choice> </xs:sequence> </xs:complexType> </xs:element> Figure 4: A fragment of an XSD (violating EDC) corresponding to the SDTD of Example 2.
From a structural perspective, SDTDs express exactly the regular tree languages; a similarly robust class as the regular string languages.
In particular, SDTDs are as expressive as unranked tree automata [2, 15].
It should be noted that the formal underpinnings of the schema language Relax NG are also based upon regular tree languages.
As noted by Murata et al. [14], XSDs can be abstracted by SDTDs extended with the Element Declarations Consistent rule (EDC).
Roughly, the constraint forbids the occurrence of elements with the same name but di erent types in the same de nition.
For instance, the XSD of Figure 4 is not allowed as dvd occurs in the presence of the two types dvd1 and dvd2 in the same rule.
The EDC rule can be formalized by requiring an SDTD to be  single-type , de ned as follows [13, 14]:2 Definition 1.
A single-type SDTD is an SDTD in which no regular expression two types bi and bj with i 6= j occur.
The SDTD of Example 2 is not single type as both dvd1 and dvd2 occur in the rule for store.
An example of a single-type SDTD is given below.
Example 3.
  regulars discounts store regulars   (dvd1)  discounts   dvd2 (dvd2)  dvd1   title price dvd2   title price discount Although there are two element de nitions dvd1 and dvd2, they occur in a di erent rule.
Although the de nition of single-type grammars is quite transparent, its e ect on de nable classes of XML documents is less so.
In Section 4 and Section 5, we return to this issue and discuss the practical implications of the latter restriction on the expressiveness and typing algorithms for XSDs.
First, we investigate in Section 3 to which extent the newly added features of XSDs (in comparison with the features of DTDs) are e ectively used in practice.
instead of SDTDs.
DTDs and XML Schema have di erent expressive power on attribute level, element level and data-value level.
All these issues can be easily incorporated into the SDTD model by adapting the tree representation of XML documents.
However, to keep the formalism simple, we focus in the present paper on the element structure of XML documents.
A variety of sources [7, 9, 11] discuss the many drawbacks of DTDs: no modularity, no XML syntax, limited basic types, restricted referencing mechanism, verbose spec-i cation of unordered data, and limited expressiveness (de- nition of an element cannot depend on its context).
Most of these concerns have been addressed by the XML Schema speci cation: namespaces and import facilities have been added; an extensive number of built in basic types as well as means to  ne tune them by restriction are provided; XML Schema supports key and referential integrity; the all construct allows to specify unordered content; and  nally, the same element name can be de ned having di erent types.
Of course, this raises the question to what extent the added features are actually used in practice.
To this end, we studied a corpus of 819 XSDs harvested from the Web.
Among the XSDs gathered, 93 were retrieved via the Cover Pages [6].3 Hence, a substantial number of high-quality XSDs representing various standards such as the XML Schema Speci cation, XHTML, UDDI, RDF and others are represented in the corpus.
Unfortunately this number is rather small, so the corpus was enlarged to its present size of 819 XSDs using Google s web services to retrieve an additional 726 XSDs.
The results concerning the use of syntactical features are summarized in Table 1.
From this table one can conclude that XML Schema s simpleType library and the ability to place restrictions on those are heavily used.
Derivation in the sense of the object orientation paradigm is only used in about 1/5 of all XSDs.
Modularity by way of imports and (nontrivial) namespaces is fairly important as well.
Uniqueness and key references are fairly uncommon.
As explained above, XSDs employ recursively de ned types to increase its expressiveness beyond DTDs.
The question remains whether XSDs occurring in practice actually use this feature.
That is, what percentage of found XSDs are not structurally equivalent to a DTD?
Unfortunately, out of the corpus of 819 harvested XSDs only 225 remain on which IBM s SQC [30] reports no errors.4 Although syntactical correctness is less critical in testing for presence or absence of syntactical features, it is mandatory for the expressiveness analysis which is more semantical in nature.
It is impossible to automatically guess for every syntactically incorrect XSD what its designer intended.
It turns out that out of the remaining 225 XSDs, 192 (85%) are in fact structurally equivalent to a DTD: at most one type is associated to every element name.5 So only
 investigated the structure of used regular expressions [1].
do not pass the syntax checker SQC.
In this respect it is interesting to note that Sahuguet reported similar  ndings on the sheer abundance of syntactically incorrect DTDs [18].
a local language.
The corresponding SDTD is of the form: feature % of XSDs derivation simpleType extension simpleType restriction complexType extension complexType restriction abstract attribute  nal attribute block attribute  xed attribute substitutionGroup rede ne interleaving modularity linking xs:all namespaces import key/keyref unique














 Table 1: XML Schema features use in the corpus
  ne non-local classes of XML documents.
Surprisingly, in
 is, they were of the kind as de ned in Example 3, where the type of dvd only depends on the label of the parent (regulars or discounts).
So, although nontrivial specialization is moderately used in practice, it is almost exclusively used in its most simplistic form: dependence on the label of the parent.
Recall that for DTDs, the type of an element only depends on its own label.
Basically, there are two possible explanations for the above observation.
Either, advanced modeling power as allowed by SDTDs is not necessary in practice.
Or, users are simply not aware of what kind of schemas can be expressed by XSDs.
In Section 4.1, we attempt to address the latter concern as we explain what is theoretically possible when using XSDs.
The former possibility is analyzed below in more detail.
In the remaining 3 XSDs, types depend on the grand or the great grandparent context.
We discuss an abstraction of one of them as an SDTD: Example 4.
a   b + c b   e d1 f c   e d2 f d1   g h1 i d2   g h2 i h1   j1 h2   j2 j1   k l j2   m n The interpretation of the example above is simple: an j1 element can only occur as the great grandchild of a b element while an j2 element can only occur as the great grandchild of a c element.
Two extreme approaches can be used to code the abstract example above in an XSD.
On the one hand, one can use the  Russian doll  model, i.e., using anonymous type de nitions In an abstract syntax the latter within type de nitions.
a1   b, a2   b where the types di er semantically.
t1
 v1 t 
 t2 v2 t 
 t1 t t t
  
 v1 t 
 v v v t                                                                                                                 v Figure 5: Ancestor-guarded subtree exchange.
reduces to the rules b   ed[gh[j[kl]]i]f and c   ed[gh[j[mn]]i]f, where the type de nition of the element b encapsulates that of d1 which in turn de nes that of h1 that  nally contains j1 s de nition.
The alternative is to  atten the XSD as has been done in Example 4, but this leads to  arti cial types  such as d1 and h1 that only exist to pass down the information that their parent and grandparent was a b-element.
It is obvious that in practice both approaches are mixed to a certain extent.
However, both lead to duplication of de n-itions, making maintenance and further development of an XSD much harder.
In view of the concerns mentioned in the previous paragraphs, we propose in Section 4.2 a general framework for XML schema languages that allows types to depend on the label of ancestors.
It would no longer be required to de ne types in terms of types, which seems to be perceived as a challenge by the average XSD author, and would allow him to access the full power o ered by XML Schema.
Duplication of de nitions would be reduced as well since dependencies on ancestor labels can straightforwardly be declared rather than being passed down via types.
As explained in Section 2.3, content models are restrained by the Element Declarations Consistent rule.
Of course, immediately a question arises: what kind of classes of XML documents can be de ned in the presence of this constraint?
To this end, we discuss a subtree exchange property that characterizes the expressiveness of XSDs completely.
Furthermore, we propose a simpler paradigm equivalent to XSDs which can serve as a lightweight front-end for XML Schema (for instance, for less experienced users).
Alternatively, the paradigm can be combined with the actual XML Schema speci cation reducing arti cial de nition duplication.
Recall the notion of label-guarded subtree exchange which characterized the class of DTD-de nable languages.
In [13, Theorem 11], it is shown that a set T of documents is de n-able by an SDTD satisfying EDC if and only if T is de nable by an SDTD and T is closed under ancestor-guarded sub-tree exchange, i.e., if the following holds (cf.
Figure 5): if two documents t1 and t2 are in T , and there are two ancestor equivalent elements v1 in t1 and v2 in t2, then the trees obtained by exchanging the subtrees rooted at v1 and v2 are also in the set T .
Here, ancestor equivalent means that the sequence of labels on the path from the root of t1 to v1 is the same as on the path from the root of t2 to v2 (cf.
Figure 6).
As an immediate consequence, the language we considered in Example 1 is not de nable by a single-type SDTD.
Note that the counterexample can be constructed in exactly the same manner.
On the other hand, the language de ned Figure 6: From left to right: a tree t, the ancestor-string of v, the ancestor-sibling-string of v and the preceding of v in t.
by the single-type SDTD in Example 3 is not de nable by a DTD, so single-type SDTDs are strictly more expressive than DTDs.
As a matter of fact, it can be decided in exponential time whether a given SDTD is equivalent to one that satis es EDC.
Unfortunately, this complexity bound is also tight [13, Theorem 14].
The importance of the above theoretical characterization stems from the fact that inexpressibility results can be formally proved rather than vaguely stated.
For instance, a shortcoming recently attributed to XSDs is their inability to express certain co-constraints [17].
An example of such a co-constraint is: a store-element can only have a dvd-element with discount child if it also has a dvd-element without a discount child.
Using the ancestor-guarded sub-tree exchange property, it is very easy to formally prove that this co-constraint cannot be expressed with XSDs.
Indeed, the counterexample is constructed from t1 in Example 1 by replacing its  rst subtree by the  rst subtree of t2.
Although the subtree exchange property characterizes the classes of XML documents de nable by XSDs, it is more a means to show that schemas are not de nable.
Therefore, the average user would bene t from a simple speci cation language allowing to express desired schemas in a transparent way.
The conducted practical study reveals that the vast majority of non-local XSDs lets types depend only on the parent context.
We therefore propose a framework in which such dependence can be made explicitly.
The framework is related to the paradigm upon which languages like Schema-tron [19] and DSD [10] are based (contextual patterns).
We combine the latter with non-recursive typing.
The main difference, however, is that our framework is equivalent to the expressiveness of XML Schema: every such schema can be translated into an XSD.
We discuss in Section 4.3 how to transform the framework into a workable form.
To ensure maximal  exibility, in a  rst stage, we only use patterns in an abstract way.
Therefore, let P be a pattern language (e.g., XPath, regular expressions,.
.
. )
de n-ing unary patterns.
That is, each pattern     P associates with every tree a set of selected nodes.
For instance, the XPath expression //hobbit de nes the pattern that selects all hobbit-elements.
We denote the set of nodes selected by   on t by  (t).
Let   and Types be  nite alphabets of element and type names, respectively.
Definition 2.
A P-schema is a triple S = ( , Types, R) where R is a  nite set of rules of the form ( ,  )   r. Here,     Types,     P, and r is a regular expression over  .
The semantics of a P-schema is de ned in two phases: (1) checking conformance w.r.t.
the grammar; and (2) assignment of types (also referred to as schema-validity assessment in [26]).
Definition 3.
A tree t is valid w.r.t.
a P-schema S := ( , Types, R) if the label of every node belongs to   and for every node v of t there is a rule ( ,  )   r such that v    (t) and the children of v match the regular expression r.
If there is only one rule ( ,  )   r such that v    (t), v is assigned the type  .
In examples, we use the short hand a   r to de ne the rule (a, //a)   r specifying that the children of every a-element should match regular expression r.
Example 5.
In the current framework, using XPath as a pattern language, the SDTD of Example 3 is equivalent to the following schema: store   regulars discounts regulars   dvd  discounts   dvd dvd  (regular-dvd, //regulars/dvd)   title price (discount-dvd, //discounts/dvd)   title price discount Here, Types = {discount-dvd, regular-dvd}.
Intuitively, a dvd element is a regular-dvd (discount-dvd) when its parent label is regulars (discounts); its content model is then determined by the regular expression title price (title price discount).
For clarity we used the types regular-dvd and discount-dvd rather than the cryptic types dvd1 and dvd2 of Example 3.
Clearly, the patterns //regulars/dvd and //discounts/dvd are disjoint.
Hence, a unique type can be assigned to every dvd element Remark 1.
De nition 3 does not require that each node has a unique type.
If unique types are desired one can add the requirement that  (t)    (t) =   for all patterns  ,   related to the same tag and all trees t. For most pattern languages occurring in practice, it can be statically checked whether this requirements holds, e.g., for XPath cf.
[20].
Hence, automatic tools can be developed to assist schema development.
Alternatively, one can assign natural numbers to rules re ecting priorities in case of con icts.
Example 6.
The P-schema equivalent to the SDTD of Example 4: a   b + c b   e d f c   e d f d   g h i h   j (j1, //b//j)   k l (j2, //c//j)   m n Also in this case, types can be uniquely attributed.
Obviously, DTDs are P-schemas where every rule is an  rule and the type of an element corresponds to its name.
It remains to discuss how the above framework relates to single-type SDTDs, our abstraction of XSDs.
Therefore, let R denote the class of regular expressions for  strings.
Regular expressions   can be used as unary patterns in the following way:   selects those nodes v on a tree t whose sequence of labels on the path from the root to v satis es  .
We refer to the latter string as the ancestor-string of v (cf.
Figure 6).
The last two rules in the R-schema equivalent to the P-schema of Example 5 then become (regular-dvd,     regulars   dvd)   title price (discount-dvd,     discounts   dvd)   title price discount Here,   denotes the set of all  strings.
In [13, Theorem 11], it is shown that the class of R-schemas corresponds precisely to the class of schemas represented by SDTDs satisfying EDC.
In other words, the in-stantiation of the general framework with regular expressions over ancestor-strings can be used as an alternative syntax for XML Schema.
XML experts already noticed that XSDs allow to express dependence of content models on ancestors (cf.
[29]).
However, the above characterization shows that this dependence can be extended to regular expressions over the ancestors and, moreover, that it cannot be extended any further.
Actually, in [13], we did not introduce a general framework, but considered ancestor-guarded DTDs.
We illustrate the translation of R-schemas into single-type SDTDs by means of an example.
In general, the resulting SDTD can be exponentially larger.
However, judging from the complexity of found XSDs, this will seldom be the case in practice.
The schema of Example 5 translates into the following SDTD:6 store( , )   regulars(reg, ) discounts( ,disc) regulars(reg, )   (dvd(reg-dvd, ))  discounts( ,disc)   dvd( ,disc-dvd) (dvd( ,disc-dvd))  dvd(reg-dvd, )   title( , ) price( , ) dvd( ,disc-dvd)   title( , ) price( , ) discount( , ) The translation algorithm  rst converts every pattern to a deterministic  nite automaton.
Then it constructs the product automaton A of all obtained automata in the standard manner.
We use states of A as types for the SDTD.
The initial state of A is assigned to the start symbol of the SDTD and every symbol b occurring on the right-hand side of a rule with left-hand side as is replaced by bs  where s  is the state reachable from state s by reading a b.
In this example, we convert the pattern //regulars/dvd to the automaton A1 depicted in Figure 7.
Note that the latter automaton is optimized w.r.t.
the strings that can occur as paths in derivation trees of the SDTD.
The automaton A2 corresponding to //discounts/dvd is similar.
As an example of the type assignments, the initial state of A1   A2 is assigned to the start symbol store.
Then, as A1 enters state reg when reading regulars and A2 remains in its initial state, we assign state (reg,  ) of A1   A2 to regulars.
Removing the types for elements having only one type then results in the SDTD equivalent to that of Example 3.
    {regulars} regulars dvd   reg reg-dvd Figure 7: An automaton representing the pattern //regulars/dvd.
The usefulness of an XML schema language requires more than a thorough understanding of its expressiveness.
Therefore, we discuss in the present section how we can migrate R-schemas into a full  edged schema language.
Rather than proposing yet another schema language we stipulate how existing languages and proposals can be adapted.
 ned by regular expressions.
Several approaches guided by our practical study are conceivable.
We suggest a two-pronged approach: on the one hand an extension to the DTD speci cation for those most comfortable with this formalism which probably includes inexperienced or new users, on the other hand an extension of XML Schema more suited for power users.
However, these seemingly di erent approaches converge behind the scenes since schemas developed both according to the DTD extension as to the XML Schema extension can be translated into an XSD valid with respect to the current XML Schema speci cation.
We discuss both proposals in more detail.
The most direct approach is to extend DTDs to the formalism of R-schemas as exempli ed in Example 7.
Instead of regular expressions, one could allow  linear XPath  expressions, incorporating only the axes child and descendant.
The results mentioned in Section 3 suggest that the latter expressiveness would be su cient to structurally capture the XSDs occurring in practice, though the power of full regular expressions is needed to capture all of XML Schema.
Example 7.
The real world XSD of Example 4 can be rewritten as the following extended DTD: <!ELEMENT a (b | c)> <!ELEMENT b (e, d, f)> <!ELEMENT c (e, d, f)> <!ELEMENT d (g, h, i)> <!ELEMENT h (j)> <!ELEMENT "//b//j" j1 (k, l)> <!ELEMENT "//c//j" j2 (m, n)> It is clear that the representation in Example 7 is much more compact than the corresponding XSD, and that duplicate de nitions have been avoided altogether.
Note that the evaluation of the linear XPath expression starts at the document root and that only the child and descendant axes are used.
Hence one can limit oneself to the abbreviated syntax ( /  and  // ) which substantially contributes to the transparency of the expressions.
To alleviate the problem of the very limited set of data types in DTDs, we propose the addition of the simple data types as de ned in the XML Schema speci cation [27] for attributes and text.
As we are not the  rst to propose an extension of DTDs for expressing schemas for XML, we do not further go into details here.
Already two such proposals for extensions of DTDs exist [24, 28].
Both focus heavily on the addition of data types to DTDs.
The former (DTD++
 the best of our knowledge we are the  rst to justify such a proposal both by a practical study and a theoretical analysis.
Indeed, in strong contrast to DTD++ 1.0, restriction to R-schemas can structurally de ne all XSDs.
A super cially similar approach is taken in the speci cation of DTD++ 2.0 [8], however, the focus is entirely different.
The emphasis in DTD++ 2.0 is on the expression of co-constraints so that the resulting speci cation exceeds the expressive power of XML Schema.
Indeed, DTD++
 strictly more expressive than XML Schema and that requires a transformation of the XML documents prior to validation.
Our approach avoids the overhead of translating XML documents and leverages the use of existing XML Schema implementations and tools.
As illustrated in Section 4.2, the above proposed extended DTDs can automatically be translated into equivalent XSDs.
This translation introduces many cryptic types (states of an automaton) so that it may be very di cult for a user to understand and also edit the resulting XSD.
Such post processing might sometimes be needed, e.g., to add key/keyrefs, or to rename types.
In that case, we can restrict to a limited vocabulary (parent, grandparent, greatgrandparent and ancestor) as opposed to linear XPath or regular expressions, that can be translated into more transparent types and is nevertheless su ciently powerful to express all context dependencies found in the corpus we analyzed.
This would facilitate the development of true round-trip editing software between extended DTDs and the generated XSD where the overall structure of the XML documents can be speci ed in the form of an extended DTD while nuts and bolts details can be  eshed out in the generated XSD.
The second option is to extend the XML Schema speci cation in such a way that element type de nitions are context dependent.
A syntactic approach using conditional alternatives similar to SchemaPath [17] is suggested.
However, rather than full XPath expressions, conditions would be limited to linear XPath (or general regular expressions) so that the expressive power of XML Schema is not exceeded as was discussed in the previous paragraph.
Whereas the extended DTDs are more expressive than traditional DTDs, extended XML Schemas provide only syntactic sugar to ease the development and make XML Schema more legible and easier to maintain since a lot of de nition duplications can be eliminated.
Example 8.
The essential fragment of Example 4 rewritten as an extended XSD: <xs:element name="j"> <xs:alt cond="//b/j" type="j1"/> <xs:alt cond="//c/j" type="j2"/> </xs:element> Example 8 shows a conditional element de nition: element j is of type j1 (j2) if it has a b (c) parent.
As mentioned before, the expressive power of SDTDs (and Relax NG) corresponds to the well-understood and very robust class of regular tree languages.
However, this expressive power comes at a price.
Although it can be determined in linear time whether a tree satis es a given SDTD, the way to do that is sometimes at odds with the way one would like to process XML documents.
More concretely, it requires to process documents in a bottom-up fashion where the type(s) of an element is only determined after reading its content.
In the context of streaming XML data or for SAX based processing, i.e., when processing an XML document as a SAX-stream of opening and closing tags, it is more desirable to determine the type of an element at the time its opening tag is met.
If an SDTD ful lls this requirement we say it is
 admits 1PPT.
Consider the example a   b1 + b2, b1   c, b2   d and the document <a><b><d/></b></a>.
The type of b depends on the label of its child.
It is hence impossible to assign a type to b when its opening tag <b> is met, i.e., without looking at its child.
An alternative formulation of 1PPT is that the type of an element cannot depend on anything occurring in document order after that element.
Hence, we require that a type is uniquely determined by the preceding of an element (cf.
Figure 6).
On top of one-pass typability, this notion therefore also enforces a unique type to every element.
The latter is, for instance, not the case for Relax NG which allows ambiguous typing.
In the XML Schema speci cation as well as in research papers various kinds of constraints have been de ned that enable e cient validation and typing of XML documents.
Although it is hardly made precise what this should mean exactly, one might argue that the intention roughly matches our notion of 1-pass preorder typability.
It should be noted here that 1PPT is a semantical notion, while the proposed notion of single-type SDTDs, for instance, is a syntactic one as its de nition refers to syntactic restrictions of the schema rather than to the documents themselves.
However, 1PPT is a robust notion precisely because it is semantic: it de nes the largest class of SDTDs that can be typed when processed in a streaming fashion.
In the following we argue that the single-type restriction (EDC) is too ad-hoc, formalize 1PPT by means of the restrained-competition SDTDs of Murata, Lee, and Mani [14], and propose to replace UPA and EDC by 1PPT to get a more robust notion of typing.
In Section 6, we generalize the analysis for the current proposal of XSDs to 1PPT schemas.
In particular, we characterize the expressiveness of 1PPT schemas and present a purely syntactical framework with corresponding express-ibility based on P-schemas.
First, we discuss validation and the constraint on deterministic content models in the context of DTDs.
Validation of a document against a DTD simply boils down to testing local consistency: does the string formed by the labels of the children of every a-labeled element satisfy the associated regular expression r?
No notion of typing is available.
To ensure e cient validation, regular expressions in right-hand sides of rules are required to be deterministic [25] (also referred to as one-unambiguous [3]).
Intuitively, a regular expression is deterministic if, when processing the input from left to right, it is always determined which symbol in the expression matches the next input symbol.
We discuss the latter notion a bit more formally as it returns in the speci cation of XML Schema in the form of the Unique Particle Attribution rule.
For a regular expression r over elements, we denote by r the regular expression obtained from r by replacing every ith a-element in r (counting from left to right) by ai.
For example, when r = (a + b) ac(b + c) , then r simply is (a1 + b1) a2c1(b2 + c2) .
Definition 4.
A regular expression r is one-unambiguous i  there are no strings waiv and wajv  in L(r) so that i 6= j.
The restriction to deterministic regular expressions is heavily criticized (cf., e.g., p. 98 of [23] and [12]) as it does not serve its purpose: even for unrestricted regular expressions e cient simple validation algorithms exist.
Further, the constraint is semantical in nature, and therefore it is di cult for the average user to assess whether a given regular expression is deterministic or not.
To date, no transparent syntactical equivalent counterpart is known.
As noted by Murata et al. [14], the EDC rule induces a simple top-down validation algorithm which assigns to every element with a symbol a a unique type ai.
The algorithm proceeds as follows: The unique type is assigned to the root; for each interior node u with type ai, it checks whether the children of u match the right-hand side of ai   r, ignoring all types; if not the tree is rejected, otherwise, as the SDTD is single-type, to each child a unique type can be assigned.
The tree is accepted if this process terminates at the leaves without any rejection.
In [13, Theorem 11], we characterize single-type SDTDs precisely as the class of SDTDs where the type of every element v in a tree pppis uniquely determined by the sequence of labels on the path from the root to v (i.e., the ancestor-string of v, cf.
Figure 6).
Therefore, every single-type SDTD admits 1PPT.
The converse, however, is not true.
Consider for example the following SDTD which is not single-type: a   b1 b2, b1   c, b2   d. Nevertheless, the SDTD admits
 the singleton <a><b><c/></b><b><d/></b></a>.
The rule for a says that the  rst b-child needs to be typed b1 and the second b-child needs to be typed b2.
For each of the b s in the document, it can be easily determined whether it is the  rst or second child of a by investigating its preceding (cf.
Figure 6).
Hence, the notion of single-type SDTDs allows for e cient unique typing, but does not capture the robust class of 1PPT SDTDs.
Apart from EDC, the XML speci cation also mentions the Unique Particle Attribution (UPA) constraint which is a rephrasing of the debatable determinism constraint for DTDs.
Although the constraint does not mention typing explicitly, it does in uence typing in an unexpected but drastic way.
Surprisingly, as explained in Section 5.4, every SDTD which satis es UPA already admits 1PPT.
Murata, Lee, and Mani [14], propose the semantical restriction to restrained competition regular expressions.
Definition 5.
A regular expression r (over Types) restrains competition if there are no strings waiv and wajv  in L(r) with i 6= j.
An SDTD is restrained competition i  all regular expressions occurring in rules restrain competition.
Intuitively, a restrained competition regular expression ensures that when visiting the children of a node from left to right it is always clear which type is associated to each node without seeing its right siblings.
An example of a restrained competition SDTD that is not single-type is given next:   (dvd1)  discounts (dvd2)  store discounts     dvd1 dvd2   title price   title price discount This restriction allows a strictly larger class of schemas than EDC while still permitting a unique top-down left-to-right assignment of types as discussed in the next paragraph.
Note that both the single-type and the restrained competition constraint are local: they restrain the structure of admissible regular expressions.
Unfortunately, EDC is syntactic while restrained-competition is a semantical notion.
Nevertheless, deciding whether an SDTD is restrained competition can be done in polynomial time [13, Theorem 13].
In Section 6.2 we generalize the framework of Section 4.2 to get an equivalent but syntactical language for restrained competition SDTDs.
We discuss typing of restrained competition SDTDs.
The ancestor-sibling string of an element is the string of ancestors of the element, and their left siblings (cf.
Figure 6).7 We say that an SDTD has ancestor-sibling-based types if the type of an element in a tree only depends on its ancestor-sibling string.
In [13, Theorem 12], we characterize restrained competition SDTDs exactly as the class of SDTDs with ancestor-sibling-based types.
One of the most remarkable results of [13, Corollary 10] is that the SDTDs satisfying 1PPT are exactly the restrained competition SDTDs.
Hence, the latter can serve as a concrete instantiation of the semantical concept of 1-pass pre-order typing.
A remarkable consequence is that in a streaming context, for any 1PPT SDTD, documents can be validated and typed in a 1-pass preorder fashion only using memory of size O(|d|), where |d| is the maximum depth of the document that is being validated.
The validation algorithm is then the preorder version of the algorithm sketched in Theorem 5.1 of [21].
Although the XML Schema speci cation allows typing in multiple passes (Section 5.2 in [26], note on multiple assessment episodes), we now show that, even without the EDC constraint, 1PPT is always enforced by the UPA constraint.
An SDTD satis es the UPA constraint when for every regular expression r over Types we have that el(r) is one-unambiguous (cf.
De nition 4), where el(r) denotes the expression obtained from r by replacing every type ai by the element a.
We argue by means of a concrete example that any SDTD satisfying UPA is restrained competition, and therefore, admits 1PPT.
Suppose that r = a1?b1(b1 + c1) a2c1.
Then, el(r) = a?b(b + c) ac and el(r) = a1?b1(b2 + c1) a2c2.
Clearly, el(r) is one-unambiguous, which means that when we match, e.g., bbcbac against el(r), the symbol against which the a must be matched (a2 in el(r)), is uniquely determined without looking ahead.
But then, the symbol in r that corresponds to a2 is also uniquely determined, and this symbol has only one type.
So we also know what type must be assigned to a without looking ahead to c. It is easy to generalize this example to show that any SDTD satisfying UPA is also restrained competition.
The converse, however, is not true.
A counterexample is the expression r = (a1 + b1) a1(a1 + b1).
Indeed, when matching a string against this expression, we always know that we need to type a and b by a1 and b1, respectively.
However, the expression el(r) = (a + b) a(a + b) is not one-unambiguous.
Indeed, a1a2a3 and a2a3 are both in L((a1 + b1) a2(a3 + b2)).
In [3] it is even shown that el(r) can not be de ned by any one-unambiguous regular expression.
To summarize, we propose to replace the UPA and EDC constraint in the XML Schema speci cation by the robust notion of 1PPT.
The latter guarantees a large and robust class of schemas that can be uniquely (unambiguously) and e ciently typed.
A local semantical de nition in terms of
 other by additional symbols.
t1
 v1 t 
 t2 v2 t 
 t1
  
 v1 t 
 Figure 8: Ancestor-sibling-guarded subtree exchange.
the restrained competition regular expressions of Murata, Lee, and Mani can be adopted.
Next, in Section 6.2, we present a purely syntactical front-end for 1PPT which is a natural instantiation of the framework of P-schemas in Section 4.2 capturing all one-pass preorder typable SDTDs.
We provide the same kind of analysis for 1PPT SDTDs as we did for single-type ones.
In particular, we provide a mechanism to show that certain schemas are not expressible by 1PPT SDTDs and instantiate the framework of P-schemas to get an equivalent syntactical counterpart.
Just like for DTDs and SDTDs satisfying EDC, there also exists a characterization of the sets of XML documents de n-able by SDTDs admitting 1PPT ([13, Theorem 12]).
Indeed, a regular set T of documents is de nable by a 1PPT SDTD if and only if it is closed under ancestor-sibling-guarded sub-tree exchange.
The latter property is de ned as follows (cf.
Figure 8): if two documents t1 and t2 are in T , and there are two nodes v1 in t1 and v2 in t2 with the same ancestor-sibling string, then the trees obtained by exchanging the subtrees rooted at v1 and v2 are also in the set T .
The language we considered in Example 1 is not de nable by an SDTD admitting 1PPT.
Note that the counterexample can be constructed in exactly the same manner.
Just as for EDC, given an arbitrary SDTD it is decidable in exponential time whether there exists an equivalent SDTD admitting 1PPT.
This upper bound is also tight [13, Theorem 14].
To raise the expressiveness of the framework proposed in Section 4.2 to the level of 1PPT SDTDs, we need an adequate pattern language.
To this end, let R  be the class of regular expressions over symbols a[r] where r is a regular expression over element names and a is an element name.
For instance, (a[a + b ] + b) a[b ] belongs to R .
We simply write a for a[ ].
We note that the given expression uses the three symbols a[a + b ], b[ ] and a[b ].
The intuition is that a[r] matches node v when v is labeled with a and the string formed by the labels of the left siblings of v match r.
We explain how general regular expressions can be used as unary patterns.
Let a1w2a2       wnan be the ancestor-sibling string of node v in tree t, such that a1       an are the labels on the path from the root to v. So, the root of t is labeled a1 and v is labeled an, and wi is the sequence of labels of left siblings of ai (from left to right).
Node v is selected by pattern   i  there exists a string a1a2[r2]       an[rn]   L( ) such that for every i = 2, .
.
.
, n, wi   L(ri).
In other words, for each symbol ai[ri], ri constrains the left siblings of the element ai.
Example 9.
Using R  as pattern language, we can de ne the SDTD in Section 5.3 in the following way: store discounts (regular-dvd, store dvd[dvd ])   title price (discount-dvd, store dvd[dvd  discount dvd ])   dvd  discounts dvd        title price discount In [13, Theorem 12] it is shown that the class of R -schemas corresponds precisely to the class of schemas represented by SDTDs satisfying 1PPT.
In other words, the instantiation of the general framework with regular expressions over ancestor-sibling-strings is an alternative syntax for all SDTDs admitting 1PPT.
In [13], we considered ancestor-sibling-guarded DTDs which are equivalent to R -schemas.
As in Section 4.3, we can adopt two approaches: extend DTDs or extend XML Schema.
To capture 1PPT SDTDs it su ces to add R patterns.
A more practical way is to add full XPath, but semantically restrict its evaluation to the preceding of each node (cf.
Figure 6).
For instance, the expression //*[.//b]//c selects only those c-elements having a b-element in their preceding as illustrated in Figure 9.
a d c b c d Figure 9: Only the circled c-element in the document has a b-element in its preceding.
The exchange property for single-type SDTDs and the framework of R-schemas provides insight into what can and cannot be expressed on a structural level by the current de- nition of XML Schema.
In future work, we plan to implement a concrete pattern based schema language as discussed in Section 4.3.
Although already an abundance of schema languages for XML has been proposed, we believe that a lightweight front end for XML Schema is bene ciary for less experienced XML users (as, e.g., in the bioinformatics community [5]).
Although we think the restriction to unambiguous typing increases transparency and e ciency of validation, the recommendations in the present paper do not justify the former.
For instance, Relax NG as well as the formal model for XML Schema of Sim eon and Wadler [22] allow ambiguous typing to relieve users from opaque restrictions.
However, if unambiguous typing is required, it should not be enforced by ad-hoc restrictions, but by the most liberal ones.
We believe the restriction to 1-pass preorder typable schemas is adequate.
Moreover, it can be reached by allowing restrained competition regular expressions.
Further, we provided an equivalent syntactic framework in terms of R -schemas.
