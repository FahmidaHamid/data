The number of Web services available on the Internet is growing very fast, some of which are functionally equivalent.
Functionally equivalent services should be interchangeable [15].
However, such services are often o ered using different interface and business protocol speci cations.
Service interface de nes the set of operations that the service provides along with message formats and data types.
Business protocol speci es the order in which operations of a service  Most of the work was done when the author was at the University of New South Wales, Australia Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
can be invoked [2].
These di erences exist despite having standard languages (e.g., WSDL and BPEL) to describe services speci cations.
Indeed, these languages only provide generic constructs, and using them to de ne functionally equivalent services by independent teams results in potentially di erent speci cations (may exhibit interface and protocol-level mismatches) [10, 27].
The problem of Web service matching and adaptation has received signi cant attention recently [5, 3, 31, 17, 14, 23, 8,
 classes of mismatches between service interfaces and protocols and suggest operators or templates for adapter developers to resolve mismatches in each class.
Existing automated approaches for service matching and adaptation focus either on the interface-level (e.g., [36, 38, 13, 31]) or the protocol-level (e.g., [3, 8, 37, 28]).
We argue that when matching service speci cations, interface and business protocols should not be treated independently.
Matching protocol speci cations in isolation ignores mismatches at the interface level.
And correct matchings at the interface level could be speci ed more e ectively considering the ordering constraints that business protocol de ni-tions impose.
For example, Figure 1 shows the operation and protocol de nition of two real-world services XWebCheck-out and Google Checkout APIs.
Considering only the interface information, in a compatibility checking scenario [6,
 Noti cation in Google checkout APIs compared to Place-Order message.
Adding the protocol de nition information (here mainly the directions of messages  incoming/outgoing  shown by  + / - ), the outgoing message AddOrderRequest can only match with incoming Place-Order (remember the compatibility scenario) but not New-Order-Noti cation which is an outgoing message.
As additional evidence, these two messages are in the same depth from the start state of the protocol encoded in state machines.
Taking into account the protocol information makes the service interface matching more precise, productive and e -cient.
This is due to the elimination of a signi cant number of false positives compared to when using only XML-based interface information.
High false positive ratio is a common issue in XML schema matching [4].
Identifying false positives is a labor-intensive and time-consuming task for users.
As another issue, automated methods for service interface matching (including our previous work [28]) consider one-to-one matching of messages.
A common class of matching between interfaces is one-to-many matches (also called message merge/split mismatch) where one message in an inter-speci cations of a number of real-world and synthetic Web services.
The result of the interface-only matching approach reveals that a major issue is false positives.
Reducing the false positive rates is important as the highlighted match-ings need to be considered by adapter developers one-by-one.
Our protocol-aware interface matching approach proves effective in reducing the rate of false positives signi cantly and therefore leads to a considerable increase in the quality of matching between service interfaces.
Note that in this paper we focus on matching service interfaces and protocols.
For methods related to interface mapping and service adapter development refer to [28, 39].
We have also discussed the feasibility of adapter development for given service speci cations and adapter development in [23].
The paper is structured as follows.
In Section 2, we present background de nitions and problem statement.
Section 3 introduces the method for identi cation of message merge/split mismatches.
Section 4 presents our protocol-aware interface matching algorithms.
In Section 5, we describe implementation and experimental results.
Section 6 discusses the related work, and we conclude and present future work in Section 7.
We present a real-world example1, which is also used as a running example to illustrate the proposed approach.
Let us consider an adaptation task for services in the management of shopping carts.
XWebCheckOut2 and Google Checkout3 are commercial checkout services.
The two services o er similar functionalities, but through di erent interfaces and protocols.
They provide facilities for sellers to manage the orders that they receive on their own websites.
The only major di erence between these two services is that Google Checkout also provides an administration website for buyers (people who do shopping on sellers  websites).
Buyers register their details with Google and manage their orders through that website.
In XWebCheckout, sellers provide administration support for buyers in sellers  websites.
Some APIs are provided by XWebCheckout to facilitate this task, for which there is no counterpart in Google APIs.
XWebCheckout and Google Checkout services provide similar APIs for order creation and management, payment processing, and order cancellation.
However, there are di er-ences in the interface de nitions (message names, number, and types) and how each service expects to exchange messages to ful ll a functionality.
For example, Figure 1 shows the protocols of the two services for placing an order.
One of the main issues to be addressed for the purpose of adapter development is  nding the matching between the interfaces of the two Web services, e.g., to  nd out that AddOrder-Request is the corresponding message to Place-Order in Figure 1.
For this purpose, considering only the XML schema de nitions of these two services is not enough, as in this case AddOrderRequest would be a better match for New-Order-Noti cation.
Indeed, we need to consider the opera-
tency of the overall approach
 3http://code.google.com/apis/checkout/ Figure 1: The operations and the corresponding protocols of CO Client (XWebCheckout) and Google checkout APIs for placing an order.
face is matched to more than one in the other [3, 14].
In this paper, we present a new method for semiautomatic identi- cation of the message merge/split class of interface-level mismatches.
We also propose a protocol-aware approach for Web service interface matching.
Speci cally, we introduce the following methods:   Message merge/split mismatch identi cation.
When matching two service interfaces, this method identi es if a given message in one interface is matching (parts of) more than one message in the other WSDL interface.
This method extends the static approach for interface matching in our previous work [28] by leveraging XML schema matching algorithms [32, 11, 12].
The innovation is in identifying candidates for message merge/split in the two interfaces.
  Depth-based interface matching.
This method extends the static approach by incorporating the depth (the number of steps from the initial state of the protocol) in which each message is de ned in the business protocol.
This is heuristic-based and the intuition behind it is that messages with the same or close depths in the business protocols may have a higher chance of matching.
The method reinforces the similarity score of messages appearing in the same (or similar) depth in the business protocol.
  Iterative reference-based interface matching.
This method incorporates the knowledge of previous matchings to reinforce or penalize the score of not-yet matched (candidate) message pairs.
It is iterative, and in each iteration a pair of messages is selected as the best candidate match.
This pair is referred to as a reference pair for the next iteration.
Based on knowledge of the reference pair, we update the similarity scores of other candidate matching message pairs.
Updating the scores (penalizing or reinforcing) is performed considering the relative position of a matching candidate compared to the reference pair in the business protocol.
The reinforcement process propagates the similarity score of the reference pair into those of their neighboring candidate match that are not in con ict with the reference pair, and penalizes the similarity scores of a message pair that could lead to deadlock in service interactions (is in con ict).
as constraints de ned on operation invocation (and directions) at the protocol level.
We  rst revisit the de nition of the most common mismatch classes at the service interface level [3].
Let us denote by SP the service provider and SC the service clients to be adapted: (i) message signature: message m in SP (corresponding to the request of a certain functionality4) has a di erent name and/or data types in the interface of SC; (ii) message split/merge: Message m in SP corresponds to (can be invoked by combining) messages m1, m2, ..., mn in SC, or vice versa;(iii) missing/extra messages: One or more messages in SP do not have any correspondence in SC, or vice versa.
To make the paper self-contained, we give the de nition of the interface and interface mappings  rst presented in [28].
The de nition of interface I of a Web service S, denoted by Is, is a simple formalization of WSDL: De nition 2.1 (Web service interface).
A Web service interface Is is a triplet P = (D, M, O), where D is the set of (XML) data types of the service, O is the set of operations supported by the service, and M is the set of messages exchanged as part of operation invocations, in which   a message m has i parts (i   1), represented as m =< d1, d2, ..., di >, m   M, dj   D, 1   j   i   o = (cid:104)mreq, mres, mf(cid:105), that is, o   O is an operation associated to at least a request message mreq or to a response message mres (or both) and optionally a fault message mf .
For simplicity we write m   Is equivalent to m   Ms. We de ne the mapping between two Web service interfaces Ic and Is as follows: De nition 2.2 (Interface Mapping).
Given interfaces Is = (Ds, Ms, Os) of service Ss and Ic = (Dc, Mc, Oc) of service Sc, an interface mapping IM<s,c> from Is to Ic is a set of functions such that: m   f unc(X), m   Ms and where the input X is either a set of messages {m(cid:48)|m(cid:48)   Mc} or a set of constant values.
The interface mapping IM<s,c> may contain more than one mapping function for a given message m   Is, or may not contain any function for another message m(cid:48)   Is.
This de nition allows for specifying one to one (1   1) mappings (to model message signature mismatch) and one to many (1 n) mappings (modeling message split/merge mismatch).
We use Ps and Pc to denote the protocol de nitions of provider Ss and a client service Sc, respectively.
We adopt  nite state machines (FSM) as the modeling formalism for business protocols [2].
The problem we tackle in this paper can be stated as that of providing semi-automated support for identifying match-ings between service interfaces for the purpose of adapter development starting from service interfaces, Is and Ic, and protocol de nitions, Ps and Pc of services S and C. The
 operation (its reply, respectively).
main challenges of tackling this problem include providing e cient and e ective protocol-aware approaches for matching of Web service interfaces, and identi cation of correspondences and mismatches at the interface level.
We de ne the problem as follows: Problem 2.1 (Service Interface Matching).
Interface matching for Is to Ic refers to identifying the correspondences between messages in Is and Ic, i.e., the set X   Mc of parameters of the function f unc(X) for generating m   Ms in function m   f unc(X), and vice versa for Ic to Is.
Note that during the interface mapping, the body of the interface mapping functions m   f unc(X) are implemented.
The identi cation of the set X, i.e., interface matching, is the most important step in specifying f unc(X).
In the following, we present novel methods for  nding the set of parameters for f unc(X).
WSDL interface de nitions are XML documents, and the type of data exchanged by messages are de ned using XML schema.
We presented a method for 1   1 matching of (WSDL) service interfaces in [28] by leveraging XML schema matching algorithms [32, 33].
This approach considers the structure of WSDL documents, i.e. the operations and their input/output de nitions as well as XML schema de nitions.
It extracts the schema de nition for each input/output message.
Then, it matches the XML schema of pairwise messages in two interfaces and generates a similarity score between messages.
In addition to the XML schema of messages, we take into account message names, and whether a message is input or output of an operation as it reduces the number of required pairwise message matchings.
In this paper, we propose a new method for the identi cation of mismatches of type split/merge (1   n).
In 1   n matching, some schema elements of a message m   Is(Ic) are matched with elements m(cid:48)   Ic(Is) and some other elements of m are matched with some elements in m(cid:48)(cid:48)   Ic(Is), etc.
Messages m(cid:48) and m(cid:48)(cid:48) are called component messages of m denoted by m(cid:48) (cid:46) m and m(cid:48)(cid:48) (cid:46) m. In general, we may have many-to-many (p   q) matching in which elements of p messages in one interface are matched with the elements of q messages in the other interface.
Here, we focus on the identi cation of component messages of a given message for message split/merge mismatch class, i.e., 1   n matching.
Algorithm 1 shows the proposed method.
Given interfaces Is and Ic, we look for any messages m1, m2, ..., mn   Is such that m1, m2, ..., mn (cid:46) m(cid:48), m(cid:48)   Ic (or reversely from Ic in Is).
Let m1   Is be a candidate message that we want to see whether m1 (cid:46) m2   Ic.
We apply two heuristic criteria to  nd component messages.
The  rst criterion makes sure that the similarity score of m1 and m2 (denoted as S(m1, m2)) is above a threshold t1 so that there is a likelihood of matching between two messages.
The threshold t1 is speci ed according to the matching algorithm that is used in experiments (see Section 5.2).
The second criterion makes sure that a signi cant number of elements in m2 (a default heuristic is more than half, but is con gurable) are matched with those of m1.
If there are more than two messages that are identi ed as components of m1, then it is told that there is a mismatch of type split/merge.
Note that the the schema matching algorithm used in 1   1 matching (see Section 5.2 for discussion of options).
Algorithm 1 Split/Merge Mismatch Identi cation Require: WSDL interface Is, WSDL interface Ic Ensure: ComponentList comList




 comList(m1)     for each message m2   I2 do if S(m1, m2, Algo)>t1&& num(M atchingElement(m1, m2))/num(Elements(m2))>c1 then Elements(m1)   Elements(m1) - M atchingElement(m1, m2) comList(m1)   comList(m1)   {m2} end if end for if getSize(comList(m1))   2 then comList   comList   {(m1, comList(m1))}






 end if 13: end for Note that we consider matching of service messages in a pairwise manner.
The granularity of matching message parts is speci ed by XML schema matching algorithms.
The protocol-aware approach incorporates protocol level information into the interface matching process.
We introduce the following two methods:   Depth-based approach for improving the static matching-based similarity score for messages with a same/close depth (the distance of the transition labeled with the message from the initial state) in a protocol, and   Iterative reference-based approach for propagating the similarity score of messages into those of their neighbor messages in the protocols, and also using already matched message pairs as references to reinforce or penalize the similarity scores of messages before and after this pair of messages in the protocol.
It builds on the depth-based method by also considering the depth information in computing the similarity score, and extends the depth-based method in how scores are computed.
The intuition behind the depth-based approach is that messages with similar depths in the two protocols Pc and Ps are more likely to match.
This heuristic holds when there are no interface-level mismatches between protocols and the two business protocols are compatible (see [2, 6] for protocol compatibility discussion).
We expect this heuristic to hold to a large degree when the protocols belong to functionally compatible services, for which adapter development is a viable solution compared to developing a new client from scratch (see service adaptation feasibility discussion in [23]).
As an example, Figure 2 shows simpli ed protocols of CO Client and Google Checkout APIs.
Messages AddOrder and PlaceOrder which are in the same depth of 1 are more Figure 2: The simpli ed protocol speci cations of CO Client and Google checkout APIs associated with respective depth numbering It is useful to consider the likely to be a correct match.
direction of messages, i.e., incoming (+) or outgoing (-) in identi cation of depth, as well.
A protocol may have loops, i.e., transitions recurring back to states closer to the initial state.
To avoid going into in -nite loops for identifying the depth of a message associated to such transitions, we propose to  rst normalize the protocol into a protocol tree in which only self-loops are allowed.
The normalization process involves traversing each transition and checking whether the outgoing transitions for the target state of the current transitions are already labeled with a smaller depth number.
If any of the outgoing transitions matched this criterion, then the normalization process does not continue this path of the protocol.
Then, the depth of a message is speci ed by the number of transitions to be traversed from the initial state s0 to the message m in this treelike representation of the protocol.
In this process, messages of each direction are numbered separately.
For instance, the message -Place-Order gets the number 1  and the message +New-Order-Noti cation the number 1+.
These numbers are relative but do not correspond to the exact depth of a message from the initial state.
In case of self-loop in P (e.g., see message +UpdateOrder in Figure 2), we associate the number 1.5+ to show that it is a self-loop (but not the depth of 2).
Given the depth of messages in the protocol, we update the 1 1 similarity scores of messages in two interfaces.
This process improves the score of each matching considering the depth information as follows.
Let m1   I1 and m2   I2, and
 S(m1, m2) be the similarity score of messages m1 and m2 The improvement weight for the score in the depth-based approach is shown in Equation 1.
scale   maxdepth   |depth(m1)   depth(m2)| maxdepth .
(1) The new score S(cid:48)(m1, m2) is computed as S(cid:48)(m1, m2) = S(m1, m2)   scale.
(2) This ensures that messages with closer depth will be scaled higher in comparison with messages that are further apart from each other.
Note that maxdepth is a constant that de nes the maximum depth obtainable in the protocol for each direction.
This approach enhances the accuracy of the matching compared to the static approach, as veri ed by experiments (see Section 5.2).
s0s1s3s4s5-Place-Order+New-Order-Notification-Charge-Order-Deliver-Orders2-Cancel-Orders 0s 1s 3s 5+AddOrder+ProcessPayment+ShipOrders 2+DeleteOrder+UpdateOrder1+1.5+2+3+2+1-1+2-3-2-s5CO_ClientGoogle Checkout APIsWWW 2010   Full PaperApril 26-30   Raleigh   NC   USA7344.2 Iterative reference-based approach The iterative reference-based approach improves the depth-based approach in two ways: (i) considering additional protocol information including the path in which messages are located in the protocol tree, as well as previous matchings for identifying the similarity, and (ii) relaxing the implicit assumption in the depth-based approach, i.e., that of the similarity of the structure of protocol trees for functionally equivalent services at a global level.
The relaxation is achieved by by allowing the initial matching of message pairs at any levels of the protocol trees.
This method is iterative and in each iteration a pair of messages is selected as the best candidate match.
Assuming it is a correct match (a user could be involved to verify the correctness of the match), this pair is selected as a reference used to update the similarity scores of other yet unmatched message pairs.
The other scores are either reinforced or penalized.
As a pre-processing step, each protocol tree is decomposed into distinct paths.
The best candidate pair of messages is considered a reference matching pair (or reference pair for short) in the same path-pair (see strategies for selecting the references later).
For instance, Figure 3(a) shows two paths from protocols Ps and Pc, respectively.
If message pair  c and +c(cid:48) are the best candidate match, we select them as a reference pair.
A reference pair could be used to reinforce or penalize the other matching candidates in the same path-pair.
The reference-based method re nes the 1   1 message similarity scores by taking into account the following:   Depth-based score improvement.
Similar to depth-based, messages with similar depth in the two protocols P1 and P2 are considered more likely to match (see Section 4.1).
  Propagation of similarities to neighbors of a matching If  c   I1 and +c(cid:48)   I2 are selected message pair.
as a reference pair, then their neighbor message before (after) the reference point are more likely to have a matching to others before (after) +c (respectively,  c(cid:48)) in those paths.
For instance, if c and c(cid:48) represent the matching invoice messages, then it is likely the messages before these messages, which are about quote and ordering, and also messages that are after these in the protocols, e.g., about payment and shipping, are more likely to match with each other, respectively.
The reinforcement is done using a rate that controls the rate at which the reinforcement decays depending on how far the matching messages are from the reference message pair.
  Penalizing con icting matching candidates crossing reference pairs.
Given reference pair +c   I1 and  c(cid:48)   I2 the candidate matching pair  f   I1 and +j(cid:48)   I2 (shown as crossing the solid reference line in Figure 3(b)) is called a con icting match.
This is because  f (an outgoing message) with a bigger depth than +j(cid:48) (an incoming message) leads to a deadlock6 in the interaction of two services in case this matching is allowed.
Therefore, the similarity score of a con icting matching pair is penalized.
6services are mutually waiting inde nitely to receive mes sages from each other Figure 3: Two paths in protocols Ps and Ps.
The reference pair is shown with a solid line.
Propagation of similarity scores to neighbors.
The propagation of similarities to neighbors of a reference pair is achieved through reinforcing the similarity scores of pairs that are not in con ict with the reference pair.
In Figure 3(a), the matching of +b and  b(cid:48), as well as +d and  (cid:48)d are reinforced.
However, the similarity scores of b and d(cid:48) and b(cid:48) and d are not reinforced as their matching lines (if drawn) cross the reference line.
This is logical as Ps expects to receive b before it sends c. On the other hand, considering the matching between b(cid:48) and d, Pc sends b(cid:48) before waiting for c(cid:48), and Ps is waiting to receive d after sending c. There are no con icts between the exchange of these messages and so these two can be a possible match.
However, we do not reinforce or penalize its similarity score.
Penalizing scores of con icting matching pairs.
As mentioned above, a con icting matching pair should be penalized to avoid potential deadlocks in service interactions according to the protocols.
A con icting matching is identi- ed among all candidate matching pairs whose line crosses the reference line by the condition that the message with the  +  sign (say m1) is before the reference message mref 1 (with  -  sign ) in the path and the message with the  -  sign (say m2) is after the reference message mref 2 (with  +  sign) in the path.
For example, in Figure 3(b) the matching of +j(cid:48) and  f (shown with a dashed line) satis es this condition and therefore is penalized.
Note that not all crossing matching candidates are penalized.
For instance, in Figure 3(c) the matching candidate pair +t(cid:48) and  v are not penalized although +t(cid:48) is in a smaller depth compared to  v.
This is because of the direction of  c in the protocol path Ps.
Indeed, this case identi es mismatch of type unspeci ed reception, which can be handled as a subclass of ordering mismatch patterns (a protocol-level mismatch) in the adapter [3, 28].
Similarly, the similarity score of  e with +x(cid:48) in Figure 3(c) is not penalized.
In general, if we have crossing matches for which the message with  -  sign is above the reference message pair and  +  is below the reference message, it is not penalized (as an adapter can receive the message with  -  sign and store it in the adapter for future use).
The success of this approach is directly related to the selection of reference pairs, and whether they are correct.
We discuss this aspect next.
Reference message selection.
We introduce two methods for the selection of a reference pair: (i) Automated reference selection: In each iteration the pair with the highest 1 1 similarity score between the two interfaces is selected as the reference and the similarity scores of others are updated, and (ii) User-driven reference selection: In each iteration, s0s1s2s3s 0s 1s 2s 3s0s1s2s3s 0s 1s 2s 3+b-c+d-b +c d PsPcPsPc-h+c-f+j c +s (a)(b)s0s1s2s3s 0s 1s 2s 3PsPc-e-c-v+t +c +x (c)(a)(b)(c)WWW 2010   Full PaperApril 26-30   Raleigh   NC   USA735the best candidate matching pair is selected and presented to the user for his/her feedback on the correctness of the match as well as reference selection.
Based on the user feedback, the similarity scores are updated and the next reference is selected.
In the automated reference-selection the success of this approach depends on the quality of the matching algorithm.
The user-driven reference selection greatly improves the accuracy and e ectiveness of matchings (see Section 5.2).
Algorithm 2 Iterative Reference-based Interface Matching Require: mList1, mList2 Ensure: mrList

 3: while mp (cid:54)=   do 4: mref 1   mp.m1, mref 2   mp.m2



 for each m2   mList2 do for each m1   mList1 do mr   getMatchResult(m1, m2, mrList) dif f m1.depth),abs(mref 2.depth- m2.depth)) rate   1 + (maxdepth   dif f )/maxdepth if then [(m1, m2) cross (mref 1, mref 2)] and conf lict mr.score   mr.score   1/scale mr.score   mr.score   rate else if m1 (m2) neighbor of mref 1(mref 1) then max(abs(mref 1.depth-






18: end while end if end for end for  

 Algorithm 2 summarizes the iterative reference-based approach.
The short forms of mList refer to list of messages (e.g., mList1 refers to the list of messages in I1), mrList refers to match result list, mp stands for message pair, and mr stands for match result.
In this algorithm, static match scores are computed and reinforced using depth-based approach (line 1).
Then, a reference pair is speci ed using one of the approaches explained above (line 2).
Next, the scores for message pairs leading to deadlock are penalized by multiplying the similarity score by the inverse of scale (line 11), which is computed according to Equation 1.
If the pair of messages are neighbors of reference pairs, their score is reinforced proportionally to the di erence of their depth with those of messages in the reference pair (line 13).
This is done by multiplying their similarity score by the reinforcement rate (computed in line 9).
Afterwards, the algorithm looks for the next reference pair, if any.
The algorithm terminates when there are no further reference pairs to be selected.
Implementation and Dataset Implementation.
The approaches presented in this paper have been implemented in Java 5.0 using Eclipse 3.2 as the programming IDE.
The static interface matching approach in the interface matching component is implemented on top of the OntoBuilder7 library of ontology matching algorithms [29, 12, 18].
OntoBuilder is an automatic schema matching tool based on ontological constructs.
An ontology consists of terms which are linked together with a parent
 or child relationship.
OntoBuilder provides Java APIs that allow programmatic access to its capabilities.
We have extracted individual messages of WSDL documents along with their XML schema and built new schemas to include WSDL contextual information as described in Section 3.
We then convert these schemas into ontologies in OntoBuilder and match them using various builtin ontology matching algorithms, e.g., term-based, graph-based, precedence, similarity  ooding algorithm, and a combined algorithm using all these algorithms at the same time.
In
 matching from OntoBuilder.
We have also compared our algorithms with the approach that uses only schema matching algorithms (in our implementation from OntoBuilder) for service interface matching (reported below).
Dataset.
We have evaluated the proposed methods in both synthetic and real-world scenarios.
The WSDL documents used for the evaluation in the real-world scenarios are obtained from real world web services in two categories: purchase order and shopping card management services (Google Checkout8, XWebCheckout V2 9, Moon Purchase Order Management Service10, Amazon Web Service11 and Amazon E-commerce Service12), and payment services (PayPal Web Service13, PaymentExpress Web Service14, Amazon Flexible Payments Service15).
Some of the WSDL documents have also been modi ed by adding operations and messages in order to evaluate the approach with protocols with various degrees of complexity.
The business protocols are constructed using the information from documentation and implementation guides for those real world web services.
They represent various scenarios such as ones with simple protocols having a few messages (each 3-5 messages with large schemas), complex protocols involving many messages (each up to 15 messages with large schemas), protocols with self-loops, protocols with loops back to states closer to the initial states of protocols and protocols with multiple paths.
The synthetic service speci cations are created by manipulating the real-world service speci cations to validate the e ectiveness of protocol-aware approaches in scenarios not covered by real-world examples.
In particular, we validate the e ectiveness and usage of protocol-aware approaches in cases that 1   1 matching (syntactical) results are correct (where only protocol-level mismatches are present).
We have used a desktop P4 Intel CPU 2.8GHz with 4 GB of RAM to conduct the experiments.
We use the following criteria to evaluate the e ciency and the accuracy of the proposed approaches with each other and existing work.
For the evaluation of accuracy, we use the well-known measures of precision and recall [34].
Precision 8http://code.google.com/apis/checkout





 15https://fps.amazonaws.com/doc/2007-01-
 by the ratio of the correct matches, in terms of message pairs in the two interfaces, to the total number of matches found.
Recall measures coverage of the matching results, and is de ned by the ratio of the correct message pairs matched to the total number of all correct matches of message pairs that should be found.
These two de nitions are summarized in Equation 3 and Equation 4: P recision = number of correct message pairs matched total number of message pairs matched (3) (a) Precision: X-Axis shows the threshold, and Y-Axis shows the precision Recall = number of correct message pairs matched total number of correct message pairs in the two interfaces (4) For an approach to be e ective, it should achieve a high precision and high recall.
However, in reality these two metrics tend to be inversely related [34].
This means that the improvements in precision come at a cost of reduction in recall, and vice versa.
For identifying the set of correct matching between message pairs of two given interfaces, we rely on the judgment of human users.
To evaluate the e ciency of the matching approaches, we measure and compare the time needed to perform the matching of WSDL documents using di erent approaches.
In the evaluation, we refer to the protocol-aware interface matching approach as reference-based, the depth-based approach as depth-based and the static 1  1 matching algorithm as static.
We also compare this result with those of only using a schema (ontology) matching algorithm (without including WSDL context information such as operations) but only matching the whole XML schema of two services at once.
We refer to this approach as schema-based.
We  rst provide the comparison of the above approaches in one representative scenario and then analyze results in others.
Google Checkout and XWebCheckout V2.
Figure 4 shows the result of applying these algorithms averaged on three versions of Google Checkout and XWebCheckout V2 speci cations having simple protocols to a complex one that includes 9 additional operations, taken from other similar services, regarding the purchase order management.
The static schema matching approach, reported here, uses the combined schema matching algorithm in OntoBuilder (with default settings) applying term, graph and precedence evidences for ontology matching.
The chart shows the results for thresholds from 0.1 to 0.6 with an interval of 0.1.
The threshold is applied on the similarity scores, obtained from the schema matching approach in the static approach, and also improved scores in the proposed protocol-aware approaches.
It is used to decide if a pair of messages match.
As can be see from the charts in Figure 4, the general trend of the precision chart is that the precision starts increasing for threshold 0.1 to 0.4.
The precision of the schema based approach is computed using the whole schema of the two services in matching.
The precisions for the schema-based and static approaches start declining from the threshold 0.4, and for others from 0.5.
On the other hand, the general trend of the recall is consistent and decreasing as the threshold increases.
Note that, in general, the precision and recall of static matching are low.
This is due to the heterogeneity (b) Recall: X-Axis shows the threshold, and Y-Axis shows the recall Figure 4: The evaluation of the proposed approaches on Google Checkout and XWebCheckout V2 of the details of XML schemas de ned by Google Checkout APIs and XWebCheckout.
The charts show that using the static approach to divide the schemas of services into those of messages leads to always achieving a better precision and recall compared to the schema-based approach.
The precision of the static approach is increasing for thresholds 0.1 to 0.4, and its recall is constantly decreasing for this range of threshold, but always demonstrates a superior performance compared to schema-based approach.
In addition, the depth-based approach improves the results of static approach for all thresholds as it boosts the similarity scores for the ones that are more likely to match.
Finally, the reference-based approach achieves a better precision than others due to disallowing deadlock cases, and it achieves a superior recall due to the propagation of similarities to the neighbors thus allowing matching message pairs, which are correct, to achieve higher scores.
In general, for the higher thresholds (up to 0.4), the precision increases as the number of matching pairs that are returned also decreases, among which the correct ones are present.
In this evaluation, each reference pair is veri ed by the user meaning that the highest matching pair are suggested to the user as the reference consecutively until a correct pair is selected, then the propagation of similarities is performed.
The unexpected decline in the precision of the static approach after the threshold of 0.4 is because the similarity score values for many correct matches fall below this threshold value.
Similarly, the overall precision for other approaches also decreases for thresholds higher than 0.5.
This is not expected, as we expect the precision to increase as the threshold increases.
The reduction in the precision in this case is due to the fact that the highest scored matching obtained from the static approach are not the correct ones.
Hence, when the threshold increases the correct matches are removed from the set of resultant matching.
However,
 proaches using OntoBuilder for matching schemas of services Approach Schema-based Static Depth-based Reference-based Time 17 min 34 sec 40.5 sec 42.2 sec 45.7 sec as we see the depth-based approach, and also the iterative reference-based approach, play the role of improving the scores for the correct matching pairs to keep them in the set of resultant matchings for threshold values of 0.4 and above.
Threshold selection.
Note that the selection of threshold depends on the algorithm and the tool used for matching of schemas, and also the schema of the services to be matched.
There has been some work in the area of schema matching to  nd parameters of matching algorithms based on the problem at hand (e.g., see [24]).
As can be seen from the results, selecting a threshold closer to the lower end of the spectrum may result in lower precision, but, it achieves a higher recall.
It has been reported in [20] that in information retrieval tasks users would tolerate a decrease in the precision if it can bring about a comparable increase in recall.
This observation should be used in selecting the threshold.
E ciency.
Evaluation of the e ciency of the approach shows that applying the proposed static interface matching signi cantly reduces the time needed to match the schemas of the interfaces of two services (See Table 1).
While matching the whole schema of Google Checkout and XWebCheck-out using OntoBuilder takes more than 17 minutes for On-toBuilder, the static approach takes 40.5 seconds, the depth-based approach 42.2 seconds and  nally reference-based approach (when all steps are performed automated) takes on average 45.7 seconds.
The remarkable improvement in the time stems from two factors: the small size of fragments of schema, corresponding to those of messages, and matching not all pairs of messages but some of them.
Results on other datasets.
We have performed experiments using the speci cations of other Web services, i.e., among payment Web services (PayPal and PaymentEx-press, AmazonFPS and PayPal), purchase order and shopping card management Web services (Google Checkout and Moon s purchase order management service, Amazon Web service and Amazon E-commerce service).
Here, we discuss our observations and lessons learned from these experiments.
The total time taken for the execution of the static and also protocol-aware approaches for interface matching is sig-ni cantly less than that of using the schema-based approach on the whole WSDL schema de nitions of services, con rm-ing the observation that can be made in Table 1.
The proposed approaches improve the accuracy compared to the schema-based approach.
On average, the reference-based approach, based on results obtained on real-world datasets, demonstrates superior performance in comparison with the depth-based and static approaches, and all performed better than applying the schema-based approaches.
The results of the iterative reference-based approach are superior when there are con icting mismatches (leading to deadlock) de ned in the protocols.
In other cases, it performs slightly better than depth-based approaches due to the propagation of scores to the neighbor messages in the protocol but often the results are comparable.
As for the recall results, a consistent decreasing trend is observed for all three approaches as the threshold value increases, as expected.
The protocol-aware approaches demonstrate a higher recall, on average, compared with the static and also schema-based approaches.
In summary, comparing the results from the protocol-aware approaches with the static approach also reveals that as protocols become more complex the bene ts of using protocol-aware approaches are more signi cant.
Re ned reference-based approach.
We performed experiments to select the reference pair automatically by taking the matching pair with the highest score.
In most cases, the pair with the highest score, especially in the  rst iteration, does not represent a correct match.
This negatively affects the precision and recall of the iterative reference-based approach.
In these cases, we have performed experiments with a variation of the reference-based approach, in which it does not penalize the matching leading to deadlock, since we are not sure if the selected matching is correct.
Comparing this approach with static and depth-based approach reveals that it improves the recall but achieves a precision slightly lower than depth-based approach.
This is because a higher number of message pairs are returned, and some of them are not correct.
The aim of the synthetic scenarios is to evaluate the effectiveness of the protocol-aware interface matching when the matching between interfaces is correct according to the information at the interface level.
We report on using two pairs of synthetic order management protocols to evaluate the approach.
In particular, the  rst scenario is represented by a pair of protocols that involve matching pairs leading to deadlock cases, similar to cases presented in Figure 3.
The precision of the static algorithm in this case is 83%.
Applying the depth-based approach does not change the precision.
This is because the depth-based approach only enhances the similarity scores of messages at same level.
However, the iterative reference-based approach achieves a precision of 100%.
This is because it does not allow matching leading to deadlock cases.
The second scenario consists of a pair of protocols involving a deadlock case and also a message matching in a path of protocol matching two messages in two di erent paths, only one of them correct.
In this case, the precision of the static and depth-based approaches is 86%.
This is improved to 93% for the iterative reference-based addressing the deadlock case.
However, the iterative reference-based approach is not su cient in  nding the matchings to di erent paths showing the need for complete protocol-interaction simulation, a complementary approach that was proposed in our previous work [28] for identifying protocol-level mismatches.
The problem of adapting interaction models in software has been studied in di erent contexts, and more notably in the area of software components integration (e.g., [39,

 categories, i.e., interface matching, behavioral matching as well as diagram matching.
main classes of approaches in the prior art.
The approaches in the  rst class focus on  nding the similarities between a given function (operation) signature to others in a repository of software components [40, 41] or Web services [13,
 pare the signature of software components and identify their matching (and identifying a measure of similarities) considering the parameter name, parameter type, parameter order, etc.
This corresponds to 1  1 matching in our work.
In addition, service interfaces (described in WSDL and XML schema) are more expressive than software signatures.
In  nding similar services to a given query or operation from a service repository (e.g., [13, 36]), the objective is not to  nd the exact matching between schema elements of messages but to  nd a measure of their similarity typically based on information retrieval techniques.
In addition, their methods rely on learning and statistical analysis (e.g., clustering) of existing service interface speci cations.
In contrast, the aim in our work is to  nd exact matching of a given pair of service speci cations (WSDL).
The second class of prior art proposes approaches for adapting a service WSDL interface to incompatible clients, e.g., [17, 31].
In [31] authors assume that interfaces of all services that provide a similar functionality are derived from a common base interface using a number of derivation operators that allow for adding or removing parameters to operations.
However, the operation names and other aspects of the service interface remain the same.
In [17], the author proposes de ning service views on top of WSDL interfaces by altering WSDL interfaces to enable interactions with incompatible services.
However, no automatic support for the generation of views is proposed.
We focus on semiautomatic protocol-aware interface matching for service adaptation.
As the third class there are ontology-based approaches for service interface matching (e.g., [1, 30, 18]).
These works correspond to 1   1 matching in our approach.
In addition, they do not consider protocol constraints.
We also build on top of the ontology matching approach o ered by the OntoBuilder tool [29, 18, 12] to perform 1   1 matching of messages in the interfaces of Web services.
Finally, as the last class, commercial products, e.g., IBM WebSphere Integration Developer16, BEA WebLogic Integration 17 or Microsoft Biztalk18 also have integrated existing methods for schema matching.
Hence, they share the same limitations of schema matching approaches compared to the approaches presented in this paper for service speci- cations matching.
[7, 21, 41, 9, 16]) or services (e.g., Behavioral and diagram matching.
There are many approaches for behavioral matching of software components (e.g., [37, 2, 6]).
They are focused on matching business process and protocol spec-i cations in the absence of interface mismatches.
Our previous work [28] is the only one that reports matching service interface as well as service protocol speci cation.
However, service interfaces are matched using a static approach (1   1).
Tan et al. [35] present a protocol-level mediation method and assume that the interface-level mismatches are identi ed and given by the developer.
In this paper, we are 16http://www.ibm.com/software/integration/wid 17http://www.oracle.com/bea/index.html 18http://www.microsoft.com/biztalk considering matching of interfaces in the context of service adaptation, rather than trying to  nd a measure of similarity of one protocol with others in a repository, which is the [19]).
focus of another complementary line of research (e.g.
The approach presented in this paper builds on and extends our previous work in [3, 28].
In particular, in [28], we presented a method to identify one-to-one matching of service messages at the interface level, and one-to-many matching is only sketched.
In this paper, we proposed a new method for identifying one-to-many (merge/split) mismatches.
More importantly, we presented a protocol-aware approach for Web service interface matching, which is complementary to our previous work on bi-simulation of interaction of business protocols for service adaptation [28].
There is another class of related work for matching software architectural diagrams as well as software behavior models (e.g., [25, 26]).
These works are focused on  nd-ing similarities between diagrams.
In this paper, we focus on matching the XML-based interfaces of Web services (considering protocol constraints), which are much more expressive than labels on diagram transitions.
The approach presented in this paper may be useful in  nding more complex relationships between diagrams as well (e.g., method for split/merge mismatch identi cation).
However, some other aspects and methods such as deadlock case elimination may not be needed in the context of diagram matching.
In this paper, we have investigated the problem of iden-ti cation of mismatches between interfaces of Web services.
The innovative contributions of the proposed approaches lie in providing a method for identi cation of the split/merge class of interface mismatches and a semi-automated, protocol-aware approach for identi cation of interface-level mismatches that result in identifying parameters of mapping functions that resolve those mismatches.
We used and extended approaches in schema (ontology) matching for static matching of service interfaces to identify split/merge mismatches.
In addition, we have proposed depth-based and also iterative reference-based approaches that incorporate the protocol information during the interface matching.
We have implemented the approach in a prototype tool and performed extensive experiments using both synthetic and real-world service interface and business protocol spec-i cations.
The result shows that these approaches considerably improve the e ectiveness and the accuracy of matching results.
The work presented in this paper complements our previous work and we believe that together they play a sig-ni cant role in reducing the e orts for adapter development in Web services.
As future directions in this area we are considering extending the matching algorithms to identify other classes of mismatches between services interfaces.
We are also considering incorporating interface and protocol matching approaches in the composition of Web services as current approaches often do not consider heterogeneities of service speci cations while composing services.
