Web pages have become complex applications.
Steady design, development, and deployment of standardized Web programming interfaces allowed Javascript code to create interesting and e ective interactive applications by modifying CSS and HTML in the page.
The introduction of XML-HttpRequest for asynchronous data update allows pages to be more responsive by delaying data loading and more timely by refreshing data after initial page load.
These improvements caused Web page development to shifted server side to client side: the  Web 2.0  phenomenon.
For more complex Web applications, developers face a sig-ni cant challenge to start the debugging process.
In principle, a developer with a complete understanding of a program Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
knows which line of code to break on for any given problem.
In practice, this fails for several reasons.
Developers can t remember all of the code in a large program[14, 6].
They employ advanced programming frameworks that make predicting code paths more complex.
They work in teams and consequently they don t know all of the code.
For these reasons setting breakpoints by navigating through source code is not always the most e ective or convenient solution.
In this paper we extend breakpoints for web debugging beyond the standard source code breakpoints.
These include breakpoints in dynamically generated code where there may be no source  le.
We also describe breakpoints on events like object-property updates, error conditions, asynchronous network events, and markup element changes.
These breakpoints allow the debugger and therefore the developer to scale up to much larger, more dynamic, multi-developer projects.
By integrating breakpoints with runtime events as we do here, the developer halts into code based on errors, graphical changes, or network events operations.
That means they don t need to know all of the code to start debugging.
Rather, they enter the salient source code based on the user-interface issue they wish to investigate.
If they wrote the code, this form of breakpoint will help them recall the design and begin new development work even if some time has passed since they last studied the source.
If the user-interface operation is implemented in a framework, they can use the call-stack in the debugger s user interface or single line-stepping to navigate into code they control and understand.
And if they are working on code written by others, these kinds of breakpoints help them understand the relationship between the application s operation and the source code.
These additional breakpoint features convert a Javascript debugger from a general-purpose source code debugger into a domain-speci c debugger for Web pages.
For the purpose of setting breakpoints, the developer thinks in terms of Web page abstractions like HTML elements, AJAX events, and so on.
Only when the breakpoint hits do they need to consider the underlying source code issues.
And at that point Firebug s integrated presentation of program objects with graphical objects supports more rapid program understanding.
Another way to describe the advantage of these kinds of breakpoints is  recall  vs  recognize  models for information retrieval.
Conventional breakpoints support  recall : the user remembers the source location and searches for it directly.
The breakpoints we describe here support  recognize : plication user interface.
For example, the developer may inspect the end-user view with a graphical element selector in the debugger like Firebug s  inspect  feature, then break when the element is changed by Javascript code.
In this case there is no  recall  of source, the breakpoint is entirely by browsing.
Our contribution here is some novel breakpoints, a comprehensive approach to Web page breakpoints, and implementation solutions in Firefox, a modern, extensible web browser.
We start with some background on the debugger then describe the user experience for each kind of break-point.
Some kinds resemble breakpoints in debuggers for other languages.
Some are novel, enabled by the combination of Firefox and Firebug s integration of Javascript and HTML/CSS.
Then we describe their implementation, then conclude with related and future work.
The interested reader can follow along with Firebug 1.5 and the online demonstration pages[1].
We will use the abbreviation XHR for XMLHttpRequest, and DOM for Document Object Model; as is conventional we will use DOM to mean the concrete data structure backing the Web page as well as the abstract architecture.
The debugger we extend is  Firebug [3].
In 2006, Joe Hewitt combined ideas from his previous work on DOMi, the Mozilla document object model inspector[4], with a Javascript debugger to create a  Web page debugger .
The Firebug user interface opens in the bottom of a Web page (see Fig. 1).
It contains a toolbar on top of a set of panels labeled Console, HTML, CSS, Script, DOM and Net.
(Other panels can be added by extensions).
Each panel renders information from inside of the DOM for the Web page.
For example, the HTML panel shows the elements of the DOM rendered as HTML.
This is not the source HTML but rather the HTML after it has been transformed by Javascript in the page.
Firebug s Javascript support included conventional breakpoints .
To use a breakpoint, a developer navigates to a representation of a source  le, selects a line of source code and clicks on the left side of the line (see Fig. 1).
A red dot marks the line as  having a breakpoint .
Then the developer runs the program.
Whenever the Javascript runtime executes that line of code, the debugger  hits the breakpoint .
It halts the execution of the Web page Javascript and begins to execute debugger code to support the developer in understanding the program state in the now frozen Web application.
Rather than examining memory directly, Firebug allows you to examine the graphical state of the user interface using the abstractions of HTML and CSS rather than only those of Javascript.
The developer has a graphically-integrated live-object view of the web page at an execution point in their program.
In the following sections we describe new breakpoints that help the developer understand more complex Web applications.
Javascript supports the creation of new executable functions at runtime with the eval() function.
The function takes a string argument and compiles it; the functions de- ned in the string are available immediately thereafter.
In a common use of eval(), the string arrives in an XML-HttpRequest.
For example, the  dojo  javascript framework uses eval() in the conditional construction of an applica-tion[2].
However, the string can be computed at runtime in many ways and for many purposes.
Since the string argument to eval() may not be related to any source  le, the Javascript compiler associates no source  le name to the compiled functions.
As a result, without something like the implementation we describe in this paper, the functions from eval() are not supported for debugging.
With our support, the user experience is wonderfully unsurprising.
By default, the debugger provides a stable but hidden  le name and all of the remaining debugger infrastructure and user interface features work as for static sources (See Fig. 2).
When eval() is used extensively and especially when the string being compiled corresponds to a source  le, the default of a short fragment of source can be confusing.
In these cases the developer may append a special comment to the eval() argument.
The comment contains the  le name after the string sourceURL= (see Fig. 3).
This comment can be appended at any time before the eval() call.
If the eval() string corresponds to a  le, the URL can be appended to the source  le.
When this comment is used, the entire debugging experience is as if the source had been loaded from a script tag with the src= attribute set to the value of the sourceURL= value in the comment.
In a Web browser, errors do not typically halt execution.
Javascript syntax errors abort the compile of a single  le; CSS or HTML errors abort the processing of only the containing syntax unit; uncaught Javascript exceptions halt only the event handler that raise them.
While this gives the Web page user as good an experience as possible given that something is wrong, developers are left without context for errors beyond  le and line information in the error message.
Firebug o er three approaches to get more information.
First, the developer can set an option to ask that the call stack be recorded at each error.
Second, the developer can use Firebug s Console panel to set a break point on the source line of the error.
Third, the developer can set Firebug to break on the next error, no matter where it occurs.
We will give more detail on the second and third cases.
When Firebug is enabled for a Web page, errors occurring in the page are signaled to the developer with a red error counter in the browser s status bar across the bottom.
Clicking on the error count opens Firebug on the Console panel (or selects the Console panel if Firebug was open).
The error message shows as a line along with a stack trace to the problem and one line of source, showing where the error occured.
The developer clicks on the left end of the line to set a breakpoint on the source code line.
This is a simple form of setting breakpoints by navigation: the developer need not know or look at the complete source to set the breakpoint.
To trigger the breakpoint, the page is operated again to reproduce the condition that caused the error.
To break on the next error, the developer clicks the Console panel s  pause  button.
This  arms  the feature, meaning that we don t break in to the debugger until the next error.
The user-interface signals this change in state by chang-panel (tab labeled 1) and set a breakpoint on line 114 (red dot under yellow triangle, labeled 2).
Then they reloaded the page and hit the breakpoint.
Note the  le name demo.html to the left and below the Script tab.
The yellow triangle and yellow highlight signals the executing line.
Variables in the runtime are summarized to the left and values are summarized in terms of the DOM.
For example, the varible  elt  is summarized as an HTML button with id of evalLoad (label 3).
Place the mouse over the word button highlights the corresponding part of the Web page.
The developer studies the state then moves forward in execution with the continue or step controls (label 4).
Figure 2: Part of the Firebug Script panel when we have set and then hit a breakpoint in a dynamically compiled Javascript function.
The red dot appears when we click in the left gray column to show that a breakpoint is associated with the line.
Note the  le name above the source code reading  demo.html/eval:  followed by some of the source code.
the name of the source.
Compare the  le name here to the comment and to the  le name in Fig. 2 Figure 4: Part of Firebug s Console panel when an error has occured in the Web page.
The small plus sign to left of the error message opens the UI to show the call stack.
Developers click on the faded red circle to set a breakpoint on the line of the error.
The circle will turn dark red.
Also note the orange parallel bars ( pause ) button used to arm the break-on-next feature.
Figure 5: Firebug s Console panel when stopped on a breakpoint after break on next is set.
The executing line is highlighted; the error message bubble informs the developer of the error message but also connects the breakpoint event to the break-on-next request in the case that multiple breakpoints may be set.
pause icon to simulate  throbbing  bars.
When the break-point hits, the user interface switches to the Script panel and the error message is shown (see Fig. 5).
The XMLHttpRequest introduced asynchronous data update; now more and more web developers are using this technique to replace traditional model where a web page is entirely reloaded every time the user performs an action.
The modern XHR approach allows loading additional data or further parts of the application logic without necessity to leave the current page.
This dramatically improves usability and responsiveness of a Web application.
Using dynamic XHR pattern for building online applications has an obvious impact on amount of code that developers have to write on the client side.
The more code is involved in the network communication, the more e ective tools for debugging are required.
Firebug already contained a tool that can be used to monitor and analyze HTTP tra c between a client browser and the server, but there was no integration with the Firebug debugger.
To increase developer awareness of the breakpoint feature, we adopt a user interface solution resembling the Script panel.
Each XHR appears on a separate line; the XHR lines are styled with a gray cell on the left end, the developer selects a request for breaking by clicking in the left end (see Fig. 6).
This is consistent with the source-code line display and breakpoint setting in the Script panel.
Network breakpoints halt Javascript execution when a requests is made to a speci c URL (see Fig. 7).
To activate the breakpoint, the developer operates the Web page to cause the XHR event.
At the breakpoint, the usual debugging operations can be performed and execution can be continued.
When many XHR events occur, the developer may avoid tedious repetitive break/continue operations by using the conditional expresssions.
A right click on the breakpoint indicator opens a one-line expression input control (See Fig. 8).
The developer enters an expression using URL query string parameters or posted data.
The breakpoint hits only if the expression evaluates to true at the time of the network event.
In the opposite extreme, the developer can elect to break on the next XHR event of any kind by clicking the yellow  pause  parallel bar icon (see Fig. 6).
The feature can be useful to gain understanding of the application when the connection between XHR and Web page user interaction is not well understood or when the XHR event timing is unclear.
This feature can be combined with the conditional XHR BP set to false to skip XHR events that are understood.
Events Modern Web pages create dynamic user experiences in part by Javascript UI event handlers that add or remove HTML elements or their attributes.
The programming model is not modular in graphical space or time: any event handler can change any part of the user interface at any time it is run.
The developer then must make the connection between changes in the UI and source code.
One way to do this is to inspect the Web page with Firebug, look through the live markup for unique strings, then search the source code for these strings.
This activity is time consuming and distracting.
The HTML breakpoint dramatically illustrates the alternative  recognize  or  browse  approach to breakpoints.
As before, a developer inspects the Web page graphical area they want to investigate.
The HTML panel updates to show the HTML reconstruction of the current state of the corresponding DOM element (see Fig. 9).
The developer right clicks on the element and selects one of  break on attribute change , child element addition or removal, or element removal.
Then they operate the page and the debugger halts on the Javascript code that causes the corresponding mutation (see Fig. 10).
Only at this last step does the developer engage with the source code view.
The developer need not recall the source of the attribute change, but can arrive at the source when the breakpoint hits.
A common feature of debuggers is to break the execution  ow when memory is written.
In object-based languages, the debugger can express this operation in terms of object changes.
Object properties are shown in Firebug as name-value pairs on separate lines in the DOM (for Document Object Model) panel.
Following the style of the Net and Script panels, the DOM panel shows a gray area on the left end of the line.
To set a breakpoint on a property change, the developer clicks in this gray area (See Fig. 11).
When the breakpoint hits, Firebug highlights the source lines causing the modi cation and a pop-up balloon gives the old and new property values.
As for the Net, Script, and DOM panels, the Firebug CSS panel includes a gray column to the left of the style rules.
Clicking here sets the breakpoint for changes to the corresponding CSS rule.
When the rule changes and the break-point hits, the script panel is selected and the source line highlighted as in the other cases.
The implementation mechanism used for most of these breakpoints is available for Firebug extensions.
This allows extensions that support higher level abstractions outside of Firebug s core support to implement breakpoints more simply and with a consistent user interface.
We implemented breakpoints in FireCookie[10] to ensure that the feature would work in an extension and to give an example for other extension developers.
Firebug works within Firefox, a production Web browser having an underlying C++ core with a layer of interpreted graphics on top.
Firebug works entirely in the interpreted layer, using API calls to extract information from Firefox or to manipulate the Web page.
To support breakpoints in dynamically created code, we need to associate a unique identi er with the code.
This identi er needs to be robust across page reloads, since the dominant paradigm for debugging is to set a breakpoint then reload the page to stop on the breakpoint and examine the browser state.
For Javascript source included with the script tag, the value of the src attribute provides such an they wish to break on, and clicks in the left column.
The red dot gives the user feedback that the breakpoint is set.
Figure 7: Hitting a XHR breakpoint in the Firebug Script panel view.
The cause of the breakpoint is given in a popup bubble over the source code line.
Figure 8: Breakpoint condition editor for the Net panel XHR event element using Firebug s inspector then uses the contextual menu to set a  break on attribute change .
Figure 10: A part of the Firebug UI when a developer has hit a breakpoint set by selecting  Break On Attribute Change  as shown in Fig. 9.
Note that this may be the  rst time the developer sees the source code, all previous operations to set the breakpoint are graphical.
Figure 11: Part of the Firebug DOM panel, showing a breakpoint set on a property of an object.
the browser is concerned.
The compiler sees only a string, the argument to eval(str).
The string may be prepared in memory just before execution and the developer may never have seen the particular instance executing.
In the particular case of the Firefox browser, obtaining the string passed to the compiler involved manipulating the javascript runtime through the debug interface.
The compiler provides noti cation of compilation (onScriptCreated) but not source compiled nor an indication of whether that source is from eval(), a script tag, or a browser generated source.
To distinguish these cases it was necessary to set a breakpoint in the compiled code at program counter zero and, when the engine hit the breakpoint, examine the call stack heuristically.
Ideally this approach would not be necessary, but it is worth noting that a debugger has this ability to create such unconventional control  ows.
Given the source string we need a unique identi er for it.
Our initial implementation followed previous suggestions to encode the source string as a  data:  URL[13].
The  data:  URL is a valid input to various parts of the brower, making it attractive for this purpose and for small programs this approach was e ective.
However the performance of this implementation was unacceptably slow, probably because it more than doubles the memory required for source  les and the encoding algorithm is not highly optimized.
We reimplemented the identi er computation in two ways.
First, as described in Sec.
3.1, we look for a sentinel string at the end of the eval() string giving a user-de ned value for the identi er; this can be used by, for example, to connect the compiled source to the download URL.
Second, we use the browser s builtin MD5 hash computation function to create a 128 bit identi er very likely to be unique to the string.
The builtin function for MD5 is highly optimized.
The sentinal string methods works even if the developer modi es the source; the MD5 method works even if the developer does not or cannot add the sentinal string.
These two combine to support the needs of most development use cases.
Attempts to apply the same solution to functions created by Javascript s new Function feature failed because the heuristics to access the source string became too complex.
Additional support from the browser will be needed for that case.
Firefox also generates functions, for example, to implement  click  event handler.
These functions wrap an expression given within HTML markup.
We support debugging these generated handlers by decompiling their Javascript bytecodes using a service provided by the Firefox Web browser API.
We could have used this decompilation for the dynamic code.
However the decompiled code has no comments, is reformatted, and has di erent line numbers from the original dynamic code.
The user experience cannot resemble debugging normal source  les.
Error-selected source-code line breakpoints simply set a conventional source code breakpoint on the line indicated by the error message.
Thus they are a user-interface short hand.
The break-on-next exception implementation relies on the Firefox engine s onError() method, called for every exception.
When onError() is called we don t directly enter the debugger s user interface code.
Rather we call a method breakNow() which sets a break-cause object containing the error message and then executes a single Javascript statement debugger;.
This triggers the JS engine to call our onDebugger() handler function.
In this handler we examine the stackframes, skip frames from the debugger itself, then  nd the  le and line number for the developer s frame.
We pick up the break cause, position the source code view to the  le and line, and pop up a bubble giving cause of the break, an error message in this case.
The breakNow() function is used for many of our breakpoints to increase code reuse and ensure a consistency in the user experience.
Firebug intercepts network requests and responses to implement the Net panel view.
On each event we compare the URL to a list of breakpoints; matches are further tested with conditional expression evaluation if required.
Successful matches set the breaking cause object to the XHR event and call the breakNow() function described above.
Events The W3C DOM Events standard[12] implemented by Firefox supports DOM mutation events raised for each change in the DOM.
The breakpoint implementation for the HTML panel simply adds listeners for each DOM mutation event and calls the breakNow() function described above.
Firefox supports a watch() method available for all objects.
The method (if de ned) is called whenever an object property value is set.
The breakpoint implementation simply de nes the watch() to call breakNow() as described above.
No standard nor Firefox speci c API supports noti cation of CSS changes.
We implemented CSS breakpoints by inserting a shim API layer in the web page for every CSS-changing API call.
For example, we de ne a new function for CSSStyleDeclaration.prototype.setProperty() that checks if this property has a breakpoint set.
If so, the breaking cause is set to CSS property change and the breakNow() function is called.
Whether or not we enter the breakpoint, we call the original function to complete the developer s intent.
A major complicating factor for this implementation is the requirements of Web browser security.
The shim functions must be compiled into the Web page, but we cannot call breakNow() directly from the Web page.
Therefore we must request breakNow() by raising an event on an element in the Web page.
In Firebug, a listener for these events makes the actual function call.
Because of this extra complexity, we did not deploy the CSS breakpoints in production versions of Firebug.
We are currently working with the Firefox team to  nd a better alternative.
We added support for dynamic Javascript to Firebug in
 the feature is e ective and used.
The  break on errors  feature has also been a part of recent version of Firebug, with a next error  feature indicated that it was both useful for many users, but also triggered too often for other users.
Discussion of these problems led us to generalize the breakpoints as we report here.
The remaining breakpoints are only now available in Firebug.
We do not as yet have objective evidence that these approaches are e ective.
We chose not to invest in an isolated user study of these features.
As developers ourselves, we believe that the concept behind these breakpoints are compelling and a small scale user study would not add significant new information.
To be correct, a user study requires developers to be skilled in the use of the breakpoints and yet it would require developers unfamiliar with the breakpoints as control subjects.
These requirements con ict and they make any such study very time comsuming.
On the other hand, since Firebug is widely used, we have an attractive alternative: measure adoption of the breakpoints.
We anticipate being able to report on the adoption of these features early in 2010.
We chose Firebug as the base for our work on breakpoints for  ve reasons: 1) when we started our work it was the only Web debugger (other Javascript-only debuggers were available but they would have required much more work), 2) both Firebug s entire source code and the source for Firefox s debugging support code are readily available, 3) Firebug is implemented in Javascript, a well-supported and garbage-collected language easing development, 4) Firebug s open BSD source code license allows unemcumbered commercial redistribution helping us to support our work, 5) Firebug has an active developer and user community providing a ready source of feedback.
After we started this work, web debuggers appeared for Opera (DragonFly) and Internet Explorer
 of Firebug but no support for Javascript debugging).
We believe that all of the techniques we describe here could be implemented in any of these other Web debuggers.
Existing debuggers, for example Eclipse, support source code breakpoints and breaking on exceptions.
Eclipse s break on exception supports breaking based on the type of the error object, while our break on next error has no such  l-ter.
The Java types are known in advance because of Java s static typing, but of course the type of the actual error is not known until runtime.
Once the error occurs, we support setting a breakpoint directly on the source line.
ZStep[8] supports integration of graphical objects and source code.
Our approach is quite di erent since the Web page run time model allows any Javascript function to operate on any part of the page.
This means that the binding of an object and the source is only meaningful during the function invocation.
For that reason our integration uses breakpoints and rerunning the code to  nd the connection.
As a specialized debugger, Firebug resembles debuggers for domain-speci c languages[16].
However, the breakpoints we introduce here support higher-level graphical and network abstractions, not higher-level source-code abstractions.
Firebug has domain-speci c breakpoints but when they hit, you are in general purpose source code.
On the other hand, the extensive integration of Javascript and HTML/CSS in the Document Object Model combined with Firebug s integration of debugger views and the Web page blurs the line.
WhyLine[5] supports integration of graphical state and source code though queries into data created while running a program.
The queries are generated by demonstration on the graphical user interface.
When successful, this approach can lead directly to the source that caused the transition demonstrated.
In our approach, multiple breakpoints might be hit before you  nd the one place in the source that causes the graphical change of interest; we mitigate this problem with conditional breakpoints.
Our breakpoints have much less run time overhead and build on existing developer experience.
FireCrystal[11] records Web page and sequences of di s to support a graphical time line view of the page.
Sweeping along the time line can be used to navigate to a graphical transition visually.
The transitions are connected to the code running at that point in the time line.
Our approach is more  spatial  and causes minimal run time overhead, but broadly they should be quite complementary.
The breakpoints we have introduced here  t easily into the Firebug user interface and, consequently, the UI operations needed to set them are easy to explain to developers.
There are cases where more complex solutions may be needed.
For example, developers need to know why an element has the color  green  independent of whether that color came from CSS parsing, changes to element attributes (for example CSS class or style), changes to the structure of the document that caused new CSS rules to apply, or changes to the CSS rules themselves.
Firebug provides good tools to master  space , both the
 Our breakpoints help connect these spatial dimensions to the source code that modi es them.
But breakpoints are intrinsically  at the wrong time : developers set them then run the program to hit them at a later time.
This limits the kind of immediacy of debugging advocated by Ungar et al.[15].
Omniscient Debugging[7], WhyLine[5], and FireCrystal[11] point to powerful new approaches to temporal issues in debugging.
Omniscient Debugging records information while a program runs to support reversal of control  ow, that is working backward in time.
Recent improvements reduce the overhead of Omniscient Debugging from 100 times to more like 7 times[9].
Since Javascript event-handlers often complete in less than a second, real-time recording may be feasible even in Javascript and we still have the potential for more performance by implementing the recorder in the
 WhyLine requires similar recording but adds queries as a navigation solution.
Finding ways to introduce Web developers to query based debugging would be an important step towards realizing the potential of these new techniques.
FireCrystal demonstrates some of the potential of trace recording integrated with graphical recording to address the  why is this green  question.
Since it is implemented in Javascript, it provides a direct prototype for exploring the integration of trace based solution with breakpoint based solutions and for exploring how the developer community can become successful with the tracing solutions.
Debugging is a special challenge in highly dynamic graphical Web pages.
We think our breakpoints are in important improvement and a  rst step towards providing much better and we hope this paper will encourage others to see that new debugging tools are feasible and exciting to create.
The Firebug project is an open source project and we gratefully acknowledge inputs from many users and developers that shapes our thinking on these paper.
We thank Prof. Eric Tanter, Prof. Brad Myers, Tessa Lau, Salman Mirghasemi, and Je  Nichols, for timely and valuable suggestions on the paper.
