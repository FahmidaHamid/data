Cross-site scripting (XSS) is recognized as the biggest se-In curity problem facing web application developers [22].
fact, XSS now tops bu er over ows as the most-reported type of security vulnerability [2].
Although each individual XSS vulnerability is easy to  x, much like each individual bu er over ow is easy to  x,  xing every XSS vulnerability in a large web site is a more challenging task, a task that many web sites never fully accomplish.
Worse, there are large public repositories of unpatched XSS vulnerabilities (e.g., xssed.com) that invite attackers to exploit a wide variety of sites.
Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
Instead of waiting for every web site to repair its XSS vulnerabilities, browsers can mitigate some classes of XSS vulnerabilities, providing protection for sites that have not yet, or might not ever, patch their vulnerabilities.
In principle, such client-side XSS  lters are easy to build.
In a re ected XSS attack, the same attack code is present in both the HTTP request to the server and the HTTP response from the server.
The browser need only recognize the re ected script and block the attack.
However, there are a number of challenges to building a  lter with zero false negatives, even for a restricted set of vulnerabilities.
In this paper, we analyze the best known client-side XSS  lters: the IE8  lter, the noXSS  lter, and the NoScript  lter.
In each case, we  nd that the  lter either is unacceptably slow (e.g., 14% overhead in page load time for noXSS) or is easily circumvented.
For example, an attacker can circumvent the IE8  lter by encoding the injected content in the UTF-7 character set, which is not decoded by the  lter s regular expressions.
Worse, these  lters can actually introduce vulnerabilities into otherwise vulnerability-free sites.
We argue that the attacks we discover are not simply implementation errors: the attacks are indicative of a design error.
Each of the  lters we examine analyzes the HTTP response before the response is processed by the browser.
This design decision lowers the  lter s precision because the  lter examines the syntax of the response not its semantics.
To increase precision, some  lter use a higher  delity simulation of the browser s HTML parser, reducing performance by, e ectively, parsing the response twice.
Instead of examining the pre-parsed response, we propose that client-side XSS  lters mediate between the HTML parser and the JavaScript engine, achieving both high performance and high precision.
By examining the response after parsing, the  lter can examine the semantics of the response, as interpreted by the browser, without performing a time-consuming, error-prone simulation.
Examining the semantics of the response reduces both false positives and false negatives by preventing the  lter s interpretation of the response from getting  out of sync  with the browser s interpretation of the same response.
Moreover, such a  lter can block XSS attacks safely instead of resorting to  mangling  the injected script by altering the pre-parsed stream.
We demonstrate our approach by implementing the design in WebKit, the open-source rendering engine used by Safari and Google Chrome (see Figure 1).
We  nd that our design is high-performance, incurring no measurable overhead to JavaScript execution or page load time.
We estimate the percent of  naturally occurring  vulnerabilities our  l-only re ected XSS vulnerabilities, where the byte sequence chosen by the attacker appears in the HTTP request that retrieved the resource.
Instead of attempting to account for every possible transformation the server might apply to the attacker s content before re ecting it in the response, we restrict our attention to mitigating vulnerabilities in which the server performs only one of a limited number of popular transformations.
Also, we consider mitigating injections at a single location only and do not seek to provide protection for so-called  double injection  vulnerabilities in which the attacker can inject content at multiple locations simultaneously.
Covering vulnerabilities is useful because the  lter will protect a web site that contains only covered vulnerabilities.
However, covering attacks is of less utility.
If an attacker can evade the  lter by constructing a convoluted attack string (e.g., by injecting script via CSS expressions [16] or via obscure parser quirks [8]), then the  lter does not actually prevent a sophisticated attacker from attacking the site.
Each  lter, then, de nes a set of vulnerabilities that are in-scope, meaning the  lter aims to prevent the attacker from exploiting these vulnerabilities to achieve his or her goals.
Attacker Goals.
We assume the attacker s goal is to run arbitrary script in the user s browser with the privileges of the target web site.
Typically, an attacker will run script as a stepping stone to disrupting the con dentiality or integrity of the user s session with the target web site.
In the limit, the attacker can always inject script into a web site if the attacker can induce the user into taking arbitrary actions.
In this paper, we consider attackers who seek to achieve their goals with zero interaction or a single-click interaction with the user.
In this section, we present attacks on existing client-side XSS  lters.
We  rst explain an architecture  aw in  lters that block ex ltration of con dential information.
We then exhibit inaccuracies in the simulations of the HTML parser used by  lters that mediate before the response is parsed, showing how an attacker can bypass these  lters.
Finally, we demonstrate how client-side XSS  lters can introduce vulnerabilities into otherwise vulnerability-free web sites.
A number of client-side XSS  lters attempt to mitigate XSS vulnerabilities by preventing the attacker s script from leaking sensitive data to the attacker s servers [5, 11, 23].
Typically, these  lters monitor the  ow of information within the web site s JavaScript environment and aim to block the attacker from ex ltrating that information to his or her servers.
One technical di culty with preventing ex ltration is that web sites frequently export data to third-party web sites.
For example, every web site that contains a hyperlink to another site leaks some amount of data to that site.
Worse, modern web sites often have rich interactions with other web sites, e.g., via postMessage, OAuth, or advertising.
To distinguish between  benign  and  malicious  information leaks, these client-side XSS  lters often employ sophisticated analysis techniques, including taint tracking and static analysis, with the attendant false negatives and false positives.
Figure 1: Our  lter blocks a re ected XSS attack on openssl.org.
Because the site does specify a character set, IE8 s XSS  lter does not have su cient  delity to repair this vulnerability.
ter mitigates by analyzing 145 re ected XSS vulnerabilities from xssed.com.
We  nd that 96.5% of the vulnerabilities are  in-scope,  meaning our  lter is designed to block 100% of the script injection vectors for these vulnerabilities.
In practice, we  nd that our  lter has a low false positive rate.
Although false negatives from implementation errors are inevitable, our design lets us repair these vulnerabilities without building an ever-more-complex simulator.
Client-side XSS  lters are an important second line of defense against XSS attacks.
We caution web developers not to rely on client-side XSS  lters as the primary defense for vulnerabilities in their applications, but we do recommend that every browser include an XSS  lter to help protect its users from unpatched XSS vulnerabilities.
Instead of using regular expressions to simulate the HTML parser, client-side XSS  lters should integrate with the rendering pipeline and examine the response after it has been parsed.
Our implementation of this design has been adopted by WebKit and has been deployed in Google Chrome.
Organization.
Section 2 presents a threat model for reasoning about client-side XSS  lters.
Section 3 demonstrates attacks against previous  lters.
Section 4 describes the design and implementation of our  lter.
Section 5 evaluates our design, both in terms of correctness and performance.
Finally, Section 6 concludes.
Attacker Abilities.
Client-side XSS  lters are designed to mitigate XSS vulnerabilities in web sites without requiring the web site operator to modify the web site.
We assume the attacker has the following abilities:   The attacker owns and operates a web site.
  The user visits the attacker s web site.
  The target web site lets the attacker inject an arbitrary sequence of bytes into the entity-body of one of its HTTP responses.
Vulnerability Coverage.
Ideally, a client-side XSS  lter would prevent all attacks against all vulnerabilities.
However, implementing such as  lter is infeasible.
Instead, we focus our attention on a narrower threat model that covers Architectural Limitations.
However, even if these  lters could track sensitive information with zero false negatives and zero false positives, the ex ltration approach does not actually prevent attackers from disrupting the con dential-ity or integrity of the user s session with the target site.
For example, if the attacker can inject script into the user s online banking web site, the attacker can transfer money to the attacker s account by generating fake user input events pro-grammatically.
Worse, an attacker can almost always steal con dential information via self-ex ltration: ex ltrating the sensitive information via the honest web server.
For example, many web sites provide a user-to-user messaging facility (e.g., YouTube, Flickr, and Facebook all provide in-site messaging).
If the attacker sends the con dential information to his or her own user account in a user-to-user message, the attacker can log into the site later and retrieve the information, circumventing the ex ltration  lter.
Even if the site does not provide an explicit user-to-user messaging mechanism, the attacker can almost always ex ltrate the con dential information anyway.
For example, consider an attacker who is able to inject script into the Bank of America web site and wishes to ex ltrate some piece of con dential information, such as the user s soft second factor authentication token.
The attacker s script can perform the following steps:

 by  lling out the login form (answering the attacker s secret questions as needed.)
the attacker wishes to ex ltrate.
The attacker can then log into his or her own account at Bank of America (this time in his or her own browser), view the stored mailing address, and learn the con dential information.
To determine how many bytes the attacker can leak using this technique, we examined the Bank of America web site for user-local persistent storage.
Our cursory examination revealed that the attacker can ex ltrate at least 400 bytes per attack.
Alternatives.
Some  lters (e.g., [20, 14, 19]) avoid the above di culties by blocking XSS attacks earlier.
Instead of letting the attacker s script co-mingle with the target web site s script, these  lters prevent the attacker from injecting malicious script in the  rst place.
Typically, these  lters block injection by searching for content that is contained in both the HTTP response and the HTTP request that generated the response.
Although not necessarily indicative of a re ection, such repeated content suggests that the server simply re ected part of the request in the response.
One disadvantage of this technique is that  lters based on matching content in the request and the response cannot mitigate stored XSS vulnerabilities because the attacker s script need not be present in the request.
In a stored XSS attack, the attacker stores malicious content in the target web site s server.
Later, when the user visit the server, the server sends the attacker s content to the user s browser.
Unfortunately, ex ltration prevention techniques cannot block stored XSS attacks either.
By de nition, the presence of a stored XSS vulnerability implies that the attacker can store content in the server.
Using this storage facility, the attacker can self-ex ltrate con dential information.
Client-side XSS  lters that block injection typically match content in an HTTP response with content in the HTTP request that generated the response.
Because responses often contain benign information from the request, these XSS  l-ters narrow their focus to detecting script that is present in both the request and the response.
However, detecting whether particular bytes in an HTTP response will be treated as script by a browser is not as simple a task as it appears.
Fidelity/Performance Trade-O .
Existing  lters mediate between the network layer and the browser s HTML parser (see Figure 2).
To determine whether a sequence of bytes in an HTTP response will be treated as script by the browser, these  lters simulate the browser s HTML parser.
Unfortunately, the browser s HTML parser is quite complex.
The bytes in the response are decoded into characters, segmented into tokens, and then assembled into a document object model (DOM) tree.
Simulating this pipeline is a trade-o  between performance and  delity.
  Low performance.
The  lter could re-implement exactly the same processing pipeline as the browser, but such a  lter would double the amount of time spent parsing the HTTP response.
For example, noXSS [19] contains an entire JavaScript parser for increased  -delity.
Unfortunately, to achieve perfect  delity, the  lter would need to fetch and execute external scripts because external scripts can call the document.write API to inject characters into the processing pipeline, altering the parsing of subsequent bytes.
HTTP ResponseXSS?HTML Parser + JS EngineNoYesMangleWWW 2010   Full PaperApril 26-30   Raleigh   NC   USA93Figure 3: Identifying scripts in raw responses requires understanding browser parsing behavior.
Figure 4: After the HTTP response is parsed, the script is easy to  nd.
  Low  delity.
Instead of implementing a high delity simulation, the Internet Explorer 8 (IE8) [20] and No-Script [14]  lters approximate the browser s processing pipeline with a set of regular expressions.
These regular expressions are much faster than a complete HTML parser, but they over-approximate which bytes in the response will be treated as script.
Low delity simulations are forced to incur a large number of false positives because the penalty for incurring a false negative is high: an attacker can construct an attack that bypasses the  lter.
For example, consider this content: <textarea><script> ... </script></textarea> The IE8  lter  ags this content as script even though the <textarea> element prevents the content from being interpreted as script, leading to a false positive.
To work around the false positives caused by its low delity simulation, Internet Explorer 8 disables its XSS  lter for same-origin requests.
However, this reduction in false positives also comes with false negatives: instead of injecting script directly, an attacker can inject a hyperlink that  lls the entire page and exploits exactly the same XSS vulnerability.
When the user clicks this hyperlink, the  lter will ignore the exploit (because the request appears to be originating from the same origin), letting the attacker run arbitrary script as the target web site.
Simulation Errors.
Worse, even high delity simulations are likely to deviate from the browser s actual response processing pipeline in subtle ways.
If the attacker can desyn-chronize the simulated parser from the actual parser, the attacker can usually bypass the  lter.
In each of the  lters we examined, we discovered attacks of this form:   noXSS.
The HTML parsing simulation used by noXSS does not correctly account for HTML entity encoded JavaScript URLs.
An attacker can bypass the  lter by injecting a full-page hyperlink to an HTML entity encoded JavaScript URL.
If the user click anywhere on the page, the attacker can run arbitrary script as the target web site.
  NoScript.
The HTML parsing simulation used by No-Script does not correctly account for the fact that the / character can be used to delimit HTML attributes.
For example, the attacker can bypass the  lter using an attack string that uses some complex parsing tricks such as <a<img/src/onerror=alert(1)//<.
  IE8.
The Internet Explorer 8  lter does not correctly approximate the byte-to-character decoding process.
If the browser decodes an HTTP response using the UTF-7 code page, the attacker can freely inject script (see Figure 3).
This issue is particularly severe because, in Internet Explorer, the attacker can force a web page that does not declare its character set explicitly to be decoded using the UTF-7 code page [10], making the IE8 XSS  lter ine ective at protecting web sites that do not explicitly declare their character set.
Once the  lter has decided that a sequence of re ected bytes constitutes an XSS attack, the  lter must prevent the browser from running the attacker s script.
If the  lter blocks the entire page, each false positive seriously degrades the user experience because users would not be able to view web pages that trigger false positives.
Instead, pre-parse  l-ters typically  mangle  injected script by altering the HTTP response in the hopes of preventing the injected script from executing.
For example, IE8 replaces the r in <script> with a #, tricking the parser into skipping the script block.
Although a nuisance, unintentional false positives rarely open new security vulnerabilities in web sites.
By contrast, false positives induced by an attacker can mangle or block security-critical code.
An attacker can induce a false positive by including the security-critical code in a request to the victim site, confusing the  lter into believing the server re ected the content and is the victim of an XSS attack.
For example, the following URL will prevent victim.com from executing the secure.js JavaScript library: http://victim.com/?<script src="secure.js"></script> Because the string <script src="secure.js"> is contained in both the request and the response, the  lter believes that the attacker has injected the script into the victim web site and mangles the script.
Induced false positives lead to a number of security issues, described below.
Container escape.
Recently, mashups such as Facebook, iGoogle, Windows Live, and Google Wave have begun displaying third-party  gadgets  that seamlessly combine content from more than one source into an integrated experience.
Because the gadget author is not trusted with arbitrary access to the user s account, these sites use frames or a JavaScript sandboxing technology such as FBJS [4], AD-safe [3], or Caja [6] to prevent the gadget from escalating its privileges.
Gadgets are typically rendered in a small rectangle and are not allowed to draw outside this area.
Facebook uses cascading style sheets to con ne gadgets to a limited region of the page.
Because Internet Explorer lets style sheets
 3c

 6d 6c 3e 0a 3c



 3e 0a 3c 2f <html>.<head>.</00000010:



 3e 0a 3c
 6f

 3e 0a 2b

 head>.<body>.+AD00000020:




 6a









 wAcwBjAHIAaQBwAH00000030:









 5a




 QAPgBhAGwAZQByAH00000040:

 4b




 6b






 QAKAAxACkAPAAvAH00000050: 4d






 6b






 MAYwByAGkAcAB0AD00000060:
 2d 3c 2f
 6f

 3e 0a 3c 2f

 6d 6c
 top.location.replace(document.location); } PayPal s frame busting can be easily circumvented in several di erent ways.
For example, the attacker can create a variable called location in the parent frame, preventing the above script for successfully changing the location of the attacker s frame [24].
The attacker can also cancel the navigation using an onbeforeunload handler [21].
Client-side XSS  lters add yet another way to circumvent frame busting: the attacker can induce a false positive that disables the frame busting script [18].
In this section, we describe the design and implementation of a client-side XSS  lter that achieves high performance and high precision without using regular expressions.
Instead of mediating between the network stack and the HTML parser, we advocate interposing a client-side XSS  lter between the HTML parser and the JavaScript engine, as shown in Figure 6.
Placing the  lter after the HTML parser has a number of advantages:   Fidelity.
By examining the response after parsing, the  lter can easily identify which parts of the response are being treated as script (see Figure 4).
Instead of running regular expressions over the bytes that comprise the response, the  lter examines the DOM tree created by the parser, making the semantics of those bytes clear.
Placing the  lter after parsing also lets the parser correctly account for external scripts that use document.write.
  Performance.
When the  lter processes the response after the parser, the  lter does not need to incur the performance overhead of running a high delity simulation of the browser s HTML parser.
  Complete interposition.
By placing the  lter in front of the JavaScript engine, the  lter can interpose completely on all content that will be treated as script.
In particular, because the JavaScript engine has a narrow interface, we can have reasonable assurance that the  lter is examining every script before it is executed.
When the  lter wishes to block a script, the  lter can simply refuse to deliver the script to the JavaScript engine instead of mangling the response.
We implemented a client-side XSS  lter, called XSSAudi-tor, in WebKit.
Our implementation has been accepted into the main line and is enabled by default in Google Chrome 4.
The  lter mediates between the WebCore component, which contains the HTML parser, and the JavaScriptCore component, which contains the JavaScript engine.
Interception Points.
The  lter interposes on a handful of interfaces.
For example, the  lter intercepts any attempts to run inline scripts, inline event handlers, or JavaScript URLs.
The  lter also interposes on the loading of external scripts and plugins.
In addition to these interception points, two other points require special consideration.
Figure 5: Container escape phishing attack using IE8 s XSS  lter to bypass Facebook s style restrictions.
contain script [16], IE8 s XSS  lter blocks attackers from injecting style sheets.
An attacker, therefore, can trick IE8 s XSS  lter into mangling Facebook s protective style sheet by inducing a false positive, letting a malicious gadget escape its container.
The attacker can then display a convincing fake login page hosted on facebook.com (see Figure 5) even though Facebook does not contain an XSS vulnerability.
If WebKit allowed scripts in style sheets, we could block the injected script instead of mangling the style sheet.
Parse Tree Divergence.
Mangling an HTTP response before parsing makes it di cult to predict how the remainder of the response will be interpreted by the browser.
When an attacker induces a false positive and intentionally mangles a page, the browser will construct a di erent parse tree than the one intended by the author: code might be interpreted as static data and data might be interpreted as code.
Parse tree divergence vulnerabilities have been discovered in the IE8 XSS  lter in the past, allowing attackers to conduct XSS attacks against web sites that have no  inherent  XSS vulnerabilities [17].
Rather than sanitizing untrusted content in a way that is robust to arbitrary mangling of the page, some security-conscious web sites prefer to rely on their own server-side defenses to prevent code injection.
For this reason, a number of popular web sites, including Google, YouTube, and Blogger, disable the IE8 XSS  lter using the X-XSS-Protection header.
Clickjacking.
In a typical clickjacking attack, the attacker s web page embeds a frame to the target web site.
Instead of displaying the frame to the user, the attacker obscures portions of the frame and tricks the user into clicking on some active portion of the frame, such as the  delete my account  button, by displaying user experience that implies that the button serves a di erent purpose and belongs to the attacker s site.
Until recently, the recommended defense for clickjacking was for the victim site to use a  frame busting  script to break out of the attacker s frame.
As a result of misleading advice on sites such as Wikipedia, the Web is littered with poorly written frame busting scripts that can be circumvented.
For example, PayPal uses this script: The HTML <base> element [1] is used to specify the base URL for all relative URLs in an HTML page.
By injecting a <base> element (or altering the href attribute of an existing <base>), an attacker can cause the browser to external scripts from the attacker s server if the script are designated with relative URLs.
For this reason, the  lter causes the browser to ignore base URLs that appear in the request.
To reduce false positives, the  lter blocks base URLs only if the URLs point to a third-party host.
Data URLs [15] require special attention for Firefox XSS  lters because data URLs inherit the privileges of the web page that contains the URL.
However, data URLs are neither an XSS attack vector for Internet Explorer nor WebKit-based browsers because data URLs either do not work (in IE) or do not inherit the privileges of their referrer (in Web-Kit).
Because our  lter is implemented in WebKit, the  lter does not need to block data URLs in hyperlinks or iframes.
However, because data URLs contain attacker-supplied content, the  lter prevents the attacker from injecting a data URL as the source of an external script or plugin.
Matching Algorithm.
Before searching for scripts in the HTTP request, the  lter transforms the URL request (and any POST data) as follows:
 ics the URL decoding that the server does when receiving an HTTP request (e.g., before PHP returns the value of $_GET["q"]).
with Unicode characters).
This step mimics a transformation done by the HTML tokenizer.
 lter applies this transformation only to some of the interception points.
For example, inline scripts are not entity decoded but inline event handlers are.
These steps assume that the server does not perform a complex transformation on the attacker s content.
If the server does perform an elaborate transformation, the  lter will not  nd an injected script in the request.
In analyzing server vulnerabilities, we found that servers commonly apply two transformations: Magic Quotes and Unicode normalization.
  Magic Quotes.
Prior to version 5.3.0, PHP automatically performs the addslashes transformation on request parameters.
This transformation attempts to mitigate SQL injection by adding \ characters before   and \ characters and by transforming null characters into \0.
To account for this transformation, the  lter ignores any \, 0, or null characters when searching for the script in the request.
  Unicode normalization.
A number of servers  normalize  Unicode characters by representing each Unicode character with its canonical code point.
For example, the character  u can be represented either by the code point U+0252 or the code point sequence U+0075, U+0308 (the  u  character combined with a diacritical mark).
Mimicking Unicode normalization is di cult and error prone because di erent servers might use different normalization algorithms.
For this reason, the  lter ignores all non-ASCII characters when searching for the script in the request.
Although the matching algorithm does simulate some of the transformations the server and the HTML parser apply to the attackers content, the  lter does not need to simulate the complex parts of the parser, such as tokenization or element re-parenting.
Over ow.
In some cases, an attacker can craft an exploit for an XSS vulnerability that is partially composed of characters supplied by the attacker and partially composed of characters that already exist in the page.
The  lter will be unable to  nd the entirety of such a script in the request because only a portion of the script originated from the request.
For example, consider the following XSS vulnerability: <?php echo $_GET["q"]; ?> <script> /* This is a comment.
*/ </script> If the attacker uses the following exploit, the injected script will extend until the end of the existing comment: <script>alert(/XSS/); /* Instead of attempting to  nd the entire script in the request, the  lter searches for the  rst 7 characters1 of the script.
Our hypothesis is that an attacker cannot construct an attack in less than 7 characters.
For example, the attacker cannot even specify a URL on another server in less than 7 characters because the scheme-relative URL //aa.cc is 7 characters long.
Chrome 4 does not implement the 7 character limit.
HTML ParserJS Enginedocument.writeXSS?NoYesHTTP ResponseWWW 2010   Full PaperApril 26-30   Raleigh   NC   USA965.
EVALUATION In this section, we evaluate the correctness and the performance of our client-side XSS  lter.
By way of correctness, we evaluate what percentage of  naturally occurring  XSS vulnerabilities are mitigated by the  lter, the  lter s false positive rate, and our assurance regarding the  lter s false negative rate.
By way of performance, we measure the performance overhead of running the  lter on a number of JavaScript and page-loading benchmarks.
Client-side XSS  lters do not require perfect correctness to be useful.
However, the usefulness of a  lter depends what percent of vulnerabilities the  lter covers and the rate of false positives and false negatives.
Vulnerability Coverage.
To estimate the percent of re ected XSS vulnerabilities covered by the  lter, we analyzed
 ties from xssed.com.
Of the selected vulnerabilities, 76 were  dead links  (meaning the site did not respond within 10 seconds or responded with an HTTP response code other than
 We were able to verify that the remaining 145 vulnerabilities were live, re ected XSS vulnerabilities.
(There were no stored XSS vulnerabilities in this data set.)
Instead of testing whether the  lter blocks the example exploit in the database, we classi ed the underlying vulnerability to assess whether the  lter is designed to block all exploits for the vulnerability (see Figure 7).
We found that 96.5% of the vulnerabilities were  in scope  for the  lter, meaning that the  lter is designed to prevent the attacker from exploiting these vulnerabilities to inject script.
The remaining 3.5% of the vulnerabilities were out-of-scope because they let the attacker inject content directly inside a <script> element.
There are a number of limitations of this evaluation.
First, the xssed.com data set is biased towards easy-to-discover vulnerabilities because the researchers who contribute the example exploits often discover the vulnerabilities using automated vulnerability scanners.
Second, the evaluation is biased towards un xed vulnerabilities because we excluded 87 vulnerabilities that were repaired before we conducted our study.
However, even with these biases, these observations suggest that a signi cant fraction of naturally occurring re ected XSS vulnerabilities are in-scope for our  lter.
False Positives.
To estimate false positives, we deployed the  lter to all users of the WebKit nightly builds and the Google Chrome Developer channel and waited for users of these browsers to  le bug reports.
Initial iterations of the  lter had a number of interesting bugs, described below.
After examining the false positives, we were able to adjust the  lter to remove the false positives in all but one case, also described below.
An early iteration of the  lter had a large number of false positives on web sites that contained <base> elements.
A number of web sites use a base URL of a form analogous to http://example.com/ on pages with URLs analogous to http://example.com/foo/bar.
The  lter blocked these <base> elements because the base URL occurred in the page s URL.
We removed these false positives by whitelisting base URLs from the same origin as the page.
Figure 7: Underlying vulnerability for 145 veri ed re ected XSS vulnerabilities from xssed.com.
96.5% were  in-scope  for XSSAuditor.
An early iteration of the  lter broke the chat feature on Facebook because the chat feature loads an external script from a URL supplied as a query parameter.
Left unchecked, this behavior would be an XSS vulnerability.
However, the Facebook server validates that the supplied URL points to a server controlled by Facebook.
We removed this false positive by reducing the set of vulnerabilities that we cover to exclude direct injections into the src attribute of script elements.
Because these vulnerabilities accounted for zero veri ed vulnerabilities in our xssed.com survey, we believe declaring these vulnerabilities out-of-scope is an acceptable trade-o  to reduce false positives.
We implemented this change by preventing a script element from loading an external script only if all of the bytes of the src attribute (including its name) appear in the request.
One subtle issue involves a user who authors a wiki that lets authors supply JavaScript content.
Typically, a wiki author edits a wiki page in a <textarea> element that is sent to the server via a POST request.
After the user edits a page, the server responds to the POST request by re ecting back the newly edited page.
If the author includes JavaScript in the wiki page, the  lter blocks the JavaScript in this response because the script is contained in the POST request.
Of course, the wiki page containing the JavaScript is stored correctly in the server s database, and the wiki page functions correctly for subsequent visitors.
One user reported this issue as a false positive in his personal wiki.
Upon investigating the issue, we discovered that the version of DokuWiki the user was running is in fact vulnerable to XSS because the  edit wiki  form is vulnerable to cross-site request forgery (CSRF).
Thus, the  false positive  correctly identi ed the web site as vulnerable to XSS.
(Unfortunately, the  lter is unable to mitigate this vulnerability because the vulnerability is a stored XSS vulnerability.)
A more recent version of DokuWiki repaired this XSS vulnerability by adding a CSRF token to the  edit wiki  form.
However, it is unclear how the  lter could distinguish between the vulnerable and the non-vulnerable cases.
Intertag,
 A/ribute escape,
 JavaScript

 Inside of script tag,
 we recommend that sites replace their circumventable frame busting scripts with the X-Frame-Options HTTP response header [12], which was designed to help mitigate clickjack-ing.
To protect users with legacy browsers that do not support this header, a web site operator should use a frame busting script that is robust to being disabled.
For example, Twitter hides its pages by default and reveals them only if a script detects that the page is not in a frame.
Some web applications might wish that the XSS  lter blocked the entire page when the  lter detects an XSS attack, especially if an induced false positive might endanger the page s security.
We let web developers enable full page blocking by sending the following HTTP header: X-XSS-Protection: 1; mode=block When the page includes this header, our  lter will stop all script execution and display a blank page if the  lter detects an XSS attack.
Performance is an essential factor in assessing the usefulness of a client-side XSS  lter.
Browser vendors are reluctant to deploy features that slow down key browser benchmarks, including JavaScript performance and page load time.
JavaScript.
We evaluate the impact of the  lter on core JavaScript performance using the industry-standard SunSpi-der [9] and V8 [7] benchmark suites.
We were unable to measure any performance di erence on these benchmarks as a result of the  lter.
This is unsurprising because the  l-ter interposes on the interface to the JavaScript engine and does not interfere with the engine s internals.
Page-Load.
We evaluated the impact of the  lter on page-load performance using the moz page-load benchmark, which Mozilla and Google run in their continuous integration  build-bots  to detect performance regressions.
Our  lter does not incur a measurable performance overhead (see Figure 8).
By contrast, the  delity-focused noXSS  lter incurs a 14% overhead on the benchmark, which is signi cant given the e ort browser vendors spend improve their page load time score by even a few percentage points.
(As expected, the IE8  lter did not incur a measurable overhead.)
Figure 8: Score on the Mozilla page-load benchmark with 10 samples.
Smaller is better.
Error bars show 95% con dence.
False Negatives.
Over the course of implementing the  l-ter, we discovered a sequence of false negatives, but all of the false negatives were implementation errors that we repaired.
After the implementation reached some level of maturity, we encouraged external security researchers to  nd additional false negatives.
A number of researchers from sla.ckers.org participated [13] and found a false negative related to Unicode denormalization.
In response, we changed the  lter s matching algorithm to ignore all non-ASCII characters.
This experience suggests that we have low assurance that the  lter lacks false negatives.
We fully expect security researchers to discover more false negatives in the future, just as these researchers continue to discover arbitrary code execution vulnerabilities in mature code bases.
However, the evidence is that these false negatives will be implementation errors that can be patched via auto-update.
Safety.
Our  lter resists two of the three induced false positive attacks described in Section 3.3:

   Container Escape.
Because WebKit does not let web sites include script in style sheets, our  lter does not prevent the attacker from injecting style sheets.
Because our  lter never disables style sheets, an attacker cannot induce a false positive to break out of a style container on Facebook.
  Parse Tree Divergence.
Because we block JavaScript from executing directly rather than mangling the HTTP response before parsing, an attacker cannot create a parse tree divergence by inducing a false positive and sites do not need to worry about changing their server-side XSS  lters to handle arbitrary mangling.
Our decision to block individual scripts rather than blocking the entire page when an XSS attack is detected means that, like the IE8 XSS  lter, our  lter can be used to disable poorly written frame busting scripts.
However, because We propose an improved design for a client-side XSS  lter.
Our design achieves high performance and high  delity by interposing on the interface between the browser s HTML parser and JavaScript engine.
Our implementation is enabled by default in Google Chrome.
Most existing client-side XSS  lters simulate the browser s HTML parser with regular expressions that produce unnecessary false positives.
These  lters can be bypassed by exploiting di erences between the simulation and the actual parser.
Worse, when they detect an attack, the  lters resort to mangling the HTTP response in a way that introduces vulnerabilities into otherwise vulnerability-free sites.
Our post-parser design examines the semantics of an HTTP response, as interpreted by the browser, without performing a time-consuming, error-prone simulation.
We block suspected attacks by preventing the injected script from being passed to the JavaScript engine rather than performing risky transformations on the HTML.
XSSAuditor (Chrome

 Filter

 noXSS (Firefox
 Page load )me (ms) Disabled Enabled classes of web security vulnerabilities, and this trend shows no signs of reversing.
Fixing every XSS vulnerability in a large web application can be a daunting task.
Every browser should include a client-side XSS  lter to help mitigate un-patched XSS vulnerabilities.
