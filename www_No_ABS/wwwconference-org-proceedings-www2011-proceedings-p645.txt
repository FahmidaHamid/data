Despite signi cant recent progress, the search for a satisfactory integration of ontologies and rules for the Semantic Web is still ongoing [17, 23].
After the publication of the 2004 W3C Recommendation for the Web Ontology Language OWL [29], discussion of the problem centered on the uncle rule brotherOf(x, y)   parentOf(y, z)   uncleOf(x, z), which is easy to state using a simple rule language such as Datalog, but which cannot be modeled at all in the 2004 version of OWL.
From the perspective of OWL design criteria, a core di culty in allowing unrestricted Datalog rules along with OWL axioms is that it leads to undecidability of reasoning in the resulting combined language.
Subsequently, a signi cant body of work has developed, investigating the integration of description logics (DLs) [1], which form the basis for OWL, and rule languages (typically Datalog).
Conceptually, one can distinguish two approaches.
Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
Frederick Maier, Adila A. Krisnadhi, Pascal Hitzler Kno.e.sis Center, Wright State University {fred,adila,pascal}@knoesis.org On the one hand, description logics have been extended with additional  description-logic-style  expressive features which make it possible to express certain types of rules.
OWL 2 [36], the 2009 revision of the OWL W3C Recommendation, in fact can express the uncle rule mentioned above.
By combining new features of OWL 2, many rules with a tree-shaped body can be expressed indirectly [26].
Decidability is nevertheless retained.
Many rules, however, such as hasParent(x,y) hasParent(x,z) married(y,z)   C(x) (1) which de nes a class C of children whose parents are married, are still not expressible.
On the other hand, there are approaches of a hybrid nature, in the sense that both OWL axioms and rules are syntactically allowed in ontologies, and a combined formal semantics de nes how the hybrid language is to be understood.
As already mentioned, such a combination generally leads to undecidability.
This is the case for the Semantic Web Rule Language SWRL [19, 20], which is the most straightforward rule extension of OWL, and for the combination of OWL DL ontologies and the Rule Interchange Format RIF (even when restricted to RIF Core) [4, 11].
A prominently discussed idea for retaining decidability is to restrict the applicability of rules to named individuals, i.e., to logical constants that are explicitly mentioned in the ontology.
Rules that are understood in this sense are called DL-safe, and the combination of OWL DL and DL-safe rules is indeed decidable [19, 33].
A generalization of DL-safe rules has been introduced in [27] in the form of DL-safe variables, as part of the de nition of the tractable rule language ELP.
Rather than restricting all variables in a (DL-safe) rule to binding only to known individuals, DL-safe variables allow the ontology engineer to explicitly specify the variables to be treated this way.
This approach was subsequently generalized to obtain DL+safe Rules as a class of expressive rule languages for which reasoning is still decidable [23].
In this paper, we expand on the above idea and improve it in several ways.
The key technical innovation is the introduction of nominal schemas as new elements of DL syntax.
While the semantic intuition behind nominal schemas is the same as that behind DL-safe variables, the di erence lies in the fact that DL-safe variables are tied to rule languages, while nominal schemas integrate seamlessly with DL syntax.
As a consequence, the language which we propose encompasses DL-safe variable SWRL while staying within the DL/OWL language paradigm.
It thus achieves within the DL framework what has hitherto only been achieved by hybrid approaches.
extended by the axioms hasParent(mary, john) ( hasParent. married.
{john})(mary) (2) (3) Axiom (2) asserts that John is a parent of Mary, while axiom (3) states that Mary belongs to the class of individuals with some (unnamed) parent who is married to John.
Using a  rst-order logic semantics as in SWRL, rule (1) would thus entail that Mary belongs to the class C. Interpreting rule (1) as DL-safe, however, does not allow this conclusion, since John s spouse is not named by any constant in the ontology.
To retain the conclusion, one can weaken this restriction to require only z to be DL-safe, while x and y can still take arbitrary values.
This is possible in the rule-based approach of DL+safe Rules, but cannot be captured in an axiom of existing description logics.
In contrast, using nominal schemas, rule (1) can be expressed as  hasParent.
{z}    hasParent. married.
{z}   C.
(4) The desired conclusion again follows.
The expression {z} is a nominal schema, which is to be read as a variable nominal that can only represent nominals (i.e., z binds to known individuals), where the binding is the same for all occurrences of the nominal schema in an axiom.
The main contributions of this paper are as follows:
 structor for description logics, denoted by the letter V in the DL nomenclature, and de ne the expressive DL SROIQV as an extension of the description logic SROIQ underlying OWL 2.
tasks to be N2ExpTime-complete, and thus not harder than OWL 2 regarding worst-case complexity, even in the DL SROIQV (Bs, ) that adds role constructors to SROIQV.
ily of DLs with nominal schemas for which reasoning is possible in polynomial time.
In particular, the DL SROELV 3( , ) is expressive enough to incorporate OWL EL and OWL RL, and to allow restricted semantic interaction between the two.
The expressivity of nominal schemas is also witnessed by the fact that it allows DLs to incorporate arbitrary DL-safe rules, given that concept intersections, existential role restrictions, and the universal (top) role are available.
Since such rules preclude polytime reasoning, our tractable DLs SROELV n( , ) employ restrictions on the number of certain occurrences of nominal schemas in each axiom.
The close relationship to nominals suggests simple ways of introducing nominal schemas into concrete syntactic forms of OWL 2, e.g.
by using the existing syntax for nominal classes with special individual names that represent variables (using some suitable naming convention).
This opens a path for introducing this feature into practical applications.
While the above worst-case complexity result for SROIQV (Bs, ) may seem encouraging, we believe that the tractable ontology language SROELV 3( , ) is the most promising candidate for implementations.
The paper is structured as follows.
In Section 2 we introduce the syntax and semantics of nominal schemas based on the expressive DL SROIQV (Bs, ).
The reasoning complexity of SROIQV (Bs, ) is studied in Section 3.
Section 4 and 5 introduce the DLs SROELV n( , ) and establish their tractability.
In Section 6 we show how DL-safe rules can be expressed with nominal schemas, based on which we can explain the relationship of SROELV 3( , ) and the tractable pro les of OWL 2 in Section 7.
We  nish by discussing further related work (Section 8) before presenting our conclusions (Section 9).
We start by introducing nominal schemas as an extension of existing description logics.
Our de nition of the resulting DL is self-contained but cannot replace introductory texts like [1, 16, 23].
The Web Ontology Language OWL 2 DL is based on the description logic SROIQ1 but we base our extension on the slightly more expressive SROIQ(Bs, ).
This DL extends SROIQ with boolean constructors ( ,  ,  ) on simple roles, and with concept products C   D that allow the construction of roles as Cartesian products of concepts.
It has been shown that this extension does not increase worst-case complexities of reasoning [23, 39].
The DL languages we study are based on a signature   =  NI , NC , NR, NV  , where NI , NC , NR, and NV are  nite and pairwise disjoint sets of individual names, concept names, role names, and variables.
The set NR is partitioned into disjoint sets N s R of non-simple role names.
R of simple role names and N n For the rest of this paper, we assume that a signature   has been  xed and so omit further references to it.
The basic building blocks of DLs are concepts and (simple or non-simple) roles: De(cid:12)nition 1.
The sets C of SROIQV (Bs, ) concepts and R (Rs/Rn) of (simple/non-simple) SROIQV (Bs, ) roles are de ned by the following grammar: R | (N s   | U |  Rs | Rs   Rs | Rs   Rs | NC NC Rs ::= N s
 R | (N n
 Rn ::= N n
 R ::= Rs | Rn
  R.C |  R.C |  Rs.Self | 6k Rs.C | >k Rs.C where k is any non-negative integer.
The constant U is the universal role, and   and   are the top and bottom concepts.
Concepts {a} with a   NI are called nominals, and concepts {x} with x   NV are called nominal schemas.
The set RC D = {C   D | C, D   C}   R is the set of all concept products.
R N n R are called inverse roles.
We de ne a function Inv : R   R as follows: For R   ) := R. For R, S   R, set NR, set Inv(R) := R Inv(R S) := Inv(R) Inv(S), Inv(R S) := Inv(R) Inv(S), and Inv( R) :=  Inv(R).
Set Inv(U ) := U and Inv(C   D) : = D   C for C, D   C.
Roles of the form R   with R   N s     and Inv(R SROIQV (Bs, ) knowledge bases are constructed from axioms as follows.
note that OWL classes and properties are called concepts and roles in DL.
inclusion axiom (RIA) is a statement of the form S1       Sk   R, with either R /  Rn, or k = 1 and S1   Rs.
A set of RIAs is regular if there is a strict partial order   on R such that   if R /  {S, Inv(S)}, then S   R if and only if Inv(S)   R; and   every RIA has the form R   R   R, Inv(R)   R, R S1 Sk   R, S1 Sk R   R, or S1 Sk   R, with R, Si   R and Si   R for each i   {1, .
.
.
, k}.
An RBox axiom is a RIA.
A TBox axiom (or general concept inclusion axiom, GCI ) is an expression C   D where C, D   C. An ABox axiom is any expression of the form C(a) or R(a, b) where C   NC , R   NR, and a, b   NI .
A SROIQV (Bs, ) axiom is any ABox, TBox, or RBox axiom, and a SROIQV (Bs, ) knowledge base is a regular set of SROIQV (Bs, ) axioms.
Some presentations of SROIQ also include RBox axioms for role characteristics which we omit here as they can already be expressed in SROIQV (Bs, ) anyway: the empty (bottom) role E ( E.     ), role disjointness disj(S1, S2) (S1   S2   E), asymmetry (disj(S, Inv(S)), re exivity (     Saux.Self, Saux   R), irre exivity ( S.Self    ), symmetry (Inv(R)   R), transitivity (R   R   R).
An example of a SROIQV (Bs, ) TBox axiom has been given as axiom (4) above, where {z} is a nominal schema.
Intuitively, each nominal schema appearing in an axiom is universally quanti ed, but ranges only over elements that are referred to by an individual name.
De(cid:12)nition 3.
An interpretation I = ( 
 I  =   and a function  I ) consists of a domain of discourse   which maps NC , NR, and NI to elements, sets, and relations of   as shown in Table 1.
A variable assignment Z for an interpretation I is a function Z : NV     such that for each v   NV , Z(v) = a for some a   NI .
For any interpretation I, assignment Z, and C(i)   C, R(i)   NR, t(i)   T, the function  I;Z I and Z satisfy a SROIQV (Bs, ) axiom  , written I,Z |=  , if the corresponding condition shown in Table 1 holds.
I satis(cid:12)es  , written I |=  , if I,Z |=   for all variable assignments Z for I. I satis(cid:12)es a SROIQV (Bs, ) knowledge base KB, written I |= KB, if I |=   for all     KB, and KB is satis(cid:12)able if such an I exists.
The axiom   is entailed by KB, written KB |=  , if all models of KB are also models of  .
is de ned as shown in Table 1.
The logic SROIQ(Bs) is obtained from SROIQV (Bs, ) by disallowing nominal schemas; concept products are already covered by SROIQ(Bs) since they can be simulated using role negations [39].
The logic SROIQ is in turn obtained from SROIQ(Bs) by disallowing boolean role constructors.
In Section 6, we show that SROIQV (Bs, ) is also expressive enough to encompass DL-safe rules (and thus DL-safe SWRL and DL-safe RIF-Core).
We note that it is straightforward to introduce nominal schemas into the normative RDF syntax for OWL 2 [37].
One way to do this would be to provide URIs for variables in the OWL namespace, used instead of individuals in owl:oneOf statements (which are used for the RDF syntax for nominals in OWL 2).
We now show that the standard inferencing problems for SROIQV (Bs, ) knowledge bases are decidable and have the same worst-case complexity as for SROIQ.
Speci cally, they are N2ExpTime-complete.
Many common inference problems for DLs require us to check whether a certain axiom or set of axioms is entailed by the given knowledge base.
For example, a concept C is subsumed by a concept D if C   D is entailed.
It is well known that such entailment questions can be reduced to checking knowledge base satis ability, i.e. asking whether some axiom is entailed is the same as asking if some (modi ed) knowledge base is satis able; see [1, 23] for details.
Hence we focus on satis ability checking only.
Reasoning with SROIQV (Bs, ) knowledge bases can be simpli ed by  rst grounding them, i.e. eliminating nominal schemas by replacing them with the ( nitely many) nom-inals that they can represent.
Reasoning in the resulting SROIQ(Bs) knowledge base is then possible as in [39].
De(cid:12)nition 4.
If   is a SROIQV (Bs, ) axiom, then its grounding ground( ) is the set of all axioms that can be obtained by uniformly replacing nominal schemas in   with nominals of the given signature.
Given a SROIQV (Bs, ) knowledge base KB, ground(KB) :=   (cid:11) KB ground( ).
Theorem 1.
A SROIQV (Bs, ) knowledge base KB is satis(cid:12)able if and only if ground(KB) is satis(cid:12)able.
In particular, checking satis(cid:12)ability of SROIQV (Bs, ) knowledge bases is decidable.
Proof.
Consider any interpretation I of the signature, which is the same for KB and ground(KB).
For any TBox axiom C   D   KB and a variable assignment Z for I, it is clear that I,Z |= C   D i  I |= C     where C     ground(KB) was obtained from C   D by replacing
 each nominal schema {x} with a nominal {c} such that c
 = Z(x).
A suitable constant c must exist for Z by De nition 3.
Conversely, every uniform replacement of nominal schemas in C   D corresponds to a choice of Z.
We conclude that I |= C   D i  I |= ground(C   D).
Analogous arguments apply to ABox and RBox axioms, showing the  rst part of the claim.
The second part follows as ground(KB) is a SROIQ(Bs)
   knowledge base, so satis ability can be checked as in [39].
Intuitively, every SROIQV (Bs, ) axiom represents an exponential number of SROIQ(Bs) axioms that are obtained by grounding.
This yields an upper bound for the complexity of reasoning with SROIQV (Bs, ) that is exponentially larger than that of SROIQ(Bs), i.e. N3ExpTime.
We now prove that this result can be re ned to obtain an N2ExpTime upper complexity bound, showing that this reasoning problem must be N2ExpTime-complete.
To accomplish this, we extend the original proof for the worst-case complexity of SROIQ [22].
We  rst recall the complexity proof of [22], including its extension to SROIQ(Bs) [39].
The proofs are based on an exponential reduction of DL knowledge bases to theories of C2, the two-variable fragment of  rst-order logic with counting quanti ers, for which satis ability can be checked in NExpTime [38].
The reduction proceeds in three steps: (1) axioms are transformed into a simpli ed normal form, (2) complex RIAs are eliminated, and (3) the resulting axioms are expressed as formulae of C2.
Name concept name role name individual name variable

 a x   top   bottom {t} nominal (schema)
 existential restriction
 universal restriction  R.Self self restriction
 concept complement
 concept conjunction
 concept disjunction quali ed number restrictions 6n R.C >n R.C universal role inverse role concept product role negation role conjunction role disjunction concept assertion (ABox) role assertion (ABox) TBox axiom RBox axiom (RIA)



 Syntax
 and     C we have     C Semantics







 a Z(x)    

     {t
 {  | there is   with  ,     R {  | for all   with  ,     R
 {  |  ,     R

  





 {  | #{ ,     R {  | #{ ,     R
   { ,   |  ,     V { ,   |     A




 ( 






 A(t) t  t
 V (t, u) , u





 R1       Rn   S R
 where   denotes the usual composition of binary relations

  








 and     B I;Z |     C I;Z |     C I;Z}   n} I;Z}   n}

 n   S



 I an interpretation; Z a variable assignment for I; A, B   NC ; C, D   C; V   NR; R(i), S   R; a   NI ; x   NV ; t, u   T.
d Ai   Bj A   {a} A    S.Self Step (1) yields an equisatis able knowledge base that contains only axioms of the following forms:
 A   >n S.B A   6n S.B where R(i)   NR and S1, S2   Rs, and C   D is short for {C   D, D   C}.
This normalization can be done in linear time; see [39] for details.
The only axioms that are not readily expressed in C2 are complex RIAs.
They are eliminated next, with exponential e ort.
  R1       Rn   R Step (2) applies a technique from [12] using nondetermin-istic  nite automata (NFA) to represent RIAs that entail non-simple roles.
Suitable NFA for SROIQ were de ned in [18, 21].
We do not repeat the details of this construction here, and merely quote the essential results.
Proofs for the following facts can be found in [18] and the accompanying technical report.
Fact 1.
Consider a SROIQ knowledge base KB.
For R, there is an NFA AR each (possibly inverse) role R   N n over the alphabet NR such that the following holds for every model I of KB, and for every word S1 .
.
.
Sn accepted by AR: If  i,  i+1    S
 .
for all i = 1, .
.
.
, n, then  1,  n+1    R
 i Moreover, let   denote a strict linear order that witnesses regularity of KB as required in De(cid:12)nition 2.
For each R   R, the number of states of AR is bounded exponentially in N n the depth of KB that is de(cid:12)ned as: max{n | there are S1   .
.
.
  Sn such that Ti1   .
.
.
  Si   .
.
.
  Timi   Si+1   KB} It su ces to construct the respective NFA for non-simple roles, and our additional role expressions thus do not interfere with this construction.
Now step (2) proceeds by replacing every axiom of the form A    R.B by the following set of axioms, where AR is the NFA as introduced above, and Xq are fresh concept names for each state q of AR: A   Xq Xq    S.Xq  Xq   B q is the initial state of AR AR has a transition q S  q q is a  nal state of AR   Moreover, all complex RIAs of the form S1   .
.
.
  Sn   R with n   2 are deleted.
The number of new axioms (and fresh concept names) that are introduced for each axiom of the form A    R.B is bounded by the sum of the number of states and transitions in AR, and the number of transitions in turn is linear in the number of role names and states.
According to Fact 1, the number of axioms introduced for each axiom A    R.B is exponentially bounded in the depth of after step (2) therefore is bounded by a function that is linear in the size of the knowledge base and exponential in the depth of the knowledge base.
Step (3),  nally, is a simple rewriting to C2 that does not increase the size of the knowledge base.
To obtain the main result of this section, it su ces to observe that grounding does not increase the depth of the knowledge base: Theorem 2.
The problem of deciding satis(cid:12)ability in SROIQV (Bs, ) KBs is N2ExpTime-complete.
Proof.
By adopting a result from [23, Proposition 5.2.1], one can show that for each SROIQV (Bs, ) knowledge base KB, one can  nd an equisatis able SROIQV (Bs, ) knowledge base without  , the size of which is linear in the size of KB.
Thus assume that KB has no concept products.
The depth of KB is only a ected by RBox axioms.
In the absence of concept products, RBox axioms are not a ected by grounding, hence the depth of ground(KB) is equal to the depth of KB.
Since ground(KB) is in SROIQ(Bs), one can apply the transformation steps (1) (3).
This yields a C2 theory T that is equisatis able to ground(KB) [39] and thus to KB (Theorem 1).
The size of T is linear in the size of ground(KB) and exponential in the depth of KB.
Both measures are exponential in the size of KB, and so is T .
Deciding satis- ability of T can be done in NExpTime [38], thus deciding satis ability of KB in N2ExpTime.
SROIQV (Bs, ) includes SROIQ, for which deciding satis ability is N2ExpTime-hard [22].
From this, hardness follows.
The result that reasoning in SROIQV (Bs, ) has the same worst-case complexity as SROIQ (and OWL 2) is encouraging, yet we are far from a practical reasoning procedure for this DL.
In particular, Theorem 2 is based on a procedure that still takes exponentially longer than the original approach for SROIQ, without this a ecting the worst-case complexity.
In this section, we therefore focus on identifying cases where inferencing is possible in polynomial time.
This still leads to a rather expressive tractable DL.
Subsequent sections will highlight the relationship to the tractable pro les of OWL 2.
Concretely, we de ne DLs SROELV n( , ) for each integer n   0, n restricting the number of  problematic  occurrences of nominal schemas detailed below.
The DLs are based on the tractable DL SROEL( , ), introduced as In essence, SROEL( , ) an extension of OWL EL [24].
is SROIQ(Bs) restricted to operators  ,   (possibly with Self),  , and some uses of  .
To preserve tractability when adding nominal schemas, we must avoid the increase in the number of axioms during grounding, which is exponential in the number of nominal schemas per axiom.
Unfortunately, one cannot reduce the number of nominal schemas by normal form transformations in general, since they represent complex dependencies that cannot be sim-pli ed.
But there are special cases where nominal schemas on the left-hand side of TBox axioms can be eliminated, or separated using independent axioms.
One such case was identi ed in [27] for the rule language ELP: if the dependencies expressed in a rule body are tree-shaped then the rule can always be reduced to a small set of normalized rules with a limited number of variables in each.
For example, a rule body that consists of a conjunction A(x)   R(x, z)   S(x, y)   B(y)   T (y, z) is not tree-shaped since there are parallel paths x R  z and x S  y T  z in the corresponding dependency structure.
In our case, binary predicates are role names, unary predicates are concept names, and constant symbols correspond to nominals.
Variables can either be  hidden  in the structure of the DL concept expression, or occur explicitly as nominal schemas (the latter are called DL-safe variables in ELP).
For example, the above rule body can be expressed as a concept A R.{z} S.(B T.
{z}).
Here, we do not introduce tree-shaped dependency structures as a general mechanism for ensuring that normal form transformations are possible, and merely identify su cient conditions for which this is the case.
This allows us to provide somewhat simpler proofs.
An obvious condition that implies tree-shaped dependencies is that a nominal schema occurs only once, and only on the left-hand side of a TBox axiom.
As in [27], the tree-shape only refers to variables (DL-safe or not), not to constants, in rule bodies.
This means that nominals (our syntax for constants) disconnect a concept s dependency structure.
E.g., if B in the above rule body is replaced by a nominal {a}, then the concept would be tree-shaped.
In such a case, we say that the nominal {z} occurs in a safe environment, as de ned next.
De(cid:12)nition 5.
An occurrence of a nominal schema {x} in a concept C is safe if C has a sub-concept of the form {a}    R.D for some a   NI , such that D contains the occurrence of {x} but no other occurrence of any nominal schema.
In this case, {a}    R.D is a safe environment for this occurrence of {x}.
S(a, x) will sometimes be used to denote an expression of the form {a}    R.D within which {x} occurs safely.
A nominal schema {x} is safe for a SROIQV (Bs, ) TBox axiom C   D if {x} does not occur in D, and at most one occurrence of {x} in C is not safe.
De(cid:12)nition 6.
Let n   0.
A SROELV n( , ) concept is a SROIQV (Bs, ) concept that may contain  ,  ,  ,  , Self, nominals and nominal schemas, but which does not contain  ,  ,  , 6k , and >k .
SROELV n( , ) roles (simple or non-simple) are SROIQV (Bs, ) roles (simple or non-simple) that may contain   (for simple roles) and U but no inverse roles,  , or  .
A SROELV n( , ) TBox axiom is a SROIQV (Bs, ) TBox axiom   that uses SROELV n( , ) concepts only, and where at most n nominal schemas are not safe for  .
An RBox axiom of SROELV n( , ) is an RBox axiom of SROIQV (Bs, ) using only SROELV n( , ) roles.
An ABox axiom of SROELV n( , ) is the same as an ABox axiom of SROIQV (Bs, ).
For a knowledge base KB and role R   NR, let ran(R) be the set of all concepts B   NC for which there is a set of the form {R   R1, R1   R2, .
.
.
, Rn 1   Rn, Rn   A   B}   KB with n   0 and R0 = R. KB is a SROELV n( , ) knowledge base if R1 Rn   S implies ran(S)   ran(Rn), and R1   R2   S implies ran(S)   ran(R1)   ran(R2).
The additional condition using ran is called admissibility of range restrictions, see [24] for details.
As explained below, restricting to at most n non-safe nominal schemas per axiom ensures that at most |NI|n axioms are introduced during grounding.
We will  x n at a constant small value, so this increase is polynomial.
It is easy to see that axiom (4) is an example of a SROELV 1( , ) axiom.
If n is constant, the problem of checking satis ability in SROELV n( , ) is possible in polynomial time w.r.t.
the size of the knowledge base.
To show this, we provide a polynomial transformation to the DL SROEL( , ), which was shown to be tractable in [24].
Let KB be a SROELV n( , ) knowledge base.
We de ne a SROEL( , ) knowledge base ground+(KB) as follows.
The RBox and ABox of ground+(KB) are the same as the RBox and ABox of KB.
For each TBox axiom   = C   D   KB, the following axioms are added to ground+(KB):
 currences in environments Si(ai, x) for i = 1, .
.
.
, l, introduce a fresh concept name Ox;(cid:11).
For every individual b   NI in KB, ground+(KB) contains an axiom  U.Si(ai, b)    U.
({b}   Ox;(cid:11)), i=1 where Si(ai, b) denotes Si(ai, x) with {x} replaced by {b}, and the empty conjunction (l = 0) denotes  .
 
   is obtained from C as follows.
Initialize := C. For each nominal schema {x} that is safe for
 by {a};  : (a) replace all safe occurrences S(a, x) in C (b) replace the non-safe occurrence (if any) of {x} in      U.Ox;(cid:11).
After these  
 contains only nominal schemas that are not steps, C
 safe for  , and neither for C     D) to ground+(KB).
Now add axioms ground(C by Ox;(cid:11); (c) set C
       Theorem 3.
Given a SROELV n( , ) knowledge base KB, the size of ground+(KB) is exponential in n and polynomial in the size of KB.
Proof.
The size of the RBox and ABox of ground+(KB) is linear in the size of KB and does not depend on n.
If m is the number of individual names in KB, then step 1 above introduces at most mk axioms for each axiom   with k nominal schemas.
This is polynomial in the size of KB.
The second step introduces |ground(C     D)| many axioms, and hence at most mn axioms for each  .
Theorem 4.
A SROELV n( , ) knowledge base KB is satis(cid:12)able if and only if ground+(KB) is satis(cid:12)able.
Proof.
We  rst introduce some notation to simplify the proof.
Let C be a SROELV n( , ) concept.
A position is a word p   {1, 2}  .
The sub-concept C|p of C at position p is de ned recursively, where   denotes the empty word: D|" := D; (D1   D2)|pi := Di|p (i   {1, 2});  R.D|p1 := D|p.
The positions of C are the positions p for which C|p is de ned.
Consider an interpretation I and variable assignment Z such that     C .
We non-deterministically de ne witnesses  p     for all positions p of C, such that  p   (C|p) .
Set  " :=  .
For the recursion, assume that  p has been de ned.
If C|p = D1   D2, then  p1 :=  p and  p2 :=  p.
If C|p =  R.D, then  p   (C|p) implies that and     D there is some   with  p,     R .
Set  p1 :=  .
Below, the selection of  p is always assumed to be arbitrary but  xed.
To clarify the context, we say that  p is a witness for some      






 .
d for     C of I that satis es the semantic conditions for     C .
Intuitively,  p thus witnesses a substructure An interpretation I for ground+(KB) is O-minimal if the following holds for all concept names Ox;(cid:11) introduced in step

   (using the notation from step 1).
Clearly, every model of KB can be extended to an O-minimal interpretation of ground+(KB).
Conversely, if ground+(KB) is satis able, it surely has an O-minimal model.
Namely, any model can be made O-minimal by reducing the extensions of Ox;(cid:11) as required.
This does not a ect the truth of other axioms, since Ox;(cid:11) only occurs in positive (non-negated) positions in the premise of TBox axioms   reducing its extension makes the premise smaller while not a ecting the conclusion.
 U.Si(ai, b) l i=1

    
 .
    D and ground(C So the claim can be obtained by showing: the O-minimal extension of every model of KB is a model of ground+(KB), and every O-minimal model of ground+(KB) is a model of KB if we ignore the interpretation of concepts Ox;(cid:11).
This can be shown individually for each axiom of KB.
It is immediate for ABox and RBox axioms.
Now consider a TBox axiom   = C   D   KB, and     D constructed in step 2.
By the proof of the axiom C
 Theorem 1, the models of C are the same.
To complete the proof, we show that an O    D. This minimal model satis es C   D i  it satis es C is implied by the following property ( ): given an O-minimal interpretation I of ground+(KB), we  nd that     C for some variable assignment Z i      C for some variable assignment Z  , where assignments in either direction of the

 claim can be chosen such that D Indeed, if I |= C   D and     C , then by ( ) we obtain Z with , and     D , thus     D     C .
The reverse direction is similar.
We show both directions of ( ) by induction over the steps used to construct C from C. The claim holds initially when
 .
Now consider the modi cations (a) (c) for one nominal schema {x} that is safe for  , and let C0, Ca, Cb, and Cc denote C in its initial state and after each of the steps (a) (c).
.
We show := Z.
Let Si(ai, x) be as in step 1.
    C  =  , we
 Since all Si(ai, x) are sub-concepts of C0 and C
 can apply our initial construction of witnesses  p to conclude Si(ai, b) = Z(x).
As I satis es the axioms of step 1 (by O-minimality), this shows  U.O .
Now Cb is obtained by replacing sub-concepts E of C0 by concepts   in (a) and (b).
Since all such E occur positively in C0, the

 claim follows from E .
For (a) this follows since   {ai}I .
For (b), we have E = {x}, and thus
  Si(ai;x) = a .
Hence  Si(ai;x)   Si(ai, b) for all i   {1, .
.
.
, l} Z(x) = b i
 follows the fact that I satis es the axioms
 so E of step 1.
introduced in (c), we have  U.O x;(cid:11)  =  , and
 thus  U.O
 If an occurrence of {x} at position p in Ca was replaced by Ox;(cid:11) in (b), then set   :=  p, where  p is a witness for     C
 .
Otherwise, if Ca = Cb, then select     O
 x;(cid:11) arbitrarily.
De ne Z such that Z(x) =   and Z(y) = Z  (y) for all y  = x.
We claim     C
 above, and
 b I  =   for all i   {1, .
.
.
, l} and some b with b For the  only if  direction, assume     C For the  if  direction, assume     C , i.e., we set Z  x;(cid:11)  =  , so O


 c = C b .
This shows C c .
We showed C c x;(cid:11) =  I
 .
For the concept
 x;(cid:11) =   .
We thus have C
 b




 c

 c
 .
b

  



 b
 b .
Now consider the witnesses  q for     C .
Thus as x does not occur in Cb, we have C     C
 b .
b It is easy to see that the same elements can be chosen as witnesses for     C , showing that the latter holds.
This follows since     {x}I;Z (for the sub-concept replaced in
 (b)), and since  S(ai;x) = a (for the sub-concepts i replaced in (a)).
  {ai}I

 A knowledge base is unsatis able if and only if it entails {a}     for arbitrary a   NI .
This reduces satis ability testing to instance retrieval (checking if a is an instance of  ).
Using the polynomial time instance retrieval method for SROEL( , ) from [24] together with Theorems 3 and 4, we thus obtain the following result.
Hardness for P follows from the hardness of SROEL( , ).
Theorem 5.
If KB is a SROELV n( , ) knowledge base of size s, satis(cid:12)ability of KB can reduced to instance retireval w.r.t.
a set of Datalog rules of size proportional to sn and at most four variables per rule.
If n is constant, the problem is P-complete.
As shown here, an interesting feature of nominal schemas is that they can be used to express arbitrary DL-safe rules [33].
These are Datalog rules with unary and binary predicates that are restricted   just like nominal schemas   to apply to domain elements that are represented by individual names.2 Identifying unary predicates with concept names, binary predicates with role names, constants with individual names, and (DL-safe) variables with the variables in nominal schemas, the syntax of DL-safe rules can be based on a DL signature.
As before, we assume the signature   =  NI , NC , NR, NV   to be  xed and omit explicit references to it.
The set of terms T of   is NI   NV .
We can now de ne the syntax and semantics of DL-safe rules.
De(cid:12)nition 7.
A concept atom is an expression of the form A(t) with t   T and A   NC   { , }.
A role atom is an expression of the form R(s, t) with s, t   T and R   NR.
An atom is a concept or role atom.
If B is a  nite and nonempty set of atoms and H is an atom, then B   H is a DL-safe rule.
B is called the body, and H is called the head.
A DL-safe rule that contains at most n distinct variables is called an n-variable rule.
, or F = R(s, t) and  s De(cid:12)nition 8.
Interpretations I and variable assignments Z for DL-safe rules are de ned as in De nition 3.
An atom F is satis(cid:12)ed by I and Z, written I,Z |= F , if either F = A(t)
 and t set of atoms B is satis(cid:12)ed by I and Z, written I,Z |= B, if I,Z |= F for all F   B.
I satis(cid:12)es a DL-safe rule B   H, written I |= B   H, if for all assignments Z for I, either I,Z |= H or I,Z  |= H.
A set of rules is satis ed if all of its elements are.
Models, satis ability, and entailment are de ned as in De nition 3.
, t The above provides a  rst-order logic semantics for DL-safe rules that is fully compatible with the semantics of
 variable assignments.
An equivalent alternative is to enforce this restriction by additional premises in rules.
See [16] for a discussion.
SROIQV (Bs, ): it uses the same kinds of models.
As such, it is meaningful to combine DL-safe rules and DL knowledge bases.
The entailment relation is immediate: a DL-safe rule or DL axiom   is entailed by a DL knowledge base KB extended with a set of rules RB if   is satis ed by all interpretations that satisfy both KB and RB.
DL-safe rules can also be used to capture the fragment of the rule language Datalog with predicates of arity at most 2, given that we are interested in the  rst-order semantics of such Datalog rules.
DL-safe rules can be transformed into SROIQV (Bs, ) axioms as follows.
  d De(cid:12)nition 9.
A syntactic transformation dl from atoms and DL-safe rules to SROIQV (Bs, ) concepts and TBox axioms is de ned as follows.
For a unary atom A(t), set dl(A(t)) :=  U.
({t}   A); for a binary atom R(s, t), set dl(R(s, t)) :=  U.({s} R.{t}).
For a DL-safe rule B   H, F B dl(F )   dl(H).
A set of DL-safe set dl(B   H) := B H RB dl(B   H).
rules RB is translated as dl(RB) := The function dl transforms rules into SROELV n( , ) TBox axioms, where n is the number of variables in the rule.
This ensures that none of the restrictions on simple and non-simple roles, regularity, or admissibility of ranges in SROELV n( , ) are violated.
In consequence, dl(RB) is a SROELV n( , ) knowledge base if RB is a set of n-variable rules.
Before showing that dl actually preserves the semantics of DL-safe rules, we present a useful lemma.
=   I;Z  =   and dl(F ) ; (2) I,Z  |= F if and only if dl(F )
 Lemma 1.
For an atom F , interpretation I, and variable assignment Z we have (1) I,Z |= F if and only if =  .
dl(F ) Proof.
Since dl(F ) has the form  U.D, there are only
 = =  .
Thus (2) is obtained as the contrapos-Given dl(F ) =  U.D, it thus su ces to show that I,Z |=
 is F i  D equivalent to (A {t}) I;Z  =  .
For F = R(s, t), the claim is that  s


  .
Both claims are clear from De nitions 3 and 8.
two options: either D   and dl(F ) itive of (1), and we only need to show the latter.
I;Z  =  .
If F = A(t), this claims that t

 is equivalent to ({s} R.
{t}) , or D =  


 , t Theorem 6.
The models of a set RB of DL-safe rules are the same as the models of dl(RB), i.e. RB and dl(RB) are semantically equivalent.
Proof.
Consider interpretation I, an assignment Z for I, and a rule B   H   RB such that dl(B   H) = CB   CH .
Lifting Lemma 1 to sets of atoms B, we  nd I,Z  |= B B =  .
It is clear that this entails the claim: either
 i  C I,Z |= H and C , or I,Z  |= B and C




 Importantly, this result con rms that nominal schemas are powerful enough to express arbitrary DL-safe rules.
The use of nominal schemas, however, in SROIQV (Bs, ) is more general than the extension of SROIQ(Bs) with DL-safe rules, since the latter correspond to a special form of SROIQV (Bs, ) axioms only.
Combining Theorem 5 with the observation that dl(RB) is linear in the size of RB, we can state the following: Theorem 7.
The problem of deciding whether a knowledge base RB   KB is satis(cid:12)able, where RB is a set of n-variable rules with n constant, and KB is a SROELV n( , ) knowledge base, is P-complete.
A   {a}

 {a}   C




 The OWL 2 standard proposes three tractable pro(cid:12)les, i.e. language fragments for which reasoning is possible in (sub)polynomial time [31].
Each of the pro les is closely related to a description logic: OWL EL is contained in SROEL( , ) [24], OWL RL is an extension of DLP [15], and OWL QL is based on DL-Lite [10].
All OWL 2 pro les include special support for datatypes and concrete data values that we have not considered here.
The respective extensions would not lead to any technical di culty, since dataype literals can be treated like individuals in all pro les.
Here, we note that with certain restrictions (speci ed below), the pro les OWL RL and OWL EL are contained within SROELV 3( , ).
The latter also covers most features of OWL QL, but we also note that the typical application areas of this pro le are not targeted by our approach.
The relation to OWL EL is obvious: a SROEL( , ) knowledge base is also a SROELV n( , ) knowledge base, for each n (including n = 3).
So this approach subsumes the pro le OWL EL without datatypes.
Similar to OWL EL, OWL RL disallows any kind of (truly) disjunctive information, but it also excludes all forms of existential quanti cation.
In return, this allows OWL RL to include inverse roles and unrestricted range restrictions which are excluded from OWL EL to preserve tractability.
Due to the lack of disjunctive and existential expressions, however, OWL RL axioms can be faithfully represented using DL-safe rules only.
Concretely, OWL RL is based on a Horn Description Logic, the axioms of which can be transformed into a number of normal forms as shown in [25].
As discussed in [23], the TBox and RBox axioms of OWL RL can thus be reduced to the normal forms in Table 2, where A, B, C   NC  { , }, R, S, T   NR, and a   NI .
Only three of these axiom types are not in SROELV n( , ).
Using DL-safe rules, we can encode A    R.C into A(x), R(x, y)   C(y), and R
 into R(x, z)   T (z, x).
For quali ed functionality restrictions, an auxiliary  DL-safe equality  role R  is encoded with the axiom {x}    R .
{y}    U.
({x}   {y}).
The axiom A   61 R.C is then represented by the DL-safe rule A(x), R(x, y1), C(x1), R(x, y2), C(x2)   R (y1, y2).
(5) Transforming DL-safe rules as in Section 6 and keeping ABox axioms without modi cation, we thus obtain a simple translation from OWL RL (without datatype-related features) to
   OWL QL,  nally, is based on DL-Lite, which is designed for its sub-polynomial AC0 data complexity [10].
This also implies that no complex RIAs are included, but inverse roles and some forms of existential quanti cation are allowed.
Inverse roles R can be replaced by new role names Rinv, with the original semantics approximated by DL-safe rules R(x, y)   Rinv(y, x) and Rinv(x, y)   R(y, x).
As in the case of OWL RL, this means that certain conclusions are lost, while tractability is preserved.
Furthermore, axioms of the form      R .C can be expressed as R       C.
  The related restrictions of De nition 6 do not apply in the absence of complex RIAs.
It must be noted that OWL RL axioms that are translated to DL-safe rules are no longer interpreted under their  rst-order semantics.
Entailments of ABox axioms   the main inference task in applications of OWL RL   are preserved, but translated axioms are not semantically equivalent to the original ontology.
Indeed, the DL obtained by allowing unions of OWL EL and OWL RL knowledge bases is
 SROIQ [35].
The combination of  DL-safe  OWL RL and OWL EL, in contrast, is still tractable, but does not entail all inferences that the unrestricted combination would.
Also, it should be pointed out that the typical uses of OWL QL for ontology-based querying of large datasets is not supported by SROEL( , ), at least not as it is by OWL QL.
Namely, the low data complexity of OWL QL enables an e cient way of query rewriting that is not available in SROEL( , ).
This limitation cannot be overcome, as AC0 ( P. Conversely, SROEL( , ) includes many features not available in OWL QL, e.g, role transitivity.
The DLs introduced here are closely related to Description Logic Rules, i.e.  rst-order rule languages that allow sets of rules to be expressed in description logics [23, 26].
As discussed in Section 6, nominal schemas are closely related to variables in DL-safe rules [33].
In [27], ELP was proposed as an extension of DL Rules for EL++ with additional DL-safe variables.
ELP is more general than the mere union of DL-safe rules and DL Rules, since a single rule can contain some variables that are DL-safe and others that are not.
However, the de nitions in [27] aim at tractability, and do not allow all uses of DL-safe variables.
As discussed in Section 4, safe environments in SROELV n( , ) are closely related to this approach.
DL-safe variables in ELP do not encompass the unrestricted use of up to n nominal schemas that is permitted in SROELV n( , ).
Like the general use of nominal schemas in SROIQV (Bs, ), this feature corresponds rather to DL+safe Rules as introduced in [23].
DL+safe Rules are obtained by allowing DL-safe variables to be used in DL Rules, and they can be viewed as a rule version of our approach.
Our complexity proofs in Section 5 are based on analogous proofs for DL+safe Rules.
In [23], the term  variable nominals  had been proposed for nominal schemas, but no according DL syntax was introduced.
Another approach toward integrating ontological modeling and rules are existential rules, that extend Datalog with existential quanti ers in rule heads.
This paradigm has attracted much interest recently, and has been studied under a variety of names such as Datalog+/{,  rules, and   primarily in the database community   tuple-generating dependencies (TGDs) [2, 3, 6, 7, 8, 9, 13, 14].
As in the combination of rules and DL, reasoning with existential rules is undecidable without further restrictions.
A chief interest of many of the above works thus is to establish formalisms for which (conjunctive) query answering is decidable, possibly with a low data complexity.
For example, it has been shown that of the DL-Lite family [7, 10].
Although the general motivation of this research is similar, there are signi cant technical di erences to our approach.
In particular, none of the above rule languages is expressive enough to capture OWL EL.
Moreover, features like cardi-nality restrictions (or equality constraints) and disjunctive modeling are hardly considered in current works.
On the other hand, many decidable fragments of existential rules are highly expressive and exhibit combined complexities of ExpTime and 2ExpTime.
Extending DLs with description graphs and rules, as proposed in [30], enables a more explicit way of modeling structured objects such as those found in the medical sciences and ontologies.
As noted in [32], in order to retain decidabil-ity, DLs are often designed with some syntactic restrictions which limit their ability to model non-tree-like structures as featured in the uncle example earlier.
On the other hand, description graphs allow us to explicitly state relationships between domain elements in the knowledge base which cannot be expressed using standard DL constructs alone.
In addition, this approach also allows description graphs to appear as graph atoms in rules, thus allowing conditional statements about the structured objects modeled by the graphs.
In its unrestricted form, extending DLs with description graphs leads to undecidability even under acyclicity conditions.
Therefore, some restrictions to prevent roles in DL axioms from interacting with roles appearing in graphs and rules are imposed to retain decidability.
Corresponding de-cidability results for SHOQ+ and SHOIQ+ have been established.
However, we are not aware of any tractable fragments of these formalisms that have been proposed.
Note that SROIQV (Bs, ) knowledge bases also induce graph-like structures due to the presence of nominals and nominal schemas, as evidenced by the fact that they can model DL-safe rules.
Yet, neither of the two languages   SROIQV (Bs, ) and DLs extended with description graphs and rules   contains the other.
A merging of both approaches is conceivable, but remains to be worked out.
We have introduced nominal schemas as an extension to DL-based ontology languages, that provides su cient ex-pressivity to incorporate rule-based modeling into ontolo-gies.
In particular, it supports the integration of Web rule languages such as SWRL and RIF with OWL 2 ontologies.
An important next step is to realize these ideas for the concrete serialization formats of these languages, and to make the corresponding modeling features available in practice.
The latter task especially includes the implementation of inference algorithms to handle nominal schemas more e -ciently.
We have shown that our extension does not increase the worst-case complexity of reasoning in OWL 2, and that versatile tractable sub-languages exist.
Whether and how these theoretical results can be put into e cient reasoning algorithms is an important research question.
Two di er-ent approaches seem viable to address this problem.
On the one hand, nominal schemas could be implemented by modifying/extending existing OWL 2 implementations that have good support for nominals, such as the OWL 2 reasoner HermiT [34].
This can be accomplished by treating nominal schemas like nominals in the deduction procedure, instantiating them with concrete individuals only when this enables relevant deduction steps.
This can be viewed as a method of deferred grounding.
On the other hand, our lightweight ontology languages could be implemented using rule-based procedures as proposed for SROEL [24].
In this setting, nominal schemas can be treated like DL-safe variables.
Thus, the rule-based deduction remains similar with the only modi cation that some variables can only be instantiated with certain constants (the approach in [24] introduces new constant symbols for eliminating existentials, and DL-safe variables are not allowed to represent these auxiliary symbols).
In conclusion, the close relationship to nominals is not merely of syntactic convenience, but prepares a path for the further practical adoption of this feature.
Instead of a paradigm shift from ontologies to rules, existing applications could be augmented with bits of rule-based modeling to overcome restrictions of classical DLs.
Nominal schemas thus may provide an exceptional opportunity for enhancing the expressive power of ontologies without giving up on established tools, format, or methodologies.
the National Science Foundation under award 1017225  III: Small: TROn Tractable Reasoning with Ontologies  and by EPSRC in project  HermiT: Reasoning with Large On-tologies  (EP/F065841/1).
The third author acknowledges support by a Fulbright Indonesia Presidential Scholarship PhD Grant 2010.
