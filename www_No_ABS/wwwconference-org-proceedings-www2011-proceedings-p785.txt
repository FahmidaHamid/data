The service-oriented architecture (SOA) is an emerging software engineering paradigm for developing distributed collaborative enterprise applications [19, 28, 29].
Proponents of SOA argue that autonomously and independently developed Web services can seamlessly interact through message exchange to enable large distributed composite applications [9, 32].
The resulting interactions among collaborating services are referred to as a service choreography [30].
A choreography of distributed Web services, deployed across different organizations, is prone to producing semantically con ict-ing behavior [18, 21, 38].
For example, an interactive procurement Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
application may involve many autonomous participants such as requester services, supplier services and evaluation services from different organizations.
The interactions of these autonomous services may generate unexpected behavior that violates the application semantics.
For instance, the sending of an item initiated by the supplier service is not an intended application semantics, if the item was already canceled by the requester service.
The occurrence of such events is referred to as a semantic con ict among collaborating Web services [21].
Semantic con icts are unacceptable for SOA applications and detrimental to business operations; often they result in loss of revenue or intolerable consumer experiences.
Thus, it is critical to control the interactions among services to prevent con icting scenarios at runtime.
Existing approaches address this issue by de n-ing a global speci cation (e.g., WS-CDL [37]) to coordinate the behavior of all participants [36, 11, 12, 22].
The global speci cation de nes allowable interactions to safeguard the collaborating services from entering into con icting situations.
To implement these approaches, the global speci cation is decomposed into local speci cations that are deployed to each service involved in the composition [36, 22].
Each local speci cation represents the allowable behavior for the corresponding participating service.
By conforming to their local speci cation, the participating services collaboratively guarantee con ict-free interactions when acting in concert as part of the composition.
Although the aforementioned solution can be applied to control the local behavior of each individually participating service so that their global interactions do not violate the speci ed application-level semantics, the solution suffers from two major limitations.
First, a global speci cation about the behavior of interacting services may not always be available, especially in a dynamic service composition.
In such a composition, the number of participating services is not  xed, services join or leave the composition freely, and services are anonymous to each other without global knowledge about the entire interaction.
The characteristics of the dynamic composition make it dif cult to design a complete global speci cation in advance [27].
For example, in emerging social commerce applications that form instant volume purchasing promotions, the number of buyer services is unknown in advance, and the strategies, among sellers that form a network dynamically, can change frequently [33].
Second, even if a global speci cation is available, the global speci cation may be non-realizable [1, 13], in the sense that there exist no local speci cations that can implement and conform to the behavior de ned by the global speci cation.
Existing approaches address the non-realizability issue by extending the global speci- cation with extra synchronization messages and coordinators [6,
 speci cation may introduce heavy end-to-end latency in the service composition, compromising its performance.
To address these limitations, we propose a novel distributed choreography framework for developing a semantic con ict-free choreography of interacting services in loosely coupled and dynamic service compositions.
In our framework, no pre-de ned and carefully crafted global speci cation is needed.
Services can join or leave a service composition dynamically by connecting and disconnecting to access points of the distributed framework that forms a service bus.
Through the choreography framework, services can interact with partners in a  exible manner by publishing messages to other services and by subscribing to messages of interest from partners.
Moreover, instead of deploying a complete global speci cation to de ne the allowable interaction behavior among collaborating services, we model only the con icting interactions as disallowable behavior and deploy them as safety constraints into the framework.
In order to avoid semantically con icting behavior among interacting services, our framework proactively controls the interactions among collaborating services to keep the safety constraints satis ed.
To reduce the extra overhead (e.g., latency) introduced by the enforcement of safety constraints, we decompose the safety constraints into sub-constraints, and deploy them to speci cally selected locations to best reduce latency in the distributed runtime environment.
We establish that the satisfaction of the sub-constraints can guarantee semantic con ict-free interactions among collaborating services.
Our approach has been fully implemented and our experimental evaluation shows that it exhibits better performance for service compositions than existing approaches.
The main contributions of this paper are fourfold: (1) we propose a novel framework to coordinate services that can dynamically join and leave a  exibly de ned and loosely-coupled service composition; (2) for the composition, we model con icting interactions among collaborating services and propose an algorithm to decompose safety constraints that prevent semantically con icting behavior; (3) we develop an algorithm to optimize the deployment of the safety constraints to minimize the coordination overhead; and (4) we conduct extensive experiments to evaluate the bene ts and characteristics of our solution.
The rest of this paper is organized as follows: Section 2 provides motivating examples to illustrate semantic con icts.
Section 3 re nes our problem statement and analyses the research challenges.
Section 4 introduces the design of our framework including: (1) the algorithm to decompose the safety constraints, along with the establishment of its correctness; and (2) the algorithm to optimize the deployment of safety constraints in the distributed runtime platform.
Section 5 evaluates our framework empirically.
Section 6 discusses the limitations of our current solution and suggests potential directions for improvements.
Section 7 compares our work to the state-of-the-art.
Semantically con icting behavior in dynamically and loosely coupled service compositions can be found in many real world scenarios.
For example, the following scenario was reported to us about an automobile manufacturer: Due to decreasing oil prices, demand for the company s hybrid vehicles dropped and sales lagged.
As a strategic business decision, the manufacturer s headquarter ordered designated dealerships to clear out their inventory through a sales promotion.
The promotion resulted in a temporary increase in sales, which triggered a noti cation to the assembly line to increase production of vehicles.
Thus, the net effect of the order to clear out excess inventory was the creation of additional inventory.
(cid:39)(cid:1004) (cid:44)(cid:89) (cid:381)(cid:396)(cid:282)(cid:286)(cid:396)(cid:400)(cid:3)(cid:24)(cid:286)(cid:258)(cid:367)(cid:286)(cid:396)(cid:400) (cid:410)(cid:381)(cid:3)(cid:272)(cid:367)(cid:286)(cid:258)(cid:396)(cid:3)(cid:381)(cid:437)(cid:410) (cid:39)(cid:454) (cid:24)(cid:286)(cid:258)(cid:367)(cid:286)(cid:396)(cid:400)(cid:3)(cid:410)(cid:381)(cid:3)(cid:258)(cid:400)(cid:364)(cid:3)(cid:18)(cid:381)(cid:381)(cid:396)(cid:282)(cid:349)(cid:374)(cid:258)(cid:410)(cid:381)(cid:396)(cid:3)(cid:410)(cid:381)(cid:3) (cid:393)(cid:349)(cid:272)(cid:364)(cid:3)(cid:410)(cid:346)(cid:286)(cid:3)(cid:374)(cid:286)(cid:454)(cid:410)(cid:3)(cid:410)(cid:258)(cid:400)(cid:364) (cid:39)(cid:1005) (cid:68)(cid:258)(cid:396)(cid:364)(cid:286)(cid:410)(cid:349)(cid:374)(cid:336)(cid:3)(cid:410)(cid:286)(cid:258)(cid:373)(cid:3) (cid:258) (cid:286)(cid:410) (cid:336) (cid:410)(cid:286)(cid:258) (cid:374)(cid:381)(cid:410)(cid:349)(cid:296)(cid:349)(cid:286)(cid:400)(cid:3)(cid:400)(cid:258)(cid:367)(cid:286)(cid:400)(cid:3)(cid:437)(cid:393)(cid:282)(cid:258)(cid:410)(cid:286)(cid:3) (cid:410)(cid:381)(cid:3)(cid:38)(cid:258)(cid:272)(cid:410)(cid:381)(cid:396)(cid:455) (cid:39)(cid:1006) (cid:75)(cid:393)(cid:286)(cid:396)(cid:258)(cid:410)(cid:349)(cid:381)(cid:374)(cid:400)(cid:3)(cid:373)(cid:258)(cid:374)(cid:258)(cid:336)(cid:286)(cid:396)(cid:3) (cid:381)(cid:396)(cid:282)(cid:286)(cid:396)(cid:400)(cid:3)(cid:393)(cid:396)(cid:381)(cid:282)(cid:437)(cid:272)(cid:410)(cid:349)(cid:381)(cid:374)(cid:3)(cid:396)(cid:258)(cid:410)(cid:286)(cid:3) (cid:272)(cid:346)(cid:258)(cid:374)(cid:336)(cid:286)(cid:3)(cid:410)(cid:381)(cid:3)(cid:38)(cid:258)(cid:272)(cid:410)(cid:381)(cid:396)(cid:455) Figure 1: Hidden pick coordination task in choreography spec-i cation from a hybrid car manufacturing use case.
(cid:39)(cid:1004) (cid:39)(cid:454) (cid:39)(cid:1005) (cid:4)(cid:437)(cid:282)(cid:349)(cid:410)(cid:349)(cid:374)(cid:336)(cid:3)(cid:393)(cid:258)(cid:396)(cid:410)(cid:374)(cid:286)(cid:396)(cid:3)(cid:400)(cid:286)(cid:374)(cid:282)(cid:400)(cid:3)(cid:296)(cid:396)(cid:258)(cid:437)(cid:282)(cid:3)(cid:449)(cid:258)(cid:396)(cid:374)(cid:349)(cid:374)(cid:336)(cid:400)(cid:3) (cid:410)(cid:381)(cid:3)(cid:4)(cid:272)(cid:272)(cid:381)(cid:437)(cid:374)(cid:410)(cid:349)(cid:374)(cid:336)(cid:3)(cid:393)(cid:258)(cid:396)(cid:410)(cid:374)(cid:286)(cid:396) (cid:4)(cid:272)(cid:272)(cid:381)(cid:437)(cid:374)(cid:410)(cid:349)(cid:374)(cid:336)(cid:3)(cid:393)(cid:258)(cid:396)(cid:410)(cid:374)(cid:286)(cid:396)(cid:3)(cid:381)(cid:396)(cid:282)(cid:286)(cid:396)(cid:400)(cid:3)(cid:272)(cid:437)(cid:400)(cid:410)(cid:381)(cid:373)(cid:286)(cid:396)(cid:3) (cid:400)(cid:286)(cid:396)(cid:448)(cid:349)(cid:272)(cid:286)(cid:3)(cid:410)(cid:381)(cid:3)(cid:349)(cid:400)(cid:400)(cid:437)(cid:286)(cid:3)(cid:396)(cid:286)(cid:296)(cid:437)(cid:374)(cid:282)(cid:3) (cid:18) (cid:410) (cid:282) (cid:410) (cid:18)(cid:437)(cid:400)(cid:410)(cid:381)(cid:373)(cid:286)(cid:396)(cid:3)(cid:400)(cid:286)(cid:396)(cid:448)(cid:349)(cid:272)(cid:286)(cid:3)(cid:349)(cid:400)(cid:400)(cid:437)(cid:286)(cid:400)(cid:3)(cid:396)(cid:286)(cid:296)(cid:437)(cid:374)(cid:282)(cid:3)(cid:410)(cid:381) (cid:296) (cid:349) (cid:349) (cid:18)(cid:437)(cid:400)(cid:410)(cid:381)(cid:373)(cid:286)(cid:396) Figure 2: Implicit coordination between consecutive tasks from a credit card processing use case.
Suppose the collaboration was designed and implemented into executable processes using Web services that are independently developed for the partners as shown in Figure 1.
G0, for instance, is an interaction between the "HQ" service and the "Dealers" service.
If there was no designated coordinator (as represented by the hidden task Gx) that governs and enforces a reliable picking of subsequent tasks given some business situation, e.g., inventory clear-out, then the partners in the collaboration can behave arbitrarily, i.e., marketing service notifying sales increase to the factory rather than having the operation management service order production decrease to the factory.
A further real world-inspired use case stems from a credit card processing scenario.
In the example, the auditing department detects fraudulent transaction on some client s account and requests the accounting department to compensate the client by crediting the amount in question back to the client s account.
However, at the same time, the client identi es the fraud on her account and demands immediate refund from the customer service department.
The customer service department, not knowing the auditing department s action, processes the refund for the client as well.
The net result for the client being a double credit.
Suppose this example was also implemented with Web services as shown in Figure 2.
The implementation implicitly imposes the coordination between the accounting service partner and the customer service partner as shown in the task Gx such that the customer service can issue the refund only if it receives the refund order from the accounting service.
The con ict in the use case was caused for the simple reason that the coordination was not actually implemented, therefore, there was nothing preventing the customer service to behave arbitrarily.
The original business logic speci ed in Figure 1 and Figure 2 is accurate from a business operations perspective.
However, the speci ed interactions are agnostic to crucial details resulting from the speci cation.
The result is that the aforementioned semantic con icts occur unintentionally.
The meticulous speci cation of constraints as safeguards against the con icts in advance is infeasible, especially in a  exible environment that allows loose-coupling of Web services.
The dynamic nature of loosely coupled Web service compositions, that is, anonymity and lack of a priori knowledge of the entire interaction, only exacerbates the problem.
A passive and na ve solution to resolve the issue is to devise an error monitoring tool and apply an error recovery approach to restore the service composition from the con icting scenarios.
However, such a solution incurs unnecessary value loss for compensating con icting interactions (e.g., the charges incurred for re-sending the canceled products to the suppliers).
Intrigued by these examples and by the lack of a reasonable solution, we develope a framework to automatically extract the hidden safety constraints, formally articulated in Section 4.
The framework enforces the constraints to prevent semantic con icts in a service choreography.
In this section we discuss the need for mechanisms to enforce con ict-free interactions in service choreographies and outline the main challenges in designing and implementing these mechanisms.
As mentioned in Section 2, the choreography of autonomous services in a loosely-coupled and dynamic service composition is prone to producing con icting interactions that violate the application semantics.
Enabling a con ict-free choreography among dynamically composed services is a challenging task for three main reasons: (1) Services can participate in the choreography at any time and from any location; (2) the number of services is a pri-ori unknown; and (3) participating services may only have a partial view of the entire collaboration and remain anonymous to each other.
In addition, preventing semantic con icts in a choreography is challenging as well.
Existing approaches that guarantee con ict-free interactions require a carefully crafted global speci cation in advance and can not handle the  exibility imposed by dynamic compositions, where no global speci cation exists a priori [27].
Instead, proactive exclusion of con icting interactions from the choreography is a more desirable approach.
In a choreography, services tend to be distributed across organizations, which precludes the use of a centralized mechanism to monitor interactions for con icts.
Centralized coordination is in-ef cient, not scalable, and might be dif cult to enforce administratively in distributed settings [20].
Therefore, a distributed coordination mechanism is needed.
However, more importantly, the distributed mechanism of excluding the con icting behavior may unintentionally overlook some con icts due to the distributed nature of the service choreography.
For example, suppose a sample service choreography is given in Figure 3(a) where Gi identi es an interaction between collaborating partners, and any message interaction sequence, except m1, m2, m4 or m1, m3, m4, should be excluded.
A distributed control mechanism is enabled in Figure 4 through a conventional decomposition method [40].
 (Gi) denotes a projection of Gi to a local task, Lxy for the collaborating partner rx with y as the unique identi er.
The control mechanism may overlook the violations of message ordering, as depicted in Figure 3(a).
In fact, the control mechanism can produce disallowed message patterns, if nothing prevents r3 from arbitrarily starting the task of sending m2 before (cid:39)(cid:1005) (cid:373)(cid:1005) (cid:396)(cid:1005) (cid:198)(cid:198)(cid:198)(cid:198) (cid:396)(cid:1006) (cid:39)(cid:1006) (cid:373)(cid:1006) (cid:396)(cid:1007) (cid:198)(cid:198)(cid:198)(cid:198) (cid:396)(cid:1008) (cid:373)(cid:1007) (cid:396)(cid:1005) (cid:198)(cid:198)(cid:198)(cid:198) (cid:396)(cid:1009) (cid:39)(cid:1007) (cid:39)(cid:1006) (cid:39)(cid:1005) (cid:373)(cid:1005) (cid:396)(cid:1005) (cid:198)(cid:198)(cid:198)(cid:198) (cid:396)(cid:1006) (cid:272)(cid:1005) (cid:396)(cid:1006) (cid:198)(cid:198)(cid:198)(cid:198) (cid:396)(cid:1007) (cid:272)(cid:1006) (cid:396)(cid:1006) (cid:198)(cid:198)(cid:198)(cid:198) (cid:396)(cid:1005) (cid:373)(cid:1006) (cid:396)(cid:1007) (cid:198)(cid:198)(cid:198)(cid:198) (cid:396)(cid:1008) (cid:272)(cid:1007) (cid:396)(cid:1008) (cid:198)(cid:198)(cid:198)(cid:198) (cid:396)(cid:1005) (cid:373)(cid:1007) (cid:396)(cid:1005) (cid:198)(cid:198)(cid:198)(cid:198) (cid:396)(cid:1009) (cid:39)(cid:1007) (cid:272)(cid:1008) (cid:396)(cid:1009) (cid:198)(cid:198)(cid:198)(cid:198) (cid:396)(cid:1005) (cid:373)(cid:1008) (cid:39)(cid:1008) (cid:396)(cid:1005) (cid:198)(cid:198)(cid:198)(cid:198) (cid:396)(cid:1007) (a) (cid:373)(cid:1008) (cid:39)(cid:1008) (cid:396)(cid:1005) (cid:198)(cid:198)(cid:198)(cid:198) (cid:396)(cid:1007) (b) Figure 3: Implicit constraints in service choreography.
(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1005)(cid:895)(cid:3)(cid:1089)(cid:3)(cid:62)(cid:1005)(cid:1005) (cid:454)(cid:894)(cid:373)(cid:1005)(cid:895) (cid:454)(cid:894)(cid:373)(cid:1008)(cid:895) (cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1008)(cid:895)(cid:3)(cid:1089)(cid:3)(cid:62)(cid:1005)(cid:1006) (cid:62)(cid:1006)(cid:1005) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1005)(cid:895) (cid:62) (cid:1089) (cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39) (cid:895) (cid:62)(cid:1007)(cid:1005) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1006)(cid:895) (cid:454)(cid:894)(cid:373)(cid:1007)(cid:895) (cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1007)(cid:895)(cid:3)(cid:1089)(cid:3)(cid:62)(cid:1005)(cid:1007) (cid:454)(cid:894)(cid:373)(cid:1005)(cid:895) (cid:894) (cid:895) (cid:454)(cid:894)(cid:373)(cid:1006)(cid:895) (cid:62)(cid:1007)(cid:1006) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1008)(cid:895) (cid:454)(cid:894)(cid:373)(cid:1008)(cid:895) (cid:62)(cid:1008)(cid:1005) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1006)(cid:895) (cid:62)(cid:1009)(cid:1005) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1007)(cid:895) (cid:454)(cid:894)(cid:373)(cid:1006)(cid:895) (cid:454)(cid:894)(cid:373)(cid:1007)(cid:895) (cid:396)(cid:1005) (cid:396)(cid:1006) (cid:396)(cid:1007) (cid:396)(cid:1008) (cid:396)(cid:1009) Figure 4: Incorrect decomposition of constraints.
r1 sends out m1, as depicted in Figure 4.
The ordering of the messages is clearly violated, rendering the safety constraint unsatis ed.
Another common type of semantic con ict that may be overlooked by a distributed control mechanism is a pick violation1.
Given the example in Figure 3(a), once G2 is picked, no message sequence other than m2, m4 should be excluded.
However, r1 in G3 can still be triggered to send m3, unless there is a mechanism to discover the hidden constraints in the pick activity to synchronize all the branches, as shown in Figure 3(b), e.g., m1 should strictly precede m2 or m3 by a con rmation message to be sent from r2 of G1 to r3 of G2.
The safety constraints cannot be enforced correctly unless the hidden constraints are discovered and enforced.
Finally, reducing the overhead introduced by the enforcement of safety constraints in a service choreography constitutes a further challenge.
Figure 3(b) shows that a distributed control mechanism to enforce safety constraints introduces extra synchronization messages c1 and c2 generated by the coordinator.
This overhead is manifest, as increase in latency depends on the location of the coordinator in the distributed environment.
Suppose the coordinator is placed in an organization to govern the pick between G2 and G3 in Figure 3(a).
It is apparent that the farther the coordinator is from the senders of G2 and G3, the more time it will take to send the synchronization messages to the senders.
Given a set of safety constraints and a number of distributed services, the deployment of the constraints into speci cally selected locations to reduce overhead is a practical goal, not previously studied.
In the remainder of paper, we address all of these challenges through our novel choreography framework.
(cid:454)(cid:894)(cid:373)(cid:1005)(cid:895) (cid:396)(cid:1006) (cid:454)(cid:894)(cid:373)(cid:1005)(cid:895) (cid:62)(cid:1006)(cid:1005) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1005)(cid:895) (cid:62)(cid:1005)(cid:1006) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1006)(cid:895) (cid:454)(cid:894)(cid:272)(cid:1007)(cid:895) (cid:454)(cid:894)(cid:272)(cid:1006)(cid:895) (cid:62)(cid:1005)(cid:1007) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1005)(cid:895) (cid:62)(cid:1006)(cid:1006) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1005)(cid:895) (cid:454)(cid:894)(cid:272)(cid:1005)(cid:895) (cid:454)(cid:894)(cid:272)(cid:1006)(cid:895) (cid:62)(cid:1006)(cid:1007) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1005)(cid:895) (cid:62)(cid:1007)(cid:1005) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1005)(cid:895) (cid:62)(cid:1007)(cid:1006) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1006)(cid:895) (cid:396)(cid:1007) (cid:454)(cid:894)(cid:272)(cid:1005)(cid:895) (cid:62)(cid:1007)(cid:1007) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1008)(cid:895) (cid:454)(cid:894)(cid:373)(cid:1006)(cid:895) (cid:454)(cid:894)(cid:373)(cid:1008)(cid:895) (cid:454)(cid:894)(cid:373)(cid:1007)(cid:895) (cid:62)(cid:1005)(cid:1009) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1007)(cid:895) (cid:62)(cid:1005)(cid:1008) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1008)(cid:895) (cid:454)(cid:894)(cid:373)(cid:1008)(cid:895) (cid:454)(cid:894)(cid:272)(cid:1008)(cid:895) (cid:62)(cid:1005)(cid:1010) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1007)(cid:895) (cid:396)(cid:1005) (cid:62)(cid:1009)(cid:1005) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1007)(cid:895) (cid:454)(cid:894)(cid:373)(cid:1007)(cid:895) (cid:1009)(cid:1005) (cid:77)(cid:77)(cid:77)(cid:77)(cid:894) (cid:1007)(cid:895) (cid:454)(cid:894)(cid:373)(cid:1007)(cid:895) (cid:62)(cid:1009)(cid:1006) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1007)(cid:895) (cid:396)(cid:1009) (cid:454)(cid:894)(cid:272)(cid:1008)(cid:895) (cid:62)(cid:1008)(cid:1005) (cid:1089) (cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1006)(cid:895) (cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1006)(cid:895) (cid:62)(cid:1008)(cid:1005) (cid:454)(cid:894)(cid:373)(cid:1006)(cid:895) (cid:454)(cid:894)(cid:373)(cid:1006)(cid:895) (cid:62)(cid:1008)(cid:1006) (cid:1089)(cid:3)(cid:77)(cid:77)(cid:77)(cid:77)(cid:894)(cid:39)(cid:1007)(cid:895) (cid:396)(cid:1008) (cid:454)(cid:894)(cid:272)(cid:1007)(cid:895) Figure 5: Example of reliable decomposition.
In this section, we provide both abstract and practical solutions for a semantic con ict-free service choreography in a dynamic and loosely coupled service composition.
We coordinate service interactions by implementing service choreography on top of a distributed content-based publish/subscribe system [10].
The publish/subscribe system is comprised of a set of brokers interconnected to form a federated overlay to route messages from data producers to consumers [20].
As opposed to tightly-coupled, end-to-end delivery solutions, a publish/subscribe system offers ef cient many-to-many communication patterns, full data source and sink decoupling, loose-coupling, message correlation capabilities, in-network content-based  ltering capabilities, and location transparency [20].
Based on these capabilities, distributed services can easily interact with each other in a loosely-coupled manner by publishing messages to partner services and by subscribing to messages of interest from partner services.
In this way, autonomous services can join or leave a composition dynamically by connecting or disconnecting to brokers in the publish/subscribe system at any time.
However, The decomposition of safety constraints into sub-constraints, as mentioned in Section 3, may neglect to capture con icting scenarios due to missing synchronization messages.
To address this issue, our solution derives missing synchronization messages and automatically incorporates them explicitly into the decomposed sub-constraints.
To sketch out the solution, we revisit the sample safety constraint from Figure 3.
The safety constraint is decomposed into sub-constraints for partner services r1, - ,r5.
Note that the key difference between Figure 4 and Figure 5 is that coordination messages, ci, where i = 1, 2, 3, 4, are derived and mapped to appropriate sub-constraints.
For example, between G1 and G2, a coordination is necessary as the safety constraint implicitly states that r3 should not send out message, m2 until r2 receives the message m1 from r2.
In this particular example, every run of the service choreography, controlled by the decomposed set of sub-constraints with the introduction of explicit coordination among the sub-constraints, guarantees to exclude invalid message sequences that are implicitly speci ed, as in Figure 3(b).
In this example, the message sequences other than m1, c1, m2, c3, m4 or m1, c2, m3, c4, m4 are invalid.
To minimize coordination overhead, we propose an algorithm to place coordinators, introduced by the decomposition of safety constraints, in the publish/subscribe system to best reduce latency for the service composition.
The algorithm is designed based on the safety constraints and the broker overlay topology of the pub-lish/subscribe system.
It takes the aggregated weights of latency for a service composition introduced by extra coordinators into account.
Then, the algorithm places coordinators at speci cally selected brokers to best reduce the overall latency.
In the next section, we turn our attention to the technique of safety constraints enforcement.
As mentioned earlier, we model con icting interactions as dis-allowable behavior and enforce safety constraints to exclude them.
Speci cally, the safety constraints are decomposed into sub-constraints and deployed into the distributed runtime platform.
In this section, we formalize the safety constraints and the decomposition algorithm to serve as a theoretical basis for our solution.
We model the safety constraints as an interaction process among services.
De nition 1.
An interaction process P is de ned as follows: m  r2, P   (aint.
  P ) | (P (cid:3) P ) | (P + P ) | 0, aint.
  r1 where aint.
represents an interaction.
i.e., r1 sends a message m to r2.
Operators  ,  (cid:3) , and  +  formally represent the sequence, parallel, and choice operators in WS-CDL, respectively.
The termination process is represented as 0.
Decomposing an interaction process into local processes to govern the behavior of each participating service may generate interaction that are different from what the original interaction process speci es.
Formally, let P be an interaction process and LSri represents the decomposed sub-constraints for a partner service, ri, and there exists an interaction sequence a1,a2,   ,ak among the partner services.
If the interaction sequence is the outcome of the composition of local interaction processes(LSr1 (cid:3)   (cid:3) LSrm), but not the outcome of P , then the decomposition results in different behavior between the local processes and the original interaction process.
Note that this difference is caused by the loss of synchronizations during the decomposition.
Therefore, to correctly enforce the safety constraints, we need to explore and incorporate the missing synchronizations into the interaction processes.
The following rules show how this is done: De nition 2.
Let P be an interaction process, and a transformation function, P (cid:2)    (P ), is de ned recursively by the following rules:
 m1  r2, bint.
  r3
 m1 
 m2  r4, r1 (cid:5)= r3, r1 r2, bint.
  r3 P2), where aint.
  r1 m2  r4, r2 (cid:5)= r3, cint.
  r2 m1  r2, bint.
  r3 m2  r4, r2 = r3.
c1  r3.
aint.
  r1 c2  r3.
m2 r4, r1 = r3.
c1  r1, cint.2   rc
 m1  r2, bint.
  r3



 Based on the rules in De nition 2, we can enrich a safety constraint with extra coordination messages and coordinators to make the decomposed sub-constraints consistent with the safety constraints.
In particular, Rule 1 addresses the out-of-order messages by adding a synchronization message between two consecutive global tasks, (i.e., interactions) where the receiver in the  rst one is different from the sender in the second one.
Rule 3 addresses the invalid pick problem by adding a coordinator to coordinate the two branches, if the senders in the different branches belong to different partners.
Rule 2 states that if the receiver in an interaction is also the sender in the immediately following interaction, then no synchronization is needed.
Similarly, Rule 4 states that if the senders in the  rst interactions in two branches are from the same partner, then no synchronization is needed.
In addition, Rule 5 states that the two interaction processes can be enriched individually in parallel.
Rules 6 and 7 specify the termination conditions of enriching an interac- tion process.
The following theorem guarantees the correctness of our approach.
Theorem 1.
Given an interaction process P and P (cid:2)    (P ), then every interaction sequence of P (cid:2) is also an interaction sequence of LSr1 (cid:3)   (cid:3)LSrm, and vice versa, where LSri is the decomposed local process of P (cid:2) .
The proof of Theorem 1 is based on the rules in De nition 2.
The full proof is provided in our technical report [40].
In the next section, we design algorithms to implement these rules.
Algorithm 1: Decomposition(G) Input: Safety constraints G, Set of partners R = {ri|i = 1, 2, ...n} Output: Set of local sub-constraints LS if G is not decomposed then foreach r   R do if G is a successor of junction task then CurrentT ask_r = junction task; (LS_currentSender)_G.AddTask(G.id(), x(current_message)); (LS_currentReceiver)_G.AddTask(G.id(), x(current_message)); foreach nextTask of G do if (nextTask.sender (cid:3)= currentReceiver) or (G is P ICK) then LS_currentReceiver.AddTask(G.id(), x(c)); LS_(nextT ask_sender).AddTask(G.id(), x(c)); foreach nextTask of G do if nextTask is not decomposed then Decomposition(nextTask); else LS_(nextT ask_sender).AddTransition(nextTask.id()); if currentSender = nextReceiver | currentReceiver = nextReceiver then LS_(nextT ask_receiver).AddTransition(nextTask.id());
















 In the previous section, we showed that the new coordination mechanism guarantees correct decomposition of safety constraints.
In this section, we present techniques to implement the coordination mechanism.
Algorithm 1 determines the arrangement of coordination messages between partners.
Suppose the two subsequent global tasks, G followed by G(cid:2) , are given.
If the receiver of G is a different partner as the sender of G(cid:2) , then the algorithm must let the receiver of G Algorithm 2: AddTask(id, Lnew) Input: Sub-constraints LS, Hash(k, List) where k = global task id, Last_k Hash.put(id, Lnew); if Lnew is PICK or FLOW then Llast = Hash.get(Last_k).getF irstElement(); Llast = Hash.get(Last_k).getLastElement(); else Succ_Llast   Succ_Llast   Lnew.id(); P rec_Lnew   P rec_Lnew   Llast.id(); Last_k   id;







 Algorithm 3: AddTransition(id) Input: Hash(k, List(L, L Last_k Lf rom = Hash.get(id).getLastElement(); Lto = Hash.get(Last_k).getLastElement(); P rec_(Lf rom)   P rec_(Lf rom)   Lto.id(); Succ_(Lf rom)   Succ_(Lf rom)   Lf rom.id(); (cid:2))) where k = global task id,



 include a local task of sending out a coordination message toward the sender of G(cid:2) into its sub-constraints as in (Algorithm 1: 6 10).
Unlike the conventional faulty decomposition methods, multiple local tasks can be produced by a single projection of a global inter-action(Algorithm 1: 6 7) for a sender and a receiver.
The mapping between the global and the local tasks is maintained in a hash table (Algorithm 2: Input).
First, the local task of sending a coordination message makes a transition from the branching task (pick/ ow) in the local process (Algorithm 3:2-3), if the local task is projected by a global branching task, as r2 in Figure 5.
When the decomposition framework explicitly requests (Algorithm 1:15-17) to set up a transition using AddTransition (Algorithm 3) from the task added by the previously projected global task (Last_k), then there is a choice to be made to which element should the last added task make a transition to, because the mapping returns a list of local tasks.
Our framework simply chooses the last element (Algorithm 3:2) and adds the transition by updating the pointers to immediately preceding (P rec) or succeeding (Succ) tasks (Algorithm 3:3-4).
The newly derived service choreography, as in Figure 5, always excludes the invalid message sequences thanks to the strict serialization through explicit arrangement of coordination among partners.
Particularly for Figure 5, there is a globally unique initial send task (L1 of r1) while others are under the constraint to start to send a message only after receiving some message  rst.
We employ a platform that can support the execution of chore-ographies of independently developed Web services at global scale.
To enable the exchange of large volumes of messages between Web services placed at geographically distributed locations, a scalable and ef cient messaging substrate is essential.
We adopt the federated content-based pub/sub messaging system, PADRES [10], already proven as distributed business process execution platform [20] and as management platform for SOA applications in large deployments [17, 24, 39].
We use the ef cient and reliable routing mechanism of PADRES for choreography message exchange as shown in Figure 6.
Each participating Web service is attached to a choreography agent.
A choreography agent interprets and translates local processes into pub/sub constructs, e.g., advertisements, subscriptions, and publications.
Upon translation of the local processes, the agent advertises and subscribes to messages to be sent out and received, respectively.
Once the initialization is complete, agents (cid:18)(cid:4) (cid:17) (cid:18)(cid:4) (cid:17) (cid:62)(cid:87) (cid:18)(cid:381)(cid:381)(cid:396)(cid:282)(cid:349)(cid:374)(cid:258)(cid:410)(cid:381)(cid:396) (cid:17) (cid:17) (cid:17) (cid:18)(cid:381)(cid:374)(cid:400)(cid:410)(cid:396)(cid:258)(cid:349)(cid:374)(cid:410)(cid:3) (cid:24)(cid:286)(cid:393)(cid:367)(cid:381)(cid:455)(cid:286)(cid:396) (cid:18)(cid:381)(cid:381)(cid:396)(cid:282)(cid:349)(cid:374)(cid:258)(cid:410)(cid:381)(cid:396) (cid:62)(cid:87) (cid:62)(cid:87) (cid:17) (cid:17) (cid:62)(cid:87) (cid:62)(cid:87) (cid:18)(cid:4) (cid:18)(cid:4) (cid:62)(cid:87)(cid:3)(cid:894)(cid:94)(cid:437)(cid:271)(cid:882)(cid:272)(cid:381)(cid:374)(cid:400)(cid:410)(cid:396)(cid:258)(cid:349)(cid:374)(cid:410)(cid:400)(cid:895)(cid:855) (cid:62)(cid:381)(cid:272)(cid:258)(cid:367)(cid:3)(cid:87)(cid:396)(cid:381)(cid:272)(cid:286)(cid:400)(cid:400) (cid:18)(cid:4)(cid:855) (cid:18)(cid:346)(cid:381)(cid:396)(cid:286)(cid:381)(cid:336)(cid:396)(cid:258)(cid:393)(cid:346)(cid:455)(cid:3)(cid:4)(cid:336)(cid:286)(cid:374)(cid:410) (cid:17)(cid:855)(cid:3)(cid:87)(cid:437)(cid:271)(cid:876)(cid:94)(cid:437)(cid:271)(cid:3)(cid:17)(cid:396)(cid:381)(cid:364)(cid:286)(cid:396) (cid:349) (cid:396) (cid:381) (cid:381) (cid:410) (cid:258) (cid:374) (cid:282) (cid:396) (cid:381) (cid:381) (cid:18) (cid:3) (cid:876) (cid:3) (cid:4) (cid:18) (cid:62)(cid:381)(cid:272)(cid:258)(cid:367) (cid:62)(cid:381)(cid:272)(cid:258)(cid:367)(cid:3) (cid:87)(cid:396)(cid:381)(cid:272)(cid:286)(cid:400)(cid:400)(cid:3) (cid:47)(cid:374)(cid:410)(cid:286)(cid:396)(cid:393)(cid:396)(cid:286)(cid:410)(cid:286)(cid:396) (cid:87)(cid:396)(cid:381)(cid:272)(cid:286)(cid:400)(cid:400) (cid:87)(cid:396)(cid:381)(cid:272)(cid:286)(cid:400)(cid:400)(cid:3) (cid:47)(cid:374)(cid:400)(cid:410)(cid:258)(cid:374)(cid:272)(cid:286)(cid:3) (cid:47)(cid:374)(cid:349)(cid:410)(cid:349)(cid:258)(cid:367)(cid:349)(cid:460)(cid:286)(cid:396) (cid:18)(cid:346)(cid:381)(cid:396)(cid:286)(cid:381)(cid:336)(cid:396)(cid:258)(cid:393)(cid:346)(cid:455) (cid:18)(cid:346)(cid:381)(cid:396)(cid:286)(cid:381)(cid:336)(cid:396)(cid:258)(cid:393)(cid:346)(cid:455)(cid:3) (cid:18)(cid:346)(cid:381)(cid:396)(cid:286)(cid:381)(cid:336)(cid:396)(cid:258)(cid:393)(cid:346)(cid:455) (cid:18)(cid:346)(cid:381)(cid:396)(cid:286)(cid:381)(cid:336)(cid:396)(cid:258)(cid:393)(cid:346)(cid:455)(cid:3) (cid:68)(cid:286)(cid:400)(cid:400)(cid:258)(cid:336)(cid:286)(cid:3) (cid:39)(cid:286)(cid:374)(cid:286)(cid:396)(cid:258)(cid:410)(cid:381)(cid:396) (cid:68)(cid:286)(cid:400)(cid:400)(cid:258)(cid:336)(cid:286)(cid:3) (cid:62)(cid:349)(cid:400)(cid:410)(cid:286)(cid:374)(cid:286)(cid:396) (cid:87)(cid:437)(cid:271)(cid:876)(cid:94)(cid:437)(cid:271)(cid:3)(cid:100)(cid:396)(cid:258)(cid:374)(cid:400)(cid:367)(cid:258)(cid:410)(cid:381)(cid:396)(cid:3) (cid:87)(cid:437)(cid:271)(cid:876)(cid:94)(cid:437)(cid:271)(cid:3)(cid:18)(cid:381)(cid:373)(cid:373)(cid:437)(cid:374)(cid:349)(cid:272)(cid:258)(cid:410)(cid:349)(cid:381)(cid:374)(cid:3)(cid:47)(cid:374)(cid:410)(cid:286)(cid:396)(cid:296)(cid:258)(cid:272)(cid:286)(cid:3) Figure 6: Choreography platform architecture.
step through the local processes by either publishing messages or listening (subscribing) to pending messages.
Local processes are guaranteed to receive coordination messages as PADRES ensures reliable, duplicate-free, per-source ordering.
A dif culty arises for the pick task.
Placing a single coordinator in a large messaging overlay is not desirable because it cannot ef ciently handle multiple pick tasks issued concurrently at different locations in the overlay.
We therefore opt to allocate multiple coordinators per pick task instead.
The challenge is to determine a placement of coordinators in the messaging overlay that reduces coordination overhead.
Our solution aims to minimize the messaging overhead involved with pick tasks.
Given a list of services r1, r2, .
.
.
, rn that are potential recipients of the pick decision, the coordination overhead, L, is formally de ned as
 n(cid:2) i=1 wri dri , where ri is a partner service, wri is the weight expressed as an average time to execute the end-to-end local interaction process of ri and dri is a distance metric which is measured in terms of hop counts from ri to the coordinator at the candidate location in the messaging overlay.
The weight, w, is to give higher precedence to a task that contributes to the pick overhead over time, e.g., a task with many subsequent tasks or with lengthy local processes.
The weight can be more accurately computed by incorporating the pick probability distribution over time, i.e., the task with higher probability to be picked obtains a higher weight.
A further issue is that there can be another pick task among the subsequent tasks of the process contributing to the overhead of the current pick task.
Therefore, the placement of a pick coordinator should be pending subject to the placement of pick coordinators for subsequent pick tasks.
To achieve this, our solution is based on recursive algorithms as presented in Algorithm 4, 5.
Revisiting the overall architecture of the platform in Figure 6, the coordinators are deployed to the overlay and follow the coordination processes just as the choreography agents follow their local processes.
Algorithm 4: Overhead(task) overhead = 0 List if task is leaf then return Overhead = runtime of task; else Overhead += runtime of task; foreach child of task do add Overhead(child) to List; return Overhead+ =P laceCoordinator (List); Algorithm 5: PlaceCoordinator(List) minimumOverhead = 0 totalOverhead = 0 bestBroker foreach broker of Brokers do foreach task of List do totalOverhead+ = Distance(task.sender, broker)   overhead; if minumOverhead > totalOverhead then minimumOverhead = totalOverhead; bestBroker = broker; Assign a coordinators to bestBroker return minimumOverhead;












 implemented on a cluster of IBM x3550 machines.
The machines in the cluster communicate over a 1Gbps switched Ethernet connection, and each machine contains two Intel Xeon 5120 dual-core
 sub-constraints are deployed to each partner that is randomly connected to one of the broker on a PADRES2 messaging overlay.
Safety constraints for the service choreography are randomly generated as an interaction process in a directed graph.
The processes vary in number of tasks, partners, and task executions.
Each task speci es a pair of sender and receiver and a message to be exchanged.
Every edge denotes a transition between two tasks.
Given the set of partners whose initial task is to send a message, our framework randomly chooses an initial sender and triggers it at a constant rate to execute the sending task during every instance of the service choreography.
In the following subsections, we empirically assess how much the service choreography based on the conventional decomposition [40] is prone to producing message communication patterns that do not conform to the implicit and hidden safety constraints.
Speci cally, we measure the number of messages delivered out-of-order and the number of pick violations that re ect the degree of potential semantic con icts.
Then, we assess the bene ts of the distributed coordination mechanism as oppose to centralized coordination in the runtime platform in terms of end-to-end latency of a choreography.
Finally, we measure the overhead of the new approach to avoid potential semantic con icts in terms of the number of coordination messages to be sent, and evaluate the runtime cost to execute the decomposition framework.
Also, we measure the increase of local tasks along with the size of the rules our framework has to maintain in order to monitor invalid message patterns during runtime.
This section presents experimental evaluation of the algorithm for reliable decomposition of safety constraints and the ef ciency of the runtime choreography platform.
The decomposition algorithm was tested on a machine with Intel Core2 Duo 1.80GHz processors and 2GB of RAM.
The runtime framework has been fully Figure 7 and Figure 8 show minimum, maximum and average number of violations of the ordering and pick constraints.
They indicate that the number of violations grows proportionally to the number of tasks and the number of executions.
The number of violations is not affected by the number of peers, as the constraints on 2http://msrg.org/projects/padres/ n o i t l a o
 i r e d r
 f o r e b m u
 s n o i t l i a o
 k c
 i f o r e b m u















 PICK-avg
 FLOW-avg
 s n o i t l a o
 i r e d r
 f o r e b m u













 PICK-avg.
FLOW-avg.
Number of Tasks Number of Partners (a) (b) Figure 7: Number of ordering violations.
PICK-avg
 s n o i t l i a o
 k c
 i f o r e b m u













 PICK-avg





 f o r e b m u
 s n o i t l a o
 i r e d r
 f o r e b m u
 s n o i t l i a o
 k c
 i














 PICK-avg
 FLOW-avg





 Number of Executions (c) PICK-avg





 Number of Tasks Number of Partners Number of Executions (a) (b) (c) Figure 8: Number of pick violations.
the message communication sequences from the global perspective are agnostic of the participating peers, i.e., no matter how many different partners are involved in the process, ordering requirements must be met.
About 20% of 2,000 task executions violated the constraints.
The results show high variance in the degree of the violations.
Identifying the structural properties that make safety constraints prone to the violations is subject to future work.
The fact that different partners contribute to the violations at different times and locations makes it a complicated and costly task to identify the root cause of the violation and to roll back the tasks already executed.
The signi cant amount of violations re ects that detrimental damage already has been done to the collaboration through the unreliable service choreography.
Figure 9(b) shows the size of the
 We measured the elapsed time to decompose safety constraints.
Given a service choreography with 1,000 tasks and 10 partners, it required from 38% and 30% more time on average to decompose the process in a pick and a  ow pattern, respectively, as shown on Figure 10.
With the varying number of partners, up to 1,000, our decomposition method took 72% and 56% more time on average for a pick and a  ow pattern, respectively.
The general increase exhibited in our experiment is due to the additional arrangement of the coordination among partners.
Yet, on average the elapsed time still remains within sub-milliseconds, thus our method does not cost signi cantly more than the conventional decomposition method, in terms of computation.
r e n t r a
 r e p s k s a
 f o r e b m u







 Reliable Faulty




 )

 ( s e u
 l r e d r
 r o f e c a p






 Order Rules Pick Rules








 )

 l ( s e u
 k c
 i r o f e c a p
 ) s u ( i e m
 n o i t i s o p m o c e







 Reliable-FLOW Reliable-PICK Faulty-FLOW Faulty-PICK ) s u ( i e m
 n o i t i s o p m o c e











 Reliable-FLOW Reliable-PICK Faulty-FLOW Faulty-PICK




 Number of Initial Tasks Number of Tasks Number of Partners Number of Tasks (a) (b) Figure 9: Coordination overhead.
(a) (b) Figure 10: Decomposition runtime.
rules that are used to detect con icts by the broker in production.
About 10KB and 1MB are needed for the rules to detect ordering and pick violations, respectively, given 1,000 tasks and 10 partners.
Figure 9(a) shows that each partner may experience about 130% increase in the number of tasks in its sub-constraint, as the tasks of either sending or receiving coordination messages are newly added through the new decomposition method.
The con ict-free service choreography is realized at the cost of strictly coordinating the messages exchanged among the partners when necessary as implied in the safety constraints.
Figure 11 shows that the number of coordination messages increases with the number of tasks and the number of executions, both for the pick and e g a s s e
 n o i t i a n d r o o
 f o r e b m u








 PICK-avg
 FLOW-avg





 s e g a s s e
 n o i t i a n d r o o
 f o r e b m u









 PICK-avg
 FLOW-avg






 s e g a s s e
 n o i t i a n d r o o
 f o r e b m u
 PICK-avg
 FLOW-avg











 Number of Tasks Number of Partners Number of Executions (a) (b) (c) Figure 11: Number of coordination messages exchanged among partners.
 ow patterns.
Pick patterns yielded more coordination messages than the  ow patterns, since not only a coordination message has to be exchanged between two consecutive tasks if necessary, but also a coordination message is required between the partner services and pick coordinators.
In our experiment each control message simply consists of a 1 byte character to distinguish the type of message and a 4 byte integer to identify the message.
Thus, for 2,000 executions, a total of only 14KB on average are used by the system.
In practice, the control message does not have to be signi cantly larger than ours.
) c e s ( e m i t n u










 Distributed Central





 ) c e s ( e m i t n u










 Distributed Central





 Number of pick tasks Number of Concurrent Instances (a) (b) Figure 12: Latency in service choreography.
We measured the end-to-end latency of completing a set of chore-ographies with the varying number of pick coordination tasks and the varying degree of concurrency.
An acyclic PADRES broker overlay with fanout of up to 2 is randomly generated on 15 nodes in our cluster.
20 unique services are randomly assigned to the nodes in the overlay.
For benchmarking purpose, we tuned Algorithm 4, 5 to create coordination mechanism.
Instead of assigning the broker at Algorithm 5:6, Algorithm 4 collects every intermediate overhead statement into a list which is iterated over to pick one coordination location in the overlay after the collection is completed.
The distributed coordination mechanism outperforms the centralized one from 2% to 14% with a single process instance with from 20 to 100 unique pick coordination tasks, respectively.
The bene t of the distributed coordination mechanism becomes bigger when multiple process instances run concurrently (Figure 12(a)).
With 10 independent choreography instances (each with 20 services and 20 picks) starting at the same time and running concurrently, the distributed coordination performed 60% better than the centralized in terms of the latency (Figure 12(b)).
Therefore, the distributed coordination promises more scalable approach to host multiple choreographed processes.
Services that participate in the collaboration may relocate frequently to cause coordination overhead to change.
This may require adaptive re-computation of the the locations for the pick coordinators.
Note that our coordination mechanism is enabled per instance.
As a future work, our framework can be extended to support coordination for interaction among multiple instances.
An alternative approach to our coordination mechanism is to allow individual services to govern the pick operation.
But this can lead to wrong pick decision making by a malicious service.
Moreover, services may have af nity to particular locations, therefore, controlling the overhead of coordination such as latency can be less  exible.
In our solution, we enrich the safety constraints with extra coordination messages to avoid potential overlooked semantic con icts.
Such coordination messages may not exactly re ect the design intention of the choreography and thus restrict the behavior of services, but our solution discovers only the hidden and missing synchronizations among the service conversations.
Choreography designers can check whether the hidden and missing synchronizations identi ed by our framework are design faults and choose to  x the problems using our recommended solution or other solutions.
In a more  exible environment, safety constraints can evolve and multiple versions of decomposed constraints can co-exit during runtime, which inevitably causes semantic con icts.
In order to avoid such a problem, management tools that can monitor the status of choreography instances and stop/resume them, if necessary, is required.
We have already started investigating the adaptation of relevant work ow management standards [15].
In this section, our work is put in context of existing techniques in service composition, veri cation of service choreography and decomposition algorithms.
Coordination Framework for Dynamic Service Compositions.
Dynamic composition of services is challenging but of bene t to changing business requirements [29].
Several approaches have been proposed to provide infrastructure support for dynamic composition of services [16].
For example, eFlow [5] is a framework supporting adaptive and dynamic composition of services.
eFlow allows the business logic of a service composition to be modi ed dynamically.
Bultan et al. proposed a theoretical framework to model service conversation speci cations and studied realizability of service compositions [4].
Nezhad et al. designed a business conversation manager to support business conversations among people around best practices [26].
Brambilla et al. proposed a CASE tool together with a web engineering methodology to model and revise as a template in these approaches to guide the adaptation or coordination of service interactions.
Our framework coordinates service interactions in a more  exible and loosely-coupled way, especially when a global speci cation is not available.
There also exist approaches based on message-oriented middle-ware to support service orchestration and choreography.
For example, Li et al. proposed a framework to deploy a centralized BPEL process into a set of distributed execution engines on top of a pub/sub middleware [20].
Overbeek et al. combined SOA and event-driven architectures to deliver services in a pub/sub network [27].
Tai et al. proposed to use message-oriented middle-ware for service interactions [34].
In addition, some industrial Web service coordination frameworks and standards are also proposed to develop service-oriented applications.
For example, WS-Coordination (WS-C)3 is a framework that provides protocols to coordinate the activities of involved services in a service composition.
Web Services Composite Application Framework (WS-CAF)4 coordinates the activities and propagates the contexts among the involved services.
The difference is that we applied a pub/sub mid-dleware not only to route messages, but also to coordinate loosely coupled,  exible and dynamic service compositions.
Moreover, we also deployed safety constraints into the distributed framework to prevent semantically con icting interactions with acceptable processing overhead.
Resolving Mismatches for Service Choreography.
Many research efforts have been devoted to constructing a choreography for independently developed services.
To resolve mismatches between interacting services, Nezhad et al. proposed a semi-automated approach to adapt service interactions based on a constructed mismatch tree [23].
Benatallah et al. proposed a framework to develop adapters for service interoperability based on mismatch patterns [2].
Dumas et al. resolved mismatches between services by adapting their behavioral interfaces with algebra and visual notations [8].
These approaches can be applied to resolve semantic con icts for interacting services by introducing adapters to bridge mismatches.
However, these solutions are incapable of handling loosely coupled and dynamic service compositions, as the adapters designed to model mismatches may not be able to anticipate new mismatches introduced by dynamically joining services.
Doganata et al. suggested to detect compliance failures in business processes using automatic auditing tools [7].
Our work provides a more  exible coordination framework to resolve semantic con icts among interacting services in dynamic service compositions.
Instead of adapting the involved services, our framework enforces safety constraints to control interactions among services to prevent service compositions from entering into semantically con icting situations.
Conformance Checking for Service Choreography.
Another solution to prevent con icts in service choreography is to select services that correctly implement a global speci cation.
This requires to check the conformance between selected services and the global speci cation of the service composition.
Aalst et al. [36] evaluated the conformance relationships between service behavior at runtime and its global speci cation in terms of two properties, that is,  tness and appropriateness.
Montali et al. [22] described the global speci cation with a declarative language and veri ed the services  behavior based on logic.
Fu et al. [12] used automata to verify service compositions with asynchronous communication.
Foster et al. [11] veri ed the safety and liveness properties of ser-3http://docs.oasis-open.org/ws-tx/wscoor/ 4http://www.oasis-open.org/committees/ws-caf/ vice compositions based on process algebra.
All these approaches are restricted to a service composition with a fully de ned global speci cation.
In a loosely coupled and dynamic service composition where the number of services is unknown and services can join or leave dynamically, a well planned global speci cation is not available in advance [27].
Therefore, our framework enforces safety constraints instead of a full global speci cation to prevent con icts in loosely coupled and dynamic service interactions.
Realizability Issue.
In service choreography, the local speci cation orchestrates the behavior of each service so that their interaction conforms to the global speci cation.
An assumption is that the global speci cation should be realizable, in the sense that the global speci cation can be implemented by a set of distributed services.
Verifying the realizability of a global speci cation is undecidable in general [1, 13].
Existing approaches enrich a global speci cation with additional synchronization messages and coordinators to render global speci cations realizable [6, 31].
Our approach also adds synchronization messages and coordinators to guarantee that the distributed sub-constraints conform to the safety constraints that are de ned to exclude con icting scenarios.
The difference between our work and the aforementioned work is that our work is to exclude disallowable behavior as opposed to specifying allowable behavior.
Moreover, we also developed an algorithm to deploy sub-constraints to speci cally selected locations in the distributed framework to reduce the enforcement overhead associated with safety constraints, which is not addressed in existing work.
Decomposition Algorithms.
In a top-down service composition approach, service developers develop a global speci cation (e.g., in WS-CDL [37]) and decompose it into local speci cations.
Services are then selected to implement the local speci cations.
Aalst et al.
applied a Petri-net based approach to decompose global speci cations into local public views with four kinds of consistency relationships [35].
Broy et al. proposed a formal model to split a service into sub-services by projection [3].
Giese et al. developed a modular approach to design, decompose, re ne and verify complex systems [14].
Nanda et al. introduced an approach to partition a composite Web service written as a single BPEL program into an equivalent set of decentralized processes [25].
In our work, we also provided an algorithms to decompose safety constraints into a set of distributed sub-constraints.
The difference is that our approach is applied to exclude semantically con icting interactions in the framework whereas existing approaches are used to specify the allowable behavior of each involved service.
This paper introduces a novel distributed framework to coordinate semantic con ict-free interactions among autonomous services in a dynamic service composition.
The framework allows services to interact with each other in a  exible and loosely-coupled way by publish/subscribe messaging.
To prevent arbitrary interactions among services that violate application semantics, we provide algorithms to enforce safety constraints for dynamic service compositions.
The algorithms decompose the safety constraints into sub-constraints which are deployed into the distributed run-time framework.
We prove that these sub-constraints can collaboratively prevent semantic con icting interactions among the participating services.
We also develope an algorithm to place the sub-constraints to well selected locations in the distributed framework to reduce the enforcement overhead for safety constraints.
According to our evaluation, the framework exhibits negligible overhead in enforcing the safety constraints and higher scalability than a centralized approach.
