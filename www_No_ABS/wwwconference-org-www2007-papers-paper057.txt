An important vision of service oriented computing is to enable dynamic service binding, i.e., it should become possible to automatically choose and invoke service providers at runtime.
To achieve this, appropriate means to describe and match services are needed.
In our previous work we have presented such means, namely a service description language and an e cient matching algorithm for this language [5, 6, 7].
However, when trying to  nd a match for a certain request it may often happen, that the request cannot be serviced by a single o er alone but could be handled Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
by combining existing o ers.
Traditional service matching mechanisms fail in these cases but techniques of automatic service composition o er a solution.
Although automatic composition is a very active  eld of research it is mainly viewed as a planning problem and usually treated separately from service discovery.
Most composition approaches do not deal with semantic discovery at all and many use proprietary request (or better goal) description languages suitable for planning and composition, but not for discovery.
Furthermore, most frameworks for automated service composition have no or at least only a very limited notion of the quality of a created composition or preferences among alternative compositions.
This is partly due to the fact that classical planning (where many service composition approaches root in) usually does not even attempt to  nd an optimal plan, but only to  nd a plan at all.
Furthermore, expressing precise preferences that usually involve competing optimization goals (like quality versus price) is a di cult problem on its own.
Clearly automated service composition could bene t here from service discovery and matchmaking where preferences among competing o ers naturally play a central role.
Thus, in this paper we propose an approach that integrates service composition into service discovery and matchmaking.
On the one hand we can leverage previous work on preference modelling for use in automated service composition, on the other hand, we increase the likelihood to be able to service a given request in a fully automated fashion by integrating automated composition into service discovery and matchmaking.
In this paper we focus on a class of service requests that ask for multiple connected e ects (like purchasing of a good and delivery of the purchased good to a certain destination).
We discuss general issues involved in describing and matching such services and extend the matching algorithm introduced in [5, 7] in theory and practice to be able to successfully match such requests.
Imagine an automotive manufacturer with several locally distributed factories.
At each site, several parts are needed to construct the cars, most of which are purchased from external component suppliers and delivered to the appropriate sites by third party shippers.
As an example, a factory in Karlsruhe could   require a quantity of screws with a countersunk head, zinc plated and a size of 5x40 mm   which have to be delivered to Karlsruhe ideally on December 8th, but not earlier than December 3rd.
In order to detect appropriate service providers, these effects need to be captured by a semantic service request description.
We call requests like this one, that contain more than one e ect (in this case purchasing and delivery) which are dependent on each other (e.g.
delivery has to depart at the location where the screws are purchased), requests with multiple connected e ects.
Generally the formulation of any service request should be driven by the desired e ects, only.
It should not be necessary for the requester to take into consideration which services are available at any given time.
This is particularly important in dynamic environments, where the set of service providers may change over time.
While the manufacturer will probably need screws on a regular basis, instead of statically binding to a certain (combination of) provider(s), the most appropriate service providers should be identi ed anew each time the respective request is issued.
Thereby, we ensure that each time the best matching provider is chosen (e.g., changes in prize or quality are taken into account) and that we consider all service providers that are available at this point of time and only those.
The requester does not necessarily have knowledge about the service landscape at execution time, and thus, doesn t know at which granularity services are o ered.
This implies, that it should not be necessary for the requester to divide the request into parts so that each part can be ful lled by a single service o er.
As an example, the following set of o ers could be present:   Service 1: a component supplier could sell 2000 di er-ent types of high quality screws to customers within the EU.
Screws can be picked up at a number of listed warehouses (e.g.
Hamburg, Paris, Berlin, .
.
.
).
  Service 2: a shipper could deliver goods within Germany, Austria and Switzerland, if the goods do not need any cooling or freezing and their packages adhere to certain maximum weights and sizes.
  Service 3: a component supplier could sell and ship 1000 di erent types of screws and bolts to customers within Germany and Austria.
For a human, it is quite obvious, that either a combination of the  rst two services or the third service alone might be able to ful ll the service request.
For an automated matcher this problem is far from trivial.
The matcher does not only have to realize that a combination of services provide the desired e ects, it also has to ensure certain constraints on the composition like whether Service 2 is able to ship from Service 1 s location to Karlsruhe and whether the package that Service 1 will provide the screws in adheres to Service 2 s restrictions on weights and sizes.
This is, where planning-based approaches to composition have their weakness.
A planner typically will be able to determine that the request could be answered by a combination of a manufacturer and a shipment service.
However, since these planners are executed separate of service discovery, the enforcing of the constraints has to be handled separately.
Also, there is no guarantee, that suitable services will be available at runtime.
In our approach, on the contrary, only currently valid o ers are taken into consideration, constraint enforcement is an integrated part of service composition and di erent combinations of providers are ranked according to the requester s preferences.
The goal of our approach is to build an automated matcher that is able to compose services, provides  ne-grained and precise ranking among competing o ers (single ones as well as automatically composed ones) and is able to automatically invoke the best o er.
Thus, we need the ability to express constraints like the ones listed above within the service descriptions and we need an algorithm that is able to handle requests containing multiple connected e ects.
In the following two sections we will quickly recap previous work on describing services and matching such descriptions without the ability to cover multiple connected e ects.
In Section 5 we will introduce a conceptual foundation for extending the language and the matching algorithm to cover multiple connected e ects and enable automatic composition for these cases.
In Section 6 we will explain the implementation of our ideas in our matching algorithm in detail.
Thereafter, we will evaluate our approach, give an overview of the related work and conclude.
DSD (DIANE Service Descriptions) is a service description language based on its own lightweight ontology language that is specialized for the characteristics of services and can be processed e ciently at the same time.
For the following an intuitive understanding of DSD is su cient, since the concepts of the matching algorithm are not spe-ci c to DSD.
We will explain the basic features of DSD on the basis of a simple example shown in Figure 1 that shows a request for a shipment service formulated in DSD.
More comprehensive information about DSD and the matching algorithm can be found in [5, 6, 7].
The basis for DSD is standard object orientation which is extended by four additional elements:   operational elements: Services change the state of the real-world (or the information space).
Operational elements allow to express this world-altering capacity.
In Figure 1, you ll  nd the operand e ect, describing that we are looking for a service that creates a state of the world where something is shipped.
We view these operational elements as the most central property of a service, thus, in DSD, services are primarily described by their e ects   all other aspects (as  ow of information, choreography etc.)
are seen as secondary, derived properties.
Concepts like states are declaratively de- ned which leads to descriptions as trees as seen in Figure 1.
  aggregating elements: A service is typically able to offer not one speci c e ect, but a set of similar e ects.
A shipment service for instance will be able to o er transport of di erent kinds of goods from one arbitrary destination to another.
That means, services o er to provide one out of a set of similar e ects.
Requesters on the other hand, typically are looking for the perfect service, but accept services that deviate from this service to a certain degree with lower preference (e.g.
a slightly more expensive service is acceptable if no cheaper service is available).
Thus, the e ect of a service (request or o er) is typically not a single but a set of states, depicted in DSD by a small diagonal line in the upper left corner of a concept.
This way, o ers describe the set of possible e ects they can provide and Figure 1: Simpli ed DSD shipping request requests describe the set of e ects they are willing to accept.
  selecting elements: While a service will o er di erent e ects, upon invocation, the requester needs to choose which of these e ects the service should provide in this speci c instance.
Meanwhile, after service execution the requester might need to receive results about the speci c e ect performed by the invocation.
In DSD, variables (denoted by a grayed rectangle) are used to support this.
In o ers, variables allow the requester to con gure the o er and to choose the particular desired e ect to provide.
In the request seen in Figure 1, the requester requires to retrieve the exact price of the shipment after service invocation.
  rating elements: This type of element is used in service requests only.
As mentioned, requesters will typically be willing to accept services with slightly di ering effects although with di ering preference.
These preferences can be expressed by fuzzy instead of crisp sets in request descriptions   the larger the membership value, the higher the preference.
Rating elements are a key feature of DSD and are the main feature used to choose among competing o ers.
This will be explained in more detail in the following section.
A matcher for service descriptions generally has two tasks: First and foremost it has to determine if - and how well an o er description  ts a given request description.
But if service o ers are con gurable (and usually they are) it also has to  nd an optimal con guration of the o er.
This is necessary to determine precisely how well an o er  ts a request and to be able to automatically invoke the best o er service later [8].
In DSD this con guration is done by choosing and assigning concrete values to all variables in an o er description during the matching process.
Since any description language should be capable of expressing preferences among competing o ers, the result of matching a request with an o er should not be a Boolean value but rather some metric of the degree of correspondence.
In the following we refer to this result as a  matching value  normalized in the interval [0,1].
The basic problem of matching a DSD o er o against a DSD request r can thus be stated as follows: Compute the fuzzy containment value (out of [0, 1]) of o s e ect sets in r s e ect sets and - while doing this - where possible con gure o in a way that maximizes this value.
Since DSD request as well as o er descriptions are trees stemming from similar ontological concepts (classes), an obvious basic technique for comparing both descriptions is a graph matching approach.
Beginning with the root element of type Service, the two descriptions are traversed synchronously and compared step by step.
This algorithm has been introduced in [5, 6, 7].
The matching value of a leaf of a description is computed using the fuzzy membership value of the o er element set in the corresponding request element set.
In our example (see Figure 1), the requester is willing to pay any price below 50 USD but would prefer lower prices over higher ones1.
Alike the requester would like to have the shipping time less than ten days, but is willing to accept a standard deviation up to ten percent again with linearly decreasing preference.
The matching value of an inner node is basically computed by combining the matching values of it s child nodes.
The way how to do this (called connecting strategy) can be con g-ured by a requester.
Naturally any requester prefers shorter shipping time and lower prices, but in the example the re-questor emphasizes that the prize is more important to him than the shipping time by specifying how to compute the membership value for the Shipped set by using a weighted sum (0.3   shippingT ime + 0.7   price) of the membership values for the shippingTime and the price.
DSD s rating features (fuzzy sets combined with customizable connecting strategies) allow to prescribe the desired e ect very precisely yet allow for a certain  exibility, thus maximizing the likelihood of  nding an appropriate service.
The issues related to the optimal con guration of an o er during the matching process are beyond the scope of this paper (see [7] for details) but it is important to mention
 of 0 is requested, but a deviation up to 50 is accepted with lower preference.
unit(cid:13)upper(cid:13)request(cid:13): (cid:13)Service(cid:13)upper.profile(cid:13): (cid:13)ServiceProfile(cid:13)presents(cid:13)effect(cid:13)Shipped(cid:13)0.3 * shippingTime + 0.7 * price(cid:13)toAddress(cid:13)cargo(cid:13)Address(cid:13)String(cid:13)== "Mr. Barney Gumble"(cid:13)name(cid:13)String(cid:13)== "320 East 7th Street"(cid:13)street(cid:13)String(cid:13)== "10021"(cid:13)zipCode(cid:13)City(cid:13)== newyork(cid:13)city(cid:13)domain.measure(cid:13): (cid:13)WeightMeasure(cid:13)weight(cid:13)val(cid:13)domain.measure(cid:13)pound(cid:13): (cid:13)WeightUnit(cid:13)top(cid:13): (cid:13)PhysicalEntity(cid:13)Integer(cid:13)== 10(cid:13)Price(cid:13)OUT,e,1(cid:13)Currency(cid:13)== usd(cid:13)Double(cid:13)~==[0,50] 0(cid:13)currency(cid:13)val(cid:13)price(cid:13)Duration(cid:13)~<= <P10DT>(cid:13)shippingTime(cid:13)that DSD has been designed in a way that largely allows the matcher to optimize variable  llings locally.
This ensures e cient processability.
To maintain this feature is one of the biggest obstacles in extending the basic matching algorithm for single e ects2 to cover multiple connected e ects also.
We will illustrate this issue in the next section.
Although at  rst glance it seems straightforward to extend the above explained procedure that is capable of handling single e ect services to also cover multiple e ects, on closer inspection some problems arise.
These problems are mainly due to the fact that multiple e ect services usually contain relations between e ects.
Recall the example from Section 2.
Here, the place of manufacture needs to correspond to the location where the shipping company picks up the goods.
Also, the restrictions on the shipping service s delivered weights and sizes need to correspond to the packages used by the manufacturer.
Such connections between e ects are the main reason why we need service descriptions containing multiple e ects.
If the e ects were unrelated, the user could as well simply pose multiple requests each one consisting of a single e ect.
It turns out that when using straightforward extensions to the service description language the matchmaking becomes ine cient and doesn t scale anymore.
This problem as well as our solution is in the focus of this section.
The central issue in describing a service covering multiple e ects is how relations between those e ects can be expressed.
Regarding our example, we are looking for a way to request a particular quantity of screws (E ect 1: owning screws) as well as their delivery within a certain amount of time (E ect 2: delivery).
Since at the time of establishing the request it is unclear which suitable manufacturer is available, it is also unknown where the delivery departs.
All that can be said is that the shipping service has to pick up the screws where the manufacturer is located.
That is, the place where the manufacturer is located and the departure of the delivery are the same.
Furthermore, the purchased screws are the good that is to be transported.
This is important for instance to compute the price of the shipment depending on the weight of the good.
An intuitive approach to describing such a connection is by having both e ects pointing to the same concept.
This is shown in Figure 2 which shows the central aspects of a request description corresponding to the example introduced in Section 2.
Clearly, this is su cient to express the desired request.
However, it breaks the tree structure of the service description which poses a problem when variables have to be  lled by the matcher.
In the example the address of the preferred warehouse needs to be given to the screw manufacturer and the address of that warehouse as well as certain properties of the screws need to be given to the shipping service.
But the address of the warehouse cannot be optimized locally.
If one wants to match this request with a composi-
since the above mentioned procedure does work for multiple e ects if they are unconnected and thus do not break the tree structure of DSD service descriptions.
Figure 2: Intuitive approach for connected e ects.
tion of two distinct o ers, one for purchasing the screws and one for shipping them, several problems arise.
Assume that we found a manufacturer having warehouses in Hamburg and in Paris and assume that we choose the warehouse in Paris since this is closer to Karlsruhe where we need the screws.
It might turn out later when con g-uring the shipping provider that it would have been much better, if we had chosen the warehouse in Hamburg because shipping within Germany is cheaper than shipping between France and Germany.
It might even turn out that we cannot  nd a shipper that operates between France and Germany at all.
Thus the location of the warehouse cannot be optimized locally.
To  nd the optimal con guration a matcher would have to build all possible combinations of warehouses and shipping options and compare each with the request.
Note that there are two sources of choice for the matcher.
There may be di erent service o ers (like competing screw manufacturers) as well as di erent con gurations of each of these o ers (like di erent screw types and warehouses of a single manufacturer).
Thus, more precisely, the matcher would have to build all possible combinations of all con gu-rations of all di erent o ers.
In general, with n e ects, the complexity amounts to O(m1   m2   .
.
.  mn) where mi is the number of di erent con gurations of the various o ers for one e ect that have to be compared against the corresponding requested e ect i, which can be estimated to O(mn) for m being the maximum of all mi.
This complexity is not tractable in practice, since m can grow to very large numbers: Even if there are not that many suitable o ers (which is reasonable to assume), there will usually be many ways to con gure each o er, e.g.
shipping services will o er shipment to a huge number of locations, possibly yielding di erent prices.
Thus, we argue that con guring multiple e ects by using an intuitive global optimization of the  llings isn t a suitable approach for on the  y composition.
The central problem here is that the time performance of the algorithm will drastically deteriorate.
Opposed to our example in Figure 2, the number of possible parameter  llings can be very high in every e ect involved.
In addition, the number of connected effects can easily exceed two.
For instance, the requester could demand an insurance for the delivery, whose price could also Address(cid:13)Screw(cid:13)Shipped(cid:13)Owned(cid:13)upper(cid:13)request(cid:13): (cid:13)Service(cid:13)upper.profile(cid:13): (cid:13)ServiceProfile(cid:13)Address(cid:13)presents(cid:13)cargo(cid:13)entity(cid:13)effect(cid:13)effect(cid:13)location(cid:13)fromAddress(cid:13)toAddress(cid:13)the  rst e ect, take the optimal result and calculate the m2 matching values for the second e ect with it and so on.
Altogether, this way the matching algorithm has a complexity of O(m1 + m2 + .
.
.
+ mn) or O(m   n) if m is the maximum of all mi, thus leading to a linear complexity.
Naturally this comes at a price.
Although our modi ed semantics yields a well de ned result which can be stipulated by the user (by ordering the e ects), we are not looking anymore for a globally optimal solution.
However, we believe that this restriction is not critical: In real world examples, e ects will often be naturally ordered, i.e. one e ect can be seen as a  main e ect  whereas the others are dependent e ects (e.g., in our example, owning a correct screw is the main goal of the requester, its delivery is necessary but dependent on this main e ect).
Furthermore, in contrast to a heuristic which limits the search space without letting the requester in u-ence the limitation, our strategy allows to restrict the search space in a well-de ned, user-driven and predictable manner.
After having explained the basic concepts of our approach we will now introduced the extended matching algorithm for multiple connected e ects.
A structural overview of the extended matching algorithm using the example from Section 2 is shown in Figure 4.
To master the complexity of the matching process and to improve e ciency the matching process is performed as a three step process; each step will be discussed in turn.
The Plug-In Match.
The  rst extension to the basic matching procedure for single e ects is that of using a plugin semantics for matchmaking.
That is, when we start matching an available o er with a request we only ask whether the o er is capable of ful lling a subset of the requested e ects.
The aspect of completely ful lling a request is delayed until later in the matching process.
This approach is motivated by the insight that even if an o er doesn t completely cover a request, it still can be used in a composition of services and consequently shouldn t be dismissed.
To improve e ciency we  rst ignore all composition related issues and concentrate on reducing the number of o ers that need to be regarded during the following composition process as much as possible.
This is done by matching o ers in isolation.
Note that variables cannot be  lled correctly without regarding the restrictions related to connections between requested e ects (i.e. without regarding issues related to the composition process).
By deferring the consideration of connections we reduce code complexity through separating concerns and improve the e ciency as this work isn t done on obviously unsuitable o ers.
Thus, as a  rst step in the matching process (marker A in Figure 4) each o er is examined wrt.
whether all of its e ects match the requested ones.
This corresponds to the above mentioned plugin match.
On the one hand we do not care whether an o er provides all requested e ects, on the other hand an o er providing an e ect that is not requested is obviously unsuitable4.
The check whether a single o er Figure 3: Alternative value propagation semantics.
depend on the departure and destination of the route.
scribing Multiple Connected Effects In order to address this problem, we propose a  value propagation semantics, i.e. the idea is to modify the semantics of when an o er is considered optimal.
At the heart of our proposed solution is the introduction of an ordering on the e ects.
This ordering is de ned by the requester who thereby is given a further ability to express his preferences.
The idea now is to locally optimize the parameter s  llings based on the ordering as de ned by the user.
This approach is illustrated in Figure 3.
Here, the e ect of buying screws is considered to be more important by the user and thus is chosen to be e ect number one.
Consequently, this is the e ect that is processed  rst by the matchmaker.
The parameters are  lled optimally with respect to this e ect with the only constraint that the  lling must not be chosen in a way that completely precludes to  nd a match for the other e ects3.
Thus, the e ect is regarded mainly in isolation and de nes the location, which is stored in a variable $x.
The chosen con guration might restrict the possible choices for those parameters contained in the following e ects.
Regarding the example, after having chosen the warehouse s location in x, this value restricts the possible  llings of the route s departure (in fact, it completely determines the  ll-ing which, in general, isn t necessarily the case).
In order to take this into consideration, these restrictions (which can only occur on connections) will be propagated in order to be taken into account when con guring the following e ects, hence the name  value propagation .
Using this approach we  rst have to annotate all o er descriptions we plan to use combined to service a request to prevent choosing a con guration for one o er that precludes to combine it with the other o ers.
This can be done in linear time in the number of con guration options as will be explained in Section 6.
We then can match the e ects in isolation, thus we have to calculate m1 matching values for
 rope, it is assured that no screw factory outside of Europe will be chosen as provider of the screws.
This constraint can be assured e ciently, as will be shown in Section 6
 more e ects than requested might be a match ( We get even more than we asked for ).
However, the unrequested e ect might just as well be harmful, if it results in buying (and Address(cid:13)Screw(cid:13)Shipped(cid:13)Owned(cid:13)upper(cid:13)request(cid:13): (cid:13)Service(cid:13)upper.profile(cid:13): (cid:13)ServiceProfile(cid:13)Address(cid:13)presents(cid:13)effect 2(cid:13)effect 1(cid:13)location(cid:13)fromAddress(cid:13)toAddress(cid:13)Screw(cid:13)Address(cid:13)Screw(cid:13)defines $x(cid:13)Screw(cid:13)uses $x(cid:13)Address(cid:13)defines $y(cid:13)Address(cid:13)uses $y(cid:13)entity(cid:13)cargo(cid:13)Figure 4: Overview of the Multiple E ect Matching Process described in Section 6 e ect matches a certain request e ect is done by calling the algorithm for matching single e ects from Section 4.
Computing Compositions.
After having performed the plugin match the compositions can be computed (marker B in Figure 4).
This involves two tasks.
First we compute all possible compositions (called coverages) of the o ers left by the plugin match so that every requested e ect is covered by an o er exactly once.
This can be thought of as decomposing the request s e ects into subsets so that for each subset a suitable service provider exists.
After having computed the possible coverages we need to prepare these coverages for the matching with the value propagation semantics (which will form the last step of the matching process).
The problem is, that if there is a repaying for) something we didn t want.
A complete discussion of this issue is beyond the scope of this paper.
lation speci ed in the request like the common location in our example and a corresponding connection is not speci ed in the o er (for instance because the e ects stem from distinct services that are merely composed to yield a coverage of the request), a wrong  lling of parameters might prevent a successful matchmaking.
Assume we use Coverage 1 with Service 1 having warehouses in Germany and France and Service 2 that ships within Germany, Austria and Switzerland.
Assume now we match the vending request e ect  rst and choose a French warehouse (e.g.
in Paris) as it is closer to Karlsruhe where we need the screws.
When matching the shipping request e ect later the coverage will fail since the chosen shipper does not service France.
If we had chosen Hamburg as the warehouse s location in the  rst place the composition would have been suitable.
There are two possible ways to address this problem.
On the one hand, we could implement some kind of backtracking that tries to Coverage 2(cid:13)Coverage 1(cid:13)Service 3'(cid:13)(300 packages(cid:13)of screw #93 to(cid:13)Karlsruhe)(cid:13)Service 1'(cid:13)(500 packages(cid:13)of screw #384(cid:13)in Hamburg)(cid:13)Service 2'(cid:13)(shipping from(cid:13)Hamburg to(cid:13)Karlsruhe)(cid:13)Plug-In Matcher(cid:13)(effect - to   effect, ignores variables)(cid:13)Service(cid:13)request(cid:13)descrip-(cid:13)tion(cid:13)Service(cid:13)offer(cid:13)descrip-(cid:13)tions(cid:13)Service Composer(cid:13)(1. compute effect coverages, 2. restrict variables)(cid:13)Final Matcher(cid:13)(effect - to - effect, fills variables)(cid:13)Service 4(cid:13)(shipping(cid:13)between(cid:13)US-DE)(cid:13)Service 3(cid:13)(vendor(cid:13)with(cid:13)shipping)(cid:13)Service 2(cid:13)(shipping(cid:13)in DE,(cid:13)AU, CH)(cid:13)Coverage 2(cid:13)Service 3(cid:13)(vendor(cid:13)with(cid:13)shipping)(cid:13)Coverage 1(cid:13)Service 1*(cid:13)(vendor in(cid:13)DE)(cid:13)Service 2*(cid:13)(shipping(cid:13)in DE)(cid:13)*) Variables are restricted (e.g.
(cid:13)warehouses outside of operation(cid:13)range of shipper are excluded)(cid:13)MV: 0.7(cid:13)MV: 0.9(cid:13)MV: 0.8(cid:13)MV: 0.72(cid:13)Remaining(cid:13)offers(cid:13)Service 1(cid:13)(vendor in(cid:13)DE, FR)(cid:13)Service 5(cid:13)(vendor in(cid:13)Asia)(cid:13)Remaining(cid:13)offers(cid:13)(all combinations(cid:13)containing Service(cid:13)4 and 5 can not be(cid:13)restricted properly(cid:13)in step 2 and are(cid:13)dismissed)(cid:13)MV: 0.7(cid:13)Final result(cid:13)(two readily(cid:13)configured options,(cid:13)Coverage 1 being(cid:13)slightly better than(cid:13)Coverage 2)(cid:13)A(cid:13)B(cid:13)C(cid:13)re-con gure the  rst e ect in case this happens.
Unfortunately, this approach has an exponential complexity (which to avoid was the primary task of the value propagation semantics).
We take an alternative approach at this point and compute the cut on the parameters involved from the di erent e ects that need to be aligned.
Service 1 has warehouses in Germany and France and Service 2 ships within Germany, Austria and Switzerland, thus the cut on both sets yields all German warehouses of Service 1 and restricts Service 2 to their locations.
If a coverage yields an empty cut like a composition of Vending Service 5 and Shipping Service 4 in Figure 4 that do not share a common location it will be dismissed.
The cut computation can be done ef- ciently (in the best case by a symbolic comparison (e.g.
if the instances in question are numbers), in the worst case by iterating over the possible  llings (e.g.
all listed warehouse locations)).
After computing the cut we annotate the o er descriptions used in the coverage at hand to restrict the concerned parameters to the instances contained in the cut, i.e. to those instances that are contained in all e ects that need to be connected.
Thus we remove all warehouse locations outside Germany from the o er description of the screw manufacturer and alter the description of the shipper used in Coverage 1 as if it accepted only addresses in Germany as pickup locations (compare to Figure 4).
This will allow us in a  nal step to  ll the parameters (in this case choosing a concrete warehouse) by again solely regarding a single e ect at a time but still be safe not to choose a  lling that will break the composition in another e ect.
Final Result Computation.. As indicated above there are two steps left.
We still need to optimally con gure each offer and compute the overall matching value of each coverage.
Due to the value-propagation semantics and work in the preceding steps this again can be done by considering the e ects in isolation according to the order de ned by the requester (marker C in Figure 4).
For each o er in each coverage, each e ect is matched against the corresponding request effect.
This is again mainly done using the algorithm introduced in Section 4, this time regarding variables and  lling them optimally, thereby con guring the o er.
When the request is matched against Coverage 1, the Owned E ect will be matched  rst.
Assume the warehouse in Hamburg will be picked.
Consequently the pickup address of the shipping service is set to its address.
Overall the resulting con gura-tions of Service 1 and Service 2 might yield matching results of 0.9 and 0.8 resprectively, leading to a result of 0.72 for the overall compositions (note that the way how to combine the single results from each e ect can be con gured by the requestor).
Similarly the resulting con guration of Service 3 might yield a result of 0.7 which corresponds to the over all result of Coverage 2.
Consequently, the composition of Service 1 and Service 2 will be returned as the best o er5.
As discussed in Section 1 our integrated approach to service discovery and composition tackles situations where sim-
compared to an o er from a single provider for various reasons.
Generally a composition will contain more potential points of failure during execution.
Thus it might be reasonable to add a preference-penalty for compositions depending on the number of services involved.
Component Complexity Prematch Plug-In Match O(n) O( 1   n   m) O(( 1 2   n)const) Computing Compositions Result Computation O( 3   ( 1 2n)const   m) Table 1: Overview: Complexity of the components Overall number of o ered services n m Mean number of di erent con gurations of an o er e ect Selectivity of the pre-matcher,  1 (cid:191) 1 Selectivity of the plug-in-matcher,  2 < 1 Selectivity of the composition-process,  3 < 1  1  2  3 Table 2: Meaning of the variables.
ple discovery looking at a single matching service fails, but a composition of existing services is able to ful ll a goal.
This approach has to suit an important requirement: In order not to give up on the idea of dynamic discovery, the composition has to be performed on the  y reacting to a request.
Thus, e ciency of the composition algorithm is a central issue.
In this section, we evaluate our composition approach with a special focus on this requirement.
We will show that its time consumption is well suited for real world deployments and that our approach scales well with the number of available o ers.
When it comes to scalability, three parameters have to be discussed: The size of the request description (or number of requested e ects), the number of available o ers and the number of ways to con gure a single o er by choosing di erent  llings for its input variables.
Regarding the  rst parameter we feel that it is unrealistic to have requests coverings thousands of e ects.
A realistic number would be anywhere between one e ect for a simple request, e.g.
searching a printer or reserving a  ight, two e ects for a large class of services that involve payment, up to maybe ten e ects for more complex tasks.
Keep in mind that in order for a request consisting of multiple e ects to make sense, these e ects need to be related to each other.
Otherwise they constitute separate requests.
Thus in the following we treat the number of e ects and the size of the request description as constant and address the issue of scalability in the other two parameters by a discussion of our architecture s complexity which is given in Table 1 as an overview.
The notation used throughout this discussion is provided in Table 2.
The architecture implemented di ers from the algorithm introduced in Section 6 in that an additional selective matching run is performed before the actual algorithm starts.
This prematch processes only those parts of the service descriptions which can be processed extremely e ciently in order to reduce the number of services that need to be considered by the actual matching algorithm.
In case of question it acts conservatively, thus it doesn t dismiss a service that might match (recall of 1.0).
The pre-matcher: The pre-matcher considers each offer exactly once and doesn t check for di erences regarding variable  llings.
Thus the complexity of the pre-matching is in O(n).
Despite that, the pre-matcher has a very good selectivity  1 (cid:191) 1.
Thus  1   n, the number of o ers that subsequent steps need to regard, is typically by several orders of magnitude smaller than n.
The plug-in-matcher: In the next step, every remaining o er is again considered exactly once but unlike in the prematch all information from the service descriptions is used, in particular the options how to  ll input variables are regarded.
This results in a complexity of O( 1   n   m) where m is the mean number of ways to con gure a single o er e ect.
The number of distinct con gurations of an effect depends on the use case but can reach magnitudes of thousands or more (e.g.
transportation may be possible to all German cities yielding di ering prices).
This complexity is paid o  by a very precise matching result eliminating all o ers that are unsuitable on an e ect-to-e ect basis (selectivity  2 < 1).
As a result the number of o ers that have to be considered during the next steps of the matching process will typically range from a couple of services to a few dozend or hundred services at the very most.
Creating Coverages: The Service-Composer determines those combinations that should be considered further.
In our current implementation, we simply consider every combination of o ers that is suitable for covering the request s e ects.
This yields a polynomial number of coverages with respect to the available o ers: O(( 1    2   n)c) (where c is an upper bound for the number of requested e ects).
After determining the possible coverages, the multi-e ect-manager is concerned with a preparation step for  lling the parameters, in which the cut on those sets of possible parameter  llings is computed that in uence each other due to connections between the corresponding e ects.
This cut computation can be performed without knowing the precise matching value a single parameter  lling will yield and can thus be performed in time linear in the size of the coverage being inspected.
It therefore doesn t increase the theoretical complexity bound.
Coverages with empty cuts are dismissed leading to a selectivity of  3.
Computing the Final Result: In order to compute the  nal result the exact parameter  llings have to be determined.
Thanks to the previous cut computation and the value-propagation semantics discussed in section 5 and 6 this can be done on a single e ect basis for each coverage, yielding a complexity bound of O( 3   ( 1 2   n)c   m).
The computation of the  nal matching value performed as a last step is linear in the number of remaining coverages and thus uncritical.
Summing up, the time consumption of our approach is dominated by the number of coverages computed on the one hand and the number of possible variable  llings on the other hand.
By introducing the value propagation semantics we were able to avoid a combinatorial explosion of the last one.
In the following section we will introduce our experimental results that indicate that for typical scenarios the unavoidable cost of determining the optimal variable  llings still outweights the cost of determining the coverages (i.e.
the composition).
Thus we expect our approach to be well suited for real world scenarios under the given constraint of dynamic composition.
In order to test our approach with regard to the requirement of e cient composition, we ran a series of tests with our implementation.
We created a set of 11 service o ers which were designed according to some real world web services in order to have a realistic complexity of the services.
(Although this is not a huge number this is not critical in terms of the evaluation.
Only service o ers that suit pretty well are considered further after the prematching and the prematching scales extremely well.
Thus, even if we had used a much bigger number of o ers, the number of offers considered during most of the matching process would not have increased drastically.)
The test services were chosen from the domains cinema reservation,  ight reserva-tion/booking, hotel reservation/booking as well as combinations thereof representing travel agencies  services.
Note that in our modelling the booking of a hotel or  ight involves charging a credit card as a further e ect.
After establishing the o er descriptions we asked a volunteer to come up with 11 service requests from the domains hotel,  ight and cinema.
The requests di ered in the number of e ects ranging from one to four as well as the number of connections which also ranged from one to four.
Overall, for the 11 requests there existed 40 di erent possibilities of matching a request with a subset of the available services such that the requests can be ful lled.
The runtime to compute each of these fourty o er combinations ranged from 0.2s to 2.3s with a mean of less than 1s.
Figure 5 shows the mean shares of the overall runtime of the di erent matching components.
The measurements shown correspond to the 40 di erent possibilities of matching a request with a composition of o ers, but for reasons of presentation similar results have been merged, thus resulting in the ten (instead of fourty) displayed measurements.
It can be seen in the  gure that each run is dominated by the single-e ect-matcher (plugin match) rather than the multi-e ect-manager (creating the compositions) thus underpinning our claim that the composition performed does not compromise the e ciency of the matching as such.
The most closely related work with regard to discovery is the recently presented WSMO-MX Matchmaker by Kaufer and Klusch [3].
WSMO-MX is a hybrid matchmaker for WSML services that borrows the graph-matching approach from the DSD Matchmaker, but combines it with other concepts developed within other matchmakers which the DSD Matchmaker is lacking.
What distinguishes the DSD Matchmaker most from WSMO-MX, as from all other discovery approaches is DSD s concept of precise  ne-grained preferences and ranking.
Most matchers proposed for OWLS (see e.g.
[11] for a typical example) rely on subsumption matching of inputs and outputs and do not take the e ects of the service into account.
The matcher proposed recently in [17] additionally matches service product and classi cation.
In contrast, DSD s matching is purely state-based.
This has two advantages: First, DSD compares whether a service provides the desired e ect or not, second, DSD can abstract from di ering interface and  nd functionally matching services even if their interface di er.
For WSMO, a discovery mechanism that abstracts from the individual e ect to a desired, more generic goal is pro-Figure 5: Distribution of the overall runtime among the components for groups of similar results posed.
In [4] the developers argue that this abstraction is necessary due to performance considerations.
Likewise, OWLS [2], e.g., inherits di culties with reasoning on the instance level from the description logics it is based on.
Tools for OWLS thus tend to not use instance information.
In both cases, the e ort of determining whether a found service is really able to answer a speci c request does not disappear, but is simply shifted to the execution phase.
None of the above mentioned matchmakers integrate automated composition like our approach does.
This is probably due to the fact that service composition is usually viewed as a problem separated from service discovery and matchmaking, thus most approaches focus on one of both.
This di ers from our approach where we use service composition as an integral part of service matchmaking in order to address dynamically on the  y situations where no single service does match a request.
One of the main bene ts from integrating the service composition into the matchmaking is that we do not only attempt to  nd some  tting composition but instead are able to  nd the composition that suits best to the given request s precise preferences.
To the best of our knowledge this distinguishes our composition approach from related work.
The METEORS framework [18, 1] provides dynamic binding of services, but works with composite service templates and does not attempt to dynamically synthesize service compositions as we do.
Although METEORS stresses the importance to select component services optimized with regard to certain global optimization criteria like overall monetary cost, it is lacking  negrained user preferences as realized by DSD s fuzzy sets.
Regarding service composition there are many approaches that apply sophisticated AI-Planning techniques to this domain.
A comprehensive discussion of these approaches is beyond the scope of this article, see [9, 12] for an overview.
The application of the HTN-Planner Shop2 to the web service composition problem by the Mindswap group [16, 10] may serve as an example.
Although accomplishing impressive results in terms of the necessary compromise between planning power, completeness and expressivity on the one hand and planning complexity on the other, in [15] Sirin et.
al.
identify a number of severe problems related to the original approach (e.g.
the complete lack of a notion of preference among competing plans).
In the same work they extend their approach to address template based compositions (similar as METEORS does).
They couple Shop2 with an OWL-DL reasoner and are thus able to overcome some of the shortcomings.
However, this way complexity issues related to OWL-DL reasoning are introduced to the otherwise very e cient planning process [14].
It remains an open problem whether precise, expressive and yet e cient discovery as realized by the DSD Matchmaker can be e -ciently coupled with more general planning as for instance realized by Shop2.
Finally a large number of composition approaches deal mainly with chaining of services.
This typically addresses situations where either additional knowledge gathering or some form of data transformation is needed to service a user request with the available o ers.
An exemplary example for such an approach is [13].
Problems typically addressed by chaining approaches are complementary to the problem of multiple connected e ects as dealt with in this work.
In this paper we motivated the need to integrate automated service composition into matchmaking.
In particular we dealt with a common class of service requests asking for multiple connected e ects that   depending on the service landscape at that time   cannot be serviced by any single one of the available o ers.
As a  rst step towards being capable of automatically dealing with such requests, we have considered the problem on a conceptional level.
By using a  value propagation  semantics for service descriptions that cover multiple e ects we succeed in avoiding exponential complexity for determining an optimal con guration of the o ers used for a composition.
The basis of our approach to service composition on a practical level is the idea of  rst using a plugin matching, i.e. when examining available offers we look whether they are suitable for ful lling at least a subset of the requested e ects.
The underlying idea is that if they don t completely cover the request they still can be used as a component in a composition.
Our  nal step towards an e cient composition approach is to compute a cut on possible parameter  llings in separate but connected e ects.
This enables us to avoid a costly backtracking in the process of  lling parameters.
We implemented our concepts within the DSD matchmaker and thus integrated automated composition into the matchmaking process.
On the one hand
 a large class of requests it couldn t successfully match previously.
On the other hand we could leverage distinguishing features of our matchmaker for the composition process, most notably its sophisticated means of dealing with user preferences to choose among competing alternatives.
Thus we are not only able to automatically synthesize a composition but  nd the best available option with regard to the preferences of the user as speci ed in its request.
In our evaluation we presented a theoretical analysis of the complexity of our approach as well as experimental measurements of the runtime performance.
The results emphasize the claim that our approach is scalable and e cient enough to be used for dynamic on the  y matchmaking and composition, even in real world settings.
