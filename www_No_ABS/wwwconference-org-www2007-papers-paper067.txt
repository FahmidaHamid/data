The Web Ontology Language (OWL) is the W3C standard language for modeling ontologies in the Semantic Web.
The logical underpinning for OWL is provided by description logics (DLs) [3].
OWL can be seen as an expressive schema language; however, its axioms have a di erent meaning from analogous statements in relational databases.
When OWL axioms are meant to be interpreted as integrity constraints (ICs), the formal semantics of OWL may seem confusing and/or inappropriate.
To understand the nature of the problem, consider an application for managing tax returns in which each person is required to have a social security number.
In a relational database, this would be captured by an inclusion dependency stating that a social security number must exist for each person.
During database updates, such a dependency is interpreted as a check: whenever a person is added to the database, a check is performed whether that person s social  This work was funded by the EPSRC project REOL.
Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
security number has been speci ed as well; if not, the update is rejected.
An analogous dependency can be expressed in OWL by means of an existential restriction, but will result in a quite di erent behavior: adding a person without a social security number to the ontology does not raise an error, but only leads to the inference that the person in question has some (unknown) social security number.
In Section 2, we study this problem by comparing OWL with relational databases w.r.t.
their schema languages, reasoning problems, and constraint checking.
Our analysis suggests that OWL ontologies can be understood as incomplete databases [15].
Many databases encountered in practice are, however, complete.
To obtain a  exible schema language, we would like to explicitly control the degree of incompleteness.
Integrity constraints (ICs) formulae that check whether all necessary information has been provided explicitly seem to be the proper mechanism for this purpose.
Extending logic-based KR formalisms with database-like ICs has already been considered in the literature.
Reiter observed that ICs are not objective sentences about the world, but are epistemic sentences about the database state [23].
Based on this idea, constraints have been added to DLs using nonmonotonic modal [11] or rule extensions [24, 20].
Such ICs, however, just constrain the shape of an ABox; they are not a part of the core conceptual model and do not a ect schema reasoning at all.
In contrast, ICs have a dual role in relational databases: they describe the possible worlds as well as the states of the databases [1], so they are used both in data reasoning (e.g., for checking database integrity) and in schema reasoning (e.g., for computing query subsump-tion).
The semantic relationship between these two roles of ICs is clear, which simpli es their usage.
In Section 3, we introduce extended DL knowledge bases, which allow a modeler to designate a subset of the TBox axioms as ICs.
For schema (TBox) reasoning, these axioms are treated as usual.
For data (ABox) reasoning, these axioms do not derive new information; instead, they are interpreted as checks.
Thus, the relationship between the interpretations of ICs in TBox and ABox reasoning is clear, and is analogous to relational databases.
In fact, in Section 4, we show that, if an ABox satis es the ICs, we can disregard the ICs while answering positive ABox queries.
In Section 5, we discuss the typical usage patterns of our approach.
Finally, in Section 6, we discuss algorithms for checking IC satisfaction.
Due to space limitations, we present only the intuition behind our algorithms; for details, please refer to [19].
Our notion of ICs solves common problems of OWL-based applications: through constraint satisfaction checking, these applications can ensure that all required data has explicitly been speci ed in an ontology, and thus detect potential errors in the data.
Furthermore, we expect signi cant performance improvements in query answering, especially in applications that would use ICs extensively.
We assume the reader to be familiar with the basics of OWL and DLs; please refer to [3] for an introduction.
It is well-known that the OWL DL variant of OWL corresponds to the DL SHOIN (D).
Because of that, in this paper we refer to OWL and DLs interchangeably.
An obvious distinction between OWL/DLs and relational databases is that the former use open-world, whereas the latter use closed-word semantics.
In this section, we argue that such a classi cation is too super cial; rather, we should see both semantics as complementary to each other.
The schema part of a DL knowledge base is typically called a TBox (terminology box), and is a  nite set of (possibly restricted) universally quanti ed implications.
For example, a TBox can state that each person has a social security number (SSN), that a person can have at most one SSN, and that each SSN can be assigned to at most one individual.
These statements are expressed using these TBox axioms: Person    hasSSN .SSN Person     1 hasSSN SSN     1 hasSSN   (1) (2) (3) Most DLs can be seen as decidable fragments of  rst-order logic [7].
Hence, the axioms (1) (3) can be translated into the following  rst-order formulae:  x : [Person(x)    y : hasSSN (x, y)   SSN (y)]  x, y1, y2 : [Person (x)   hasSSN (x, y1)   hasSSN (x, y2)   y1   y2]  x, y1, y2 : [SSN (x)   hasSSN (y1, x)   hasSSN (y2, x)   y1   y2] (4) (5) (6) The schema of a relational database is de ned in terms of relations and dependencies.
Di erent types of dependencies have been considered, such as functional, inclusion, or join dependencies.
As discussed in [1], most dependencies can be represented as  rst-order formulae of the form (7), where   and   are conjunctions of function-free atoms:  x1, .
.
.
, xn : [ (x1, .
.
.
, xn)    y1, .
.
.
, ym :  (x1, .
.
.
, xn, y1, .
.
.
, ym)] (7) Although the expressivity of DLs underlying OWL and of relational dependencies is clearly di erent, the schema languages of the two are quite closely related.
In fact, the formula (4) corresponds to an inclusion dependency, whereas (5) and (6) correspond to key dependencies.
DL TBoxes and relational schemas are interpreted according to standard  rst-order semantics: they distinguish the legal from the illegal relational structures that is, the structures that satisfy all axioms from the structures that violate some axiom.
In DLs, the legal structures are called models, whereas in relational databases they are called database instances; the underlying principle is, however, the same.
There is a slight technical di erence between models and database instances: models can typically be in nite, whereas database instances must typically be  nite.
The latter is due to the fact that only  nite databases can be stored in practical systems.
For certain classes of dependencies, the restriction to  nite structures is not really relevant: whenever an in nite relational structure satisfying the schema exists, a  nite structure exists as well (this is the so-called  nite model property).
For languages such as OWL, this does not necessarily hold: some ontologies are satis ed only in in nite models [3].
Even though the complexity of  nite model reasoning is, for numerous DLs, the same as the complexity of reasoning w.r.t.
arbitrary models, the former is usually more involved [18].
Hence, in the rest of this paper, we drop the restriction to  nite database instances and consider models and database instances to be synonymous.
Relational databases assign types to columns of relations; for example, the second position of hasSSN could be restricted to strings of a certain form.
Typing is used in practice to determine the physical layout of the database.
In contrast, typing is often not considered in theory (e.g., in algorithms for checking query containment); rather, columns draw their values from a common countable domain set [1].
To provide for explicit typing of relationships, the DLs underlying OWL have datatypes a simpli ed variant of the so-called concrete domains [4].
In this paper, we consider neither typed relational schemas nor DL knowledge bases with concrete domains, and simply interpret both relational schemata and TBoxes in  rst-order logic.
This simpli es both formalisms signi cantly.
For example, adding key constraints to untyped DLs is not a problem [8], whereas adding them to DLs with typed predicates is much more involved [17].
Checking subsumption relationships between concepts has always been a central reasoning problem for DLs.
A concept C is subsumed by a concept D w.r.t.
a DL TBox T if the extension of C is included in the extension of D in each model I of T .
This inference has many uses; for example, in ontology modeling, derived subsumption relationships can be used to detect modeling errors.
Concept subsumption has been used to optimize query answering [13], especially when generalized to subsumption of conjunctive queries [10,
 satis ability that is, determining whether a model of T exists in which a given concept has a nonempty extension.
Concepts are usually unsatis able due to modeling errors, so this inference is also useful in ontology modeling.
Reasoning about the schema is certainly not the most prominent feature of relational databases, yet a signi cant amount of research has been devoted to it.
The most important schema-related inference in databases is checking query containment [1]: a query Q1 is contained in a query Q2 w.r.t.
a schema T if the answer of Q1 is contained in the answer of Q2 for each database instance that satis es T .
This inference is used by virtually all database systems to rewrite queries into equivalent ones that can be answered more e ciently.
Another useful inference is dependency minimization that is, computing a minimal schema that is equivalent to the given one.
In both DLs and relational databases, schema reasoning problems correspond to checking whether some formula   holds in each model (i.e., database instance) of T  that is, checking whether T |=  .
In other words, the terminological problems in both DLs and relational databases correspond to  rst-order consequences of a  rst-order theory.
Since the problems are the same, it should not come as a surprise that the methods used to solve them are closely related.
Namely, reasoning in DLs is typically performed by tableau algorithms [5], whereas the state-of-the-art reasoning technique in relational databases is chase [1].
Apart from notational di erences, the principles underlying these two techniques are the same: they both try to construct a model that sat-is es the schema T but not the formula  .
To summarize, DLs and databases treat schema reasoning problems in the same way.
Thus, DLs can be understood as expressive but decidable database schema languages.
Apart from the schema (or TBox) part, a DL knowledge base K typically also has a data (or ABox) part.
The main inference for ABoxes is instance checking that is, checking whether an individual a is contained in the extension of a concept C in each model of K, commonly written as K |= C(a).
Instance checking can be generalized to answering conjunctive queries over DL knowledge bases [10,
 mula   with free variables x1, .
.
.
, xn.
Like schema reasoning, the semantics of query answering in DLs is de ned as  rst-order entailment; hence, it takes into account all models of K: a tuple a1, .
.
.
, an is an answer to   over K if K |=  [a1/x1, .
.
.
, an/xn], where the formula  [a/x] is obtained by replacing in   all free occurrences of x with a.
Queries in relational databases are  rst-order formulae (restricted in a way to make them domain independent) [1], so they are similar to queries in DLs.
A signi cant di erence between DLs and relational databases is the way in which the queries are evaluated.
Let   be a  rst-order formula with the free variables x1, .
.
.
, xn.
A tuple a1, .
.
.
, an is an answer to   over a database instance I if I |=  [a1/x1, .
.
.
, an/xn].
Hence, unlike in DLs, query answering in relational databases does not consider all databases instances that satisfy the knowledge base K; instead, it considers only the given instance I.
In other words, query answering in relational databases is not de ned as entailment, but as model checking, where the model is the given database instance.
Although the de nition of query answering in relational databases from the previous paragraph is the most widely used one, a signi cant amount of research has also been devoted to answering queries over incomplete databases [15]  a problem that is particularly interesting in information integration.
An incomplete database K is described by a set A of incomplete extensions of the schema relations and a set T of dependencies specifying how the incomplete extensions relate to the actual database instance.
Queries in incomplete databases are also (possibly restricted)  rst-order formulae.
In contrast to complete databases, a tuple a1, .
.
.
, an is a certain answer to   over K if I |=  [a1/x1, .
.
.
, an/xn] for each database instance I that satis es A and T .
In other words, query answering in incomplete databases is de ned as  rst-order entailment, exactly as in DLs.
Consequently, DL query answering can be understood as answering queries in incomplete databases.
In DLs, one can check whether an ABox A is consistent with a TBox T  that is, whether a model I of both A and T exists and thus detect possible contradictions in A and T .
This inference is not, however, a suitable basis for constraint checking.
For example, let T contain the axioms (1) (3), and let A contain only the following axiom: Person(Peter ) (8) If (1) were interpreted as an integrity constraint, we would expect it to be violated by A   T : the ABox states that Peter is a person without specifying his social security number.
The knowledge base A   T is, however, satis able: the axiom (1) is not interpreted as a check; rather, it implies the existence of some (unknown) SSN.
Thus, T describes the legal models, but not the legal ABoxes.
In fact, the DLs underlying OWL do not provide any means to express database-like integrity constraints.
In contrast, constraints play a central role in relational databases, where they are used to ensure the integrity of data.
As in DLs, a relational schema T is a set of formulae that must hold for any database instance.
A relational database instance, however, corresponds to exactly one model, whereas a DL ABox typically has in nitely many models.
Just like query answering, constraint checking in relational databases corresponds to model checking: given a database instance I, a relational database checks the satisfaction of the schema constraints T by checking whether I |= T .1 In our example, if the ABox A is taken as the database instance I, then, clearly, I 6|= T  as expected, the integrity constraints are not satis ed.
OWL users have frequently complained about the  open-world semantics of OWL  or  the unintuitive constraints in OWL.  From our experience, this is often due to incorrect interpretation of the fundamental assumptions behind OWL and relational databases, respectively.
From the standpoint of conceptual modeling, DLs provide a very expressive, but still decidable language that has proven to be implementable in practice.
The open-world semantics is natural for a schema language since a schema selects the legal database instances.
In fact, when computing the subsumption relationship between concepts or queries, we do not have a  xed instance.
Therefore, we cannot interpret the schema in either OWL or the relational databases under closed-world assumption; rather, we must employ the open-world semantics in order to consider all instances.
In our experience, complaints from OWL users are most common in data-centric applications that is, applications that focus on the management of large volumes of data.
In practice, relational databases are typically complete: any missing information is either encoded metalogically (e.g., users often include  elds such as hasSpeci edSSN to signal that particular data has been supplied in the database), or it is represented by null-values (which are also interpreted outside  rst-order logic).
In contrast, ABoxes in DLs are closely related to incomplete (relational) databases.
Clearly, problems may arise if certain aspects of the information about
 database updates; these dynamic aspects are, however, not important for this discussion.
individuals in ABoxes are expected to be complete.
To understand the problems that occur in such cases, consider the following example.
Biopax2 is an ontology used for data exchange between biological databases.
It de nes a property NAME and states its domain to be the union of bioSource , entity , and dataSource :  NAME .    bioSource   entity   dataSource (9) The intention behind this axiom is to de ne which objects can be named that is, to ensure that a name is stated only for objects of the appropriate type.
In fact, the data in the Biopax ontology is complete w.r.t.
this constraint: each object with a name is also typed (sometimes indirectly through the class hierarchy) to at least one of the required classes.
The axiom (9), however, does not act as a constraint; instead, it says that, if some object has a name, then it can be inferred to be either a bioSource, an entity , or a dataSource .
Therefore, (9) cannot be used to check whether all data is correctly typed.
Furthermore, since the concept in the consequent is a disjunction, the axiom (9) requires reasoning by case, which is one of the reasons why DL reasoning is intractable [3, Chapter 3 ].
Hence, the axiom (9) causes two types of problems: on the one hand, it does not have the desired semantics and, on the other hand, it introduces a performance penalty during reasoning.
Representing incomplete information is, however, needed in many applications.
Consider the following axiom stating that married people are eligible for a tax cut:  marriedTo.    TaxCut (10) To apply this axiom, we do not necessarily need to know the name of the spouse; we only need to know that a spouse exists.
Thus, we may state the following fact: Section 2 to DLs.
In such an approach, an ABox would be interpreted as a single model and the TBox axioms as formulae that must be satis ed in a model; the constraints would be satis ed if A |= T .
Such an approach, however, is not satisfactory, as it requires an  all-or-nothing  choice: we then have to assume that all information in the ABox is complete; furthermore, TBox axioms could only be used to check whether an ABox is of an appropriate form and would not imply new facts.
To obtain a more versatile formalism, we propose a combination of inferencing and constraint checking.
For example, let A1 be the following ABox: Student (Peter ) hasSSN (Peter , nr12345 ) SSN (nr12345 ) Student (Paul ) Furthermore, let T1 be the following TBox: Student   Person Person    hasSSN .SSN (12) (13) (14) (15) (16) (17) Let us assume that we want to treat (17) as a constraint, but (16) as a normal axiom.
Then, we derive Person(Peter ) and Person(Paul) by (16).
The constraint (17) is satis ed for Peter due to (12), (13), and (14); however, an SSN has not been speci ed for Paul, so we expect (17) to be violated.
Following this intuition, we de ne extended DL knowledge bases to distinguish the axioms that imply new facts from the ones that check whether all necessary information is derivable.
Our de nition is applicable to any DL.
Definition 3.1.
An extended DL knowledge base is a triple K = (S, C, A) such that ( marriedTo.Woman)(Peter ) (11)   S is a  nite set of standard TBox axioms, We are now able to derive that Peter is eligible for a tax cut even without knowing the name of his spouse.
Providing complete information can be understood as  lling in a  Spouse name  box on a tax return, whereas providing incomplete information can be understood as just ticking the  Married  box.
The existential quanti er can be understood as a well-behaved version of null-values that explicitly speci- es the semantics of data incompleteness.
For use cases that require reasoning with incomplete information, DLs provide a sound and well-understood foundation.
Thus, one would ideally like to be able to explicitly control  the amount of incompleteness  in an ontology.
Such a mechanism would allow the ontology modeler to explicitly state which data must be fully speci ed and which can be left incomplete.
This goal can be achieved through an appropriate form of integrity constraints that check whether all data has been speci ed as required.
Transforming inappropriate and/or erroneously introduced axioms into integrity constraints should also speed up query answering by eliminating unintended and potentially complex inferences.
In this section, we extend DL knowledge bases with ICs in order to overcome the problems discussed in the previous section.
Since TBoxes are  rst-order formulae, it is straightforward to apply the model checking approach described in 2http://www.biopax.org/   C is a  nite set of constraint TBox axioms, and   A is a  nite set of ABox assertions ( )A(a), R(a, b), a   b, or a 6  b, for A an atomic concept, R a role, and a and b individuals.
In De nition 3.1, we restrict ourselves to ABoxes with only possibly negated atomic concepts.
This does not result in any loss of generality because S can be used to introduce names for nonatomic concepts.
Next, we discuss how to de ne an appropriate semantics for extended DL knowledge bases.
The simplest solution is to interpret A   S in the standard  rst-order way and to require C to be satis ed in each model I for which we have I |= A   S. The following example, however, shows that this does not satisfy our intuition.
Let A2 contain only the fact (12), S2 =  , and let C2 contain only the axiom (17).
The interpretation I = {Student (Peter ), Person(Peter )} is a model of A2   S2 that does not satisfy C2, which would make C2 not satis ed for A2   S2.
Intuitively, though, the fact Person(Peter ) is not implied by A2   S2, so we should not check whether Peter has an SSN at all; C2 should hold only for the facts that are implied by A2   S2.
These considerations might suggest that C should hold for all  rst-order consequences of A   S. In the example from the previous paragraph, this produces the desired behavior: Person(Peter ) is not a consequence of A2   S2, so the axiom from C2 should not be checked for Peter .
Consider, however, the ABox A3 containing only the following axiom: Cat(ShereKahn ) Furthermore, let S3 contain the following axiom: Cat   Tiger   Leopard Finally, let C3 contain the following two axioms: Tiger   Carnivore Leopard   Carnivore (18) (19) (20) (21) Now neither Tiger (ShereKahn) nor Leopard (ShereKahn ) is a  rst-order consequence of A3   S3, which means that the axioms from C3 are satis ed; furthermore, we have A3   S3 6|= Carnivore(ShereKahn ).
This answer does not satisfy our intuition: in each model of A3   S3, either Tiger (ShereKahn ) or Leopard (ShereKahn ) holds, but Carnivore(ShereKahn ) does not necessarily hold in either case.
Hence, by treating (20) (21) as constraints and not as standard axioms, we neither get a constraint violation nor derive the consequence Carnivore(ShereKahn ).
Intuitively, the constraints should check whether the facts derivable from A   S   C are also derivable using A   S only.
This notion seems to be nicely captured by minimal models; hence, we check C only w.r.t.
the minimal models of A   S.
Roughly speaking, a model I with an interpretation domain  I of a formula   is minimal if each interpretation I   over  I such that I     I is not a model of  , where we consider an interpretation to be represented by the set of all positive ground facts that are true in it.
Consider again A2, S2, and C2.
The fact Person(Peter ) is not derivable from A2   S2 in any minimal model (in fact, there is only a single minimal model), so the constraint axiom (17) is not violated.
In contrast, A3   S3 has exactly two minimal models: I1 = {Cat(ShereKahn), Tiger (ShereKahn)} I2 = {Cat(ShereKahn), Leopard (ShereKahn)} These two models can be viewed as the minimal sets of derivable consequences.
The constraint TBox C3 is not satis ed in all minimal models (in fact, it is violated in each of them).
In contrast, let A4 = A3 and C4 = C3, and let S4 contain the following axiom: Cat   (Tiger   Carnivore)   (Leopard   Carnivore) (22) Now Carnivore(ShereKahn) is derivable whenever we can derive either Tiger (ShereKahn ) or Leopard (ShereKahn), so the constraints should be satis ed.
Indeed, A4   S4 has the following two minimal models: I3 = I1   {Carnivore (ShereKahn)} I4 = I2   {Carnivore (ShereKahn)} Both I3 and I4 satisfy C4.
Furthermore, we do not lose any consequences, despite the fact that we treat (20) (21) as constraints, since the following holds: A4   S4 |= Carnivore(ShereKahn ) Minimal models have been used, with minor di erences, in an extension of DLs with circumscription [6] and in the semantics of open answer set programs [14].
Consider, however, the following ABox A5: Woman(Alice) Man(Bob) (23) (24) Furthermore, let S =   and C contain the following axiom: Woman   Man     (25) No axiom implies that Alice and Bob should be interpreted as the same individual, so we expect them to be di er-ent  by default  and the constraint to be satis ed.
Now the de nitions from [6, 14] consider all interpretation domains, so let  I = { }.
Because  I contains only one object, we must interpret both Alice and Bob as  .
Clearly, I = {Woman( ), Man( )} is a minimal model of A5, and it does not satisfy C5.
This problem might be remedied by making the unique name assumption (UNA) that is, by requiring each constant to be interpreted as a di erent individual.
This is, however, rather restrictive, and is not compatible with OWL.
Another solution is to interpret A   S in a Herbrand model (i.e., a model in which each constant is interpreted by itself) where   is a congruence relation; then, we minimize the interpretation of   together with all the other pred-In such a case, the only minimal model of A5 is icates.
I   = {Woman(Alice), Man(Bob)} since the extension of   is empty due to minimization, so C5 is satis ed in I  .
Unfortunately, existential quanti ers pose a whole range of problems for constraints.
Let A6 contain these axioms: HasChild (Peter ) HasHappyChild (Peter ) TwoChildren(Peter ) Furthermore, let S6 contain these axioms: HasChild    hasChild .Child HasHappyChild    hasChild .
(Child   Happy ) Finally, let C6 contain the following constraint: (26) (27) (28) (29) (30) TwoChildren     2 hasChild .Child (31) It seems intuitive for C6 to be satis ed in A   S6: no axiom in S6 forces the children of Peter  the two individuals whose existence is implied by (29) and (30) to be the same, so we might conclude that they are di erent.
Now consider the following quite similar example.
Let C7 = C6, and let A7 contain the following axioms: HasChild(Peter ) TwoChildren(Peter ) (32) (33) Furthermore, let S7 contain the following axiom: HasChild    hasChild.Child    hasChild.Child (34) As in the previous example, C7 is satis ed in A7   S7 since (34) introduces two (possibly identical) individuals in the extension of Child.
Let S  
 only the axiom (35): HasChild    hasChild .Child (35) Now C7 is not satis ed in A   S   7 since (35) implies the exis- tence of only one child.
Given that S   7 is semantically equiv alent to S7, this is rather unsatisfactory; furthermore, it suggests that C7 should not be satis ed in A7   S7, since (34) requires the existence of only one individual.
Recall, however, that S6 and S7 are quite closely related: the e ect of (34) with respect to Child is the same as that of (29) and (30).
Hence, if (34) should introduce only one individual, then (29) and (30) should do so as well, which is in con ict with our intuition that C6 should be satis ed in A6   S6.
Thus, our intuition does not give us a clear answer as to the appropriate treatment of existential quanti ers in the standard TBox: the names of the concepts and the structure of the axioms suggest that the existential quanti ers in (29) and (30) should introduce di erent individuals, whereas the existential quanti ers in (34) should  reuse  the same individual.
These two readings pull in opposite directions, so a choice between the two should be based on other criteria.
The example involving S7 and S   7 reveals an important disadvantage of one possible choice: if we require each existential quanti er to introduce a distinct individual, then it is possible for a constraint TBox C to be satis ed in A   S, but not in A   S  , even though S and S   are semantically equivalent.
As we have seen, C7 is satis ed in A7   S7, but not in A7   S  
 is clearly undesirable for IC satisfaction to depend on the syntactic structure of the standard TBox.
Introducing distinct individuals for each existential quan-ti er can be justi ed by skolemization [21], the well-known process of representing existential quanti ers with new function symbols.
For example, for   =  y : [R(x, y)   C(y)], by skolemization we obtain sk( ) = R(x, f (x))   C(f (x)): the variable y is replaced by a term f (x), for f a new function symbol.
Skolemized formulae are usually interpreted in Herbrand models, whose domain consists of all ground terms built from constants and function symbols in the formula.
If the formula contains at least one function symbol, then Herbrand models are in nite; furthermore, the models of DL axioms are forest-like (i.e., they can be viewed as trees possibly interconnected at roots).
We use these properties in our procedure for checking IC satisfaction in Section 6.
Definition 3.2.
Let   be a  rst-order formula and sk( ) the formula obtained by outer skolemization of   [21].
A Herbrand interpretation w.r.t.
  is a Herbrand interpretation de ned over the signature of sk( ).
A Herbrand interpretation I w.r.t.
  is a model of  , written I |=  , if it satis es   in the usual sense.
A Herbrand model I of   is minimal if I   6|=   for each Herbrand interpretation I   such that I     I.
We write sk( ) |=MM   if I |=   for each minimal Herbrand model I of  .
We now de ne the notion of IC satisfaction.
We use an operator   that translates a set of DL axioms S into an equivalent formula  (S) of  rst-order logic with equality and counting quanti ers [3, 7].
Definition 3.3.
Let K = (S, C, A) be an extended DL knowledge base.
The constraint TBox C is satis ed in K if sk( (A   S)) |=MM  (C).
By an abuse of notation, we often omit   and simply write sk(A   S) |=MM C.
Note that the addition of constraints does not change the semantics of DLs or OWL: De nition 3.3 is only concerned with the semantics of constraints, and a traditional knowledge base (T , A) can be seen as an extended knowledge base (T ,  , A).
For subsumption and concept satis ability tests, we can use S   C together as the schema, as usual.
As discussed above, skolemization introduces a new function symbol for each existential quanti er, which e ectively introduces a new individual for each quanti er.
We invite the reader to convince himself that De nition 3.3 closely follows our intuition on the examples presented thus far.
Furthermore, in Section 4 we show that, if the constraints are sat-is ed, we can throw them away without losing any positive consequences; that is, we can answer positive queries by taking into account only A and S. We take this as con rmation that our semantics of IC satisfaction is intuitive.
We now discuss a nonobvious consequence of our semantics.
Let A8 be an ABox with only the following axioms: Vegetarian (Ian) eats (Ian, soup) (36) (37) Furthermore, let S8 =  , and let C8 contain only the following constraint: Vegetarian    eats. Meat (38) One might intuitively expect C8 not to be satis ed for A8 since the ABox does not state  Meat (soup).
Contrary to our intuition, C8 is satis ed in A8: the interpretation I containing only the facts (36) and (37) is the only minimal Herbrand model of A8 and I |= C8.
In fact, the axiom (38) is equivalent to the following axiom: Vegetarian    eats.Meat     (39) When written in the latter form, the axiom should be intuitively satis ed, since Meat (soup) is not derivable.
As this example illustrates, the intuitive meaning of constraints is easier to grasp if we transform them into the form C   D, where both C and D are negation-free concepts.
Namely, our constraints check the positive facts.
To check negative facts, we must give them atomic names.
Let A9 = A8; furthermore, let S9 contain the following axiom: NotMeat    Meat Finally, let C9 contain the following axiom: Vegetarian    eats.NotMeat (40) (41) The constraint (40) is now of the  positive  form C   D, so it is easier to understand the intuition behind it: everything that is eaten by an instance of Vegetarian should provably be NotMeat .
Now, A9   S9 has the following two minimal models, and I5 6|= C9, so C9 is not satis ed for A9: I5 = {Vegetarian (Ian), eats(Ian, soup), Meat (soup)} I6 = {Vegetarian (Ian), eats(Ian, soup), NotMeat (soup)} If we add to A9 the fact NotMeat (soup), then only I6 is a minimal model, and C9 becomes satis ed as expected.
Hence, it is advisable to restrict constraints to positive for-mulae in order to avoid such misunderstandings.
We  nish this section with a note that di erent applications might choose to treat di erent subsets of the same ontology as ICs.
In practice, this might be addressed by a mechanism that allows one to create an application-speci c view of an OWL ontology.
The discussion of such a mechanism is, however, out of scope of this paper; here, we focus on the semantic and computational aspects of ICs.
We now state an important result about answering unions of positive conjunctive queries in extended DL knowledge bases: if the ICs are satis ed, we need not consider them in query answering.
This shows that our semantics of IC satisfaction is reasonable: constraints are checks and, if they are satis ed, we can discard them without losing relevant consequences.
Moreover, this result is practically important because it simpli es query answering.
In Section 6, we show that, for certain types of OWL ontologies, both checking IC satisfaction and query answering can be easier than standard DL reasoning.
Before proceeding, we  rst remind the reader of the de nition of unions of conjunctive queries.
Definition 4.1.
Let x be a set of distinguished and y a set of nondistinguished variables.
A conjunctive query Q(x, y) is a  nite conjunction of positive atoms of the form A(t1, .
.
.
, tm), where ti are either constants, distinguished, or nondistinguished variables.3 A union of n conjunctive i=1  yi : Qi(x, yi).
A tuple queries is the formula  (x) = of constants c is an answer to  (x) over a DL knowledge base K, written K |=  (c), if  (K) |=  (x)[c/x].
n Our result is captured by the following theorem, whose proof can be found in [19]: Theorem 4.2.
Let K be an extended DL knowledge base that satis es C. Then, for any union of conjunctive queries  (x) over K and any tuple of constants c, we have A   S   C |=  (c) if and only if A   S |=  (c).
Consider, for example, the following knowledge base.
Let the standard TBox S10 contain the following axioms: Cat   Pet  hasPet .Pet   PetOwner (42) (43) Let the constraint TBox C10 contain the following axiom: CatOwner    hasPet .Cat (44) Finally, let the ABox A10 contain the following assertions: CatOwner (John) hasPet (John, Gar eld ) Cat(Gar eld ) (45) (46) (47) Under the standard semantics, we can draw the following conclusion from K: S10   C10   A10 |= PetOwner (John) Furthermore, it is easy to see that the constraint (44) is satis ed in K: the only derivable fact about CatOwner is CatOwner (John) and the ABox contains the explicit information that John owns Gar eld who is a Cat.
Therefore, we do not need the axiom (44) to imply the existence of the owned cat: whenever we can derive CatOwner (x) for some x, we can derive the information about the cat of x as well.
Hence, we can disregard (44) during query answering, but our conclusion holds just the same: S10   A10 |= PetOwner (John) Note that both entailments in Theorem 4.2 use the standard semantics of DLs; that is, we do not assume a closed-world semantics for query answering.
Furthermore, Theorem 4.2 does not guarantee preservation of negative consequences; in fact, such consequences may change, as the
 concept, a role, or an nary predicate in case of nary DLs.
following example demonstrates.
Let S11 =  , C11 contain the axiom Cat   Dog     (48) and A11 contain the axiom (47).
By taking S11 into account, we get the following inference: S11   C11   A11 |=  Dog(Gar eld ) Furthermore, the constraint is satis ed; however, if we disregard C11, we lose this consequence: S11   A11 6|=  Dog(Gar eld ) A similar example can be given for queries containing universal quanti ers.
Theorem 4.2 has an important implication with respect to TBox reasoning.
Let  1(x) and  2(x) be unions of conjunctive queries such that  (K) |=  x : [ 1(x)    2(x)].
Provided that C is satis ed in K, each answer to  1(x) w.r.t.
A   S is also an answer to  2(x) w.r.t.
A   S. To summarize, we can check subsumption of unions of conjunctive as usual, by treating C   S as an ordinary DL TBox.
Subsequently, for knowledge bases that satisfy C, we can ignore C when answering queries, but query answers will still satisfy the established subsumption relationships between queries.
The notion of ICs from Section 3 is very general.
To provide practical guidance for modelers, we discuss in this section the typical usage patterns.
Participation constraints involve two concepts C and D and a relation R between them, and they state that each instance of C must participate in one or more R-relationships with instances of D; often, they also de ne the cardinality of the relationship.
The general form of such constraints is as follows, where     { ,  , =} and n is a nonnegative integer: C     n R.D (49) Participation constraints are similar to inclusion dependencies in relational databases.
A typical participation constraint is the axiom (1), which states that each person must have an explicitly speci ed SSN.
Another example is the following statement, which al-lowes each person to have at most one spouse: Person     1 marriedTo.Person (50) To understand the di erence in treating (50) as a standard axiom or a constraint, consider the following ABox A: Person(Peter ) marriedTo(Peter , Ann) marriedTo(Peter , Mary ) (51) (52) (53) If (50) were a part of the standard TBox S, then A   S would be satis able; furthermore, due to (50), we would derive Ann   Mary.
If we put (50) into the constraint TBox C, then the only minimal model of A contains exactly the facts (51) (53).
Namely, the equality predicate   is minimized as well, so Ann is di erent from Mary.
This matches our intuition because no other knowledge requires Ann and Mary to be the same.
Thus, Peter is married to two di erent people, so the constraint (50) is not satis ed in A.
Constraints can be used to check whether objects are correctly typed.
A typical example of such constraints are domain and range restrictions: for a role R and a concept C, they state that R-links can only point from or to objects that are explicitly typed as C. In this way, these constraints act as checks, saying that R-relationships can be asserted only for objects in C. The general form of domain constraints is
 whereas for range constraints it is
 (54) (55) A typical example of a domain constraint is (9), which ensures that a name can be given only to objects that are either bioSource, entity , or dataSource .
Another example is the following axiom, which states that it is only possible to be married to a Person:      marriedTo.Person (56) To understand the di erence in treating (56) as a standard axiom or a constraint, consider an ABox A containing only the fact (52).
If (56) were a part of the standard TBox S, then A   S would be satis able; furthermore, due to (56), we would derive Person(Ann).
If we put (56) into the constraint TBox C, then the only minimal model of A contains only the fact (52).
Thus, Ann is not explicitly typed to be a Person , so the IC (56) is not satis ed in A.
Sometimes, we might want to check whether certain objects are known by name.
For example, an application for the management of tax returns might deal with two types of people: those who have submitted a tax return for processing, and those who are somehow related to the people from the  rst group (e.g., their spouses or children).
For the application to function properly, it might not be necessary to explicitly specify the SSN for all people; only the SSNs for the people from the  rst group are of importance.
In such an application, we might use axioms (1) (3) not as ICs, but as elements of the standard TBox S. Furthermore, to distinguish people who have submitted the tax return, we would introduce a concept PersonTR for persons with a tax return and would make it a subset of Person in S: PersonTR   Person (57) Two things should hold for each instance of PersonTR:  rst, we might require each such person to be explicitly known by name, and second, we might require the SSN of each such person to be known by name as well.
Although ICs can be used to check whether an individual is present in an interpretation, they cannot distinguish named (known) from unnamed (unknown) individuals.
We can, however, solve this problem using the following  trick.  We can use a special concept O to denote all individuals known by name and state the following two constraints: PersonTR   O PersonTR    hasSSN .
(O   SSN ) (58) (59) Furthermore, we add the following ABox assertion for each individual a occurring in an ABox: O(a) (60) Now in any minimal model of S   A, the assertions of the form (60) ensure that O is interpreted exactly as the set of all known objects.
Hence, (58) ensures that each PersonTR is known, and (59) ensures that the social security number for each person is known as well.
One can object that this solution is not completely model-theoretic: it requires asserting (60) for each known individual, which is a form of procedural preprocessing.
We agree that our solution is not completely clean in that sense; however, we believe that it is simple to understand and implement and is therefore acceptable.
For TBox reasoning, statements of the form (60) are, by de nition, not taken into account.
Finally, instead of the axioms (60), one could be tempted to use the following statement, where ai are all individuals from the ABox: O   {a1, .
.
.
, an} (61) This, however, requires nominals in the DL language, which makes reasoning more di cult [25].
Furthermore, since O occurs only in the constraint axioms, the axioms of the form (60) are su cient: the minimal model semantics ensures that O contains exactly the individuals a1, .
.
.
, an.
We now present an algorithm for checking IC satisfaction.
Our algorithm uses an alternative characterization of De -nition 3.3 based on logic programming.
Note that, since the semantics of other reasoning problems is de ned as usual, they can be solved using existing algorithms.
Definition 6.1.
Let K = (S, C, A) be an extended DL knowledge base,   = sk( (S)),4 and   be the result of transforming   into conjunctive normal form.
Then, LP(S) is the logic program obtained by ( i) converting each clause  A1   .
.
.
   An   B1   .
.
.
  Bm from   into a rule A1   .
.
.
  An   B1   .
.
.
  Bm; ( ii) adding an atom HU (x) to the body of each rule in which the variable x occurs in the head but not in the body; ( iii) adding a fact HU (c) for each constant c; and ( iv) adding the following rule for each nary function symbol f : HU (x1)   .
.
.
  HU (xn)   HU (f (x1, .
.
.
, xn)) [ Furthermore, CN( ) is the strati ed datalog program de- ned as follows, where   and sub are de ned in Table 1: CN( ) =  ( )   CN( )  sub( ) Finally, let CN(C) = CN( (C)) and EC = E (C).
The following theorem, whose proof is given in [19], shows that IC satisfaction can be checked using logic programming.
Theorem 6.2.
The constraint TBox C is satis ed in an an extended DL knowledge base K = (S, C, A) if and only if A   LP(S)   CN(C) |=c EC.
The program LP(S) is obtained by translating S into a  rst-order formula  (S), skolemizing it, and translating the result into conjunctive normal form.
The last step does not
 of DL axioms into a  rst-order formula.
kV



  1    2  y :    y :    ky :  
 Table 1: Translating Formulae into Constraints    ( )


  1    2   HU (x1)   .
.
.
  HU (xn)   not E (x1, .
.
.
, xn)   E (x1, .
.
.
, xn) E 1 (y1, .
.
.
, ym)   E 2 (z1, .
.
.
, zk)   E (x1, .
.
.
, xn) HU (x1)   .
.
.
  HU (xn)   E 1 (y1, .
.
.
, ym)   E (x1, .
.
.
, xn) HU (x1)   .
.
.
  HU (xn)   E 2 (z1, .
.
.
, zk)   E (x1, .
.
.
, xn) E (y1, .
.
.
, ym)   E (x1, .
.
.
, xn) HU (x1)   .
.
.
  HU (xn)   not E y: (x1, .
.
.
, xn)   E (x1, .
.
.
, xn) E (y1, .
.
.
, ym)[yi/y]   not yi   yj   E (x1, .
.
.
, xn) sub( )   { } { 1,  2} { 1,  2} { } { y :  } { }  ky :   i=1 HU (x1)   .
.
.
  HU (xn)   not E k+1y: (x1, .
.
.
, xn)   E (x1, .
.
.
, xn) { k+1y :  }
 Note: For   a  rst-order formula, x1, .
.
.
, xn are the free variables of  , and E  is a fresh nary predicate unique for  .
Furthermore, y1, .
.
.
, ym are the free variables of   and  1, and z1, .
.
.
, zk are the free variables of  2.
The predicate A can be  , and not is the negation-as-failure of logic programs.
1 i<j k change the models, so the minimal models of LP(S) are in a one-to-one correspondence with the minimal models of sk( (S)).
The only di erence between them is that each model of LP(S) contains an enumeration of the entire Her-brand universe in the predicate HU ; this is used to make the rules from LP(S) and CN(C) safe (i.e., to ensure that each variable occurring in a rule also occurs in a positive body atom).
The program LP(S) can be exponentially larger than S, so in [19] we discuss possible ways of avoiding this.
The program CN(C) from De nition 6.1 is similar to the Lloyd-Topor transformation [16], which transforms logic programs with  rst-order formulae in rule bodies into ordinary logic programs.
Given an interpretation I and an n-tuple of constants a1, .
.
.
, an, we have I |= E (a1, .
.
.
, an) if and only if I |=  [a1/x1, .
.
.
, an/xn].
Hence, CN(C)  evaluates  C in I; furthermore,  (C) is a quanti er-free formula, so I |= C if and only if I |= EC.
Theorem 6.2 is now a simple consequence of the following two facts: the minimal models of A   LP(S) correspond to the minimal models of sk( (S   A)), in which CN(C)  evaluates  the ICs; thus, the ICs are satis ed if and only if each such  evaluation  derives EC.
The di culty in applying Theorem 6.2 is primarily determined by the complexity of the standard TBox S. To pinpoint the main source of di culty, we use the following de nition: a standard TBox S is existential-free if no axiom in S contains either a existential quanti er under positive or a universal quanti er under negative polarity.
For example, such a TBox may contain (62), but not (63):

 (62) (63) The axioms of existential-free TBoxes cannot imply the existence of unknown individuals.
For example, the axiom (62) only checks whether there is an R-link to an object in C, whereas, for each individual in C, the axiom (63) implies the existence of an R-link to some (unknown) individual in D. For an existential-free TBox S, the program LP(S) does not contain function symbols, so we can limit our attention to the individuals explicitly mentioned in A   S. For  nite ontologies, the number of such individuals is  nite, which implies that checking IC satisfaction is decidable.
It is easy to see that CN(C) is strati ed, so the complexity of IC satisfaction checking is determined by the program LP(S).
If the latter is nondisjunctive, then constraint checking and, by Theorem 4.2, answering positive queries can be performed in polynomial time; this holds even if S   C is expressed in a DL such as SHOIN (D).
Thus, our approach allows for e cient query answering for languages beyond existing polynomial DLs (e.g., DL-lite [9] or EL++ [2]), provided that the  di cult  axioms occur only as ICs.
If we apply this algorithm to S10, C10, and A10 from Section 4, we obtain the following program CN(S10): Pet (x)   Cat(x) PetOwner (x)   hasPet (x, y)   Pet (y) (64) (65) Furthermore, we obtain CN(C10) as follows (for readability, we omit certain intermediate rules): E1(x)   hasPet (x, y)   Cat(y) E2   CatOwner (x)   not E1(x) EC   not E2 (66) (67) (68) Now A10   S10 |=c EC, so the constraints are satis ed.
If S is not existential-free, then LP(S) contains function symbols; e ectively, this means that S has only in nite Her-brand models.
Due to skolemization, however, we can restrict our attention to in nite forest-like models, which consist of in nite trees possibly connected at their roots.
To obtain a decision procedure, we clearly cannot examine such structures in their entirety.
In [19], we present a decision procedure for checking IC satisfaction if S is an ALCHI knowledge base.
The algorithm is based on a reduction of our problem to the problem of checking satis ability of an SkS formula a monadic second-order formula on k-ary in nite trees [22].
Intuitively, we encode K in an SkS formula   such that the forest-like models of K correspond to the models of  .
To enforce minimality of models, we use the second-order quanti cation of SkS .
Due to its high computational complexity, we do not expect this algorithm to be used in practice; rather, it should be taken as evidence that constraint satisfaction checking is possible for nontrivial log-ics.
We shall try to establish tight complexity bounds and derive a practical algorithm in future.
Motivated by the problems encountered in the applications of OWL to data-centric problems, we have compared OWL and relational databases w.r.t.
their approaches to schema modeling, schema and data reasoning problems, and constraint checking.
We have seen that both databases and DLs employ the standard  rst-order semantics for schema reasoning.
The di erences between the two become apparent when we consider data reasoning problems.
In relational databases, answering queries and IC satisfaction checking correspond to model checking whereas, in DLs, the only form of constraint checking available is checking satis ability of an ABox w.r.t.
a TBox a problem that is not concerned with the form of the data.
This often causes misunderstandings in practice: OWL ontologies can be understood as incomplete databases, while the databases encountered in practice are usually complete.
To control the degree of incompleteness in an ontology, we have proposed the notion of extended DL knowledge bases, in which a certain subset of TBox axioms can be designated as constraints.
For TBox reasoning, constraints behave just like normal TBox axioms; for ABox reasoning, however, they are interpreted in the spirit of relational databases.
We de- ne the semantics of IC satisfaction in such a way that they indeed check whether all mandatory assertions are entailed by the given ABox and TBox.
We have also shown that, if the constraints are satis- ed, we can disregard them while answering positive queries.
This indicates that our semantics of constraint satisfaction is indeed reasonable, and means that answering queries under constraints may be computationally easier since we may have a smaller input TBox.
Finally, we have sketched algorithms for checking IC satisfaction.
In future, we will try to obtain tight complexity bounds for constraint checking in the case of knowledge bases that are not existential-free.
Furthermore, we plan to implement our approach in the OWL reasoner KAON2 and test its usefulness on practical problems.
