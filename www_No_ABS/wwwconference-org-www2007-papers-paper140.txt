CPPL is a domain speci c language for expressing cryptographic protocols with trust annotations.
It matches the level of abstraction of the Dolev-Yao model [2], in the sense that the programmer regards the cryptographic primitives as black boxes, and concentrates on the structural aspects of the protocol.
CPPL allows the programmer to control protocol actions using trust constraints [5], so that an action such as transmitting a message will occur only when the indicated trust constraint is satis ed.
Semantic Interpretation.
The CPPL semantics identi es a set of strands [11] annotated with trust formulas as the meaning of a role in a protocol.
A strand merely speci es what messages are sent and received.
The representation does not specify to whom message are sent or from whence they are received.
This corresponds to a model that allows an adversary to have maximal power to manipulate the protocol by modifying, redirecting, and generating messages ex ni-hilo.
This ensures that proofs built on the semantics are secure in face of a powerful adversary.
A strand as the meaning of a protocol is local in the sense that it describes what one principal P does.
It says nothing about how messages are routed on a network; nothing about what another principal P  does with messages received from P; nothing about how another principal P  created the messages that P receives; etc.
In essence, it describes only a single principal executing a single run.
We must specify how to combine strands to fully reason about CPPL programs.
This global semantics has been provided by earlier work [4].
It de nes a regular strand a strand that conforms to the semantic interpretation of some protocol.
It then explains how we may reason that multiple regular strands must be communicating, given the values they share.
We may then reason about whether secrecy and other protocol goals are reached.
However, the details of all this are not important for our purposes, because this work focuses on preserving the local semantics under a different implementation, rather than developing a new global semantics.
Trust Management.
The sender of a message must guarantee the formula associated with sending the message, by showing the formula is a consequence of its local theory.
The receiver of a message relies on a formula associated with receiving the message by adding the formula to its local theory for use in later deductions.
Relying on a formula is justi ed when the protocol is sound.
A protocol is sound if in every execution, whenever a message is received and its formula is relied upon, there were corresponding message transmissions with guaranteed formulas that allow it to be deduced.
A protocol designer is responsible for demonstrating a protocol is sound.
A sound protocol is easily implemented using CPPL.
The language is designed around a few simple concepts: branching on incoming and outgoing messages, and consulting a trust management engine [5] during messaging.
These simple concepts are natural to the designer of cryptographic protocols and proof authors.
This is bene cial because there is no impedance mis-p   proc f y  Y c   return F x  c | | | | | let x = new in c let x = accept in c let x = channel y in c (sb ) | (x rb ) | (cb ) (x mb ) x m c sb   send F rb   recv m Y c mb   match m c cb   call F m   x f x  y  Y | m, m  | (m) | c r m | { m } x | [ m ] x Figure 1: CPPLm Language match between the description a designer uses to show soundness and the CPPL program that implements the protocol.
The Core Language.
The syntax of the CPPLm core language is presented in Figure 1.
The CPPL core language has procedure declarations and seven types of code statements.
A minor extension of the language, CPPLm, introduces one more code statement.
Therefore, every CPPL program is syntactically a CPPLm program, although we often distinguish between the two languages in the body.
The previous work did not describe match statements, because they do not induce message transmission or require message reception.
They were therefore left out of the earlier semantics, although they were included in the earlier implementation.
We describe them because they play an important role in our work.
In addition, they are essential to building useful protocols.
Programming language identi ers are indicated by x and y, lists of identi ers by x , message tags (such as High) by r, and procedure names by f .
When used to concatenate message patterns, the comma operator is right associative, and tagging binds less tightly than comma.
The language has syntax for guarantees and relies  by convention we write guarantees as F and relies as Y  which are  nite lists of trust management formulas.
We use  nite lists, which we interpret conjunctively.
A procedure declaration speci es the name f of the procedure, a list (y ) of formal parameters, and a list of preconditions Y involving the formal parameters.
The body of the procedure is a code statement c. A code statement may be: a return instruction, which speci es a list of postconditions F and return parameters (x ); a let-statement; or a list of send branches, receive branches, call branches, or match branches.
An identi er x is either a lowercase identi er id, or else an identi er with typing information id:type.
We write ide(X) for the set of identi ers used in the phrase X.
We write Free(S , X) for the set of identi ers free in X, where S represents bound identi ers.
A well-formed code statement c with two return statements at and return different locations must have the same postconditions F parameters x .
The Runtime Environment.
The language is organized around a speci c view of protocol behavior.
In this view, as a principal executes a single local run of a protocol, it builds up an environment that binds identi ers to values encountered.
These bindings are commitments, never to be updated; once a value has been bound to an identi er, future occurrences of that identi er must match the value or else execution of this run aborts.
In particular, when a known value is expected in an incoming message, any other value will prevent execution of this run from continuing.
cute, we  rst introduce an auxiliary notion: guaranteeing formulas in a runtime environment.
This means asking the runtime trust management system to attempt to ascertain the formulas F .
Iden-ti ers in F already bound in the runtime environment are instantiated to the associated values.
Identi ers not yet bound in the run-time environment are instantiated by the trust management system, if possible, to values that make the formulas F true.
The runtime environment extended with these new bindings is the result of successfully guaranteeing F .
If the runtime trust management system fails to establish an instance of F the guarantee fails.
To execute a return statement, we attempt to guarantee the formulas F .
If successful, we select from the resulting environment the values of each of the return parameters x ; these values are returned to the caller.
If the attempt to guarantee F fails, execution terminates abnormally, and the caller is informed of the failure.
The caller receives no parameter values in case of failure.
To execute a list of send branches, the runtime trust management system selects a branch within which it can successfully guarantee the formulas F .
The message pattern m speci ed on this branch, instantiated using the values in the resulting extended run-time environment, is then transmitted.
Execution proceeds with the continuation1 c embedded within this send branch in the extended environment.
If the runtime trust management system fails to guarantee the formulas F on any send branch, then execution terminates abnormally, and the caller is informed of the failure.
To execute a list of receive branches with identi er x, the run-time environment is consulted for the value bound to x.
This value should be a channel.
When a message is received over this channel, the message is matched against the patterns m within the receive branches.
In a successful match, the message must agree with the runtime environment for identi ers in m that are already associated with a value.
Other identi ers in m will be bound to the values observed in the incoming message, yielding an extended runtime environment.
If at least one receive branch has a successful match, one such branch is selected.
The formulas Y are instantiated using the extended runtime environment, and supplied to the runtime trust management system as additional premises.
Execution proceeds with the continuation c embedded within this receive branch in the extended environment.
If no receive branch has a successful match, then execution terminates abnormally, and the caller is informed of the failure.
To execute a list of call branches, the system treats the call branches as sends followed by receives.
The system acts as if the principal sends the message x  after guaranteeing the formulas F , then recvs the message y  and relies on the formulas Y .
That is, the the runtime trust management system selects a branch, within which it can successfully guarantee the formulas F It calls the associated subprotocol procedure f with the parameters x  instantiated using the values in the resulting extended runtime environment.
This procedure may return normally, in which case it supplies values for the parameters y ; execution continues with the embedded continuation c, using the extended runtime environment.
The instances of the formulas Y are supplied to the runtime trust management system as additional premises during execution of c.
If the f does not return normally, then execution may continue with a different call branch; execution proceeds in the original environ-.
continuation is simply  what remains to be done  in a computation.
Notice that CPPLm contains no sequencing operation; instead, what computation occurs after any given statement is speci ed directly as part of that statement, by the c at the end.
Each c is that statement s continuation.
ment, without any extension from the abnormally terminated call branch.
To execute a list of match branches with identi er x, the runtime environment is consulted for the value bound to x.
This value is matched against the patterns m within the match branches.
In a successful match, the value must agree with the runtime environment for identi ers in m that are already associated with a value.
Other identi ers in m will be bound to the values contained in the value of x, yielding an extended runtime environment.
If at least one match branch has a successful match, one such branch is selected.
Execution proceeds with the continuation c embedded within this match branch in the extended environment.
If no match branch has a successful match, then execution terminates abnormally, and the caller is informed of the failure.
Having summarized CPPLm, we return to the problem of the paper: deploying protocols on the Web.
On the Web, a single server usually runs several sessions of a protocol.
The essence of the deployment problem is thus determining which (if any) of many sessions of a protocol should receive an incoming message.
What information does a message contain that can help a dispatcher, and how can we use it?
Our strategy is to inspect the protocol encoded in the CPPLm program and determine whether, at each message reception, the message s content is suf cient for uniquely identifying a session.
Besides message structure, this largely boils down to  nding distinguishing values in the message that are visible at that point.
The set of distinguishing values is not  xed.
Many applications may manifest such values speci c to that application, such as the user s identity.
In all applications, however, nonces are globally unique, and therefore distinguish the session that generated them.
In this work, we will therefore provide the most conservative analysis by treating only locally-originating nonces as distinguishing values.
Our solution, however, easily generalizes to other, including application-speci c, notions of distinction.
We note where such values can be used as we describe our analysis.
These distinguishing values are assumed to be unique and non-forgeable, like nonces in the Dolev-Yao [2] model, and therefore not vulnerable to duplication by attackers.
This is essential to the correctness of our analysis.
We will refer to a message that contains a distinguishing value as dispatchable, because the destination session is identi able.
We will also call a code phrase dispatchable if all messages received within it are dispatchable.
We may be tempted to simply inspect each branch of each recv statement and ensure that the message pattern contains an identi er bound to a distinguishing value, but this will reject programs that should be accepted, as shown below.
match statements contain additional information that will allow more recv statements to be considered dispatchable.
This fact will complicate our analysis, but will produce a more useful answer.2 For example, the following procedure clearly contains a recv statement that contains a distinguishing value and therefore is dis-patchable: 1 proc example1 (chnl, v) _ 2 let n = new in
 ment logic database.
We could pursue this angle, but do not to avoid creating dependencies on the particular trust management logic, thereby enabling users to employ whichever one is most appropriate for their setting.
(send _ chnl n (chnl recv n _ return _ v)) The message received on line 4 is exactly the nonce n.
However, the following procedure appears to contain a recv statement that does not contain a distinguishing value and therefore is not dispatchable:       | | | x   m ;     +    x . 



 Figure 2: Constraint Language Syntax let n = new in (send _ chnl n (chnl recv m _ 1 proc example2 (chnl, v) _




 return _ v))) (m match n The message received on line 4 is a completely new binding, m, and therefore not identi able directly as the nonce n. However, on line 5 of the program, that value is checked against n, so the program will succeed only if m = n. Thus, we should consider this program as being dispatchable.
This last example demonstrates a general aspect of match statements: they impose constraints on messages that are received earlier in the program.
In example2, the match on line 5 imposes the constraint that the message received on line 4, m, must match the pattern n, i.e., must equal n.
The following pattern, common to commitment protocols [3], demonstrates a more complicated constraint imposition: 1 proc commit (chnl) _
 (chnl recv payload _



 ...
(chnl recv key _ (payload match {objective} key return _ objective))) In this protocol, one participants receives an encrypted payload (line 2), performs some further work and communication (elided in line 3), then receives a commitment from the other participant in the form of a key (line 4), to the data sent earlier (line 5), which contains the objective (line 6).
In this example, the match on line 5 imposes the constraint on the message received on line 2 that  There must exist some value key which decrypts payload .
Another kind of constraint is introduced by branching in the language.
Consider the following contrived example: (chnl recv prod _ 1 proc example3 (chnl, left, right) _




 return _ left match right return _ right)) (prod match left In this example, the match beginning on line 3 imposes the constraint on the message received on line 2 that  prod must match either left or right.  Neither of these examples is dispatchable, as neither the message patterns nor the constraints imply that the message contains a distinguishing value.
However, more complicated protocols with similar constraints are dispatchable.
In Sec.
5.1 we develop how to make this judgment.
Work ow.
A protocol engineer uses our tool to turn a CPPLm source program into an executable that can be used to deploy their protocol.
If the protocol passes our analysis, the engineer will have a deployable binary.
If not, they see an error indicating the message of the protocol that does not contain a distinguishing value.
Solution Overview.
Our system consumes a CPPLm  le, generates all the constraints on incoming messages imposed by the rest of the program, checks that the incoming messages all contain some distinguishing value, then produces an executable.
This executable uses a runtime library that provides cryptographic communication and checks for the satisfaction of the computed constraints.
This executable is combined with a server that consumes messages and dispatches them to sessions.
The server can use a very na ve dispatching algorithm.
Whenever it receives a message, it can attempt to deliver it to all sessions, stopping when one session has accepted the message.
If no session accepts the message, then it can attempt to create a new session for the message.
Only if this  nal step fails is the message rejected.
The analysis of this paper makes such a dispatching algorithm suf cient.
In the absence of such an analysis, the algorithm would be doubly erroneous: it might deliver messages to the wrong session, i.e., one intended for session A might resume session B, causing both B to incorrectly resume and A to incorrectly starve.
Sec.
5 describes the algorithm formally and justi es our claim that it is not susceptible to such errors.
The heart of this section show how constraints are generated from CPPLm phrases (Sec.
4.2).
To support this, we describe the language of constraints (Sec.
4.1) and give their semantics.
Once we have generated constraints, we show how to annotate CPPLm programs with them by translation to an intermediate language, CPPLm+c, in Sec.
4.3.
As a  nal bookkeeping step, we present the semantics of this annotated language in Sec.
4.4.
With semantics in hand, we then show that properties proved about translated CPPL programs are maintained, satisfying one of our primary goals.
Fig. 2 speci es the syntax of the constraint language.
In this syntax, the ; and + operators are right-associative, and + binds less tightly than ;.
The language is best explained through a description of the informal execution semantics.
This semantics depends on a runtime environment binding identi ers to values, corresponding to the runtime environment of the CPPLm program at the point where constraint satisfaction occurs.
To check a TOP constraint of the form  , nothing need be done, as this constraint is always satis ed.
To check a MATCH constraint of the form x   m;  , the runtime environment is consulted for the value bound to x.
This value is matched against the pattern m. For the match to be successful match, the value must agree with the runtime environment for iden-ti ers in m that are already associated with a value.
Other values in m will be bound to the values contained in the value of x, yielding an extended runtime environment.
If the match is successful, constraint checking continues with the constraint   in the extended runtime environment.
If   is satis ed in this environment, then this constraint is satis ed.
An example of a MATCH constraint is the constraint on the recv statement on line 4 in example2 in Sec.
3: m   n;  .
In this cons 1 = s   s   [x] matches m  dom(s |= (x   m  ;  )  )   ide(m ) s 1 |=  
 |=  
 |=   |=   +   |=   +  
 [x 7  v]  |=   for some v  |=  x . 
 |=   Figure 3: Constraint Satisfaction straint m is the message received on line 4, n is the pattern used in the match statement on line 5, and the   constraint comes from the continuation of this match, i.e., the return on line 6.
To check an OR constraint of the form  + , the two sub-constraints are checked independently, i.e., the runtime environment is copied in each branch.
If one of the sub-constraints is satis ed, this constraint is satis ed and the other need not be consulted.
To check an EXISTS constraint of the form  x . , the runtime environment is extended with values for x , if possible, that make the constraint   satis ed.
If there is no assignment of the identi ers x  to values for which   may be satis ed, then this constraint is not satis ed.
The formal semantics of constraint satisfaction is given in Fig. 3.
The judgments have the form: |=   and the con-where the runtime environment is represented by s straint is represented by  .
Runtime Implementation.
The semantics does not explicitly state how to generate values for the identi ers bound in EXISTS constraints during satisfaction checking.
An implementation must solve this problem.
The obvious solution is to use uni cation of identi- ers with CPPLm values and identi ers in match patterns.
Identi- ers introduced by these constraints are initially unbound.
Iden-ti ers are bound by their  rst comparison in a MATCH constraint.
After an identi er has been bound, a failure to unify with a value in a MATCH constraint is a failure of the EXISTS constraint that introduced the identi er.
There are some subtleties, however, due to the use of cryptography.
For example, the following constraint can be satis ed with uni cation: [x 7  (0,0)] |=  y.x   (y, y);   The following, however, cannot: |=  x, k.M   {x}k; x   V ;   because it refers to the contents of an encryption for which the key, k, is unknown.
We can, however, still perform some checking of this constraint.
Speci cally, M can be checked to ensure that it is long enough (in bits) to be decrypted to an x that is as long (in bits) as the value of V .
Our compiler also optimizes some constraints at compile-time.
Informally, if the identi er introduced in an EXISTS constraint does not appear in any of the message patterns in the sub-constraint, then the EXISTS constraint can be removed.
This allows the constraint-solver to short-circuit the uni cation mechanism in many cases.
This optimization could be incorporated into the constraint generation phase of our analysis, but to do so would complicate our analysis and shift attention from the essence of the problem.
This section discusses how to generate constraints from CPPLm phrases.
For each recv branch, we must  nd the constraints imposed on the message by the continuation.
Each code statement in the continuation of the receive statement can refer to identi ers bound by the message.
For example, in the commit protocol (Sec.
3) the continuation starting on line 3 imposes constraints on the message received in line 2 through the use of the identi er payload.
Although in that example this is the only identi er bound by the pattern on line 2, in general a receive pattern may bind any number of identi ers.
Therefore, our constraint generation analysis is de ned with respect to (a) the identi ers bound by the message, (b) all bound iden-ti ers, to decide what identi ers are introduced by the message, and (c) a code statement, initially the continuation of the recv.
The phrase  bound by the message  is quite subtle.
The message binds identi ers in the recv branch message pattern and in any match pattern where the variable being matched was bound by the message.
For example, in the commit protocol, the message received on line 2 introduces payload on line 2 and objective on line 5.
We will now present the analysis.
The judgments are of the form:
 |= c :   represents the set of bound identi ers and P where S represents a set of identi ers bound by the message.
These judgments can be roughly categorized into a few cases based on the code statements:   Statements without continuations, such as return, that generate a TOP constraint.
  Statements that introduce bindings, such as let, recv, send, and call statements that generate an EXISTS constraint for each of the identi ers they bind.
  Statements that represent branching, such as recv branches, send branches, and match branches, that introduce OR constraints for each branch.
Examples of each of these categories are presented in Fig. 4.
However, match statements do not  t into any of these categories.
The judgments for them are shown in Fig. 5.
If the identi er being matched, x, is in P If the identi er being matched is not in P , then this match represents further use of the original message.
Therefore, any identi ers bound by this match must be incorporated into the P used to analyze the continuation.
Furthermore, the pattern used to match the identi er must be incorporated into the constraints via a MATCH constraint.
, then this match is treated like any other statement that introduces bindings.
In Fig. 6 we present an example of constraint generation for lines
 use < i > to represent the continuation beginning on line i of the source.
Having generated these constraints, we still need to show how to incorporate them into an analysis that checks for the presence of distinguishing values.
We provide these constraints to the analysis by translating CPPLm phrases into another language that contains these constraints as annotations on recv statements.
s s s s s s s s s s
 {payload, key, objective}, {payload, objective} |= < 6 > :   payload   {payload} {payload, key}, {payload} |= < 5 > : payload   {objective} key;   {payload}, {payload} |= < 4 > :  key.payload   {objective} key;   Figure 6: CPPLm Example Constraint Generation x  :   |= return F


 {y } = Free(S
 |= send F S   {y },P x m c :  y .  |= c :   .
.
.
|= sbn :  n

 |= sb0 :  0
 |= (sb0 .
.
.
sbn) : ( 0 +       +  n) Figure 4: CPPLm Constraint Generation Examples MATCH (x IN P ) {y } = Free(S , m) S   {y },P   {y } |= c :   x   P |= x match m c : x   m ;   MATCH (x NOT IN P {y } = Free(S ) , m) S   {y },P |= c :   x /  P |= x match m c :  y .  Figure 5: CPPLm Constraint Generation: Matching We will refer to this new language as CPPLm+c.
We specify the syntax below as a modi cation to CPPLm.
The syntax is identical, except that an annotation has been added to the recv branch case: the constraint,  , imposed on this statement by its continuation.
rb   recv m   Y c The form of translation judgments is: S   c c  where S is a set of bound identi ers, c is a CPPLm program statement, and c  is the CPPLm+c program statement produced by the translation and eventually run in the server.
Except for the judgment dealing with recv statements, all the judgments are obvious and only carry along information about the introduction of identi ers.
Therefore, they are not included in this short presentation.
The judgment for recv statements is:
 S   P 0   c c  S   recv m Y P 0 = Free(S , m) S   P 0,P 0 |= c :   c recv m   Y c  The identi ers initially bound by the message pattern are used as the initial set of identi ers bound by the message (P 0) in the constraint generation process (Sec.
4.2) that analyzes the continuation of the recv statement.
The generated constraint,  , is used in the resulting translated program statement.
s 1 = s   s   [x] matches m  )   ide(m) dom(s ;G   (x match m c rb ) : s,u s 1;G   c : s,u
 ;G   (x mb ) : s,u ;G   (x match m c mb ) : s,u Figure 8: Semantics of match
 In keeping with previous CPPL work [4], we give the semantics of CPPLm+c procedures and code statements by describing the strands that specify their possible behavior.
Each strand is a sequence of transmissions and receptions that is possible for a principal executing this CPPLm+c phrase faithfully.
As mentioned in Sec.
2, this describes the local nature of protocol execution.
Our local semantics is identical to previous work [4], except in the RECEIVE AND RELY, RECEIVE ALTERNATIVE MATCH AND RELY, and MATCH ALTERNATIVE cases.
The semantics of a receive statement (Fig. 7) is identical to the earlier semantics, except that the extended runtime environment, s 1, is checked against the   constraint according to the constraint satisfaction semantics in Fig. 3.
(And, for technical reasons the semantics of RECEIVE ALTERNATIVE must be modi ed for the new syntax.)
The semantics of a match statement (Fig. 8) is very close to the semantics of a receive statement, except: (a) there is no message reception or transmission, and (b) we must explicitly state that the value bound to x in the runtime environment, s , matches the message pattern, m. This is normally implicit in the description of the strand unleashed by a receive statement.
The semantics described in this section is a replacement for the local semantics of earlier work [4].
The original work also describes a global semantics relating bundles of strands.
In this work, there is no reason to modify the global semantics of that earlier work.
We elide it for brevity.
We would like to show that properties proved about CPPL programs remain true about the translated CPPLm+c programs.
THEOREM 1.
If a CPPL phrase, c, unleashes a strand s by the earlier semantics [4], then the translation of c unleashes strand s by the CPPLm+c semantics.
PROOF.
Consider the changes made between CPPL and CPPLm+c.
The two differences are (1) the introduction of match statements and (2) the introduction of constraint satisfaction of recv statements.
A CPPL program, which by de nition does not include match statements, unleashes the same strand by the CPPLm+c semantics, after translation, because (1) no match statements are in-





s s s s
 s 1 = s   s   s 1 |=   ;G   (x recv m   Y  )   ide(m) dom(s s 1;G c rb ) : ( msg (x, m)s 1 , Y
 1   c : s,u 1)   s,u Figure 7: Semantics of recv
 ;G   (x rb ) : s,u ;G   (x recv m   Y c rb ) : s,u troduced by translation and (2) only match statements generate constraints that may not be satis ed.
Therefore, the strand unleashed by a CPPL phrase is identical to the strand unleashed the translation of this phrase.
This is not an if and only if statement: because match statements do not cause communication and only reject messages, it is possible for some CPPLm+c program, p, to unleash a strand s which is also unleashed by some CPPL program, p , such that p is not the translation of p .
Notice that we have not yet discussed whether our compilation of CPPLm+c programs preserves properties, or, more formally, correctly executes the strand.
We have simply shown that the translation of CPPL to CPPLm+c does not change the strands unleashed by CPPL programs.
So far we have calculated the constraints imposed on incoming messages, recorded the constraints as annotations in an extended language, and taken a  rst step towards proving correctness.
We still must describe how these constraints can be used to guarantee that all messages received by a protocol contain distinguishing values.
We must also describe the algorithm used for dispatching.
Sec.
5.1 describes the analysis that is run on CPPLm+c programs to ensure that all received messages contain distinguishing values.
Sec.
5.2 presents the algorithm used by the dispatching server that relies on this analysis.
Sec.
5.3 proves correctness properties on both of these.
Given a CPPLm+c program, or more generally a CPPLm+c phrase, we must check that all received messages contain a distinguishing value.
A message may contain such a distinguishing value directly, in a message pattern, or indirectly, in the constraints imposed on the message by the rest of the program.
The analysis to check these conditions is fairly straightforward, once we understand exactly what we are checking.
In particular, we are checking for visible distinguishing values.
The notion of visibility is somewhat subtle: if a message component contains a distinguishing value but is encrypted by an unknown key, then the distinguishing value is not visible.
Similarly, if our language modeled hashing, then a distinguishing value would be visible if it was hashed together with any number of visible data.
Our de nition of visibility is given in Fig. 9.
The majority of the analysis is obvious, merely carrying along information across the structure of the code phrase, and is therefore not included in this short presentation.
The judgments are of the form: n   c signifying the fact that given the set of distinguishing values n messages received in c contain a visible distinguishing value.
, all The only interesting judgments are on one variant of let statements, recv statements, and match statements.
vis : {x }       bool vis(n ,  ) = vis(n , /0,  ) vis : {x }   {x }       bool ,   +  ) = vis(n ,s ,  x . ) = vis(n ,s   {x },  ) vis(n ,s vis(n ,s ,  )   vis(n ,s ,  ) vis(n ,s ,  ) = false , x   m;  ) = vis(n ,s vis(n ,s , m)   vis(n ,s ,  ) vis : {x }   {x }   m   bool vis(n ,s , x) = x   (n   s ) vis(n ,s vis(n ,s vis(n ,s vis(n ,s vis(n ,s , (m, m )) = vis(n ,s , (r m)) = vis(n ,s , (m)) = vis(n ,s , [m]x) = vis(n ,s , {m}x) = vis(n ,s , m)   vis(n ,s , m) , m) , m)   x /  s , m)   x /  s , m ) Figure 9: Visibility under constraints
 n   {x}   c n   let x = new in c This rule simply introduces a new distinguishing value into the set .
Recall that the new case of the let form generates a globally-unique, i.e., locally-originating, nonce.3
 x   n   {y}   c n   x match y c
 x /  n  y.m = y n   x match m c n   c These rules handle match statements.
The interesting subtlety is that pattern matching can introduce aliases for existing distinguishing values.
When such an alias is detected, i.e., when the pattern is simply an identi er, y, then that identi er must be added to the set.
(Recall that only identi ers may appear on the left side of a match, so detecting aliasing is very simple.)
n   c n   ide(m)   vis(n ,  ) n   recv m   Y c This is the pivotal rule.
It checks that either the message pattern or the constraint contains a visible distinguishing value, by employing the de nition of visibility given in Fig. 9.
distinguishing, then custom rules similar to this one can be added that incorporate identi ers bound to these values into the n set.
s s s s n n n There are a few subtleties we do not formalize here.
First, sub-protocols invoked by a protocol must themselves be dispatchable.
Second, these protocols must not have messages that overlap, in the sense discussed in the conclusion.
Third, the analysis as presented will fail on protocols that start with message reception, because no distinguishing values have been transmitted.
However, we can relax this restriction, but it requires some uninteresting technical modi cations to the analysis.
Having shown an analysis that ensures every expected incoming message contains a distinguishing value, we must show how to build a dispatching server that can correctly dispatch incoming messages.
The fundamental implication of our analysis is that only one session will accept any given message, because each message contains a distinguishing value.
Given this, de ning our server is very simple.
The server simply attempts to deliver an incoming message to all existing sessions.
By the above, at most one session will accept the message.
Before we formally present the dispatching algorithm, we must clarify the notion of a  session .
A session, s, captures the entire state of a protocol run: the runtime environment, the trust management database, and the current continuation.
A session may be initialized by a procedure p by creating the runtime environment containing bindings for p s arguments, initializing a trust management database, and using the continuation embedded in p. A session is waiting if its continuation is a recv statement, i.e., it is waiting for an incoming message.
We say that a session s evolves into a session s  if executing the continuation of s with the given runtime environment and trust management database reduces after some number of steps to the session s .
If a session s evolves to a session s  where the continuation is a return statement, then the session s is said to have returned.
A session s that cannot evolve to any session s  is said to be stuck.
We say that we deliver a message M to a waiting session s when we allow s to evolve and receive message M at the recv statement at the top of the continuation.
Notice that if we deliver a message M to a waiting session s where M does not match the message pattern or constraints in any of the branches of the recv statement at the top of s s continuation, then s is stuck.
The server obeys the following algorithm, with P representing the CPPLm+c protocol being served.
(a) If s returns, remove s from sessions, and go to step 2.
(b) If s evolves into a waiting session s , remove s from sessions, add s  to sessions and go to step 2.
(c) If s is stuck, go to step 4.
message M to snew.
(a) If snew returns, go to step 2.
(b) If snew evolves into a waiting session s , add s  to sessions and go to step 2.
Our goal is not only to deploy protocols on the Web but also to show that, in the process of doing so, we have preserved any properties proven about them.
We must therefore show that our dispatching algorithm is  correct  in some way.
Correctness is, however, dif cult to de ne in this context.
One de nition of correctness would be that if a message is delivered to a session, then that session can run to completion.
One way of stating this formally is: If a message M0 is delivered to a session s, then if some sequence of messages M1, .
.
.
,Mn is subsequently delivered to s, then session s will return.
This condition is, however, not easy to prove, and it is not always possible to even check in an actual implementation.
For example, consider the commit protocol given in Sec.
3.
As we mentioned, it is not possible to check that some key will decrypt payload (indeed, cryptographic security relies on this fact).
Given this, it is dif cult to imagine a means of realistically implementing a checker for the above condition for a message received on line 2.
In other words, it is dif cult to establish that the dispatching algorithm is  right , i.e., that it ensures progress.
Absent this stronger form of correctness, we should at least try to demonstrate the algorithm does not do anything  wrong , i.e., that it exhibits preservation.
In particular, it seems clearly wrong to deliver a message meant for one session to some other session.
Our work adopts this approach, but with a practical restriction.
To understand this restriction, consider two sessions, A and B, of a protocol that employs the empty message, e , as a keep-alive.
Under the strand-space network model, when an e message is received, there is no reason why it should be delivered to A rather than to B.
Informally, there is no harm in sending an e message  meant  for A to B, provided A eventually receives an e message.
Pragmatically, however, it is clear that conditions outside the pure strand space model such as timeouts can cause session abortion.
Our analysis therefore forces every every message to contain a distinguishing value.
This is a property that the e message, in particular, fails to exhibit.
So long as messages contain distinguishing values that some session accepts but no other sessions can, we can easily demonstrate that no message will be delivered incorrectly.
This  nal analysis is therefore implemented by our compiler.
It is satis ed by a wide range of existing protocols, and also provides a useful guideline for the creation of new ones.
To prove this form of preservation, we  rst show that we have correctly formulated a de nition of visibility and that our analysis is correct.
LEMMA 1.
If vis(n ,s of unknown identi ers s , m) for some message pattern m and set , then some identi er in n is visible.
PROOF.
We proceed by structural induction over the cases of m.
Case (1) Assume that m = x.
If x   n , then x is visible and is in .
If x /  n or x is unknown, then x is not visible or in n .
This our base case.
Case (2) Assume that m = (m , m ).
By induction.
Case (3) Assume that m = (r m ).
By induction.
Case (4) Assume that m = (m ).
By induction.
Case (5) Assume that m = [m ]x.
We may proceed by induction provided the signing key x is known.
Case (6) Assume that m = {m }x.
We may proceed by induction provided the encrypting key x is known.
LEMMA 2.
If vis(n ,s ,  ) for some constraint   and set of unknown identi ers s , then some identi er in n is visible.
(c) If snew is stuck, reject the message and go to step 2.
PROOF.
We proceed by structural induction over the cases of  .
Case (1) Assume that   =   and vis(n ,s ,  ).
This is clearly a contradiction of our de nition.
Case (2) Assume that   =   +  .
This OR constraint represent two branches of the program.
We must ensure that all paths through the program contain distinguishing values.
Thus, each sub-constraint must contain some identi er of n .
Case (3) Assume that   =  x . .
By induction.
Case (4) Assume that   = x   m;  .
By induction and Lemma 1.
THEOREM 2.
If a CPPLm+c phrase passes the analysis, then each message it receives contains a distinguishing value.
PROOF.
We proceed by induction and cases.
Clearly the only interesting case is recv statements.
A recv statement is satis ed only if some distinguishing value, i.e., a member of the set n , n, is in the set of identi ers of the message pattern, or if it is visible under the constraints,  , of the statement.
In the  rst case, the distinguishing value is clearly in the message.
In the second case, we know by Lemma 2 that the message contains the distinguishing value.
Now that we have shown our analysis is correct, we can prove our algorithm is correct by relying on these proofs.
We do so in two steps.
LEMMA 3.
If the dispatching algorithm rejects a message M, Figure 10: Typical Benchmark Results then no session could accept message M.
PROOF.
Suppose that some session s could have accepted message M. If the message has been rejected, then it must have been rejected in step 7c.
This implies that snew rejected the message and that the set tmp was empty (step 4).
Suppose that tmp was initially {s0, .
.
.
,sn}.
For tmp to become empty, step 5 must be executed for each session s0 through sn.
At step 6, the algorithm must have taken branch 6c, to return to step 4 and then 5.
The algorithm only takes branch 6c when the session (si) rejects the message.
Thus all sessions have rejected M, resulting in a contradiction with the assumption that some session s exists.
LEMMA 4.
If a session s accepts a message M, then no other session s  could have accepted message M.
PROOF.
Assume that some other session s  exists that also accepts message M.
If s accepts M, then it is waiting on some pattern p for a message that satis es constraints   and M matches p and satis es the constraints  .
If s  accepts M, then it is waiting on some pattern p  for a message that satis es constraints   and M matches p  and satis es the constraints  .
Recall that the code associated with s and s  have passed the analysis.
Therefore p or   contains some visible distinguishing value n, and p  or   contains some visible distinguishing value n .
If M satis es both patterns and constraints, then it contains both n and n .
This is a contradiction to our assumptions about distinguishing values, and in particular, our Dolev-Yao [2] assumptions about nonces, which are globally unique and non-forgeable.
Thus, s  must not exist.
THEOREM 3.
The dispatching algorithm delivers all messages that can be delivered and does not deliver a message to session s that should be delivered to session s .
PROOF.
By Lemmas 3 and 4.
We have modi ed the existing CPPL compiler to support the analysis described above.
This compiler is implemented using OCaml [7] and translates a CPPLm source  le into OCaml.
Each CPPLm procedure is translated into an OCaml procedure that takes a number of CPPLm values as arguments and returns a tuple of results.
Our implementation performs the analysis described in this paper; if the analysis fails, the compiler displays an error.
The error message advises the protocol author about which line contains a recv statement that does not contain a distinguishing value.
For example, an error message would be displayed for line 2 of the commit protocol example from Sec.
3.
This helps a protocol author identify where hand soundness proofs must occur or where the protocol must be changed for Web deployment.
In our previous implementation, translated CPPL source  les were combined with OCaml source  les that set up the environment correctly and then invoked the CPPL procedures with the proper arguments.
Our implementation provides a dispatching server, like a Web server, written in OCaml that runs the CPPLm procedures on incoming messages as described by our algorithm.
Our implementation also records the values returned by each successful protocol run, whereas the earlier implementation prints this information when the single protocol run completes.
Performance.
We have built a benchmarking suite based on a sample of protocols from the SPORE [10] repository.
Fig. 10 shows results for two protocols which captures the trend across the suite.
The horizontal axis shows the number of concurrent clients and the vertical axis shows the average time to session completion.
The upper lines show the outcome for the previous compiler, and the lower lines show the outcome for our approach.
The reason for this gain is clear.
Enabling deployment of CPPL protocol speci cations on stock Web servers engenders both usability (since both deployers and clients can leverage the Web s infrastructure) and scalability (owing to the Web s statelessness).
In particular, deployments can now leverage the frequent improvements multiple protocols simultaneously.
This would require an analysis of all participating protocols to ensure that there are no messages that match receive branches in multiple protocols, i.e., to ensure that the messages do not overlap.
Acknowledgments.
This material is based upon work supported by NSF grant CNS-0627310 and under a National Science Foundation Graduate Research Fellowship.
