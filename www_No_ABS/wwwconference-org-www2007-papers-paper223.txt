The increased popularity of mobile communication devices with embedded positioning capabilities (e.g., GPS) has triggered the development of location-based applications.
General Motor s OnStar navigation system, for example, combines the vehicle s position with real-time information to avoid tra c jams, and automatically alerts the authorities in case of an accident.
More applications based on the users  location are expected to emerge with the arrival of the latest gadgets (e.g., iPAQ hw6515, Mio A701) which combine the functionality of a mobile phone, PDA and GPS receiver.
Consider the following scenario: Bob uses his GPS enabled mobile phone to ask the query  Find the nearest hospital to my present location .
This query can be answered by a Location-Based Service (LBS) in a public server (e.g., Google Maps), which is not trusted.
To preserve his privacy, Bob does not contact the LBS directly.
Instead he submits his query via an intermediate trusted server which hides his ID (services for anonymous web sur ng are commonly available nowadays).
However, the query still contains the exact coordinates of Bob.
One may reveal sensitive data by combining the location with other publicly available information.
If, for instance, Bob uses his mobile phone within his residence, the untrustworthy LBS may infer Bob s identity and speculate that he su ers from a medical condition.
In practice, users are reluctant to access a service that may disclose sensitive information (e.g., corporate, military), or their political/religious a liations and alternative lifestyle.
To preserve privacy in LBS, recent research focused on adapting the well established K-anonymity technique to the spatial domain.
K-anonymity [19, 21] has been used in statistical databases as well as for publishing census, medical and voting registration data.
A dataset is said to be K-anonymized, if each record is indistinguishable from at least K 1 other records with respect to certain identifying attributes.
In the LBS domain, a similar idea is to employ spatial cloaking [9, 10] to conceal user locations: instead of reporting the exact coordinates to the LBS, an Anonymizing Spatial Region (K-ASR) is constructed, which encloses the locations of K 1 additional users.
Ref.
[13, 17] extend this method and also address processing of anonymized queries.
Most existing approaches utilize a centralized anonymizer: a trusted server that acts as an intermediate tier between the users and the LBS.
All users subscribe to the anonymizer and continuously report their location while they move.
Each user sends his query to the anonymizer, which constructs the putes the answer based on the K-ASR, instead of the exact user location; thus, the response of the LBS is a superset of the answer.
Finally, the anonymizer  lters the result from the LBS and returns the exact answer to the user.
Our work is motivated by the following shortcomings of existing approaches: (i) The centralized anonymizer is a bottleneck due to handling query requests, frequent updates of user locations and result post-processing.
Moreover, the anonymizer is a single point of failure; the system cannot function without it.
(ii) The complete knowledge of the locations and queries of all users is a serious security threat, if the anonymizer is compromised.
Even if there is no attack, the centralized anonymizer may be subject to governmental control, and may be banned or forced to disclose sensitive user information (similar to the legal case of the Napster  le-sharing service).
(iii) Independent of the centralized architecture, the hierarchical partitioning method for K-ASR construction [10, 17] fails to provide anonymity under certain conditions (see Section 3).
We propose Priv e, a distributed architecture for anonymous location-based queries, which addresses the problems of existing systems.
Our contributions are: (i) We develop a superior K-ASR construction mechanism based on the Hilbert space lling curve, that guarantees query anonymity even if the attacker knows the locations of all users.
(ii) We introduce a distributed protocol used by mobile entities to self-organize into a fault-tolerant overlay network.
The structure of the network resembles a distributed B+-tree (each mobile user corresponds to a data point), with additional annotation to support e ciently the Hilbert-based K-ASR construction.
In Priv e, K-ASRs are built in a decentralized fashion, therefore the bottleneck of the centralized server is avoided.
Moreover, since the state of the system is distributed, Priv e is resilient to attacks.
(iii) We also conduct an extensive experimental evaluation.
The results con rm that Priv e achieves e cient anonymization and load balancing with low maintenance overhead, while being fault-tolerant.
Therefore, it is scalable to large numbers of mobile users.
The rest of the paper is organized as follows: Section 2 discusses the architecture of Priv e.
Section 3 introduces spatial K-anonymity concepts and highlights the limitations of existing solutions.
In Section 4, we introduce our Hilbert-based K-ASR construction mechanism and in Section 5 we describe the distributed protocol of the overlay network.
Section 6 presents the experimental evaluation of our system.
A brief survey of the related work is included in Section 7.
Finally, Section 8 concludes the paper and discusses directions for future work.
Fig. 1 depicts the architecture of Priv e.
We assume a large number of users who carry mobile devices (e.g., mobile phones, PDAs) with embedded positioning capabilities (e.g., GPS).
The devices have processing power and access the network through a wireless protocol such as WiFi, GPRS or 3G.
Moreover, each device has a unique network identity (e.g., IP address) and can establish point-to-point communication (e.g., TCP/IP sockets) with any other device in the system through a base station (i.e., the two devices do not need to be within communication range of each other).
For security reasons, all communication links are encrypted.
...
Pseudonym services Location-Based Service Certification Server
 u2 u0
 u1 u3 u4 u6 u5
 u8 u7
 u9 Figure 1: Architecture of Priv e In addition, we assume the existence of a trusted central Certi cation Server (CS), where users are registered.
Prior to entering the system, a user u must authenticate against the CS and obtain a certi cate.
Users having a certi cate are trusted by all other users.
Typically, a certi cate is valid for a few hours; it can be renewed by recontacting the CS.
Apart from the certi cate, the CS returns to u the IP addresses of some users who are currently in the system.
u uses this list to identify an entry point to the distributed network.
Note that the CS does not know the locations of the users and does not participate in the anonymization process.
Therefore the workload of the CS is low (i.e., no location updates); moreover it does not store any sensitive information.
Each user corresponds to a peer.
Peers are grouped into clusters, according to their location.
Within each cluster, peers elect a cluster head, and the set of heads is grouped recursively to form a tree.
To achieve load balancing, cluster heads are rotated in a round-robin manner.
By de nition, cluster heads belong to multiple levels of the tree.
In Fig. 1, for instance, there is a two-level hierarchy, where users u2, u3, u8 are the heads of cluster C1, C2 and C3, respectively; also, u8 is the head of the upper layer cluster C4.
Typically users ask Range or Nearest-Neighbor (NN) queries with respect to their location.
For example, user u1 in Fig. 2, may ask:  Find the nearest hospital to my present location  (the answer is h2).
Such queries reveal the exact location of u1.
To achieve anonymity, Priv e requires users to set a degree of anonymity K (note that K is based on individual criteria and may vary among queries).
In our example, u1 chooses K = 3.
Priv e identi es an appropriate set of three users (i.e., u1, u2 and u3) in a distributed manner and constructs the corresponding K-ASR (i.e., the rectangle which encloses the three users).
Next, the transformed query is sent to LBS by u1.
In order to hide his IP address, u1 uses a pseudonym.
To obtain a pseudonym, any existing service for anonymous web sur ng can be used1.
Note that the pseudonym service does not know the location of any user.
Moreover, the auxiliary users inside the K-ASR collaborate only to hide the location, but do not know the exact query of u1; therefore, a single point of attack is avoided.
Priv e can collaborate with various untrustworthy spatial databases providing LBS.
The only requirement for the LBS is to support NN queries of regions (i.e., K-ASRs) as opposed to points.
Intuitively, the nearest neighbors of a region are all the data objects inside the region plus the NN of every
 that service is not a bottleneck or a single point of failure.
h4 u1 u1 h3 h3 u3 u3 u2 h1 h2 h1 h2 h5 h4 u1 h3 u3 u2
 Figure 2: Example:  Find the nearest hospital  (users are shown as black dots).
point in the perimeter of the region.
In our example (Fig. 2), the NN of the K-ASR are {h2, h3, h4}; the set is  ltered by u1 to obtain the actual answer h2.
The cardinality of the NN set (thus the processing and communication cost) depends on the K-ASR; therefore we aim to minimize the size of the K-ASR.
Query processing at the LBS [11, 13, 17] is orthogonal to our work, but outside the scope of this paper.
A user u who issues a location-based query is considered to be K-anonymous if his identity is indistinguishable from that of K 1 other users [10].
Formally: De nition [Spatial K-anonymity] Let H be a set of K distinct user entities with locations enclosed in an arbitrary spatial region K-ASR.
A user u   H is said to possess K-anonymity with respect to K-ASR if the probability of dis-tinguishing2 u among the other users in H does not exceed
 Note that: (i) The de nition assumes a snapshot of user locations.
Although Priv e supports user mobility, K-ano-nymity is unde ned across multiple snapshots.
(ii) Spatial K-anonymity does not depend on the size of the K-ASR.
In the extreme case, the K-ASR can degenerate to a point, if K users are at the same location.
In general, we prefer small K-ASRs, in order to minimize the processing cost at the LBS and the communication cost between the LBS and the mobile user.
Nevertheless, some applications impose a lower bound on the size of the K-ASR [17].
In such a case, the K-ASR can be trivially enlarged to satisfy the lower bound, by symmetrical scaling in all directions.
The same procedure can also be used to avoid having users on the perimeter of the K-ASR.
A na ve K-ASR construction algorithm would choose a random K-ASR.
However, if the K-ASR is too small it may contain fewer than K users, whereas if it is larger than necessary, it will a ect the query cost.
Constructing the K-ASR in the neighborhood of the querying user u (e.g., using the K nearest neighbors of u) is also inappropriate, because u tends to be closest to the center of the K-ASR, thus easily identi ed.
Moreover, we cannot pick randomly K 1 auxiliary users and send K independent NN queries to the LBS, because we would disclose the exact locations of K users; this is undesirable in any anonymization method.
on background knowledge (e.g.
user medical history) are outside the scope of this work Figure 3: K-ASR Reciprocity Example, K=5 We identify the following property that is su cient for a K-ASR construction technique in order to preserve user privacy: De nition [K-ASR Reciprocity] Consider a user uq issuing a query and its associated K-ASR Aq.
Aq satis es the reciprocity property i  there exists a set of users AS lying in Aq such that (i) |AS|   K, (ii) uq   AS and (iii) every user u   AS lies in the K-ASRs of all other users in AS.
Fig. 3 shows an example with ten users.
For K=5, the K-ASR of users u1, u3, u4, u8, u10 is area A1 an the K-ASR of users u2, u5, u6, u7, u9 is area A2.
In this example, K-ASRs of all users satisfy the reciprocity property.
For instance, for user u1, if we set AS = {u1, u3, u4, u8, u10}, we may easily verify that AS satis es all the requirements of the reciprocity property.
Theorem 3.1.
For a given snapshot of user locations, and regardless of the query distribution among users, a K-ASR construction technique guarantees spatial K-anonymity if every generated K-ASR satis es the reciprocity property.
Proof.
We assume the worst case scenario, where an attacker knows the exact location of all users in the system (from an outside source).
The attacker intercepts a set A of K-ASRs associated to user queries.
Consider K-ASR Aq   A.
The attacker attempts to infer the user uq that constructed Aq.
Since Aq satis es the reciprocity property, there exists a set of users AS (lying in Aq) such that (i) |AS|   K, (ii) uq   AS and (iii) every user u   AS lies in the K-ASRs of all other users in AS.
Moreover, since every K-ASR satis es the reciprocity property, it follows that when the attacker inspects any K-ASR that includes uq, he will observe the same set of users AS.
Therefore, for all users u in AS, the probability Pu of being the query issuer is: Pu = Puq =

 Hence, the K-anonymity property is satis ed.
In view of this property, an optimal K-ASR construction algorithm would partition the user population into K-ASRs that possess the reciprocity property, such that the sizes of the resulting K-ASRs are minimized.
However, optimal K-anonymity is an NP-Hard problem [16].
A number of on-the- y K-ASR construction techniques have been proposed, which attempt to achieve anonymity and reduce the K-ASR size.
In the following, we brie y survey these solutions and highlight their drawbacks.
The anonymization technique of Ref.
[10] indexes user locations in a PR-Quad-tree.
When user u issues a query, the Quad-tree is traversed until a quadrant which contains u and less than K 1 other users is found.
The parent of that quadrant is returned as the K-ASR.
A similar idea is used in Ref.
[17].
We refer to this technique as quadASR.
There are two drawbacks of quadASR: (i) It may fail to achieve anonymity for some user distributions.
Consider the example of Fig. 4.
Each user resides in his own quadrant identi ed by its lower-left and upper-right coordinates.
When any of the users u1, u2 or u3 issues a query with degree of anonymity K=3, the quadrant q2 = ((0, 2), (2, 4)) which encloses u1...3 will be returned as the K-ASR.
On the other hand, when the isolated user u4 issues a query with K=3, the larger quadrant q1 = ((0, 0), (4, 4)) is returned.
Note that if 1 < K   3, the only reason to return quadrant q1 is that u4 issued a query.
If an attacker knows the locations of the users in the area3, he will be able to pinpoint u4 as the query origin.
This vulnerability is the result of the fact that quadASR does not satisfy the reciprocity property (i.e. u1..3 belong to the K-ASR associated to u4, but not the other way around).
(ii) A second drawback of quadASR is that due to the nonuniform distribution of user locations, the number of users enclosed by a K-ASR may grow much larger than K (as for u4 in the previous example).
This corresponds to larger spatial extent of the K-ASR, hence higher processing cost.
Recently, a P2P system has been proposed that performs distributed query anonymization for location-based queries; we refer to it as cloakP2P [7].
cloakP2P uses a technique similar to iterative deepening [23] to construct K-ASRs.
The query source initiates a K-ASR request by contacting all peers within a given physical radius r, which is a  xed system parameter.
If the set of peers S0 found in the initial iteration is larger than K, the nearest K of them are chosen to form the K-ASR; otherwise, the process continues, and all peers in S0 issue a request to all peers within radius r. The process stops when K or more users have been found.
Intuitively, cloakP2P determines a query K-ASR by  nding the K  1 users nearest to the query source.
Unfortunately, this simple heuristic fails to achieve anonymity in many cases, since the query issuer tends to be near the center of the K-ASR.
In Section 6, we show experimentally the vulnerability of cloakP2P.
None of the existing methods satis es the reciprocity property.
Next, we describe our hilbASR algorithm, which overcomes the aforementioned drawbacks.
Our hilbASR algorithm guarantees that the probability of identifying the query initiator is always bounded by
 hilbASR uses the Hilbert [6] ordering to group users into
 tion of a user within 50-300 meters, as required by the US authorities (E911).
(cid:25) (cid:24) (cid:23) (cid:20) (cid:26) (cid:27) (cid:22) (cid:21) (cid:20)(cid:19) (cid:28) (cid:20)(cid:23) (cid:20)(cid:24) (cid:20)(cid:20) (cid:20)(cid:21) (cid:20)(cid:22) (cid:20)(cid:25) Figure 5: Hilbert Curve (Left: 4   4; Right: 8   8).
Figure 6: HILBASR, K=3 and K=4 buckets of K. The Hilbert space lling curve is a continuous fractal which maps each region of a multidimensional space to an integer.
In our case, the 2D coordinates of user locations are mapped to a 1D value.
With high probability, if two points are close in the 2D space, they will also be close in the Hilbert transformation.
Fig. 5, for instance, shows the curve for a 4  4 and 8  8 space partitioning; the granularity of the regions can be arbitrary small.
To compute the K-ASR, hilbASR employs a partitioning scheme that supports user mobility and varying K with minimal overhead.
Intuitively, hilbASR computes and sorts the Hilbert values of all users.
Then, the algorithm conceptually groups the sorted Hilbert values into K-buckets that contain K users, except from the last one which may contain up to 2 K 1 users.
Let us consider a user u asking a query with anonymity degree K. To compute the K-ASR of u, hilbASR computes the Hilbert value H(u) of u and  nds the K-bucket that H(u) belongs to.
The minimum bounding rectangle (MBR) of all the users in the K-bucket corresponds to the K-ASR.
For example, in Fig. 6, we illustrate the locations of ten users and their sorted Hilbert values.
To compute the 3-ASR of user u9, hilbASR  rst  nds the K-bucket which H(u9) belongs to.
In our case, this consists of four users, u8, u9, u10 and u7.
Then, hilbASR returns the MBR of these users.
Thus, the 3-ASR of user u9 is area A3.
Similarly, the 4-ASR of user u5 is area A4.
Note that for a given snapshot, hilbASR returns the same K-ASR for all users in the K-bucket.
This makes the K users of the K-bucket indistinguishable from each other.
Thus, the probability of identifying the query initiator is bounded by

 Lemma 4.1.
For a snapshot of user locations, hilbASR guarantees query source anonymity against location-based attacks.
Proof.
hilbASR satis es the reciprocity property, so from Theorem 3.1 immediately results that hilbASR guarantees spatial K-anonymity.
In general, techniques that use  xed buckets su er from lack of  exibility in accommodating queries with varying K.
Our method overcomes this limitation by avoiding to materialize the K-buckets.
Instead, it maintains a balanced sorting tree, which indexes the Hilbert values of user locations.
Let user u initiate a query with anonymization degree Ku.
Our algorithm performs a search for H(u) in the index and computes ranku, which corresponds to the position of H(u) in the in-order traversal of the tree.
From ranku, we calculate the start and end positions de ning the K-bucket which includes H(u), as 4: start = ranku   (ranku mod Ku) end = start + Ku   1 (1) To compute ranku e ciently, we use an annotated B+-tree (similar to the aR-tree [18]), where each tree node stores the number of leaf nodes in each of its subtrees.
Consider the example in Fig. 7.
For each internal node entry e, we store the number of leaf entries that are rooted at e; annotation counters are shown in parenthesis.
Assume we want to determine a K-ASR for entry 37, with K=6.
First, we compute the rank of entry 37 (Fig. 7a): we follow the path in the tree from root to the leaf that contains 37, and at each internal node we add to the rank value the sum of all counters in the node situated at the left of the followed pointer.
At the leaf layer, we add to the rank the local rank value of key 37 in its leaf, and obtain rank 8 (ranks start from 0).
Then, we calculate the bucket delimiters using Eq.
(1), and obtain the interval [6..11].
Next (Fig. 7b), we perform a range search to locate the entries with ranks [6..11].
Observe that this operation uses the annotation, rather that the B+-tree keys.
Sub-ranges at each level are determined by splitting the initial range based on subtree sizes; the o set for the recursive call at entry e is determined as the initial start value minus the sum of counters of all entries in the node preceding e.
The resulting K-ASR is highlighted in the diagram.
The data structure is scalable, since the complexity of constructing the K-ASR is O(log N + K), whereas search, insert and delete cost is O(log N ).
Therefore, hilbASR is applicable to large numbers of mobile users who update their position frequently and have varying requirements for the degree of anonymity K.
In this section, we introduce Priv e, a distributed protocol which supports decentralized query anonymization using the hilbASR algorithm.
Priv e mimics the functionality of a B+-tree in a distributed setting.
Each mobile user u has
 justed accordingly Figure 8: Distributed Index Structure,  =2 an associated index entry consisting of an ID (e.g., IP address), and the Hilbert value H(u) of his location as index key.
A node (leaf or internal) in the B+-tree corresponds to a cluster of users, with size bounded between   and 3 , where   is a  xed system parameter.
We use the terms cluster and index node interchangeably.
The maximum cluster size is 3 , instead of the usual 2  for B+-trees, to prevent cascading splits and merges (i.e., a split followed by a user departure), which are costly in the distributed environment.
Every user belongs to a leaf level cluster (level 0), and the contents of each cluster are disjoint (see Fig. 8).
The users of each cluster C elect a leader called head(C).
The head (marked with an asterisk) handles all index operations on behalf of the users in the cluster.
Cluster heads are recursively grouped to form a tree; therefore, they belong to multiple levels of the tree.
We denote by C i u, the level i cluster which includes user u.
In our example, user ua is the head of cluster C 0 a at level 0, and also the head of clusters C 1 a and C 2 a; therefore, it belongs to every level of the tree.
There is a single cluster at the top of the hierarchy, denoted as top.
The cluster head of top is denoted by root (ua in the example).
In our protocol description, we use remote procedure call convention to specify interactions between users.
The notation u.f unc(params) denotes the invocation of subroutine f unc with parameters params at user u.
Each cluster is associated with its state information.
The state of a leaf level cluster consists of an ordered list of (IP address, H(u)) pairs (user coordinates can be derived from the H(u) value).
The state of an upper layer cluster with m elements consists of a list of m user addresses, separated by m   1 key values used to direct the search; the process is similar to a B+-tree, with the role of memory pointers ful lled by the IP addresses of users.
Each internal node entry is annotated with a counter (depicted in parenthesis) representing the total number of users at the subtree under the entry.
Only the head needs to know the state of the cluster.
However, in our implementation, we replicate the state on every user within the cluster, to improve fault tolerance (in Section 6, we discuss the tradeo  between fault tolerance and maintenance cost).
The Priv e hierarchy has at most log  N layers, where N is the total number of users.
Since the cluster size is bounded and a user may belong to at most one cluster at each level, there is an upper bound of O(  log  N ) on the membership state stored at a user.
The index supports four operations: join, departure, relocation and K-request (i.e., a request for a K-ASR with anonymization degree K).
We establish two performance metrics for Priv e: (i) latency: the number of hops an in-Index Operations Figure 11: K-request,  =2, K=6 u).Relocate(u, Hu,0) u.Relocate(relocated user,H,l) u.RelocateMyself() /*executed by moving user*/ determine new key value Hu = Hilbert(u.x, u.y) call head(C0 if (H in indexed key range at level l ) if (l = 0) add relocated user to leaf user list; return else let n be the next hop for H call n.Relocate(relocated user, H,l   1) else call head(parent(Cl u)).Relocate(relocated user, H,l + 1) Figure 10: User Relocation dex operation requires to complete.
The latency is equal to the longest tree path followed as a result of the operation.
Multiple paths may be followed in parallel during an operation.
(ii) communication cost: the number of messages generated by an index operation.
Join.
User join corresponds to a B+-tree insertion operation.
Newly joining users authenticate at the certi cation server and receive the address of a user already inside the system.
Without loss of generality, we assume that joining users know the root, since the root can be reached from any user in O(log  N ) cost.
We stress that since we require an index structure with annotation (in order to determine the absolute ranks of users), all joins must occur through the root.
To avoid overloading the root, we devise a load-balancing mechanism (Section 5.2).
User join has O(log  N ) complexity in terms of latency and O(log  N +  ) communication cost; the second term is for updating the cluster state in all the users of the a ected cluster.
Consider user uy with Hilbert value H(uy) = 46 that joins the index of Fig. 8: uy contacts ua (at the root level) who forwards the join request to ub and updates ub s annotation counter in C 2 a to 14. ub then forwards the request to uh, whose annotation counter in C 1 b is updated to 4.
Fig. 9(a) shows the join outcome.
User join may trigger a cluster split, handled similarly to a B+-tree node split; the head initiating the split leads one of the resulting clusters, and appoints a random initial cluster node to lead the other.
Departure (informed).
User departure is similar to a B+-tree deletion.
The e ect of deletion must be propagated to root to update the annotation counters.
Deletion has O(log  N ) latency and O(log  N +  ) communication cost.
If the cluster size decreases below  , the head triggers a merge operation with the neighbor leaf-level cluster that has fewer members (to avoid a cascaded split).
The head of the resulting cluster can be any of the initial heads, except if one of them (e.g., ua) is also head at the higher level.
If so, ua will be chosen as leader, to minimize membership changes.
Relocation.
User mobility is treated as an entry update, which in a B+-tree translates into a deletion and an insertion.
Since users are likely to change location often, we optimize this process by performing local reassignment of users to nearby clusters.
Due to the good locality properties of Hilbert ordering, the number of clusters involved in relocation is likely to be small.
Annotation counter updates are only performed by a ected clusters; this way, updates are not propagated all the way to the root.
The upper bound on relocation latency is O(log  N ), but in most cases relocation only involves a few clusters, at the low layers of the index.
The pseudocode for user relocation is given in Fig. 10.
Consider user us from Fig. 8 who relocates to a new position with Hilbert value 60.
He forwards the request to ua = head(C 0 s ).
ua cannot keep us within the same leaf entry, since the new value is outside the interval [49..55].
Since ua = head(C 1 a), with no additional message, ua decides that us can be relocated to C 0 f , forwards the request to uf and updates the annotation counters of ua and uf accordingly.
Fig. 9(b) illustrates the relocation outcome.
K-request.
This operation corresponds to the hilbASR algorithm described in Section 4.
Consider the example in Fig. 11, where user um issues a K-request with K=6.
The request follows the path: um   ud   ub   ua (solid arrows in Fig. 11(a)).
The root ua determines the K-bucket (i.e., start = 6, end = 11) and sends a K-ASR request to ub (dotted arrows in Fig. 11(a)).
ub sends in parallel requests for partial K-ASRs with ranges [6..6], [7..9] and [10..11] to ud, ue and uh, respectively.
ub, which is the head of the lowest-layer cluster that completely covers the K-bucket (shown hashed in Fig. 11(b)) collects the partial K-ASRs, assembles the  nal query K-ASR and sends it back to the query issuer on the reverse path of the request.
Note that, the cluster head that covers the K-bucket sustains the highest load among all other users involved in the query.
This potential load imbalance issue is addressed in Section 5.2.
A K-request has O(log  N )+O(log  K) latency and O(log  N )+O(K/ ) communication cost.
The pseudocode for K-request is shown in Fig. 12.
Once the K-ASR is constructed, the query issuer (i.e., um) can send the anonymized query to the LBS through a pseudonym service, as explained in Section 2.
Priv e implements a soft-state based mechanism to deal with user failures or disconnections without noti cation.
Each cluster leader sends periodically (i.e., every  t seconds) a membership update message to all cluster members.
The message contains the membership list of the current cluster C and that of parent(C).
Cluster members respond to these messages; if a cluster member does not respond to two consecutive messages, it is considered disconnected and removed from the cluster.
The change is broadcast by the cluster head to the remaining cluster members.
determine key value Hu = Hilbert(u.x, u.y) call head(C0 u.ForwardRequest(H, count, l) u).ForwardRequest(Hu, 0, 0) if (l = 0) count = rankH in leaf entry else count+ = sum of annotation counters of keys < H if (u is root) compute start and end using eq (1) K-ASR = root.f indM BR(start, end, root height) else call head(C u ).ForwardRequest(H, count, l + 1) l+1 u. ndMBR(start,end,l) if (l = 0) /*leaf level*/ return MBR of members with local rank in [start,end]  nd set of next hops U for range [start,end]
 (cid:1)   U for u M BR = M BR   u (cid:1) return M BR . ndMBR(startu(cid:1) , endu(cid:1) , l   1) Figure 12: K-request If a non-head cluster member u does not receive a membership update from its head for a 2 t period, it initiates a leader election process.
Alternatively, when u attempts to initiate a operation, such as query or relocation, but cannot contact the cluster head for two consecutive attempts, it triggers the leader election protocol without waiting for the timer to expire.
u checks the membership it had at the last update, and chooses as leader (i.e., new head) the user with the smallest identi er.
It then sends a transfer head message to new head, which in turn sends a membership update message to all cluster users and also contacts head(parent(C)) to notify the change in leadership.
new head will replace the old head in all layers where the latter was leader before disconnection.
The hierarchical structure can cause signi cant di erences between the load sustained by cluster heads and ordinary cluster members, as well as among cluster heads at di erent layers of the hierarchy.
To alleviate the inherent imbalance, we propose a cluster head rotation mechanism, where users take turns in ful lling the cluster head role.
Since the promotion to cluster head translates into presence at a higher layer of the hierarchy, the rotation also ensures that users equally share the load at di erent layers.
Rotation is triggered when a node reaches a certain load threshold, denoted by load unit.
In wireless devices, the communication cost is dominant.
It is also important from the user s perspective, since mobile phone operators charge by the amount of transferred data.
Therefore, in Priv e the load is best represented by the number of messages sent and received by the user.
When user u reaches one load unit, it triggers a head rotation in all the clusters it currently heads, starting with its highest layer.
For each node along the path to its level 0 cluster, the member with the least load is appointed as new head.
Note that, since u stores the membership state about all clusters it belongs to at di erent layers, the appointment of a new leader can be done directly by u, without the need for a complex protocol or additional messages.
Choosing the cluster member with the lowest load prevents the newly appointed head to start a fresh rotation soon after promotion.
Fig. 13 illustrates the rotation mechanism.
For simplicity, all clusters have size 2.
Assume all queries originate at user ud with K=4.
After ua reaches one load unit, it hands over the root role to ue (at layer 2) from the right-hand subtree.
Also, at layer 1, uc becomes the head and is automatically promoted to layer 2.
Similarly, at layer 0, ub Figure 13: Load Balancing Mechanism becomes the head and is promoted to layer 1; the result is shown in Fig. 13(b).
Next, uc reaches its load unit, because more requests pass through it (it must inject queries and collect partial K-ASRs).
uc triggers a rotation at level 1 and appoints ub as cluster head (see Fig. 13(c)).
Subsequently, ub may be the next one to reach the load threshold, and start a new rotation in the left subtree.
Observe that at step (d), the left subtree has already performed a complete rotation round, whereas the right subtree has only performed one change.
Hence, our rotation mechanism alleviates hotspots (an entire subtree shares the load generated by ud) and at the same time provides a degree of fairness, not allowing a localized hotspot to a ect a large partition of the index.
The granularity of load unit choice is important in practice, in order to achieve a good tradeo  between load balancing and communication cost, since a rotation may incur a number of messages as large as O(  log  N ).
We further discuss this issue in Section 6.
To evaluate Priv e, we have implemented an event-driven packet level simulator in C++.
Since we are mostly interested in the overlay-layer performance, we consider a full mesh topology with lossless 500ms round-trip time links between any pair of users.
Our workload consists of user locations and movement patterns, and is generated using the Network-based Generator of Moving Objects [5], which models user movement on public road networks.
We consider user velocities ranging from 18 to 68km/h.
We present our results for a data set consisting of the San Francisco bay area (Fig. 16(a)), with number of users N varying from 1000 to

 queries over the set of users.
Anonymity Strength.
In Section 4, we have proved that hilbASR guarantees anonymity against location-based attacks, under any query distribution.
We illustrate this property in comparison with cloakP2P[7] and quadASR[10].
We assume that an attacker knows (from an external source) the locations of all users, and employs a simple strategy which infers the query source as uc, the user who is nearest to the center of the K-ASR.
We consider a 10000 users scenario in which 10000 random queries are issued.
In Fig. 14 we plot the identi cation success probability (i.e. of uc being the query source), for various values of K. The dotted line represents the value 1/ K, the ideal performance for an ano-nymization algorithm.
In the case of cloakP2P, for K=40, the probability of uc being the query source is 10%, four times the 1/K=2.5% maximum allowed bound.
For larger values of K, the situation gets worse, as the number of users included in the K-ASR increases.
The users are likely to come uniformly from all directions; hence, uc is disclosed as the query source.
On the other hand, hilbASR achieves the required anonymity degree K at all times.
Due to its poor anonymization strength, we omit cloakP2P from our further discussion.
quadASR has lower probability of iden-ti cation for this particular type of attack.
However, this e c r u o
 y f i t n e d
 (








 CloakP2P


 Figure 14: Anonymity Strength hilbASR quadASR Area Area










 hilbASR quadASR

 (a) Varying K, 10k users














 (b) K=80, varying N
 Figure 15: K-ASR area does not mean that it provides stronger anonymization than hilbASR: the ideal probability is given by the 1/K bound.
quadASR includes an excessively large number of users in the K-ASR, yielding high query processing cost; furthermore, it is still vulnerable to attacks such as those described in Section 3.1, while hilbASR provides anonymity guarantees under all circumstances.
K-ASR Size.
In this experiment, we compare hilbASR against quadASR in terms of spatial extent (i.e., area) of the generated K-ASR.
We consider a snapshot of user locations and generate a number of queries equal to the population size N .
Each query is initiated by a random user.
Fig. 15(a) shows the results for varying K and 10K users.
hilbASR is better in all cases.
In Fig. 15(b) we set K=80 and vary the number of users.
The decrease in K-ASR size with increasing N is explained by the higher user density in the same dataspace (i.e., K users can be located in a smaller region).
hilbASR again outperforms quadASR in terms of K-ASR extent.
Recall that smaller K-ASR translates into reduced execution cost at the LBS and communication cost between the LBS and the user.
Note that quadASR has been proposed only for centralized anonymization.
Still, the size of the resulting K-ASR is independent of whether it is constructed in a centralized or distributed setting.
Nevertheless, hilbASR outperforms quadASR in terms of both K-ASR size and anonymity strength (recall from Section 3.1 that quadASR may fail for certain user distributions).
The only other system that considers anonymization in a decentralized setting is cloakP2P, but we have shown that it fails to provide anonymity by a large margin.
Hence, hilbASR is the only protocol that guarantees anonymity.
Furthermore, it can be deployed in decentralized environments, and outperforms existing methods in terms of K-ASR size.
We further investigate the performance of Priv e, which implements hilbASR in a decentralized fashion.
Join and Departure.
In a system with N users, we perform 0.1N random user joins, followed by 0.1N random user departures.
Fig. 16(b) shows the join latency measured as hop count from the time a user issues a join request until he receives a join response message from its leaf-level head.
We observe that the latency is lower than the theoretical 1 + log  N , as a user may appear in multiple levels and can avoid sending redundant messages to himself.
The communication cost (i.e., total messages) per join and departure operation (Fig. 16(c)) varies linearly with  , since every join/departure translates into a membership update broadcast message within one leaf-level cluster.
Note the role of   in the latency-cost tradeo : an increase of   decreases latency as log  N , but triggers a linear cost increase in membership noti cation.
A larger   also increases the cost of periodic cluster membership maintenance.
K-request.
Fig. 16(d) and 16(e) show the K-request latency and communication cost for varying  , where K=40.
Larger   decreases the latency as the height of the index decreases.
The communication cost also decreases, as fewer leaf-level cluster heads need to be contacted to build the K-ASR.
However,   cannot grow very large from index maintenance considerations.
Fig. 16(f) and 16(g) show the latency and communication cost variation with anonymization degree K,   = 5.
Latency is only marginally a ected by K (the dominant factor in latency is log  N , since in practice K(cid:5) N ), while the communication cost grows linearly with K. The percentage of the user population involved in answering a single K-request operation is shown in Fig. 16(h) and 16(i).
For small N values, at most 2% of all users are needed to answer a K-request, while for larger N , less than 0.5% of the users are required.
Relocation.
Priv e addresses user mobility by using an index update algorithm that attempts to resolve relocation at the lower levels of the hierarchy, in order to reduce both latency and communication cost.
In our simulated scenario, we consider 10000 users across 20 consecutive time frames, with half of the indexed users moving at each time frame.
We consider three velocities: 68, 40 and 18km/h.
Fig. 16(j) and 16(k) show that relocation is e ciently handled: for the moderate   = 10 value, the relocation is done on average in 2.5 hops for fast-moving users and 1.5 hops for slow-moving users.
The dominant communication cost is that of the membership change propagation; for   = 10 this cost is roughly a quarter compared to the cost of an index deletion followed by insertion for the 68km/h case, and 1/8 for
 pleted at various levels of the hierarchy for a 6-level,   = 3,
 levels of the hierarchy: for slow movement, 70% are solved at the leaf level and 86% at levels 0 and 1; for fast movement, 32% of relocations are completed at the leaf level, 63% at levels 0 and 1, and 86% at levels 0, 1 or 2.
Fault-tolerance.
Starting with a system having correct cluster membership, we fail simultaneously 10, 20 or 30% of the nodes.
We use maintenance timer values of 30 seconds for refreshing cluster membership and 60 seconds for purging a failed member.
Fig. 16(m) shows the evolution of membership state correctness over time (1 represents completely correct state).
The system recovers to a correct state within 3 purge cycles (138 sec) for 10% failure and 4 purge cycles (197 sec) for 30% failure.
Load-balancing.
We measure the load incurred by each user for a 10000 users system,   = 5, K=80, load unit = 200 messages and a simulated time of 1 hour, during which an average of 8 queries/user were generated.
We consider both uniform and skewed (Zipf 0.8) query source distribution.
Fig. 16(n) shows the cumulative distribution function






 Latency




  

 Cost


















  

 Latency




  

 Cost












  

 (a) San Francisco Bay (b) Join Latency vs   (c) Join/Leave Cost vs   (d) Query Latency vs   (e) Query Cost vs   Latency












 Cost













 (f) Query Latency vs K

 (g) Query Cost vs K

 (h) Percentage vs K









 Cost 68km/h 40km/h 18km/h

  

 (k) Relocation Cost








 Frequency 68km/h 40km/h 18km/h





 Level (l) Relocation Level Membership Correctness


 Nodes(%)



























 Nodes(%)




  











 Latency 68km/h 40km/h 18km/h

  

 (i) Percentage vs   (j) Relocation Latency Load CDF







 Absolute Load Uniform Zipf(0.8)
















 Time(sec)

 No Rotation Rotation-unif Rotation-Zipf(0.8) Ideal










 (m) Failure Recovery (n) Node Load CDF (o) Absolute Node Load Figure 16: Priv e Experimental Evaluation (CDF) of sorted user loads.
The load is highly unbalanced if no rotation is performed, with 10% of users sustaining more than 80% of the load.
With rotation, for uniform query distribution, the load is close to the ideal one (i.e., diagonal line).
For skewed query distribution, most of the users share equal load, while part of the users (roughly 10%) share a slightly higher load, as dictated by the fairness requirement discussed in Section 5.2.
This is illustrated better in Fig. 16(o) which shows the absolute load of each user.
K-anonymity was  rst discussed in relational databases where published statistical data (e.g., census, medical) should not be linked to speci c persons.
Samarati and Sweeney [19, 21] proposed the following de nition: A relation satis- es K-anonymity if every tuple in the relation is indistinguishable from at least K 1 other tuples with respect to a set of quasi-identi er attributes.
Quasi-identi ers are sets of attributes (e.g., date of birth, gender, zip code) which can be linked to publicly available data to uniquely identify individuals.
Two techniques are used to transform a relation to a K-anonymized one: suppression, where some of the attributes or tuples are removed, and generalization, which involves replacing speci c values (e.g., phone number) with more general ones (e.g., only area code).
Both techniques result in information loss.
Ref.
[4] and Ref.
[14] discuss e cient algorithms for anonymizing an entire relation while preserving as much information as possible.
In Ref.
[22] the authors consider the case where each individual requires a di erent degree K of anonymity, while Aggar-wal [1] shows that anonymizing a high-dimensional relation results to unacceptable loss of information due to the dimen-sionality curse.
Finally, Machanavajjhala et al. [15] propose (cid:3)-diversity, an anonymization method which protects against disclosure of sensitive attribute values.
K-anonymity has also been adopted in the LBS domain: in Ref.
[9, 10], the location of the user is concealed by constructing an Anonymizing Spatial Region (K-ASR) which encloses the locations of the query source and K 1 additional users.
However, their methods of K-ASR construction are ine cient, and anonymization may fail for some data distributions.
Ref.
[13, 17] extend further these ideas and present a framework for the entire process of anonymi-zation and query processing at the LBS.
Nevertheless, the aforementioned methods assume a centralized anonymizer, which may constitute a bottleneck or a single point of attack.
Prior to our work, the only decentralized solution was a P2P-based system, presented in Ref.
[7].
However, that system fails to achieve anonymity in many situations (see Section 6).
Key and range search has been studied extensively in distributed environments.
Several structured Peer-to-Peer systems (e.g, Chord [20]) support distributed key search with O(log N ) complexity.
The drawback of such systems is that they cannot support e ciently node annotation.
Without node annotation, the communication cost for satisfying the reciprocity property (which guarantees K-anonymity) is O(N ); this cost is too high for large scale systems (recall work is the P-tree [8], which supports range queries by embedding a B+-tree on top of an overlay network.
No global index is maintained; instead each node maintains its own B+-tree-like structure.
BATON [12] also addresses range queries, by embedding a balanced tree onto an overlay network.
It uses additional cross-links to prevent hotspots, and achieves O(log N ) complexity for search and maintenance.
Similar to Chord, these systems cannot support e ciently node annotation.
Hierarchical clustering in distributed environments has been an active research topic in recent years.
In Ref.
[3], a hierarchical-clustering routing protocol for wireless networks is presented.
The NICE project [2] proposes a scal-able application-layer multicast protocol, based on delivery trees built on top of a hierarchically connected control topology.
Nodes participating in a multicast group are organized into a multi-layer hierarchy of clusters with bounded size.
NICE trees obtain delays in the order of O(log N ), where N is the size of the multicast group, and there is an upper bound of O(log N ) in terms of control state maintained per node.
Priv e also uses hierarchical clustering of mobile users, but the requirements of total ordering and annotation impose particular challenges that have not been addressed by existing research.
In this paper we introduced Priv e, a distributed system for query anonymization in LBS.
In Priv e, mobile users who issue location-based queries organize themselves into a hierarchical overlay network and anonymize queries in a fully decentralized fashion.
Priv e supports our hilbASR anonymization technique, which guarantees anonymity under any user distribution.
We show experimentally that our system is e cient, scalable, fault tolerant and achieves load balancing.
LBS for mobile users are already a reality in some countries (e.g., Japan), where new mobile phones are equipped with a positioning device, and high-speed wireless networks are common.
As such applications gain popularity, privacy and con dentiality concerns are expected to rise.
In the future, we plan to address anonymity of continuous spatial queries, and extend our algorithm to trajectories, as opposed to points.
We also plan to deploy Priv e in infrastructure-less environments, such as ad-hoc wireless networks (WiFi, Bluetooth), without point-to-point links between all users.
