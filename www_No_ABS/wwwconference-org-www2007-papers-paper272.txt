The Semantic Web is a web of data that can be processed by machines, enabling them to interpret, combine and use Web data [4, p. 191].
RDF1 is the foundational representation model of the Semantic Web.
Statements in RDF are triples consisting of a subject, a predicate, and an object and assert that a subject has a property with some value.
Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
Developing Semantic Web applications requires handling the RDF data model in a programming language.
Although a majority of current software is developed in the object-oriented paradigm2, programming in RDF is currently triple-based.
For relational databases, object-oriented APIs have been long available: frameworks such as Hibernate [2] or ADO.Net provide an automatic mapping from relational databases to object-oriented programming.
Partially inspired by such object-relational mappings, the development of an object-oriented RDF API has been suggested several times [15, 16].
Such an API would map RDF Schema3 (RDFS) classes to programming classes, RDF resources to programming objects and RDF predicates to methods on those objects, containing Person.firstName instead of Resource.getProperty(http://xmlns.com/foaf/
 In this paper we present an architecture and implementation of such an object-oriented RDF API.
In section 2 we examine the di erences between the object-oriented paradigm and the RDF model and explain why techniques used in object-relational mapping approaches are not su cient.
We present our solution architecture in section 3 and analyse the suitability of scripting languages for our mapping architecture.
Section 4 introduces our implementation ActiveRDF, while section 5 illustrates the integration of ActiveRDF with the web application framework Ruby on Rails.
We evaluate our work in section 6, discuss related approaches in section 7 and conclude in section 8.
The conceptual model and semantics of RDF Schema differ substantially from the object-oriented paradigm, more so than the relational paradigm does.
In this section we examine these di erences and explain why existing mapping approaches do not su ce for Semantic Web data.
Although the exact meaning of  object-oriented  varies [1], we will consider typical object-oriented features and focus mostly on Java.
The semantics of classes and instances in RDF Schema is open-world and description logics-based while object-oriented type systems are closed-world and constraint-based [10].
This 2http://www.tiobe.com/tpci.htm
 1. class membership: in popular object-oriented languages such as Java or C# an object is member of exactly one class: its membership is  xed and is de ned during the object instantiation.
In RDF Schema, a resource can belong to multiple classes: its membership is not  xed but de ned by its rdf:type and the properties that belong to the resource.
2. class hierarchy: in popular object-oriented type systems, such as in Java or C#, classes can inherit from at most one superclass, while in RDF Schema classes can inherit from multiple superclasses (including inheritance cycles).
3. attribute vs. property: in the object-oriented model, attributes are de ned locally inside their class, can be used only by instances of that class, and generally have single-typed values.
In contrast, RDF properties are standalone entities that can be used by any resource of any class and that can have values of di erent types.
4. structural inheritance: in object-oriented programming, objects inherit their attributes from their parent classes.
In RDF Schema, since properties do not belong to a class, they are not inherited.
Instead, property domains are propagated, but given their speci c meaning indicating the class membership of resources using that property, domains propagate into the upwards direction of the class hierarchy.
5. object conformance: in most object-oriented languages, the structure of instances must exactly follow the de -nition of their classes, whereas in RDF Schema, a class de nition is not exhaustive and does not constrain the structure of its instances: any RDF resource can use any property.
6.  exibility: object-oriented systems usually do not al- low class de nitions to evolve during runtime.
In contrast, RDF is designed for integration of heterogeneous data with varying structure from varying sources, where both schema and data evolve during runtime.
For relational databases several object relational mappings exist, such as Java Data Objects and Hibernate for Java, ADO.Net for C# and ActiveRecord for Ruby.
Most of these mappings follow the Active Domain Object or Active Record pattern [8, p. 160] which abstracts the database, simpli es data access and ensures data consistency.
Although the mapping frameworks di er in how they solve the impedance mismatch between the relational model, which is normalised for fast data retrieval, and the object-oriented model, which captures real-world objects as closely as possible, the general mapping is the same in all frameworks.
Tables are mapped to classes; table columns are mapped as attributes in the class, except for foreign keys which are mapped to object relationships; and every tuple in the relational model is mapped to an object.
Intersection tables, which are introduced in the relational model to capture many-to-many relations, are mapped to object relationships (is-a, has-a relations).
To apply the general mapping methodology to RDF data, adjustments are required to address the six identi ed mismatches listed above.
Existing approaches do not address these mismatches since they do not occur in relational data: 1. class membership: in the relational model, every tuple belongs to exactly one table, which maps without problem to the object-oriented requirement that every object must be member of exactly one class.
2. class hierarchy: a nonissue since no hierarchy of tables is allowed in the relational model.
3. object attributes: columns are the relational counter part of object attributes, and map without problems to object attributes: columns are de ned locally to a table, can be used only by tuples of that tables and have single-typed values.
4. structural inheritance: a nonissue since inheritance does not exist in the relational model.
5. object conformance: in the relational model each tuple must conform strictly to the table de nition in the schema, which maps without problem to the object-oriented notion of object conformance.
Although tables can have optional columns, a tuple cannot contain other columns than speci ed in the table de nition.
6.  exibility: database systems are typically closed sys- tems whose schema de nitions do not change dynamically at runtime, rendering the level of  exibility needed for RDF data again a nonissue.
The previous section discussed the mismatches between the object-oriented paradigm and RDF data and explained why existing object-relational mappings do not address these mismatches.
To resolve these issues one can either impose restrictions on the usage of RDF or remove some restrictions in the object-oriented language.
We take the second approach: our solution is based on object-oriented scripting languages, where the mismatch between the object-oriented paradigm and RDF is smaller than with compiled object-oriented languages.
This section introduces scripting languages, explains their suitability and introduces our architecture for an object-oriented RDF API.
Dynamic, general-purpose scripting languages such as Perl, Python, and Ruby are typically interpreted, use dynamic typing, have strong meta-programming capabilities (which enable the programmer to alter the semantics of the language) and allow runtime introspection [13].
Through dynamic typing and meta-programming, scripting languages enable us to implement a domain-speci c language for RDF(S) data and alleviate the discussed mismatches as follows: 1. class membership: the dynamic typing of scripting lan- guages does not require object types to be de ned statically, these are rather determined at runtime by the capabilities of the object.
Dynamic typing maps well to RDF(S) class membership which can also change guages can have only one type at a time, we can override that behaviour using meta-programming.
2. class hierarchy: although most scripting languages do not support multiple inheritance, this behaviour can usually be changed through meta-programming.
3. attribute vs. property: the meta-programming facil- ity of scripting languages enables the addition of attributes to objects dynamically whereas their dynamic typing enables the attributes to have values of multiple types.
4. structural inheritance: by itself, the lack of structural inheritance in RDF(S) does not form a problem for an object-oriented mapping.
However, as we will describe in Sect.
4.1, the lack of structural inheritance limits the possibility of resolving ambiguous property shorthands, e.g.
Person.name.
5. object conformance: scripting languages typically do not require objects to strictly conform to their class de nitions but instead allow objects to deviate from their classes.
For example, it is often possible to specify a di erent behaviour (method implementation) for several objects of the same class.
6.  exibility: since scripting languages are interpreted and do not rely on strict and prior-de ned classes, they are well-suited for  exible environments in which both data and schema can evolve.
The introspection allows programs to investigate the schemas and domain vocabulary that are available during program execution.
In summary, dynamic scripting languages o er the properties required for a virtual and  exible API for RDF(S) data.
Our arguments apply equally well to any dynamic Turing-complete language with these capabilities.
The general principle of our architecture is to represent RDF resources through transparent proxy objects.
Each proxy object represents one RDF resource but does not contain any state.
All methods (manipulations) on the proxy object are translated into (read or write) queries related to the proxy s RDF resource.
Transparent proxy objects are simpler to implement than rich objects that copy the state and data of an RDF resource.
Since rich objects often offer better performance, caching data in such rich objects can be implemented as an extension but requires a cache-management policy.
Our architecture consists of four layers, as shown in Fig. 1, that incrementally abstract RDF data into objects.
The object manager is the library entry point and provides all the mapping functionality.
It provides the domain model with all its manipulation and generic search methods.
It is not a generated API (hence the name virtual ), but uses meta-programming to catch unhandled method calls (such as john.firstName) and respond to them.
The object manager maps RDF data to objects and data manipulation to methods.
For example, when the application calls a  nd method or when a new person is created, Figure 1: ActiveRDF architecture the mapping layer translates this operation into a query on the data source.
The object manager also creates object-oriented classes from RDF Schema classes if schema information is available.
Developers can augment the object-oriented classes with custom methods to provide additional behaviour.
Such methods can be overridden in subclasses to de ne speci c be-haviour: for example, a toString method might return different results for di erent kinds of objects.
In typical object-oriented systems, the de nition in the most speci c class is used when multiple method de nitions are given.
However, given the multiple inheritance in RDF Schema and the possibility of multiple membership, an additional resolution strategy must be used for methods that are de- ned multiple times, in classes that have no inheritance relation to each other.
Possible solutions are to execute the  rst-found method de nition, to select the most applicable method through a more re ned distance-measure, to let the developer explicitly indicate the de nition to use, or to raise an error.
The query engine provides an abstract query API that is independent of a speci c data source and query language.
It is used by the object manager to construct queries for each object manipulation.
The federation manager manages the collection of available data sources, distributes the queries over some or all of these sources and collects their results.
The federation manager should, when querying multiple data sources, consolidate the results [7]: similar objects that are identi ed di erently in the di erent data sources should be merged before the results are returned.
Adapters provide access to a speci c RDF data-store by translating generic RDF operations to a store-speci c API.
Such RDF data-store speci c adapters are necessary, because of the absence of a general standardised query language which provides create, read, update, and delete access.
As such adapters are responsible for translating and exe-adapter(s)federationobject managerquery engineapplicationdata source(s)accessing dataexposing dataWWW 2007 / Track: Semantic WebSession: Query Languages and DBs819cuting queries from the federation manager into a query language supported by their data source.
Each adapter must implement a simple API, which allows new adapters to be added easily.
Adapters do not necessarily wrap RDF data sources, they could also wrap  legacy  sources such as desktop application data (as in the Aperture architecture [14]) or relational databases (as in the D2R system [5]), as long as they expose their query results as RDF.
We have implemented the presented architecture in our Ruby library ActiveRDF, which provides a virtual API for managing RDF data in an object-oriented manner.
We have reported on an initial implementation earlier [11].
Since then, ActiveRDF was completely re-implemented according to the architecture described above.
ActiveRDF is currently implemented in around 600 lines of code; the adapters are written in on average 160 lines of code.
The object manager o ers a virtual API to manipulate RDF.
This virtual API can be divided into three parts: mapping RDF(S) resources into objects, instance-level methods for manipulating these resources, and class-levels methods for searching resources.
In ActiveRDF every object can be member of many classes.
Since Ruby does not allow such multiple membership, we override the builtin Ruby behaviour.
All builtin methods that use the class of an object are overridden to rely on the rdf:type(s) in the data source.
Apart from the virtual API, developers can augment the domain model with custom methods.
As discussed in section 3.2.1, a search strategy is needed to resolve multiple (clash ing) method de nitions in classes: as a pragmatic solution our current implementation uses the  rst-found de nition.
The object manager maps all RDF(S) classes to Ruby classes, all RDF resources to Ruby objects, and all RDF properties to attributes on the Ruby objects.
All RDF resources are by default created as Ruby objects of class RDFS::Resource.
Domain-speci c methods such as john.age or john.name are not generated but provided virtually: the object manager catches their invocation and translates the method call into a query.
Without the object manager s interference, Ruby would throw a MethodNotFound error.
Such meta-programming caters for  exibility: as we do not generate the API but  pretend  it based on the data available at runtime, we do not need to recompile or regenerate the API when the data changes.
To prevent clashes between similarly-named classes in different libraries we map the RDF namespaces onto the names-pace mechanism provided by Ruby.
Listing 1 shows how to register a namespace abbreviation for the FOAF namespace and how to create an instance of FOAF::Person.
Listing 1: Mapping resources Namespace.register(:foaf,  http://xmlns.com/foaf/0.1 ) ObjectManager.construct classes john = FOAF::Person.new( http://example.org/foaf.rdf#me )    end  end        
 Resources can be manipulated depending on the data access permissions and capabilities of the data source.
Listing 2 shows how to use standard Ruby closure to traverse John s friends and print the name of each of them.
Listing 2: Traversing using Ruby closure john.knows.each do |friend| puts friend.name  end In this example, the object manager transparently catches the method calls john.knows and friend.name and translates each into a query.
Part of this translation is determining the full URI of the predicate for  knows  and  name , which is straightforward with a unique local part, but ambiguous when di erent predicates have the same local parts.
As discussed in Sect.
2, the schema de nition cannot be used to determine which predicate might apply to a certain resource, since the schema does not constrain usage of predicates to classes.
For example, every resource can use foaf:name, the resource then simply becomes of type foaf:Person.
One might be tempted to use the schema de nition and class hierarchy to limit this ambiguity and to  nd the most relevant property for a resource, but the RDF(S) notion of  domain  does not cater for this.
Developers can still use an ambiguous but convenient shorthand, as in Listing 3, but are not guaranteed the desired results since the  rst matching predicate will be used.
Instead, they can explicitly specify the predicate through its namespace, as in Listing 4.
Listing 3: Ambiguous property accessors john.knows.each do |friend| puts friend.name Listing 4: Unambiguous property accessors john.foaf::knows.each do |friend| puts friend.foaf::name Searching resources Each such resource manipulation is translated into a query.
Invocations that change attribute values are handled similarly, but generate update queries instead of read queries.
If the URI of the resource is known to the application programmer, a proxy object is created as shown in the listing above.
If the URI is not known, ActiveRDF o ers two ways to search for it: with  dynamic  nders  in the object manager, or through the Query API.
Listing 5 demonstrates the dynamic  nders.
The  rst shows a search returning all resources named  John , the second all thirty-year-olds named  John .
These  nders allow to locate a resource through one or more conjunctive clauses.
If the developer requires more complicated queries the Query API can be used.
Listing 5: Dynamic  nders FOAF::Person. nd by name( John ) FOAF::Person. nd by name and age( John ,30)
 The current implementation of the query engine supports conjunctive datalog with select, distinct, and arbitrary where     this) counting query results, specifying the limit and o set of the query results and full-text keyword search.
The query engine is used internally by the object manager for all manipulations.
Further, it can be used by the application developer to execute complex queries on the data sources.
Listing 6 shows some typical queries.
The  rst query counts the number of distinct predicates used in the dataset, the second one returns all distinct foaf:names of the earlier de ned John, and the third one  nds all resources mentioning  apple .
  Listing 6: Usage of Query API Query.new.count.distinct(:p).where(:s, :p, :o) Query.new.distinct(:o).where(john, FOAF::name, :o) Query.new.distinct(:s).where(:s, :keyword,  apple )
 The federation manager distributes queries amongst all registered data sources and aggregates their results.
In the current implementation query distribution is achieved by simply querying all data sources sequentially; query result aggregation is achieved through a union of individual results (using either set union for distinct queries or bag union for non-distinct queries).
We have not yet implemented a consolidation strategy in the federation manager, but we do o er an extension point for later addition of such functionality.
Adapters wrap a data source into a standard interface, which includes methods such as query, add and delete.
To translate the abstract query into the query language of the data source, adapters can either reuse existing translators or implement their own translation.
To fully conform to RDF(S) semantics, ActiveRDF relies on the data sources to do so as well; data from sources without RDFS inferencing can still be used inside ActiveRDF, but the mapping will then not fully conform to RDF(S) semantics.
We have implemented adapters for generic SPARQL endpoints, to the RDF data stores Sesame [6], Jena [17], YARS [9], and Redland [3].
We have also implemented proof-of-concept adapters to desktop application data such as the Evolution email address book (exposed as FOAF data).
We have further developed rd ite, a simple and lightweight RDF store (and adapter) based on SQLite4 with support for full-text search.
We distribute rd ite as an adapter for ActiveRDF to enable simple prototyping without installing a fully edged RDF store.
Ruby on Rails is a rapid application development framework for web applications, following the model view controller paradigm.
Developers are presented with default models, views, and controllers and can adjust these to their domain.
The model is usually provided by an existing database, the controller implements the control ow in Ruby and the view is speci ed using HTML and embedded Ruby code.
Ruby on Rails has two main strengths: on the one hand it provides default application logic for the generic parts of web applications and several helper methods for data manipulation and JavaScript e ects, alleviating developers from these 4http://www.sqlite.org   tasks.
On the other hand, since Ruby on Rails is targeted towards web applications that operate on relational databases, it integrates the business logic with the domain data using the ActiveRecord object-relational mapping: database tables serve as domain models and database tuples become Ruby instances.
We have designed ActiveRDF such that it can serve as a data layer in Ruby on Rails, replacing or augmenting the default ActiveRecord layer.
As such, it provides a solution for rapid development of Semantic Web applications, leveraging the large and vibrant community of Ruby on Rails developers with their extensions and plugins.
We have developed several web applications using ActiveRDF and Ruby on Rails; we will brie y describe two of them:
 We have developed a simple conference schedule5 purely built on Ruby on Rails and ActiveRDF.
Originally developed for the International Semantic Web Conference 2006 this application operates on the conference metadata to show participants an overview of the conference schedule with details about each presentation and participant.
The application operates strictly on RDF metadata using vocabularies such as eswc, iswc, swrc, foaf and ical.
Using ActiveRDF the integration of Rails with RDF data was straightforward and the development e ort was minimal.
Most development time was actually dedicated to support di erent browsers for the views.
The models itself are automatically provided as virtual models, the controller (with all application logic) contains around 250 lines of code, and the views contain around 200 lines of HTML, Ruby and JavaScript code.
To allow navigation in arbitrary RDF datasets we have developed a faceted metadata browser6.
Faceted browsing is a data exploration technique for large datasets.
BrowseRDF extends this technique for complete graph-based data and adds algorithms to rank facets automatically based on facet entropy [12].
Again, using ActiveRDF the development e ort was minimal once the formal model and the algorithms had been developed: the models are automatically provided, the controller contains around 300 lines of code, and the views contain around 250 lines of HTML, Ruby and JavaScript code.
BrowseRDF currently uses the rd ite data store, but the data source abstraction in ActiveRDF allows us to easily switch to a more scalable RDF store such as YARS or Sesame for larger datasets.
We evaluate ActiveRDF in two ways: a quantitative evaluation to indicate possible performance overhead of our library and a qualitative evaluation to indicate the possible ease-of-use and increased productivity in software development.
For practical reasons we have not measured productivity increase directly (as e.g.
task completion speed of several similarly quali ed programmers with and without ActiveRDF), instead an indication is given through the 5http://schedule.semanticweb.org 6http://www.browserdf.org








  #mindswapHomepage> ?homepage . }
SELECT ?homepage WHERE { ?person <http://xmlns.com/foaf/0.1/name> Ashok Agrawala .
?person <http://owl.mindswap.org/2003/ont/owlweb.rdf SELECT ?p ?o WHERE { <http://activerdf.org/bnode#genid56> ?p ?o . }
SELECT ?p WHERE { <http://activerdf.org/bnode#genid56> ?p ?o . }
SELECT ?s ?p ?o WHERE { ?s ?p ?o . }
SELECT ?s ?p WHERE { ?s ?p ?o . }
SELECT ?s WHERE { ?s ?p ?o . }
SELECT DISTINCT ?p WHERE { <http://activerdf.org/bnode#genid56> ?p ?o . }
SELECT DISTINCT ?p WHERE { ?s ?p ?o . }
SELECT ?s WHERE { ?s <http://www.w3.org/1999/02/22 rdf syntax ns#type> <http://xmlns.com/foaf/0.1/Person> . }
Figure 2: Evaluation queries   relatively few lines of codes needed for the applications presented in section 5.
For quantitative evaluation, we compared query execution on Sesame (using various queries and various datasets) using the curl HTTP client (which shows the time needed by the data store for query answering), the Sesame Java API and ActiveRDF.
We evaluated nine queries (ranging from selecting all triples to joins over two resources, see Fig. 2) using  ve di erent datasets (ranging from 2500 50.000 triples).
Each test was  rst run to warm-boot the server and then repeated ten times.
The tests were run on a server with two
 Figure 4: Querying Sesame ActiveRDF using JSON

 Many RDF APIs exist currently7 (in various programming languages).
Some provide access to one speci c RDF store, such as the Jena API [17] or the Sesame API [6], and some are agnostic to the underlying data store, such as RDF2Go8.
Most of these APIs are generic and triple-based, o ering methods such as getStatement and getObject.
These are exactly the APIs that we want to abstract from.
The development of an object-oriented API has been attempted in Java in RdfReactor9, Elmo10 and Jastor11.
These approaches ignore the  exible and semi-structured nature of RDF data and instead: (i) assume the existence of a schema, because they rely on the RDF Schema to generate corresponding classes, (ii) assume the stability of the schema, because they require manual regeneration and recompilation if the schema changes and (iii) assume the conformance of RDF data to such a schema, because they do not allow objects with di erent structure than their class de nition.
We have presented ActiveRDF, an object-oriented library for RDF data written in Ruby.
We have analysed why the techniques used in traditional object-relational mapping approaches are not su cient for the Semantic Web and RDF in 7http://www.wiwiss.fu-berlin.de/suhl/bizer/ toolkits 8http://rdf2go.ontoware.org 9http://rdfreactor.ontoware.org/ 10http://www.openrdf.org/doc/elmo/users/index.html 11http://jastor.sourceforge.net/ Figure 3: Querying Sesame in ActiveRDF Fig. 3 shows the average response time (including result parsing in Java and ActiveRDF) of each query using curl, Java, and ActiveRDF in a logarithmic scale.
It can be seen that for most queries ActiveRDF adds only little overhead.
On some queries ActiveRDF seems to perform faster than using curl HTTP, which is probably due to random hardware variations and measurement di culties in those small response time ranges.
For queries #3, #4 and #5 however the overhead of Ac-tiveRDF is substantial.
Because these queries return large amounts of XML results, we suspected the performance to be in uenced by the Ruby XML parser.
Fig. 4 therefore shows the average response time for same queries but with the JSON result format instead of XML: indeed the response time is on average halved for queries #3 (from  30s to  15s), #4 (from 20s to 12s) and #5 (from 13s to 7s); note that the graphs are in logarithmic scale.
to implement ActiveRDF in an object-oriented scripting languages.
Among the advantages of these languages is the dynamic typing of objects, which maps well onto the RDF(S) class membership, meta-programming, which allows us to implement the multi-inheritance of RDF(S), and a relaxation of strict object conformance to class de nitions.
ActiveRDF is lightweight and implemented in around 600 lines of code.
It can be used with generic SPARQL endpoints, on popular RDF data stores, and with desktop application data.
We have designed ActiveRDF such that it can serve as a data layer in Ruby on Rails, replacing or augmenting the default ActiveRecord layer, and providing a solution for rapid development of Semantic Web applications.
We have shown that ActiveRDF adds only little performance overhead, which can probably be decreased by carefully considering the parsing implementation.
With its higher abstraction level and integration with Ruby on Rails, Ac-tiveRDF allows the development of Semantic Web applications in relatively few lines of code.
The work presented in this paper was supported by the Science Foundation Ireland under Grants No.
SFI/02/CE1/-I131 and SFI/04/BR/CS0694.
We thank Benjamin Heit-mann for his help in development and documentation, and the reviewers for their helpful feedback and suggestions.
