[5]) and word sense disambiguation (e.g.
Many applications in modern information technology utilize ontological background knowledge.
This applies above all to applications in the vision of the Semantic Web, but there are many other application  elds.
Machine translation (e.g.
[3]) exploit lexical knowledge, query expansion uses taxonomies (e.g.
[16, 11, 27]), document classi cation based on supervised or semi-supervised learning can be combined with ontologies (e.g.
[14]), and [13] demonstrates the utility of background knowledge for question answering and information retrieval.
Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
Furthermore, ontological knowledge structures play an important role in data cleaning (e.g., for a data warehouse) [6], record linkage (aka.
entity resolution) [7], and information integration in general [19].
But the existing applications typically use only a single source of background knowledge (mostly WordNet [10] or Wikipedia).
They could boost their performance, if a huge ontology with knowledge from several sources was available.
Such an ontology would have to be of high quality, with accuracy close to 100 percent, i.e. comparable in quality to an encyclopedia.
It would have to comprise not only concepts in the style of WordNet, but also named entities like people, organizations, geographic locations, books, songs, products, etc., and also relations among these such as what-is-located-where, who-was-born-when, who-has-won-which-prize, etc.
It would have to be extensible, easily reusable, and application-independent.
If such an ontology were available, it could boost the performance of existing applications and also open up the path towards new applications in the Semantic Web era.
Knowledge representation is an old  eld in AI and has provided numerous models from frames and KL-ONE to recent variants of description logics and RDFS and OWL (see [22] and [24]).
Numerous approaches have been proposed to create general-purpose ontologies on top of these representations.
One class of approaches focuses on extracting knowledge structures automatically from text corpora.
These approaches use information extraction technologies that include pattern matching, natural-language parsing, and statistical learning [25, 9, 4, 1, 23, 20, 8].
These techniques have also been used to extend WordNet by Wikipedia individuals [21].
Another project along these lines is Know-ItAll [9], which aims at extracting and compiling instances of unary and binary predicate instances on a very large scale   e.g., as many soccer players as possible or almost all com-pany/CEO pairs from the business world.
Although these approaches have recently improved the quality of their results considerably, the quality is still signi cantly below that of a man-made knowledge base.
Typical results contain many false positives (e.g., IsA(Aachen Cathedral, City), to give one example from KnowItAll).
Furthermore, obtaining a recall above 90 percent for a closed domain typically entails a drastic loss of precision in return.
Thus, information-extraction approaches are only of little use for applications that need near-perfect ontologies (e.g.
for automated reasoning).
Furthermore, they typically do not have an explicit (logic-based) knowledge representation model.
widely employed ontologies are still man-made.
These include WordNet [10], Cyc or OpenCyc [17], SUMO [18], and especially domain-speci c ontologies and taxonomies such as SNOMED1 or the GeneOntology2.
These knowledge sources have the advantage of satisfying the highest quality expectations, because they are manually assembled.
However, they su er from low coverage, high cost for assembly and quality assurance, and fast aging.
No human-made ontology knows the most recent Windows version or the latest soccer stars.
This paper presents YAGO3, a new ontology that combines high coverage with high quality.
Its core is assembled from one of the most comprehensive lexicons available today, Wikipedia.
But rather than using information extraction methods to leverage the knowledge of Wikipedia, our approach utilizes the fact that Wikipedia has category pages.
Category pages are lists of articles that belong to a speci c category (e.g., Zidane is in the category of French football players4).
These lists give us candidates for entities (e.g.
Zidane), candidates for concepts (e.g.
IsA(Zidane, FootballPlayer)) [15] and candidates for relations (e.g.
isC-itizenOf(Zidane, France)).
In an ontology, concepts have to be arranged in a taxonomy to be of use.
The Wikipedia categories are indeed arranged in a hierarchy, but this hierarchy is barely useful for ontological purposes.
For example, Zidane is in the super-category named  Football in France , but Zidane is a football player and not a football.
WordNet, in contrast, provides a clean and carefully assembled hierarchy of thousands of concepts.
But the Wikipedia concepts have no obvious counterparts in WordNet.
In this paper we present new techniques that link the two sources with near-perfect accuracy.
To the best of our knowledge, our method is the  rst approach that accomplishes this uni cation between WordNet and facts derived from Wikipedia with an accuracy of 97%.
This allows the YAGO ontology to pro t, on one hand, from the vast amount of individuals known to Wikipedia, while exploiting, on the other hand, the clean taxonomy of concepts from WordNet.
Currently, YAGO contains roughly 1 million entities and 5 million facts about them.
YAGO is based on a data model of entities and binary relations.
But by means of rei cation (i.e., introducing iden-ti ers for relation instances) we can also express relations between relation instances (e.g., popularity rankings of pairs of soccer players and their teams) and general properties of relations (e.g., transitivity or acyclicity).
We show that, despite its expressiveness, the YAGO data model is decidable.
YAGO is designed to be extendable by other sources   be it by other high quality sources (such as gazetteers of geographic places and their relations), by domain-speci c extensions, or by data gathered through information extraction from Web pages.
We conduct an enrichment experiment with the state-of-the-art information extraction system Leila[25].
We observe that the more facts YAGO contains, the better it can be extended.
We hypothesize that this positive feedback loop could even accelerate future extensions.
The rest of this paper is organized as follows.
In Section
 1http://www.snomed.org 2http://www.geneontology.org/

 sources from which the current YAGO is assembled, namely, Wikipedia and WordNet.
In Section 4 we give an overview of the system behind YAGO.
We explain our extraction techniques and we show how YAGO can be extended by new data.
Section 5 presents an evaluation, a comparison to other ontologies, an enrichment experiment and sample facts from YAGO.
We conclude with a summary in Section 6.
To accommodate the ontological data we already extracted and to be prepared for future extensions, YAGO must be based on a thorough and expressive data model.
The model must be able to express entities, facts, relations between facts and properties of relations.
The state-of-the-art formalism in knowledge representation is currently the Web Ontology Language OWL [24].
Its most expressive variant, OWL-full, can express properties of relations, but is undecidable.
The weaker variants of OWL, OWL-lite and OWL-DL, cannot express relations between facts.
RDFS, the basis of OWL, can express relations between facts, but provides only very primitive semantics (e.g.
it does not know transitivity).
This is why we introduce a slight extension of RDFS, the YAGO model.
The YAGO model can express relations between facts and relations, while it is at the same time simple and decidable.
As in OWL and RDFS, all objects (e.g.
cities, people, even URLs) are represented as entities in the YAGO model.
Two entities can stand in a relation.
For example, to state that Albert Einstein won the Nobel Prize, we say that the entity Albert Einstein stands in the hasWonPrize relation with the entity Nobel Prize.
We write AlbertEinstein hasWonPrize NobelPrize Numbers, dates, strings and other literals are represented as entities as well.
This means that they can stand in relations to other entities.
For example, to state that Albert Einstein was born in 1879, we write: AlbertEinstein bornInYear 1879 Entities are abstract ontological objects, which are language-independent in the ideal case.
Language uses words to refer to these entities.
In the YAGO model, words are entities as well.
This makes it possible to express that a certain word refers to a certain entity, like in the following example:  Einstein  means AlbertEinstein This allows us to deal with synonymy and ambiguity.
The following line says that  Einstein  may also refer to the musicologist Alfred Einstein:  Einstein  means AlfredEinstein We use quotes to distinguish words from other entities.
Similar entities are grouped into classes.
For example, the class physicist comprises all physicists and the class word comprises all words.
Each entity is an instance of at least one class.
We express this by the type relation: AlbertEinstein type physicist Classes are also entities.
Thus, each class is itself an instance of a class, namely of the class class.
Classes are arranged lation: physicist subClassOf scientist In the YAGO model, relations are entities as well.
This makes it possible to represent properties of relations (like transitivity or subsumption) within the model.
The following line, e.g., states that the subClassOf relation is transitive by making it an instance of the class transitive-Relation: subclassOf type transitiveRelation The triple of an entity, a relation and an entity is called a fact.
The two entities are called the arguments of the fact.
Each fact is given a fact identi er.
As RDFS, the YAGO model considers fact identi ers to be entities as well.
This allows us to represent for example that a certain fact was found at a certain URL.
For example, suppose that the above fact (Albert Einstein, bornInYear, 1879) had the fact identi er #1, then the following line would say that this fact was found in Wikipedia: #1 foundIn http : //www.wikipedia.org/Einstein We will refer to entities that are neither facts nor relations as common entities.
Common entities that are not classes will be called individuals.
Then, a YAGO ontology over a  nite set of common entities C, a  nite set of relation names R and a  nite set of fact identi ers I is a function y : I   (I   C   R)   R   (I   C   R) A YAGO ontology y has to be injective and total to ensure that every fact identi er of I is mapped to exactly one fact.
Some facts require more than two arguments (for example the fact that Einstein won the Nobel Prize in 1921).
One common way to deal with this problem is to use nary relations (as for example in won-prize-in-year(Einstein, Nobel-Prize, 1921)).
In a relational database setting, where relations correspond to tables, this has the disadvantage that much space will be wasted if not all arguments of the nary facts are known.
Worse, if an argument (like e.g.
the place of an event) has not been foreseen in the design phase of the database, the argument cannot be represented.
Another way of dealing with an nary relation is to introduce a binary relation for each argument (e.g.
winner,prize, time).
Then, an nary fact can be represented by a new entity that is linked by these binary relations to all of its arguments (as is proposed for OWL): AlbertEinstein winner EinsteinWonNP1921 NobelPrize prize EinsteinWonNP1921
 However, this method cannot deal with additional arguments to relations that were designed to be binary.
The YAGO model o ers a simple solution to this problem: It is based on the assumption that for each nary relation, a primary pair of its arguments can be identi ed.
For example, for the above won-prize-in-year-relation, the pair of the person and the prize could be considered a primary pair.
The primary pair can be represented as a binary fact with a fact identi er: #1 : AlbertEinstein hasWonPrize NobelPrize All other arguments can be represented as relations that hold between the primary pair and the other argument: #2 : #1 time 1921
 This section will give a model-theoretic semantics to YAGO.
We  rst prescribe that the set of relation names R for any YAGO ontology must contain at least the relation names type, subClassOf, domain, range and subRelation-Of.
The set of common entities C must contain at least the classes entity, class, relation, acyclicTransitive-Relation and classes for all literals (as evident from the following list).
For the rest of the paper, we assume a given set of common entities C and a given set of relations R.
The set of fact identi ers used by a YAGO ontology y is implicitly given by I = domain(y).
To de ne the semantics of a YAGO ontology, we consider only the set of possible facts F = (I   C   R)   R   (I   C   R).
We de ne a rewrite system     P(F )   P(F ), i.e.   reduces one set of facts to another set of facts.
We use the shorthand notation {f1, ..., fn} ,  f to say that F   {f1, ..., fn}   F   {f1, ..., fn}   {f} for all F   F, i.e. if a set of facts contains the facts f1, ..., fn, then the rewrite rule adds f to this set.
Our rewrite system contains the following (axiomatic) rules:5   ,  (domain, domain, relation)   ,  (domain, range, class)   ,  (range, domain, relation)   ,  (range, range, class)   ,  (subClassOf, type, acyclicTransitiveRelation)   ,  (subClassOf, domain, class)   ,  (subClassOf, range, class)   ,  (type, range, class)   ,  (subRelationOf, type, acyclicTransitiveRelation)   ,  (subRelationOf, domain, relation)   ,  (subRelationOf, range, relation)   ,  (boolean, subClassOf, literal)   ,  (number, subClassOf, literal)   ,  (rationalNumber, subClassOf, number)   ,  (integer, subClassOf, rationalNumber)   ,  (timeInterval, subClassOf, literal)   ,  (dateTime, subClassOf, timeInterval)   ,  (date, subClassOf, timeInterval)   ,  (string, subClassOf, literal)   ,  (character, subClassOf, string)   ,  (word, subClassOf, string)   ,  (URL, subClassOf, string) it contains
 6= type, c for all
 r1


 Furthermore, the following rules r, r1, r2   R, x, y, c, c1, c2   I   C   R, type, r2 r acyclicTransitiveRelation: (1) {(r1, subRelationOf, r2), (x, r1, y)} ,  (x, r2, y) (2) {(r, type, acyclicTransitiveRelation), (x, r, y), (y, r, z)} (3) {(r, domain, c), (x, r, c)} ,  (x, type, c) (4) {(r, range, c), (x, r, y)} ,  (y, type, c) (5) {(x, type, c1), (c1, subClassOf, c2)} ,  (x, type, c2) ,  (x, r, z) Theorem 1: [Convergence of  ] Given a set of facts F   F , the largest set S with F   S is unique.
(The theorems are proven in the appendix.)
Given a YAGO ontology y, the rules of   can be applied to its set of facts,
 applying the rules of   the set of derivable facts of y, D(y).
Two YAGO ontologies y1, y2 are equivalent if the fact iden-ti ers in y2 can be renamed so that (y1   y2   y2   y1)   D(y1) = D(y2) The deductive closure of a YAGO ontology y is computed by adding the derivable facts to y.
Each derivable fact (x, r, y) needs a new fact identi er, which is just fx,r,y.
Using a relational notation for the function y, we can write this as y  := y   { (fr,x,y, (r, x, y)) | (x, r, y)   D(y) , (r, x, y) 6  range(y) } A structure for a YAGO ontology y is a triple of   a set U (the universe)   a function D : I   C   R   U (the denotation)   a function E : D(R)   U  U (the extension function) Like in RDFS, a YAGO structure needs to de ne the extensions of the relations by the extension function E. E maps the denotation of a relation symbol to a relation on universe elements.
We de ne the interpretation   with respect to a structure < U ,D,E > as the following relation:   := {(e1, r, e2) | (D(e1),D(e2))   E(D(r))} We say that a fact (e1, r, e2) is true in a structure, if it is contained in the interpretation.
A model of a YAGO ontology y is a structure such that 1. all facts of y  are true

 then there exists no x such that  (x, r, x) A YAGO ontology y is called consistent i  there exists a model for it.
Obviously, a YAGO ontology is consistent i 
   (x, r, x)   D(y) Since D(y) is  nite, the consistency of a YAGO ontology is decidable.
A base of a YAGO ontology y is any equivalent YAGO ontology b with b   y.
A canonical base of y is a base so that there exists no other base with less elements.
Theorem 2: [Uniqueness of the Canonical Base] The canonical base of a consistent YAGO ontology is unique.
In fact, the canonical base of a YAGO ontology can be computed by greedily removing derivable facts from the ontology.
This makes the canonical base a natural choice to e -ciently store a YAGO ontology.
The YAGO model is very similar to RDFS.
In RDFS, relations are called properties.
Just as YAGO, RDFS knows the properties domain, range, subClassOf and subPropertyOf (i.e. subRelationOf).
These properties have a semantics that is equivalent to that of the corresponding YAGO relations.
RDFS also knows fact identi ers, which can occur as arguments of other facts.
The following excerpt shows how some sample facts of Section 2.1 can be represented in RDFS.
Each fact of YAGO becomes a triple in RDFS.
<rdf:Description rdf:about="http://mpii.mpg.de/yago#Albert_Einstein"> <yago:bornInYear rdf:ID="f1">1879</yago:bornInYear> </rdf:Description> <rdf:Description rdf:about="http://mpii.mpg.de/yago#f1"> <yago:foundIn rdf:ID="f2" rdf:resource="http:..."/> </rdf:Description> However, RDFS does not have a builtin transitive relation or an acyclic transitive relation, as YAGO does.
This entails that the property acyclicTransitiveRelation can be de ned and used, but that RDFS would not know its semantics.
YAGO uses fact identi ers, but it does not have builtin relations to make logical assertions about facts (e.g.
it does not allow to say that a fact is false).
If one relies on the denotation to map a fact identi er to the corresponding fact element in the universe, one can consider fact identi- ers as simple individuals.
This abandons the syntactic link between a fact identi er and the fact.
In return, it opens up the possibility of mapping a YAGO ontology to an OWL ontology under certain conditions.
OWL has builtin counterparts for almost all builtin data types, classes, and relations of YAGO.
The only concept that does not have an exact builtin counterpart is the acyclicTransitiveRelation.
However, this is about to change.
OWL is currently being re ned to its successor, OWL 1.1.
The extended description logic SROIQ [12], which has been adopted as the logical basis of OWL 1.1, allows to express irre exivity and transitivity.
This allows to de ne acyclic transitivity.
We plan to investigate the relation of YAGO and OWL once OWL 1.1 has been fully established.
WordNet is a semantic lexicon for the English language developed at the Cognitive Science Laboratory of Princeton University.
WordNet distinguishes between words as literally appearing in texts and the actual senses of the words.
A set of words that share one sense is called a synset.
Thus, each synset identi es one sense (i.e., semantic concept).
Words with multiple meanings (ambiguous words) belong to multiple synsets.
As of the current version 2.1, WordNet contains 81,426 synsets for 117,097 unique nouns.
(Wordnet also includes other types of words like verbs and adjectives, but we consider only nouns in this paper.)
WordNet provides relations between synsets such as hypernymy/hyponymy (i.e., the relation between a sub-concept and a super-concept) and holonymy/meronymy (i.e., the relation between a part and the whole); for this paper, we focus on hypernyms/hyponyms.
Conceptually, the hypernymy relation in WordNet spans a directed acyclic graph (DAG) with a single source node called Entity.
Wikipedia is a multilingual, Web-based encyclopedia.
It is written collaboratively by volunteers and is available for free.
We downloaded the English version of Wikipedia in January
 Wikipedia article is a single Web page and usually describes a single topic.
The majority of Wikipedia pages have been manually assigned to one or multiple categories.
The page about Albert philosophers, Swiss physicists, and 34 more.
Conveniently, the categorization of Wikipedia pages and their link structure are available as SQL tables, so that they can be exploited without parsing the actual Wikipedia articles.
Our system is designed to extract a YAGO ontology from WordNet and Wikipedia.
Currently, the relations of YAGO are  xed.
Their properties (such as domain and range) are described in Table 2.
YAGO is designed to be extendable, i.e. new facts from new sources can be added to the ontology.
For this purpose, each fact is tagged with a con dence value between 0 and
 dence estimation (see Section 5.1.1), which lies between 0.90 and 0.98.
Facts extracted by other techniques (e.g.
based on statistical learning) can have smaller con dence values.
Since Wikipedia knows far more individuals than Word-Net, the individuals for YAGO are taken from Wikipedia.
Each Wikipedia page title is a candidate to become an individual in YAGO.
For example, the page title  Albert Einstein  is a candidate to become the individual AlbertEinstein in our ontology.
The page titles in Wikipedia are unique.
The Wikipedia Category System.
To establish for each individual its class, we exploit the category system of Wikipedia.
There are di erent types of categories: Some categories, the conceptual categories, indeed identify a class for the entity of the page (e.g.
Albert Einstein is in the category Naturalized citizens of the United States).
Other categories serve administrative purposes (e.g.
Albert Einstein is also in the category Articles with unsourced statements), others yield relational information (like 1879 births) and again others indicate merely thematic vicinity (like Physics).
Identifying Conceptual Categories.
Only the conceptual categories are candidates for serving as a class for the individual.
The administrative and relational categories are very few (less than a dozen) and can be excluded by hand.
To distinguish the conceptual categories from the thematic ones, we employ a shallow linguistic parsing of the category name (using the Noun Group Parser of [26]).
For example, a category name like Naturalized citizens of the United States is broken into a pre-modi er (Naturalized ), a head (citizens) and a post-modi er (of the United States).
Heuristically, we found that if the head of the category name is a plural word, the category is most likely a conceptual category.
We used the Pling-Stemmer from [26] to reliably identify and stem plural words.
This gives us a (possibly empty) set of conceptual categories for each Wikipedia page.
Conveniently, articles that do not describe individuals (like hub pages) do not have conceptual categories.
Thus, the conceptual categories yield not only the type relation, but also, as its domain, the set of individuals.
It also yields, as its range, a set of classes.
The Wikipedia categories are organized in a directed acyclic graph, which yields a hierarchy of categories.
This hierarchy, however, re ects merely the thematic structure of the Wikipedia pages (e.g., as mentioned in the introduction, Zidane is in the category Football in France).
Thus, the hierarchy is of little use from an ontological point of view.
Hence we take only the leaf categories of Wikipedia and ignore all other categories (such as Football in France).
Then we use WordNet to establish the hierarchy of classes, because WordNet o ers an ontologically well-de ned taxonomy of synsets.
Integrating WordNet Synsets.
Each synset of Word-Net becomes a class of YAGO.
Care is taken to exclude the proper nouns known to WordNet, which in fact would be individuals (Albert Einstein, e.g., is also known to WordNet, but excluded).
There are roughly 15,000 cases, in which an entity is contributed by both WordNet and Wikipedia (i.e.
a WordNet synset contains a common noun that is the name of a Wikipedia page).
In some of these cases, the Wikipedia page describes an individual that bears a common noun as its name (e.g.
 Time exposure  is a common noun for Word-Net, but an album title for Wikipedia).
In the overwhelming majority of the cases, however, the Wikipedia page is simply about the common noun (e.g.
the Wikipedia page  Physicist  is about physicists).
To be on the safe side, we always give preference to WordNet and discard the Wikipedia individual in case of a con ict.
This way, we lose information about individuals that bear a common noun as name, but it ensures that all common nouns are classes and no entity is duplicated.
Establishing subClassOf.
The subClassOf hierarchy of classes is taken from the hyponymy relation from Word-Net: A class is a subclass of another one, if the  rst synset is a hyponym of the second.
Now, the lower classes extracted from Wikipedia have to be connected to the higher classes extracted from WordNet.
For example, the Wikipedia class American people in Japan has to be made a subclass of the WordNet class person.
To this end, we use the following algorithm: head =headCompound(c) pre =preModi er(c) post =postModi er(c) head =stem(head) If there is a WordNet synset s for pre + head Function wiki2wordnet(c) Input: Wikipedia category name c Output: WordNet synset








 10 fail return s1 return s If there are WordNet synsets s1, ...sn for head (ordered by their frequency for head) We  rst determine the head compound, the pre-modi er and the post-modi er of the category name (lines 1-3).
For the Wikipedia category American people in Japan, these are  American ,  people  and  in Japan , respectively.
We stem the head compound of the category name (i.e. people) to its singular form (i.e. person) in line 4.
Then we check whether there is a WordNet synset for the concatenation of pre-modi er and head compound (i.e. American person).
If this is the case, the Wikipedia class becomes a subclass of the WordNet class (lines 5-6).
If this is not the case, we exploit that the Wikipedia category names are almost exclusively endocentric compound words (i.e. the category name is a hyponym of its head compound, e.g.
 American person  is a hyponym of  person ).
The head compound (person) has to be mapped to a corresponding WordNet synset word may refer to multiple synsets in WordNet.
We experimented with di erent disambiguation approaches.
Among others, we mapped the co-occurring categories of a given category to their possible synsets as well and determined the smallest subgraph of synsets that contained one synset for each category.
These approaches lead to non-satisfactory results.
Finally, we found that the following solution works best: WordNet stores with each word the frequencies with which it refers to the possible synsets.
We found out that mapping the head compound simply to the most frequent synset (s1) yields the correct synset in the overwhelming majority of cases.
This way, the Wikipedia class American people in Japan becomes a subclass of the WordNet class per-son/human.
Exceptions.
There were only a dozen prominent exceptions, which we corrected manually.
For example, all categories with the head compound capital in Wikipedia mean the  capital city , but the most frequent sense in WordNet is  nancial asset .
In summary, we obtain a complete hierarchy of classes, where the upper classes stem from WordNet and the leaves come from Wikipedia.
Exploiting WordNet Synsets.
Wikipedia and Word-Net also yield information on word meaning.
WordNet for example reveals the meaning of words by its synsets.
For example, the words  urban center  and  metropolis  both belong to the synset city.
We leverage this information in two ways.
First, we introduce a class for each synset known to WordNet (i.e. city).
Second, we establish a means relation between each word of synset and the corresponding class (i.e. ( metropolis , means, city)).
Exploiting Wikipedia Redirects.
Wikipedia contributes names for the individuals by its redirect system: a Wikipedia redirect is a virtual Wikipedia page, which links to a real Wikipedia page.
These links serve to redirect users to the correct Wikipedia article.
For example, if the user typed  Einstein, Albert  instead of  Albert Einstein , then there is a virtual redirect page for  Einstein, Albert  that links to  Albert Einstein .
We exploit the redirect pages to give us alternative names for the entities.
For each redirect, we introduce a corresponding means fact (e.g.
( Einstein, Albert , means, Albert Einstein)).
Parsing Person Names.
The YAGO hierarchy of classes allows us to identify individuals that are persons.
If the words used to refer to these individuals match the common pattern of a given name and a family name, we extract the name components and establish the relations givenNameOf and familyNameOf.
For example, we know that Albert Einstein is a person, so we introduce the facts ( Einstein , familyNameOf, Albert Einstein) and ( Albert , givenNameOf, Albert Einstein).
Both are sub-relations of means, so that the family name  Einstein , for example, also means Albert Einstein.
We used the Name Parser from [26] to identify and decompose the person names.
Exploiting Wikipedia Categories.
We exploit relational Wikipedia categories for the extraction of the following relations: bornInYear, diedInYear, establishedIn, locatedIn, writtenInYear, politicianOf, and has-WonPrize.
For the extraction of the bornInYear and diedInYear facts we make use of the categories ending with   births  and   deaths  respectively.
For example, if a page is in the category  1879 births , it means that the corresponding individual is a person born in 1879.
The establishedIn facts are extracted from categories ending with   establishments .
For example, if a page is in the category 1980 establishments, this means that the corresponding individual (mostly an organization) was established in 1980.
We normalize vague date expressions (like  5 th century BC  ) to a common form (e.g.
-500).
The locatedIn facts are extracted from categories that imply that all its members share a geographical location.
For example, if a page is in the category Cities in Germany, this indicates that the corresponding individual is located in Germany.
We make use of categories starting with Countries in..., Rivers of..., Attractions in... and similar ones.
Note that we do not need to extract the classes for the individuals, since this information has already been extracted within the scope of the type relation.
Further relations that we considered are the writ-tenInYear relation which holds between books and the year in which they appeared, the politicianOf relation which holds between politicians and states as well as the hasWonPrize relation which concerns prize winners and the prizes they won.
The facts for these three relations were extracted analogously to the afore mentioned facts.
Filtering the Results.
Not all facts extracted this way constitute valid facts in the YAGO ontology, because their arguments may not be known entities in YAGO.
For example, Eugene of Savoy is in the category  Governors of the Habsburg Netherlands , but we cannot admit the fact (Eugene of Savoy, politicianOf, Habsburg Netherlands), because Habsburg Netherlands is not a page in Wikipedia and hence not an entity in YAGO.
This is why a cleaning step is necessary, in which the system  lters out all facts with arguments that are not in the domain of the previously established type relation.
Despite the huge number of extracted facts, the actual extraction process took only a few hours.
This is because it is not necessary to access the Wikipedia pages themselves   let alone parse them or POS-tag them.
All information is derived from the category lists.
Descriptions.
Due to its generality, the YAGO ontology can store meta-relations uniformly together with usual relations.
For example, we store for each individual the URL of the corresponding Wikipedia page.
This will allow future applications to provide the user with detailed information on the entities.
We introduce the describes relation between the individual and its URL for this purpose.
Witnesses.
YAGO is prepared to be extended by new facts.
If a new fact was extracted from a particular Web page, we call this page the witness for the fact.
We introduce the foundIn relation, which holds between a fact and the URL of the witness page.
We use the extractedBy relation to identify the technique by which a fact was extracted.
The information about witnesses will enable applications to use, e.g., only facts extracted by a certain technique, facts extracted from a certain source or facts of a certain date.
Context.
Last, we store for each individual the individuals it is linked to in the corresponding Wikipedia page.
For example, Albert Einstein is linked to Relativity Theory.
For this purpose, we introduce the context relation between individuals.
This will allow applications to use re-simple co-occurrence table of words, the context relation connects entities instead of words, i.e.
its arguments are already disambiguated.
The YAGO model itself is independent of a particular data storage format.
To produce minimal overhead, we decided to use simple text  les as an internal format.
We maintain a folder for each relation and each folder contains  les that list the entity pairs.
We store only facts that cannot be derived by the rewrite rules of YAGO (see 2.2), so that we store in fact the unique canonical base of the ontology.
Furthermore, we provide conversion programs to convert the ontology to di erent output formats.
First, YAGO is available as a simple XML version of the text  les.
Furthermore, YAGO can be converted to a database table.
The table has the simple schema FACTS(factId, arg1, relation, arg2, confidence).
We provide software to load YAGO into an Oracle, Postgres or MySQL database.
For our experiments, we used the Oracle version of YAGO.
Last, we also provide an RDFS version of YAGO, as explained in Section 2.3.
YAGO is designed to be extendable by new facts.
An application that adds new facts to the YAGO ontology is required to obey the following protocol.
Suppose that the application wishes to add the fact (x, r, y).
First, it has to map x and y to existing entities in the YAGO ontology.
This task is essentially a word sense disambiguation problem, in which the  words  x and y have to be disambiguated to YAGO entities.
For the disambiguation, the application can make use of the extensive information that YAGO provides for the existing entities: the relations to other entities, the words used to refer to the entities, and the context of the entities, as provided by the context relation.
If x or y do not yet exist in the ontology, they have to be added as new entities.
Next, r has to be mapped to a relation in the YAGO ontology.
Currently, YAGO comprises only a  xed set of relations, which simpli es this task.
The application should provide a con dence value c   [0, 1] for the proposed fact (x, r, y).
If (x, r, y) exists already in the ontology, the application merely adds a new witness for this fact.
Supposing that the fact identi er of the existing fact is f and that the witness is w, the new fact would be (f, foundIn, w) with con dence c. Then, the con dence of the existing fact has to be recomputed as an aggregation of the con dences of the witnesses.
We propose to take the maximum, but other options can be considered.
If (x, r, y) does not yet exist in the ontology, the application has to add the fact together with a new fact identi er.
We propose to use name spaces as in OWL/RDFS: each application has a universally unique id and the fact identi er is composed of the application id and a running number.
Section 5.3 shows how the enrichment can be implemented in practice.
We were interested in the accuracy of YAGO.
To evaluate the accuracy of an ontology, its facts have to be compared to some ground truth.
Since there is no computer-processable ground truth of suitable extent, we had to rely on manual evaluation.
We presented randomly selected facts of the ontology to human judges and asked them to assess whether the facts were correct.
Since common sense often does not su ce to judge the correctness of YAGO facts, we also presented them a snippet of the corresponding Wikipedia page.
Thus, our evaluation compared YAGO against the ground truth of Wikipedia (i.e., it does not deal with the problem of Wikipedia containing false information).
Of course, it would be pointless to evaluate the portion of YAGO that stems from WordNet, because we can assume human accuracy here.
Likewise, it would be pointless to evaluate the non-heuristic relations in YAGO, such as describes, means, or context.
This is why we evaluated only those facts that constitute potentially weak points in the ontology.
To be sure that our  ndings are signi cant, we computed the Wilson interval for   = 5%.
Table 1: Accuracy of YAGO Relation # evalu- Accuracy subClassOf type familyNameOf givenNameOf establishedIn bornInYear diedInYear locatedIn politicianOf writtenInYear hasWonPrize ated facts





















 The evaluation shows very good results.
Especially the crucial type relation and the link between WordNet and Wikipedia, subClassOf, turned out to be very accurate.
But our heuristic algorithms cannot always achieve an accuracy of 100%.
This may also have to do with the inconsistency of the underlying sources.
For example, for the relation bornInYear, most false facts stem from erroneous Wikipedia categories (e.g.
some person born in 1802 is in the Wikipedia category 1805 births).
In addition, the evaluation of an ontology is sometimes a philosophical issue.
To start with, even simple relations su er from vagueness (e.g.
is Lake Victoria locatedIn Tanzania, if Tanzania borders the lake?
Is an economist who works in France a French Economist, even if he was born in Ireland?).
Next, it is not always clear whether an entity should be an individual or a class (e.g.
a judge might decide that physics is an individual, because it is an instance of science).
YAGO, however, in accordance with WordNet, sees abstract notions in general as classes, because they can have subclasses (e.g., physics can have the subclass astrophysics).
Furthermore, not everybody may agree on the de nition of synsets in WordNet (e.g., a palace is in the same synset as a castle in WordNet).
These cases of disputability are inherent even to human-made ontologies.
Thus, we can be extremely sat-is ed with our results.
Further note that these values measure just the potentially weakest point of YAGO, as all other facts were derived non-heuristically.
It is di cult to compare YAGO to other information extraction approaches, because the approaches usually di er in the choice of relations and in the choice of the sources.
YAGO is tailored to Wikipedia and WordNet, but it comes accuracy can usually be varied at the cost of recall.
Approaches that use pattern matching (e.g.
the Espresso System [20] or Leila [25]) typically achieve accuracy rates of
 the-art taxonomy induction as described in [23] achieves an accuracy of 84%.
KnowItAll [9] and KnowItNow [4] are reported to have accuracy rates of 85% and 80%, respectively.
Size Table 2 shows the number of facts for each relation in YAGO.
The overall number of ontological facts is about 5 million.
This number is completed by the respective witness facts and approximately 40 million context facts.
Table 2: Size of YAGO (facts) Relation Domain subClassOf class type entity context entity describes word bornInYear person diedInYear person establishedIn entity locatedIn object writtenInYear book politicianOf hasWonPrize means familyNameOf givenNameOf organization person word word word Range class class entity entity year year year region year person prize entity person person # Facts

  40,000,000










 Table 3 shows the number of entities in YAGO.
Table 3: Size of YAGO (entities)
 Relations
 Classes Individuals (without words)
 It is not easy to compare the size of YAGO to other on-tologies, because the ontologies usually di er in their structure, their relations and their domain.
For informational purposes, we list the number of entities and facts that are reported for some of the most important other domain-independent ontologies in Table 4.
Table 4: Size of other ontologies Ontology Facts
 KnowItNow [4]
 KnowItAll [9]


 WordNet [10] OpenCyc [17]

 Cyc [17] Entities





 With the exception of Cyc (which is not publicly available), the facts of these ontologies are in the hundreds of thousands, whereas the facts of YAGO are in the millions.
Table 5 shows some sample facts of YAGO.
In YAGO, the word  Paris , can refer to 71 distinct entities.
We list some interesting ones.
The football player Zinedine Zidane, e.g., is an instance of 24 di erent classes in our ontology.
We list some of them.
In the table, type+subclass means that the individual is an instance of a class that is a subclass of the given class.
Table 5: Sample facts of YAGO Zidane Zidane Zidane Zidane  Paris   Paris   Paris   Paris  Paris, France Paris, France Paris, France Paris, France football player Person from Marseille Legion d honneur recipient
 type+subclass type type bornInYear familyNameOf Priscilla Paris givenNameOf means means locatedIn type+subclass type establishedIn Paris Hilton Paris, France Paris, Texas France capital Eurovision host city -300 We also provide an interface to query YAGO in a SPARQL-like fashion [28] 6.
A query is a list of facts containing variables and regular expressions.
Preprocessing ensures that words in the query are considered in all their possible meanings.
The query algorithms are not in the scope of this paper.
Here, we only show some sample queries to illustrate the applicability of YAGO (Table 6).
Table 6: Sample queries on YAGO Query When was  Mostly Harmless  written?
(Mostly Harmless,writtenInYear,$y) Which humanists were born in 1879?
($h, type subClassOf*, humanist) ($h, bornInYear, 1879) Which locations in Texas and Illinois bear the same name?
($t, locatedIn, Texas) ($n, means, $t) ($n, means, $k) ($k, locatedIn, Illinois) Result $y=1992 $h=Albert Einstein and 2 more $n= Farmersville  and 121 more
 To demonstrate how an application can add new facts to the YAGO ontology, we conducted an experiment with the knowledge extraction system Leila [25].
Leila is a state-of-the-art system that uses pattern matching on natural language text.
It can extract facts of a certain given relation from Web documents.
We trained Leila for the headquar-teredIn relation (as described in [26]).
This relation holds between a company and the city of its headquarters.
We ran Leila on a corpus of 150 news documents to extract pairs of companies and headquarters.
Each extracted pair is a if Leila extracted the pair Microsoft candidate fact (e.g.
/ Redmond, then (Microsoft, headquarteredIn, Redmond) is a candidate fact).
Since the headquarteredIn relation is not part of YAGO, no candidate fact is already present in YAGO.
For each candidate fact, the company and the city have to be mapped to the respective individuals in YAGO.
To disambiguate the company name, we proceeded as follows: By the means relation, one can  nd out which individuals in YAGO the company name refers to.
If exactly one of these individuals is an instance of the class company, we map the company name to this individual.
If multiple individuals are instances of the class company, we cannot be
 didate fact, because we aim at a high accuracy at the cost of a potentially lower coverage (this did not happen in our experiment).
If no individual is a company, we introduce the company name as a new individual for YAGO.
To disambiguate the city name, we proceed similarly.
We identify a set of potential individuals by the means relation together with the constraint that the individual be a city.
If no individual is a city, we abandon the fact because we assume that Wikipedia knows all major cities.
If multiple individuals are a city, we use a simple disambiguation heuristic: We pick the city located in the state that is mentioned most frequently in the article.
If no such city exists, the fact is abandoned.
This way, both the company and the city get mapped to the respective YAGO individuals.
The con dence of the new fact is computed as a normalization of the con dence score returned by Leila.
Table 7 shows the number of company names and headquar- teredIn facts contributed by Leila.
Table 7: Leila headquarteredIn facts Abandoned candidates because of an unknown city because of an ambiguous city because of an ambiguous company Total Inserted candidates with a known company name with a new company name Total






 In the above merging process, entities that are already present in the ontology can help to disambiguate new entities.
Hence we assume that the more facts and entities YAGO contains, the better it can be extended by new facts.
The better YAGO can be extended, the more facts it will contain.
This mutual contribution could constitute a positive re-enforcement loop, which could help future expansion.
In this paper, we presented YAGO, a large and extendable ontology of high quality.
YAGO contains 1 million entities and 5 million facts   more than any other publicly available formal ontology.
As our evaluation shows, YAGO has a near-human accuracy around 95%.
Our data model de nes a clear semantics for YAGO.
It is decidable and it guarantees that the smallest ontology in a set of equivalent ontologies is unique, so that there is a canonical way to store a YAGO ontology.
We demonstrated how YAGO can be extended by facts extracted from Web documents through state-of-the-art extraction techniques.
We observed that the more facts YAGO contains, the easier it is to extend it by further facts.
We hypothesize that this positive feedback loop could facilitate the growth of the knowledge base in the future.
YAGO is available in di erent export formats, including plain text, XML, RDFS and SQL database formats at http://www.mpii.mpg.de/~suchanek/yago.
YAGO opens the door to numerous new challenges.
On the theoretical side, we plan to investigate the relationship between OWL 1.1 and the YAGO model, once OWL 1.1 has been fully developed.
This might necessitate extensions or additional semantic restrictions of the YAGO model.
On the practical side, we plan to enrich YAGO by further facts that go beyond the current somewhat arbitrary relations   including high con dence facts from gazetteers, but also extracted information from Web pages.
In particular, we envisage to analyze and exploit the positive feedback loop of data gathering.
We hope that the availability of a huge, clean, and high quality ontology can give new impulses to the Semantic Web vision.
Let F be a ( nite) set of fact triples, as de ned in Chapter
 reference on term rewriting).
All rules of the rewrite system are of the form F   F   {f}, where F   F and f   F .
Hence   is monotone.
Furthermore, F is  nite.
Hence   is  nitely terminating.
It is easy to see that if F   F  {f1} and F   F   {f2} for some F   F and f1, f2   F, then F   F   {f1}   F   {f1, f2} F   F   {f2}   F   {f1, f2} Hence   is locally con uent.
Since   is  nitely terminating,   is globally con uent and convergent.
Thus, given any set of facts F   F , the largest set DF with F   DF is unique and  nite.
A canonical base of a YAGO ontology y is any base b of y, such that there exists no other base b0 of y with |b0| < |b|.
This section will prove that, for a consistent YAGO ontology, there exists exactly one such base.
In the following,   denotes the rewrite system and F denotes the set of facts de ned in Chapter 2.2.
Lemma 1: [No circular rules] Let y be a consistent YAGO ontology, and {f1, ..., fn} a set of facts.
Then there are no sets of facts F1, ..., Fn, such that that F1, ..., Fn   D(y) and F1 ,  f1 F2 ,  f2 ...
Fn ,  fn with with with f2   F1 f3   F2 f1   Fn Proof: By analyzing all possible pairs of rule schemes (1)...(5), one  nds that the above rules must fall into one of the following categories:   All rules are instances of In this case, (c, subClassOf, c)   D(y) for some common entity c and hence y cannot be consistent.
(5).
  All rules are instances of In this case, (c, subRelationOf, c)   D(y) for some common entity c and hence y cannot be consistent.
(1).
  All rules are instances of In this case, (c, r, c)   D(y) for some common entity c and relation r and (r,type,acyclicTransitiveRelation)  D(y) and hence y cannot be consistent.
(2).
  n = 2, one rule is an instance of (1), and the other an instance of (2).
In this case, (c, r, c)   D(y) for some common entity c and relation r and (r,type,acyclic-TransitiveRelation)  D(y) and hence y cannot be consistent.
Let y be a consistent YAGO ontology and b a canonical base of y and let B = range(b).
Let f   D(y) be a fact such that D(y)\{f}   D(y).
Then f 6  B.
Proof: Since b is a base, there is a sequence of sets of facts B0, ..., Bn such that B = B0   B1   B2   .
.
.
  Bn 1   Bn = D(y) This sequence is a sequence of rule applications, where each rule has the form S ,  s, where S   F and s   F. We call S the premise of the rule and s its conclusion.
We say that a fact t contributes to a set of facts T in the sequence B0, ...Bn, if there is a sequence of rule applications r1, ...rm, so that t is in the premise of r1, the conclusion of r1 is in the premise of r2 etc.
and the conclusion of rm is in T .
Now assume f   B.
Since D(y)\{f}   D(y), there must be a rule G ,  f with G   D(y)\{f}.
Let i   [0, n] be the smallest index such that Bi   G. f cannot contribute to G, because then there would exist circular rules in the sense of the preceding lemma.
Hence f does not contribute to G. Then B\{f} is also a base, because the above rule applications can be reordered so that f is derived from Bi.
Hence b cannot be a canonical base.
Now we are ready to prove Theorem 2: Theorem 2: [Uniqueness of the Canonical Base] The canonical base of a consistent YAGO ontology is unique.
Proof: Let b be a canonical base of a consistent YAGO ontology y.
Let B = range(b).
We de ne the set C := D(y) \ {f | D(y)\{f}   D(y)} Intuitively speaking, C contains only those facts that cannot be derived from other facts in D(y).
By the previous lemma, B   C. Assume B   C, i.e. there exists a fact f   C, f 6  B.
Since C   D(y), f   D(y).
Since b is a base, there exists a rule S ,  f for some S   D(y).
Hence f 6  C, which is a contradiction.
Hence B = C and every canonical base equals b.
This theorem entails that the canonical base of a YAGO ontology can be computed by removing all facts that can be derived from other facts in the set of derivable facts.
