After the data and ontology layers of the Semantic Web stack have achieved a certain level of maturity in standard recommendations such as RDF and OWL, the query and the rules layers seem to be the next building-blocks to be  nalized.
For the  rst part, SPARQL [18], W3C s proposed query language, seems to be close to recommendation, though the Data Access working group is still struggling  An extended technical report of this article is available at http://www.polleres.net/publications/.
Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
with de ning aspects such as a formal semantics or layering on top of OWL and RDFS.
As for the second part, the RIF working group 1, who is responsible for the rules layer, is just producing  rst concrete results.
Besides aspects like business rules exchange or reactive rules, deductive rules languages on top of RDF and OWL are of special interest to the RIF group.
One such deductive rules language is Dat-alog, which has been successfully applied in areas such as deductive databases and thus might be viewed as a query language itself.
Let us brie y recap our starting points: Datalog and SQL.
Analogies between Datalog and relational query languages such as SQL are well-known and studied.
Both formalisms cover UCQ (unions of conjunctive queries), where Datalog adds recursion, particularly unrestricted recursion involving nonmonotonic negation (aka un-strati ed negation as failure).
Still, SQL is often viewed to be more powerful in several respects.
On the one hand, the lack of recursion has been partly solved in the standard s
 ternal function calls are missing in pure Datalog.
However, also developments on the Datalog side are evolving and with recent extensions of Datalog towards Answer Set Programming (ASP)   a logic programming paradigm extending and building on top of Datalog   lots of these issues have been solved, for instance by de ning a declarative semantics for aggregates [9], external predicates [8].
The Semantic Web rules layer.
Remarkably, logic programming dialects such as Datalog with nonmonotonic negation which are covered by Answer Set Programming are often viewed as a natural basis for the Semantic Web rules layer [7].
Current ASP systems o er extensions for retrieving RDF data and querying OWL knowledge bases from the Web [8].
Particular concerns in the Semantic Web community exist with respect to adding rules including non-monotonic negation [3] which involve a form of closed world reasoning on top of RDF and OWL which both adopt an open world assumption.
Recent proposals for solving this issue suggest a  safe  use of negation as failure over  nite contexts only for the Web, also called scoped negation [17].
The Semantic Web query layer   SPARQL.
Since we base our considerations in this paper on the assumption that similar correspondences as between SQL and Datalog can be established for SPARQL, we have to observe that SPARQL inherits a lot from SQL, but there also remain substantial di erences: On the one hand, SPARQL does not deal with nested queries or recursion, a detail which is indeed surpris-1http://www.w3.org/2005/rules/wg on RDF where, typical recursive queries such as transitive closure of a property might seem very useful.
Likewise, aggregation (such as count, average, etc.)
of object values in RDF triples which might appear useful have not yet been included in the current standard.
On the other hand, subtleties like blank nodes (aka bNodes), or optional graph patterns, which are similar but (as we will see) di erent to outer joins in SQL or relational algebra, are not straightforwardly translatable to Datalog.
The goal of this paper is to shed light on the actual relation between declarative rules languages such as Datalog and SPARQL, and by this also provide valuable input for the currently ongoing discussions on the Semantic Web rules layer, in particular its integration with SPARQL, taking the likely direction into account that LP style rules languages will play a signi cant role in this context.
Although the SPARQL speci cation does not seem 100% stable at the current point, just having taken a step back from candidate recommendation to working draft, we think that it is not too early for this exercise, as we will gain valuable insights and positive side e ects by our investigation.
More precisely, the contributions of the present work are:   We re ne and extend a recent proposal to formalize the semantics of SPARQL from P erez et al. [16], presenting three variants, namely c-joining, s-joining and b-joining semantics where the latter coincides with [16], and can thus be considered normative.
We further discuss how aspects such compositionality, or idempo-tency of joins are treated in these semantics.
  Based on the three semantic variants, we provide translations from a large fragment of SPARQL queries to Datalog, which give rise to implementations of SPARQL on top of existing engines.
  We provide some straightforward extensions of SPARQL such as a set di erence operator MINUS, and nesting of ASK queries in FILTER expressions.
  Finally, we discuss an extension towards recursion by allowing bNode-free-CONSTRUCT queries as part of the query dataset, which may be viewed as a lightweight, recursive rule language on top of of RDF.
The remainder of this paper is structured as follows: In Sec.
2 we  rst overview SPARQL, discuss some issues in the language (Sec.
2.1) and then de ne its formal semantics (Sec.
2.2).
After introducing a general form of Datalog with negation as failure under the answer set semantics in Sec.
3, we proceed with the translations of SPARQL to Datalog in Sec.
4.
We  nally discuss the above-mentioned language extensions in Sec.
5, before we conclude in Sec.
6.
In examples, we will subsequently refer to the two RDF graphs in Fig. 1 which give some information about Bob and Alice.
Such information is common in FOAF  les which are gaining popularity to describe personal data.
Similarities with existing examples in [18] are on purpose.
We assume the two RDF graphs given in TURTLE [2] notation and accessible via the IRIs ex.org/bob and alice.org2
 ing  http://  or other schema identi ers in IRIs.
We assume the pairwise disjoint, in nite sets I, B, L and V ar, which denote IRIs, Blank nodes, RDF literals, and variables respectively.
In this paper, an RDF Graph is then a  nite set, of triples from I   B   L   I   I   B   L,3 dereferenceable by an IRI.
A SPARQL query is a quadruple Q = (V, P, DS, SM ), where V is a result form, P is a graph pattern, DS is a dataset, and SM is a set of solution modi ers.
We refer to [18] for syntactical details and will explain these in the following as far as necessary.
In this paper, we will ignore solution modi ers mostly, thus we will usually write queries as triples Q = (V, P, DS), and will use the syntax for graph patterns introduced below.
Result Forms.
Since we will, to a large extent, restrict ourselves to SELECT queries, it is su cient for our purposes to describe result forms by sets variables.
Other result forms will be discussed in Sec.
5.
For instance, let Q = (V, P, DS) denote the query from Fig. 1, then V = {?X, ?Y }.
Query results in SPARQL are given by partial, i.e. possibly incomplete, substitutions of variables in V by RDF terms.
In traditional relational query languages, such incompleteness is usually expressed using null values.
Using such null values we will write solutions as tuples where the order of columns is determined by lexicographically ordering the variables in V .
Given a set of variables V , let V denote the tuple obtained from lexicographically ordering V .
The query from Fig. 1 with result form V = (?X, ?Y ) then has solution tuples ( Bob , : a), ( Alice , alice.org#me), : c).
We write substitutions in sqare brackets, so ( Bob , these tuples correspond to the substitutions [?X    Bob , ?Y   : a], [?X    Alice , ?Y   alice.org#me], and [?X    Bob , ?Y   : c], respectively.
Graph Patterns.
We follow the recursive de nition of graph patterns P from [16]:   a tuple (s, p, o) is a graph pattern where s, o   I   L   V ar and p   I   V ar.4   if P and P   are graph patterns then (P AND P  ), (P OPT P  ), (P UNION P  ), (P MINUS P  ) are graph patterns.5   if P is a graph pattern and i   I V ar, then (GRAPH i P ) is a graph pattern.
  if P is a graph pattern and R is a  lter expression then (P FILTER R) is a graph pattern.
For any pattern P , we denote by vars(P ) the set of all variables occurring in P .
As atomic  lter expression, SPARQL allows the unary predicates BOUND, isBLANK, isIRI, isLIT-ERAL, binary equality predicates  =  for literals, and other features such as comparison operators, data type conversion
 original RDF speci cation in that we allow literals in subject positions.
mantically equivalently replaced by variables in graph patterns [6].
SPARQL, but we use them here for reasons of readability and in order to keep with the operator style de nition of [16].
MINUS is syntactically not present at all, but we will suggest a syntax extension for this particular keyword in Sec.
5.
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix bob: <ex.org/bob#> .
<ex.org/bob> foaf:maker : a.
# Graph: alice.org @prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix alice: <alice.org#> .
: a a foaf:Person ; foaf:name "Bob"; alice:me a foaf:Person ; foaf:name "Alice" ; foaf:knows : b.
foaf:knows : c.
: b a foaf:Person ; foaf:nick "Alice".
: c a foaf:Person ; foaf:name "Bob" ; <alice.org/> foaf:maker : b foaf:nick "Bobby".
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
 FROM <alice.org> FROM <ex.org/bob> WHERE { ?Y foaf:name ?X .}
 Bob   Bob 
 : a : c  Alice  alice.org#me Figure 1: Two RDF graphs in TURTLE notation and a simple SPARQL query.
and string functions which we omit here, see [18, Sec.
11.3] for details.
Complex  lter expressions can be built using the connectives  , , .
Datasets.
The dataset DS = (G, {(g1, G1), .
.
.
(gk, Gk)}) of a SPARQL query is de ned by a default graph G plus a set of named graphs, i.e. pairs of IRIs and corresponding graphs.
Without loss of generality (there are other ways to de ne the dataset such as in a SPARQL protocol query), we assume G given as the merge of the graphs denoted by the IRIs given in a set of FROM and FROM NAMED clauses.
For instance, the query from Fig. 1 refers to the dataset which consists of the default graph obtained from merging alice.org   ex.org/bob plus an empty set of named graphs.
The relation between names and graphs in SPARQL is de ned solely in terms of that the IRI de nes a resource which is represented by the respective graph.
In this paper, we assume that the IRIs represent indeed network-accessible resources where the respective RDF-graphs can be retrieved from.
This view has also be taken e.g.
in [17].
Particularly, this treatment is not to be confused with so-called named graphs in the sense of [4].
We thus identify each IRI with the RDF graph available at this IRI and each set of IRIs with the graph merge [13] of the respective IRIs.
This allows us to identify the dataset by a pair of sets of IRIs DS = (G, Gn) with G = {d1, .
.
.
, dn} and Gn = {g1, .
.
.
, gk} denoting the (merged) default graph and the set of named graphs, respectively.
Hence, the following set of clauses FROM <ex.org/bob> FROM NAMED <alice.org> de nes the dataset DS = ({ex.org/bob}, {alice.org}).
In this section we will discuss some important issues about the current speci cation, and how we will deal with them here.
First, note that the default graph if speci ed by name in a FROM clause is not counted among the named graphs automatically [18, section 8, de nition 1].
An unbound variable in the GRAPH directive, means any of the named graphs in DS, but does NOT necessarily include the default graph.
Example 1.
This issue becomes obvious in the following query with dataset DS = ({ex.org/bob},  ) which has an empty solution set.
SELECT ?N WHERE {?G foaf:maker ?M .
GRAPH ?G { ?X foaf:name ?N } } We will sometimes  nd the following assumption convenient to avoid such arguably unintuitive e ects: De nition 1.
(Dataset closedness assumption) Given a dataset DS = (G, Gn), Gn implicitly contains (i) all graphs mentioned in G and (ii) all IRIs mentioned explicitly in the graphs corresponding to G.
Under this assumption, the previous query has both ( Alice ) and ( Bob ) in its solution set.
Some more remarks are in place concerning FILTER expressions.
According to the SPARQL speci cation  Graph pattern matching creates bindings of variables [where] it is possible to further restrict solutions by constraining the allowable bindings of variables to RDF Terms [with FILTER expressions].  However, it is not clearly speci ed how to deal with  lter constraints referring to variables which do not appear in simple graph patterns.
In this paper, for graph patterns of the form (P FILTER R) we tacitly assume safe  lter expressions, i.e. that all variables used in a  lter expression R also appear in the corresponding pattern P .
This corresponds with the notion of safety in Datalog (see Sec.3), where the builtin predicates (which obviously correspond to  lter predicates) do not su ce to safe unbound variables.
Moreover, the speci cation de nes errors to avoid mistyped comparisons, or evaluation of builtin functions over unbound values, i.e.  any potential solution that causes an error condition in a constraint will not form part of the  -nal results, but does not cause the query to fail.  These errors propagate over the whole FILTER expression, also over negation, as shown by the following example.
Example 2.
Assuming the dataset does not contain triples for the foaf : dummy property, the example query
 WHERE { {?X a foaf:Person .
OPTIONAL { ?X foaf:dummy ?Y . }
} FILTER (  (isLITERAL (?Y)) ) } would discard any solution for ?X, since the unbound value for ?Y causes an error in the isLITERAL expression and thus the whole FILTER expression returns an error.
the semantics of FILTER expressions later on.
The semantics of SPARQL is still not formally de ned in its current version.
This lack of formal semantics has been tackled by a recent proposal of P erez et al. [16].
We will base on this proposal, but suggest three variants thereof, namely (a) bravely joining, (b) cautiously-joining, and (c) strictly-joining semantics.
Particularly, our de nitions vary from [16] in the way we de ne joining unbound variables.
Moreover, we will re ne their notion of FILTER satisfaction in order to deal with error propagation properly.
We denote by Tnull the union I   B   L   {null}, where null is a dedicated constant denoting the unknown value not appearing in any of I, B, or L, how it is commonly introduced when de ning outer joins in relational algebra.
A substitution   from V ar to Tnull is a partial function   : V ar   Tnull.
We write substitutions in post x notation: For a triple pattern t = (s, p, o) we denote by t  the triple (s , p , o ) obtained by applying the substitution to all variables in t. The domain of  , dom( ), is the subset of V ar where   is de ned.
For a substitution   and a set of variables D   V ar we de ne the substitution  D with domain D as follows: x D =  x  if x   dom( )   D null if x   D \ dom( ) Let  1 and  2 be substitutions, then  1    2 is the substitution obtained as follows: x( 1 2) = 8< : x 1 if x 1 de ned and x 2 unde ned else: x 1 if x 1 de ned and x 2 = null else: x 2 if x 2 de ned else: unde ned Thus, in the union of two substitutions de ned values in one take precedence over null values the other substitution.
For instance, given the substitutions  1 = [?X    Alice , ?Y   : a, ?Z   null] and  2 = [?U    Bob , ?X    Alice , ?Y   null] we get:  1    2 = [?U    Bob , ?X    Alice , ?Y   : a, ?Z   null] Now, as opposed to [16], we de ne three notions of compatibility between substitutions:   Two substitutions  1 and  2 are bravely compatible (b-compatible) when for all x   dom( 1)   dom( 2) either x 1 = null or x 2 = null or x 1 = x 2 holds.
i.e., when  1    2 is a substitution over dom( 1)   dom( 2).
  Two substitutions  1 and  2 are cautiously compatible (c-compatible) when they are b-compatible and for all x   dom( 1)   dom( 2) it holds that x 1 = x 2.
  Two substitutions  1 and  2 are strictly compatible (s-compatible) when they are c-compatible and for all x   dom( 1)   dom( 2) it holds that x( 1    2) 6= null.
Analogously to [16] we de ne join, union, di erence, and outer join between two sets of substitutions  1 and  2 over domains D1 and D2, respectively, all except union parame-terized by x   {b,c,s}:  1  x  2 = { 1    2 |  1    1,  2    2, are x-compatible}  1    2 = {  |  1    1 with   =  D1 D2  2    2 with   =  D1 D2 or }

  1  x  2 = {     1 |  2    2,   and  2 not x-compatible}  1= x  2 = ( 1  x  2)   ( 1  x  2) The semantics of a graph pattern P over dataset DS = (G, Gn), can now be de ned recursively by the evaluation function returning sets of substitutions.
De nition 2.
(Evaluation, extends [16, Def.
2] ) Let t = (s, p, o) be a triple pattern, P, P1, P2 graph patterns, DS = (G, Gn) a dataset, and i   Gn, and v   V ar, then the x-joining evaluation [[ ]]x DS is de ned as follows: DS = {  | dom( ) = vars(P ) and t    G} [[t]]x [[P1 AND P2]]x
 [[P1 UNION P2]]x [[P1 MINUS P2]]x [[P1 OPT P2]]x
 [[GRAPH i P ]]x [[GRAPH v P ]]x [[P FILTER R]]x

 DS  x [[P2]]x DS   [[P2]]x DS  x [[P2]]x DS = x [[P2]]x (i, ) = [[P1]]x DS = [[P1]]x DS = [[P1]]x = [[P1]]x DS = [[P ]]x DS = { [v   g] | g   Gn,     [[P [v   g] ]]x DS = {    [[P ]]x DS | R  =  }

 (g, )} Let R be a FILTER expression, u, v   V ar, c   I   B   L.
The valuation of R on substitution  , written R  takes one of the three values { ,  ,  }6 and is de ned as follows.
R  =  , if: (1) R = BOUND(v) with v   dom( )   v  6= null; (2) R = isBLANK(v) with v   dom( )   v    B; (3) R = isIRI(v) with v   dom( )   v    I; (4) R = isLITERAL(v) with v   dom( )   v    L; (5) R = (v = c) with v   dom( )   v  = c; (6) R = (u = v) with u, v   dom( )   u  = v    u  6= null; (7) R = ( R1) with R1  =  ; (8) R = (R1   R2) with R1  =     R2  =  ; (9) R = (R1   R2) with R1  =     R2  =  .
R  =  , if: (1) R = isBLANK(v),R = isIRI(v),R = isLITERAL(v), or R = (v = c) with v 6  dom( )   v  = null; (2) R = (u = v) with u 6  dom( )   u  = null   v 6  dom( )   v  = null; (3) R = ( R1) and R1  =  ; (4) R = (R1   R2) and (R1  6=     R2  6=  )   (R1  =     R2  =  ); (5) R = (R1   R2) and R1  =     R2  =  .
R  =   otherwise.
We will now exemplify the three di erent semantics de ned above, namely bravely joining (b-joining), cautiously joining (c-joining), and strictly-joining (s-joining) semantics.
When taking a closer look to the AND and MINUS operators, one will realize that all three semantics take a slightly di ering view only when joining null.
Indeed, the AND operator behaves as the traditional natural join operator   in relational algebra, when no null values are involved.
Take for instance, DS = ({ex.org/bob, alice.org},  ) and P = ((?X, name, ?N ame) AND (?X, knows, ?F riend)).
When viewing each solution set as a relational table with variables denoting attribute names, we can write:
 : a alice.org#me : c ?Name  Bob   Alice   Bob 
 : a   alice.org#me ?Friend : b : c
 : a = ?Name  Bob  alice.org#me  Alice  ?Friend : b : c Di erences between the three semantics appear when joining over null-bound variables, as shown in the next example.
6  stands for  true ,   stands for  false  and   stands for errors, see [18, Sec.
11.3] and Example 2 for details.
ing query which might be considered a naive attempt to ask for pairs of persons ?X1, ?X2 who share the same name and nickname where both, name and nickname are optional: Example 5.
Let DS = ({ex.org/bob, alice.org},  ) and assume a slight variant of a query from [5] which asks for persons and some names for these persons, where preferably the foaf : name is taken, and, if not speci ed, foaf : nick.
P = ( ((?X1, a, Person) OPT (?X1, name, ?N )) AND P = ((((?X, a, Person) OPT (?X, name, ?XN AM E)) ((?X2, a, Person) OPT (?X2, nick, ?N )) ) OPT (?X, nick, ?XN AM E)) Again, we consider the tabular view of the resulting join:
 : a : b : c alice.org#me
  Bob  null  Bob   Alice 
 : a : b : c  x alice.org#me
 null  Alice   Bobby  null Now, let us see what happens when we evaluate the join  x with respect to the di erent semantics.
The following result table lists in the last column which tuples belong to the result of b, c and s-join, respectively.
: a : a : b : b : b : b : c : c = alice.org#me alice.org#me alice.org#me
  Bob   Bob  null  Alice   Bobby  null  Bob   Bob   Alice   Alice   Alice 
 : a alice.org#me : a : b : c alice.org#me : a alice.org#me : a : b alice.org#me b b b,c b b b,c b b b b,c,s b Leaving aside the question whether the query formulation was intuitively broken, we remark that only the s-join would have the expected result.
At the very least we might argue, that the liberal behavior of b-joins might be considered surprising in some cases.
The c-joining semantics acts a bit more cautious in between the two, treating null values as normal values, only uni able with other null values.
Compared to how joins over incomplete relations are treated in common relational database systems, the s-joining semantics might be considered the intuitive behavior.
Another interesting divergence (which would rather suggest to adopt the c-joining semantics) shows up when we consider a simple idempotent join.
Example 4.
Let us consider the following single triple dataset DS = ({(alice.org#me, a, Person)},  ) and the following simple query pattern: P = ((?X, a, Person) UNION (?Y, a, Person)) DS = {(alice.org#me, null), (null, alice.org#me)} Clearly, this pattern, has the solution set [[P ]]x under all three semantics.
Surprisingly, P   = (P AND P ) has di erent solution sets for the di erent semantics.
First, [[P  ]]c DS =  , since null values are not compatible under the s-joining semantics.
Finally, [[P  ]]b DS = {(alice.org#me, null), (null, alice.org#me), DS = [[P ]]x DS, but [[P  ]]s (alice.org#me, alice.org#me)} As shown by this example, under the reasonable assumption, that the join operator is idempotent, i.e., (P   P )   P , only the c-joining semantics behaves correctly.
However, the brave b-joining behavior is advocated by the current SPARQL document, and we might also think of examples where this obviously makes a lot of sense.
Especially, when considering no explicit joins, but the implicit joins within the OPT operator: Only [[P ]]b for the bNode : b.
DS contains the expected solution ( : b,  Alice ) All three semantics may be considered as variations of the original de nitions in [16], for which the authors proved complexity results and various desirable features, such as semantics-preserving normal form transformations and com-positionality.
The following proposition shows that all these results carry over to the normative b-joining semantics: Proposition 1.
Given a dataset DS and a pattern P which does not contain GRAPH patterns, the solutions of [[P ]]DS as in [16] and [[P ]]b DS are in 1-to-1 correspondence.
Proof.
Given DS and P each substitution   obtained DS can be reduced to a substitution   by evaluation [[P ]]b obtained from the evaluation [[P ]]DS in [16] by dropping all mappings of the form v   null from  .
Likewise, each substitution   obtained from [[P ]]DS can be extended to a substitution   =  vars(P ) for [[P ]]b
 Following the de nitions from the SPARQL speci cation and [16], the b-joining semantics is the only admissible definition.
There are still advantages for gradually de ning alternatives towards traditional treatment of joins involving nulls.
On the one hand, as we have seen in the examples above, the brave view on joining unbound variables might have partly surprising results, on the other hand, as we will see, the c and s-joining semantics allow for a more e cient implementation in terms of Datalog rules.
Let us now take a closer look on some properties of the three de ned semantics.
Compositionality and Equivalences.
As shown in [16], some implementations have a non-compositional semantics, leading to undesired e ects such as non-commutativity of the join operator, etc.
A semantics is called compositional if for each P   sub-pattern of P the result of evaluating P   can be used to evaluate P .
Obviously, all three the c, s and b-joining semantics de ned here retain this property, since all three semantics are de ned recursively, and independent of the evaluation order of the sub-patterns.
The following proposition summarizes equivalences which hold for all three semantics, showing some interesting additions to the results of P erez et al.
Proposition 2 (extends [16, Prop.
1]).
The following equivalences hold or do not hold in the di erent semantics as indicated after each law: (1) AND, UNION are associative and commutative.
(b,c,s)






 (6) AND is idempotent, i.e. (P AND P )   P .
(b) (b) (b) (b,c,s) (c) ven in [16], (1): for c-joining and s-joining follows straight from the de nitions.
(2)-(4): the substitution sets [[P1]]c,s = [[P2]]c,s = {[?X   a, ?Z   c]}, {[?X   a, ?Y   b]}, [[P3]]c,s = {[?Y   b, ?Z   c]} provide counterexamples for c-joining and s-joining semantics for all three equivalences (2)-(4).
(5): The semantics of FILTER expressions and UNION is exactly the same for all three semantics, thus, the result for the b-joining semantics carries over to all three semantics.
follows from the observations in Example 4.
(6): Ideally, we would like to identify a subclass of programs, where the three semantics coincide.
Obviously, this is the case for any query involving neither UNION nor OPT operators.
P erez et al. [16] de ne a bigger class of programs, including  well-behaving  optional patterns: De nition 3.
([16, Def.
4] ) A UNION-free graph pattern P is well-designed if for every occurrence of a sub-pattern P   = (P1 OPT P2) of P and for every variable v occurring in P , the following condition holds: if v occurs both in P2 and outside P   then it also occurs in P1.
As may be easily veri ed by the reader, neither Example 3 nor Example 5, which are both UNION-free, satisfy the well-designedness condition.
Since in the general case the equivalences for Prop.
2 do not hold, we also need to consider nested UNION patterns as a potential source for null bindings which might a ect join results.
We extend the notion of well-designedness, which direclty leads us to another correspondence in the subsequent proposition.
De nition 4.
A graph pattern P is well-designed if the condition from Def.
3 holds and for every occurrence of a sub-pattern P   = (P1 UNION P2) of P and for every variable v occurring in P  , the following condition holds: if v occurs outside P   then it occurs in both P1 and P2.
Proposition 3.
On well-designed graph patterns the c, s, and b-joining semantics coincide.
Proof Sketch..
Follows directly from the observation that all variables which are reused outside P   must be bound to a value unequal to null in P   due to well-designedness, and thus cannot generate null bindings which might carry over to joins.
Likewise, we can identify  dangerous  variables in graph patterns, which might cause semantic di erences: De nition 5.
Let P   a sub-pattern of P of either the form P   = (P1OPT P2) or P   = (P1UNION P2).
Any variable v in P   which violates the well-designedness-condition is called possibly-null-binding in P .
Note that, so far we have only de ned the semantics in terms of a pattern P and dataset DS, but not yet taken the result form V of query Q = (V, P, DS) into account.
We now de ne solution tuples that were informally introduced in Sec.
2.
Recall that by V we denote the tuple obtained from lexicographically ordering a set of variables in V .
The notion V [V     null] means that, after ordering V all variables from a subset V     V are replaced by null.
De nition 6.
(Solution Tuples) Let Q = (V, P, DS) be a SPARQL query, and   a substitution in [[P ]]x DS, then we call the tuple V [(V \ vars(P ))   null]  a solution tuple of Q with respect to the x-joining semantics.
Let us remark at this point, that as for the discussion of intuitivity of the di erent join semantics discussed in Examples 3 5, we did not yet consider combinations of di erent join semantics, e.g.
using b-joins for OPT and c-joins for AND patterns.
We leave this for further work.
In this paper we will use a very general form of Datalog commonly referred to as Answer Set Programming (ASP), i.e. function-free logic programming (LP) under the answer set semantics [1, 11].
ASP is widely proposed as a useful tool for various problem solving tasks in e.g.
Knowledge Representation and Deductive databases.
ASP extends Datalog with useful features such as negation as failure, disjunction in rule heads, aggregates [9], external predicates[8], etc.
7 Let P red, Const, V ar, exP r be sets of predicate, constant, variable symbols, and external predicate names, respectively.
Note that we assume all these sets except P red and Const (which may overlap), to be disjoint.
In accordance with common notation in LP and the notation for external predicates from [7] we will in the following assume that Const and P red comprise sets of numeric constants, string constants beginning with a lower case letter, or  "  quoted strings, and strings of the form hquoted-stringi^^hIRIi, hquoted-stringi@hvalid-lang-tagi, V ar is the set of string constants beginning with an upper case letter.
Given p   P red an atom is de ned as p(t1, .
.
.
, tn), where n is called the arity of p and t1, .
.
.
, tn   Const   V ar.
Moreover, we de ne a  xed set of external predicates exP r = {rdf , isBLAN K, isIRI, isLIT ERAL, =, != } All external predicates have a  xed semantics and  xed arities, distinguishing input and output terms.
The atoms isBLAN K[c](val), isIRI[c](val), isLIT ERAL[c](val) test the input term c   Const   V ar (in square brackets) for being valid string representations of Blank nodes, IRI References or RDF literals, returning an output value val   {t, f, e}, representing truth, falsity or an error, following the semantics de ned in [18, Sec.
11.3].
For the rdf predicate we write atoms as rdf [i](s, p, o) to denote that i   Const   V ar is an input term, whereas s, p, o   Const   V ar are output terms which may be bound by the external predicate.
The external atom rdf [i](s, p, o) is true if (s, p, o) is an RDF triple entailed by the RDF graph which is accessibly at IRI i.
For the moment, we consider simple RDF entailment [13] only.
Finally, we write comparison atoms  t1 = t2  and  t1 != t2  in in x notation with t1, t2   Const   V ar and the obvious semantics of (lexicographic or numeric) (in)equality.
Here, for = either t1 or t2 is an output term, but at least one is an input term, and for != both t1 and t2 are input terms.
De nition 7.
Finally, a rule is of the form h :- b1, .
.
.
, bm, not bm+1, .
.
.
not bn.
(1) where h and bi (1   i   n) are atoms, bk (1   k   m) are either atoms or external atoms, and not is the symbol for negation as failure.
We use H(r) to denote the head atom h and B(r) to denote the set of all body literals B+(r) B (r) of r, where B+(r) = {b1, .
.
.
, bm} and B (r) = {bm+1, .
.
.
, bn}.
ASP with so-called HEX-programs [8] here, since it is up to date the most general extension of Datalog.
described above denotes the binding pattern.
More precisely, we assume the following condition which extends the standard notion of safety (cf.
[21]) in Datalog with negation: Each variable appearing in a rule must appear in B+(r) in an atom or as an output term of an external atom.
De nition 8.
A (logic) program   is de ned as a set of safe rules r of the form (1).
The Herbrand base of a program  , denoted HB , is the set of all possible ground versions of atoms and external atoms occurring in   obtained by replacing variables with constants from Const, where we de ne for our purposes by Const the union of the set of all constants appearing in   as well as the literals, IRIs, and distinct constants for each blank node occurring in each RDF graph identi ed8 by one of the IRIs in the (recursively de ned) set I, where I is de ned by the recursive closure of all IRIs appearing in   and all RDF graphs identi ed by IRIs in I.9 As long as we assume that the Web is  nite the grounding of a rule r, ground (r), is de ned by replacing each variable with the possible elements of HB , and the grounding of program   is ground ( ) = Sr  ground (r).
An interpretation relative to   is any subset I   HB  containing only atoms.
We say that I is a model of atom a   HB , denoted I |= a, if a   I.
With every external predicate name lg   exP r with arity n we associate an (n + 1)-ary Boolean function flg (called oracle func-
tion) assigning each tuple (I, t1 .
.
.
, tn) either 0 or 1.
We say that I   HB  is a model of a ground external atom a = g[t1, .
.
.
, tm](tm+1, .
.
.
, tn), denoted I |= a, i  flg(I, t1, .
.
.
, tn) = 1.
The semantics we use here generalizes the answer-set semantics [11]11, and is de ned using the FLP-reduct [9], which is more elegant than the traditional GL-reduct [11] of stable model semantics and ensures minimality of answer sets also in presence of external atoms.
Let r be a ground rule.
We de ne (i) I|=B(r) i  I |= a for all a   B+(r) and I 6|= a for all a   B (r), and (ii) I |= r i  I |= H(r) whenever I |= B(r).
We say that I is a model of a program  , denoted I |=  , i  I |= r for all r   ground ( ).
The FLP-reduct [9] of   with respect to I   HB , denoted  I, is the set of all r   ground ( ) such that I |= B(r).
I is an answer set of   i  I is a minimal model of  I.
We did not consider further extensions common to many ASP dialects here, namely disjunctive rule heads, strong negation [11].
We note that for non-recursive programs, i.e.
where the predicate dependency graph is acyclic, the answer set is unique.
For the pure translation which we will give in Sec.
4 where we will produce such non-recursive programs from SPARQL queries, we could equally take other seman-
accessible resources which correspond to RDF graphs.
external predicates compute (sets of) outputs for a particular input, depending on the interpretation.
The dependence on the interpretation is necessary for instance for de ning the semantics of external predicates querying OWL [8] or computing aggregate functions.
HEX-programs, with the sole di erence that we restrict ourselves to a  xed set of external predicates.
tics such as the well-founded [10] semantics into account, which coincides with ASP on non-recursive programs.
We are now ready to de ne a translation from SPARQL to Datalog which can serve straightforwardly to implement SPARQL within existing rules engines.
We start with a translation for c-joining semantics, which we will extend thereafter towards s-joining and b-joining semantics.
Translation  c Q.
Let Q = (V, P, DS), where DS = (G, Gn) as de ned above.
We translate this query to a logic program  c Q de ned as follows.
 c Q ={triple(S, P, O, default) :- rdf[d](S, P, O).
| d   G}   {triple(S, P, O, g) :- rdf[g](S, P, O).
    (V, P, default, 1) | g   Gn} The  rst two rules serve to import the relevant RDF triples from the dataset into a 4-ary predicate triple.
Under the dataset closedness assumption (see Def.
1) we may replace the second rule set, which imports the named graphs, by: triple(S, P, O, G) :- rdf[G](S, P, O), HU (G), isIRI(G).
Here, the predicate HU stands for  Herbrand universe , where we use this name a bit sloppily, with the intention to cover all the relevant part of C, recursively importing all possible IRIs in order to emulate the dataset closedness assumption.
HU , can be computed recursively over the input triples, i.e.
HU (X) :- triple(X, P, O, D).
HU (X) :- triple(S, X, O, D).
HU (X) :- triple(S, P, X, D).
HU (X) :- triple(S, P, O, X).
The remaining program   (V, P, default, 1) represents the actual query translation, where   is de ned recursively as shown in Fig. 2.
By LT ( ) we mean the set of rules resulting from disassembling complex FILTER expressions (involving  , , ) according to the rewriting de ned by Lloyd and Topor [15] where we have to obey the semantics for errors, following De nition 2.
In a nutshell, the rewriting LT   rewrite( ) proceeds as follows: Complex  lters involving   are transformed into negation normal form.
Conjunctions of  lter expressions are simply disassembled to conjunctions of body literals, disjunctions are handled by splitting the respective rule for both alternatives in the standard way.
The resulting rules involve possibly negated atomic  lter expressions in the bodies.
Here, BOU N D(v) is translated to v = null,  BOU N D(v) to v!
= null.
isBLAN K(v), isIRI(v), isLIT ERAL(v) and their negated forms are replaced by their corresponding external atoms (see Sec.
3) isBLANK[v](t) or isBLANK[v](f), etc., respectively.
The resulting program  c Q implements the c-joining semantics in the following sense: Proposition 4 (Soundness and completeness of  c
 For each atom of the form answer1(~s, default) in the unique answer set M of  c Q, ~s is a solution tuple of Q with respect to the c-joining semantics, and all solution tuples of Q are represented by the extension of predicate answer1 in M .
Without giving a proof, we remark that the result follows if we convince ourselves that   (V, P, D, i) emulates exactly   (V, (P   AND P  ), D, i) =   (vars(P  ), P  , D, 2   i)     (vars(P  ), P  , D, 2   i + 1)   = answeri(V , D) :- triple(s, p, o, D).
  (V, (P   UNION P  ), D, i) =   (vars(P  ), P  , D, 2   i)     (vars(P  ), P  , D, 2   i + 1)   answeri(V , D) :- answer2 i(vars(P  ), D), answer2 i+1((vars(P  ), D).
answeri(V [(V \ vars(P  ))   null], D) :- answer2 i(vars(P  ), D).
answeri(V [(V \ vars(P  ))   null], D) :- answer2 i+1(vars(P  ), D).
  (V, (P   MINUS P  ), D, i) =   (vars(P  ), P  , D, 2   i)     (vars(P  ), P  , D, 2   i + 1)   answeri(V [(V \ vars(P  ))   null], D) :- answer2 i(vars(P  ), D), answer2 i  (vars(P  )   vars(P  ), D) :- answer2 i+1(vars(P  ), D). }
not answer2 i  (vars(P  )   vars(P  ), D).
  (V, (P   OPT P  ), D, i)   (V, (P FILTER R), D, i) =   (vars(P ), P, D, 2   i)   =   (V, (P   AND P  ), D, i)     (V, (P   MINUS P  ), D, i) LT (answeri(V , D) :- answer2 i(vars(P ), D), R.)   (V, (GRAPH g P ), D, i) =   (V, P, g, i) for g   V   I answeri(V , D) :- answeri(V , g), isIRI(g), not g = default.
Alternate rules replacing (5)+(6): answeri(V [(V \ vars(P  ))   null], D) :- answer2 i(vars(P  ), D), not answer2 i answer2 i :- answer2 i(vars(P  ), D), answer2 i+1(vars(P  ), D).
 (vars(P  ), D)  (vars(P  ), D) (1) (2) (3) (4) (5) (6) (7) (8) (5 ) (6 ) Figure 2: Translation  c Q from SPARQL queries semantics to Datalog.
the recursive de nition of [[P ]]x DS.
Moreover, together with Proposition 3, we obtain soundness and completeness of  Q for b-joining and s-joining semantics as well for well-designed query patterns.
Corollary 1.
For Q = (V, P, DS), if P is well-designed, then the extension of predicate answer1 in the unique answer set M of  c Q represents all and only the solution tuples for Q with respect to the x-joining semantics, for x   {b, c, s}.
Now, in order to obtain a proper translation for arbitrary patterns, we obviously need to focus our attention on the possibly-null-binding variables within the query pattern P .
Let vnull(P ) denote the possibly-null-binding variables in a (sub)pattern P .
We need to consider all rules in Fig. 2 which involve x-joins, i.e. the rules of the forms (2),(5) and (6).
Since rules (5) and (6) do not make this join explicit, we will replace them by the equivalent rules (5 ) and (6 ) for  s Q.
The  extensions  to s-joining and b-joining semantics can be achieved by rewriting the rules (2) and (6 ).
The idea is to rename variables and add proper FILTER expressions to these rules in order to realize the b-joining and s-joining behavior for the variables in VN = vnull(P )   vars(P  )   vars(P  ).
Q and  b Translation  s adding FILTER expressions Q.
The s-joining behavior can be achieved by Rs = ( ^v VN BOU N D(v) ) to the rule bodies of (2) and (6 ).
The resulting rules are again subject to the LT rewriting as discussed above for the rules of the form (7).
This is su cient to  lter out any joins involving null values, thus achieving s-joining semantics, and we denote the program rewritten that way as  s
 Q.
Obviously, b-joining semantics is more Translation  b tricky to achieve, since we now have to relax the allowed joins in order to allow null bindings to join with any other value.
We will again achieve this result by modifying rules (2) and (6 ) where we  rst do some variable renaming and then add respective FILTER expressions to these rules.
Step 1.
We rename each variable v   VN in the respective rule bodies to v  or v , respectively, in order to disambiguate the occurrences originally from sub-pattern P   or P  , respectively.
That is, for each rule (2) or (6 ), we rewrite the body to: answer2 i(vars(P  )[VN   V   answer2 i+1(vars(P  )[VN   V  

 Step 2.
We now add the following FILTER expressions (2) and Rb (6 ), respectively, to the resulting rule bodies Rb which  emulate  the relaxed b-compatibility: Rb (2) = Vv V N ( Rb (6 ) = Vv V N ( ((v = v )   (v  = v ))   ((v = v )    BOU N D(v ))   ((v = v )    BOU N D(v )) ) ((v = v )   (v  = v ))   ((v = v )    BOU N D(v ))   ((v = v )    BOU N D(v )) ) The rewritten rules are again subject to the LT rewriting.
Note that, strictly speaking the  lter expression introduced here does not ful ll the assumption of safe  lter expressions, since it creates new bindings for the variable v. However, these can safely be allowed here, since the translation only creates valid input/output term bindings for the external Datalog predicate  = .
The subtle di erence between Rb (2) and Rb (2) preferably  carries over  bound values from v  or v  to v whereas Rb (6 ) always takes the value of v .
The e ect of this becomes obvious in the translation of Example 5 which we leave as an exercise to (6 ) lies in the fact that Rb respect to |VN |) blowup of the program size by unfolding the  lter expressions into negation normal form during the LT rewriting12 is not surprising, given the negative complexity results in [16].
In total, we obtain a program which  b Q which re ects the normative b-joining semantics.
Consequently, we get sound and complete query translations for all three semantics: Corollary 2 (Soundness and completeness of  x Given an arbitrary graph pattern P , the extension of predicate answer1 in the unique answer set M of  x Q represents all and only the solution tuples for Q = (V, P, DS) with respect to the x-joining semantics, for x   {b, c, s}.
In the following, we will drop the superscript x in  Q implicitly refer to the normative b-joining translation/semantics.
As it turns out, the embedding of SPARQL in the rules world opens a wide range of possibilities for combinations.
In this section, we will  rst discuss some straightforward extensions of SPARQL which come practically for free with the translation to Datalog provided before.
We will then discuss the use of SPARQL itself as a simple RDF rules language13 which allows to combine RDF fact bases with implicitly speci ed further facts and discuss the semantics thereof brie y.
We conclude this section with revisiting the open issue of entailment regimes covering RDFS or OWL semantics in SPARQL.
Set Difference.
As mentioned before, set di erence is not present in the current SPARQL speci cation syntactically, though hidden, and would need to be emulated via a combination of OPTIONAL and FILTER constructs.
As we de ned the MINUS operator here in a completely modular fashion, it could be added straightforwardly without a ecting the semantics de nition.
Nested queries.
Nested queries are a distinct feature of SQL not present in SPARQL.
We suggest a simple, but useful form of nested queries to be added: Boolean queries QASK = ( , PASK, DSASK)) with an empty result form (denoted by the keyword ASK) can be safely allowed within FILTER expressions as an easy extension fully compatible with our translation.
Given query Q = (V, P, DS), with sub-pattern (P1 FILTER (ASKQASK)) we can modularly translate such subqueries by extending  Q with  Q  where Q  = (vars(P1)   vars(PASK), PASK, DSASK)).
Moreover, we have to rename predicate names answeri to answerQ  i in  Q  .
Some additional considerations are necessary in order to combine this within arbitrary complex  lter expressions, and we probably need to impose well-designedness for variables shared between P and PASK similar to Def.
4.
We leave more details as future work.
blowup by introducing new auxiliary predicates.
However, we cannot do the same trick, mainly for reasons of preserving safety of external predicates as de ned in Sec.
3.
We have covered only SELECT queries so far.
As shown in the previous section, we can consider ASK queries equally.
A limited form of the CONSTRUCT result form, which allows to construct new triples could be emulated in our approach as well.
Namely, we can allow queries of the form
 where PC is a graph pattern consisting only of bNode-free triple patterns.
We can model these by adding a rule triple(s, p, o, C) :- answer1(vars(PC), default).
(2) to  Q for each triple (s, p, o) in PC.
The result graph is then naturally represented in the answer set of the program extended that way in the extension of the predicate triple.
As it turns out with the extensions de ned in the previous subsections, SPARQL itself may be viewed as an expressive rules language on top of RDF.
CONSTRUCT statements have an obvious similarity with view de nitions in SQL, and thus may be seen as rules themselves.
Intuitively, in the translation of CONSTRUCT we  stored  the new triples in a new triple outside the dataset DS.
We can imagine a similar construction in order to de ne the semantics of queries over datasets mixing such CONSTRUCT statements with RDF data in the same turtle  le.
Let us assume such a mixed  le containing CONSTRUCT rules and RDF triples web-accessible at IRI g, and a query Q = (V, P, DS), with DS = (G, Gn).
The semantics of a query over a dataset containing g may then be de ned by recursively adding  QC to  Q for any CONSTRUCT query QC in g plus the rules (2) above with their head changed to triple(s, p, o, g).
We further need to add a rule triple(s, p, o, def ault) :- triple(s, p, o, g).
for each g   G, in order not to omit any of the implicit triples de ned by such  CONSTRUCT rules .
Analogously to the considerations for nested ASK queries, we need to rename the answeri predicates and def ault constants in every subprogram  QC de ned this way.
Naturally, the resulting programs possibly involve recursion, and, even worse, recursion over negation as failure.
Fortunately, the general answer set semantics, which we use, can cope with this.
For some important aspects on the semantics of such distributed rules and facts bases, we refer to [17], where we also outline an alternative semantics based on the well-founded semantics.
A more in-depth investigation of the complexity and other semantic features of such a combination is on our agenda.
The current SPARQL speci cation does not treat entailment regimes beyond RDF simple entailment.
Strictly speaking, even RDF entailment is already problematic as a basis for SPARQL query evaluation; a simple query pattern like P = (?X, rdf:type, rdf:Property) would have in nitely many solutions even on the empty (sic!)
dataset by matching the in nitely many axiomatic triples in the RDF(S) semantics.
Finite rule sets which approximate the RDF(S) semantics in terms of positive Datalog rules [17] have been im-fragments and extensions of OWL [12, 3, 14] de nable in terms of Datalog rule bases have been proposed in the literature.
Such rule bases can be parametrically combined with our translations, implementing what one might call RDFS  or OWL  entailment at least.
It remains to be seen whether the SPARQL working group will de ne such reduced entailment regimes.
More complex issues arise when combining a nonmono-tonic query language like SPARQL with ontologies in OWL.
An embedding of SPARQL into a nonmonotonic rules language might provide valuable insights here, since it opens up a whole body of work done on combinations of such languages with ontologies [7, 19].
In this paper, we presented three possible semantics for SPARQL based on [16] which di er mainly in their treatment of joins and their translations to Datalog rules.
We discussed intuitive behavior of these di erent joins in several examples.
As it turned out, the s-joining semantics which is close to traditional treatment of joins over incomplete relations and the c-joining semantics are nicely embeddable into Datalog.
The b-joining semantics which re ects the normative behavior as described by the current SPARQL speci cation is most di cult to translate.
We also suggested some extension of SPARQL, based on this translation.
Further, we hope to have contributed to clarifying the relationships between the Query, Rules and Ontology layers of the Semantic Web architecture with the present work.
A prototype of the presented translation has been implemented on top of the dlvhex system, a  exible framework for developing extensions for the declarative Logic Programming Engine DLV16.
The prototype is available as a plugin at http://con.fusion.at/dlvhex/.
The webpage also provides an online interface for evaluation, where the reader can check translation results for various example queries, which we had to omit here for space reasons.
We currently implemented the c-joining and b-joining semantics and we plan to gradually extend the prototype towards the features mentioned in Sec.
5, in order to query mixed RDF+SPARQL rule and fact bases.
Implementation of further extensions, such as the integration of aggregates typical for database query language, and recently de ned for recursive Datalog programs in a declarative way compatible with the answer set semantics [9], are on our agenda.
We are currently not aware of any other engine implementing the full semantics de ned in [16].
Special thanks go to Jos de Bruijn and Reto Krummen-acher for discussions on earlier versions of this document, to Bijan Parsia, Jorge P erez, and Andy Seaborne for valuable email-discussions, to Roman Schindlauer for his help on prototype implementation on top of dlvhex, and to the anonymous reviewers for various useful comments.
This work is partially supported by the Spanish MEC under the project TIC-2003-9001 and by the EC funded projects Trip-Com (FP6-027324) and KnowledgeWeb (IST 507482).
