Web service discovery and selection have been extensively studied in recent years.
As the set of available Web services may not be known a priori, may change frequently or service requester requirements and preferences may change, the problem of dynamic Web service selection is a fundamental one.
Considerable research and industry e ort has focussed on the (semantic) description of Web services, leading to standards such as WSDL [36], WSMO [9] and OWLS [8].
One of the key open challenges is performing dynamic service selection for highly con gurable Web services with dynamic user preferences.
Web services are typically highly con gurable, with signi cant service customisation possibilities and a choice of quality-of-service (QoS) properties, e.g.
delivery/re-sponse times, naturally each with its own price.
Customisation is critical for them to be able to di erentiate themselves from com-Copyright is held by the International World Wide Web Conference Com(cid:173) mittee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
ACM 978(cid:173)1(cid:173)59593(cid:173)654(cid:173)7/07/0005.
peting Web services and o er a better service experience to their customers.
Service requesters themselves have certain preferences on which service con gurations they want to use and their preferences may change dynamically.
Given their signi cance, there is a strong need to support customisable services.
However, we lack ef- cient methods for the representation and matching of con gurable services.
Current approaches to modelling Web service con gurations and requester preferences, such as WS-Agreement [11], enumerate the various possible service con gurations, which is ine cient when dealing with multiple service attributes and their values.
For example, a service described by  ve attributes, each with  ve possible values, already leads to 3125 di erent con gurations.
Given this combinatorial increase, a functional description of service attributes and their associated prices or preferences would be more appropriate.
In this paper, we model service con gurations and associated preferences compactly using utility function policies [17, 20], which provide a declarative mechanism for e ciently attaching price information to attribute values.
This allows us to draw from the vast literature on e cient multi-attribute decision theory methods to develop an algorithm for optimal service selection.
In addition, in order to be able to compare service attributes correctly, we need to describe them in a way that captures their semantics.
We use ontologies to describe services attributes and their values semantically, and extend the resulting semantic representation to include o ers and requests.
This allows us to de ne appropriate attribute value matching rules for each kind of attribute.
The contributions of this work are threefold.
First, we develop an OWL ontology for con gurable Web service o ers and requests that can represent (execution) context-dependent user preferences for functional and nonfunctional (e.g.
QoS) properties within a standards-based speci cation language, thus extending current semantic Web service description frameworks, such as OWLS and WSMO.
Second, we present an optimal service selection mechanism in the context of this framework and demonstrate its feasibility by analysing its performance.
For large numbers of highly con gurable o ers, given the assumption of additive functions, experimental results indicate that the algorithm introduces an overhead of only 2 sec.
compared to random selection, while giving optimal results.
This represents a 35% slowdown at 1000 o ers and 1600 con gurations per o er, which only decreases as the number of con g-urations rises.
Third, our framework enables  exible matching by specifying declarative logic-based matching rules rather than hard-coding the matching algorithm as is usual.
By providing a declarative mechanism that integrates optimization techniques, such as linear programming, we achieve computational tractability while obtaining a  exible system where di erent optimization and matching algorithms can be seamlessly plugged in.
In the following, we  rst discuss the requirements for a preference-Web service
 Publish Service Offer
 Lookup Service Repository
 Planning Service Annika
 Mobifhon Figure 1: Example for dynamic Web service binding.
based service selection framework informally through a scenario in Section 2 and discuss the state-of-the-art with respect to these requirements.
We then develop an abstract model that addresses the requirements for con gurable services, preferences over con gu-rations and service selection in Section 3.
To enable the exchange of o ers and requests in open heterogeneous environments, the abstract model is implemented in Section 4 using standard Web languages.
Based on this formalization, matching and optimization rules for service selection are presented and evaluated (Section 5).
In Section 6, we present a proof-of-concept implementation of our optimal service selection framework within the scenario developed in Section 2.
We conclude the paper with thoughts on the feasibility of optimal service selection within current Web scenarios and point to future work directions.
Consider Annika, a mobile phone user, who is currently in the city of Karlsruhe in Germany and wants to know the driving directions to Munich as soon as possible.
Annika s mobile network operator, Mobifhon, provides route planning services for several countries to its customers, dynamically outsourced from third party route planning services on the Web, as sketched in Figure 1.
Thus, the service selection takes place at Mobifhon s end.
The service selection is therefore not constrained by the limited resources and partial connectivity of Annika s mobile phone, while allowing Mob-ifhon to aggregate demands and thus procure better discounts for services than if each customer were to transact individually.
Mob-ifhon only sends the  nal route to Annika s mobile phone.
For the sake of illustration, in the we have chosen a relatively general scenario for identifying the requirements, but one could imagine several simpli cations, e.g.
where the service repository is located with Mobifhon.
(R1) Service Con gurations: The route planning services provide various kinds of routes (the fastest, the shortest etc.)
with or without highways, identifying di erent kinds of attractions on the way.
They also provide services at di erent levels of service quality.
A more complex route planning, for example, will cost more than a simple route and similarly a quick response will cost more than a slower one.
The various route planning services need to be able to describe their capabilities and con gurations to Mobifhon, such that it can choose the appropriate one at the desired QoS level.
Thus, our system must support the description of various service con gurations.
Since WSDL lacks any support for modelling QoS characteristics of Web services, there have been several proposals to extend WSDL with concrete QoS metrics, e.g.
the Web service Level Agreement (WSLA) project [14] and Web Service Modeling Language (WSML) [31].
By generalising beyond QoS attributes, XML query languages, like XQuery [39], and policy languages, like WS-Policy [38], enable the expression of constraints on arbitrary attributes.
However, these approaches lack appropriate support for attaching prices and also preferences which are addressed by requirement (R2).
(R2) Context-dependent Preferences: Many of Mobifhon s customers have di erent preferences about the services they use, based on their current context, location, activities, etc.
For example, An-nika typically prefers to travel on highways but she is currently on vacation and wants to travel through scenic country roads, possibly making several stops at attractions on the way.
Mobifhon chooses route planning services, taking into account the requirements and preferences of the user as well as its own preferences, e.g.
on service characteristics such as availability, response time, supported encryption methods etc.
Annika s preferences may also depend on her implicit context.
For example, if she has an upcoming appointment in Munich the next day, she is more likely to prefer a short route than a long scenic route.
In fact, her context-dependent preferences may be prede ned, allowing Mobifhon to choose her preferences based on her context dynamically.
To enable this, we need a way to describe requests and preferences for particular service con gurations declaratively in terms of their attributes.
Requirement (R1) and (R2) are addressed by languages such as WS-Agreement [11] and the Web Service O ering Language (WSOL) [34], which introduce classes of services that roughly correspond to what we call service con gurations and attach price and preference information to con gurations.
Both languages require the enumeration of the set of possible con gurations.
This is clearly ine cient for Web services whose attribute space is very large or even in nite (contradiction to (R4)).
For example, the charges for route plans levied by the route planning service may decrease linearly with the desired response time.
To cover such requirements, we use Utility Function Policies [17] to describe preferences and prices as a function of service attribute values, and we use declarative rules to model the context-sensitive nature of the preferences.
This is similar to the approach presented in [3], where personalized service selection is realized by expressing preferences declar-atively using SQL.
However, since there is no rule support, context-dependent preferences cannot be expressed.
In addition, matching algorithms required by (R3) are not supported there.
(R3) Semantic Web Service Descriptions: One of the advantages of using semantic description languages like OWLS and WSMO is that one can use logical reasoning, in particular class subsumption, to bridge di erent levels of abstraction that occur when specifying requests and o ers.
Thus, if Annika has speci ed that she wants to know about attractions on the route, Mobifhon can identify route planning services with information about historical sites as being relevant.
Annika may also not want to de ne preferences for all attributes.
She may not know which attributes are used by the services she is interested in and even if she did, it would be too tedious.
For example, she may want to say that she generally prefers historical sites to museums without specifying which particular types of each she prefers and by how much.
The service matching algorithm needs to match her general preference to the actual attractions information provided by individual services.
By modelling attributes as classes in a Semantic Web language, we can classify them into attribute hierarchies.
It would not be possible to rely on semantic reasoning alone for service discovery and selection, as others [18] have also argued, since this only results in a coarse ranking.
There have been previous e orts to augment OWLS and WSMO with QoS extensions [15, 33].
In addition, [21, 35] propose dynamic binding for Web service compositions using semantic service descriptions.
However, as with the Web service description languages, they cannot be used to describe complex functional relations.
Recent research [12, 26] has tried to express such relations declaratively, without however investigating how the performance of service selection is a ected by the modelling of preferences and (R4).
We use a decidable fragment of the rule language SWRL [13] to express complex functional relations declaratively, and discuss the e ects of modelling on the performance of selection.
(R4) Communication and Computational E ciency: A lesser requirement, yet nonetheless critical for resource-constrained environments such as mobile services, is that the chosen representation be designed for communication e ciency and computational tractability.
I.e., the request has to be expressed in an e cient way (e.g.
by avoiding enumeration of all possible con gurations) and the selection algorithm has to be e cient enough to enable run-time selection.
Policy languages are state-of-the-art for expressing Web service con gurations.
However, as already discussed, while alleviating the problem, they cannot solve it due to the exponential size of the attribute space.
We circumvent the problem using functional representations (as suggested in [10, 4]) by introducing Utility Function Policies.
There is a vast amount of work in economics, and particularly in operations research, addressing the computational ef- ciency of decision making algorithms.
In the context of service selection, this is investigated in [5], focusing on the complexity of service selection with one time costs and e.g.
in [40, 35] for service compositions.
Like these approaches, our work utilises e cient optimization techniques for service selection, but also augments them with the required service description and matching models.
Based on these requirements, in the next section we develop an abstract model for representing and selecting con gurable services.
Web service selection is the problem of selecting the best o er made by a service provider given a request.
In order to perform Web service selection, one requires (i) means for communicating service o ers as well as requests to the other party and (ii) an algorithm for ranking the o ers with respect to the request.
Bidding languages are a well-established means for communicating requests and o ers within economic literature.
Our abstract model essentially describes a Web service, Web service o ers and requests and the Web service selection problem.
We take a fairly abstract view of a Web service in our model and consider it to be fully described by properties A1 .
.
.
, Al, .
.
.
, An.
Such properties might comprise service input and output, behavioural aspects of a service, QoS attributes, etc., thus covering existing Web service description approaches as well as ful lling (R1).
Such a general description of a Web service allows us to abstract from various existing Web service description frameworks, while simultaneously allowing us to utilise existing decision-theoretic algorithms for multi-attribute products.
During the execution of a Web service, each attribute is assigned a value.
A set C of Web service con gurations comprises all possible combinations of attribute values, i.e. C = A1           An.
For example, considering the attributes Attractions, Highways and Response Time a concrete con guration would be a service providing routes including highways and information about nearby attractions within 10 seconds.
A speci c value of Al is denoted by ale.
A Web service contract ti j is de ned as a tuple (c,  ), where agent j provides a Web service with con guration c to a customer i at a price of     R. Furthermore, let T j denote the set of all contracts involving provider j, and Ti the set of contracts involving customer i.
Not all possible contracts are acceptable to an agent, and thus, only subsets T   i   Ti are requested or o ered, respectively.
j   T j and T  
 For our bidding language for highly con gurable Web services (R1), we draw from bidding languages for multi-attribute products [10, 4].
In this context, a common technique to e ciently encode pricing information (R4) is the use of functions that represent the relationship between Web service con gurations and their prices or utilities (as discussed in (R2)).
This avoids the combinatorial explosion that results from adding price markups to each con gu-ration.
(W  S  O ).
An o er by a provider j is de ned as a pair (C j, P j) of a set C j   C of con gurations and a function P j : C   R mapping each con guration c   C j to a real number that represents the price   of invoking service con guration c. As suggested by [4], the pricing function P j(c) is described by a base price pbase and an additive function that aggregates pricing functions for individual attributes: j P j(c) = pbase j + n Xl=1 w jl p jl(al) with n Xl=1 w jl = 1 (1) where p jl represents the pricing function of provider j for a particular attribute Al.
The weights w jl are used to adjust the in uence of the di erent attributes on the price.
Thus an o er assigns an additive pricing function to a Web service description, mapping the con gurations of the o er to a certain price.
Analogously, we introduce a functional form for representing Web service requests.
One major di erence though is that a requester s willingness to pay might depend on a runtime speci c context (R2).
Therefore, we introduce a set K =  1            n of execution contexts, where the  i represent di erent context dimensions, such as current location of a mobile device, time of service execution, history of past transactions.
Any k   K denotes a concrete execution context.
(W  S  R ).
A Web service request by requester i is de ned as a pair (Ci, Fi) of a set Ci   C of accept: Ci   K   R that maps able con gurations and a function Fi each con guration to a real number score depending on the execution context k. Due to payment monotonicity [10], i.e.   >   : (c,  )   T   i , we interpret Fi(c, k) as the maximal price for which a customer is willing to carry out the trade, i.e. T   i = {(c,  )   Ti|    Fi(c, k)}.
Fi is an additive scoring function composed of the attribute-speci c functions fil and their relative weights wil: i   (c,  )   T   Pn Fi(c, k) =     l=1 wil fil(ale, k) if c   Ci, otherwise.
with n Xl=1 wil = 1 (2) A con guration which is not requested is scored as minus in nity.
Due to the additive form of the scoring function Fi, we have to assume mutual preferential independency [16] between the attributes in the scoring function.
This holds if the utility of an attribute Al does not depend on the value of another attribute.
For example, the score for a certain guaranteed response time will not change if the type of indicated attractions changes.
Service selection in the case of con gurable services involves  nding the best provider and her best o er.
Therefore, we have to solve two maximization problems:  rst, the best contract for a given provider has to be identi ed, the so-called Multiattribute Matching Problem (MMP) [10].
Second, based on these results, the best provider can be chosen.
Service selection often requires trade-o s between the various attributes of con gurable services.
For example, it can be hard to decide between a slow route planning service that provides a lot of detailed information about en route attractions and a fast service that provides only imprecise route (e.g.
[16]) uses utility functions to make such decisions, mapping each alternative to a measure that can be used to rank the alternatives.
In our case, the utility of a service con guration is given by a quasi-linear function representing the di erence between the requester s preference score for the con guration and its price.
The MMP is thus de ned as follows:
 (MMP).
Given a request (Ci, Fi), an o er (C j, P j) and an execution context k, we solve the MMP by maximizing the requester s utility per service con guration.
The solution of the MMP for a given requester i and provider j is referred to as ui j in the following.
ui j = max c Ci  C j Fi(c, k)   P j(c) (3) Our assumptions of additive pricing and scoring functions allow us to simplify the MMP.
In particular, we can decompose the calculation into individual subproblems which can be solved independently.
The following equations (4-6) use this property to solve Equation 3 e ciently by reducing the number of iterations from O(|Ql Al|) to O(Pl |Al|).
The binary decision variable xle is associated with each attribute value and denotes whether the value is part of the best con guration.
Equation 5 ensures that exactly one attribute value is selected for each attribute.
Since the following integer programming formulation has a totally unimodular constraint matrix and only integers on the constraints  right-hand sides, the problem can be solved e ciently using the simplex algorithm [28].
max s.t.
n Xl=1 |Al | Xe=1 (wil fi(ale, k)   w jl p j(ale))xle   pbase j |Al | Xe=1 xle = 1 for 0 < l   n, xle   {0, 1} for 0 < l   n, 0 < e   |Al| (4) (5) (6) In a second step, we have to  nd the best provider from the set of all o ers.
Obviously this implies that the best contract for each provider is known, i.e. the MMP is solved for each pair of a request and an o er.
We can then determine the best provider by solving Local Allocation Problem (LAP).
(LAP).
Given a single request (Ci, Fi) and m offers (C j, P j), the Local Allocation Problem can be solved by iterating over all o ers and determining the maximal solution for MMP.
max j=1,...,m ui j (7) Solving LAP is linear with respect to the number of o ers and requires O(m) steps.
However, there are several scenarios where LAP is not su cient for service selection.
First, if we relax the requirement for quasi-linearity of the utility function, e.g.
by allowing one time costs, the problem will get considerably more complex.
It can be shown by reduction of the Uncapacitated Facility Location Problem that computing the optimal service in such scenarios is in FPNP [5].
Second, for the problem formulation in this section, we assume that o ered services are always available for all requesters and that possible resource limitations are handled at the provider side, e.g.
by adapting the guaranteed service levels or by increasing server capacity.
LAP also needs to be extended to handle scarce resources.
This is done, e.g.
in [32] using a double auction or in [7] by means of scheduling algorithms.
Third, LAP could be generalized for entire service compositions such as in [40].
The techniques presented later in this paper can also be applied to these new problems, requiring only the rewrite of a single rule to change the selection strategy.
Given the abstract selection model above, we now focus on implementing this model using existing standards and tools for the open and heterogenous Web environment.
We use the Web Ontology Language OWL [37] together with its rule extension SWRL [13] to implement our service selection framework, which allows us to perform sophisticated matchmaking and ranking of services by means of logical inferencing.
We build on well-known notions of matching for Semantic Web services, such as subsumption-based  plugin" or  exact" matches [27] and develop a  exible and extensible framework of declarative matching and optimization rules.
OWL is an ontology language standardized by the World Wide Web Consortium (W3C) [37] and is based on the description logic (DL) formalism [2].
Due to its close connection to DL it facilitates logical inferencing and allows to derive conclusions from an ontology that have not been stated explicitly.
We brie y review some of the modelling constructs of OWL using its abstract syntax.
The main elements of OWL are individuals, properties that relate individuals to each other and classes that group together individuals which share some common characteristics.
Classes as well as properties can be put into subsumption hierarchies.
Furthermore, OWL allows for describing classes in terms of complex class constructors that pose restrictions on the properties of a class.
For example, the statement Class(BigCity partial restriction(connectedTo someValuesFrom Highway)) describes the class of big cities, which are connected to some Highway.
The keyword partial means that any big city is connected to some highway, but not any city connected to a highway is also necessarily big, which would be achieved by using the keyword complete instead.
Subclass relationship can be expressed by a statement like SubClassOf(BigCity InterestingCity), saying that any big city is also interesting.
Individuals can be related to classes and assigned values by a statement like Individual(Munich type(BigCity) value(locatedIn Germany) value(population 1314551)).
Besides introducing Munich as a big German city, this statement also includes a data value for the city s population, which is supported by OWL for various datatypes such as integer or string.
An OWL ontology consists of statements like the ones above, considered logical axioms from which an agent can draw logical consequences.
For example, given an ontology O consisting of the above statements, it follows that Munich is an interesting city, which is denoted by O |= InterestingCity((Munich)).
For the declarative formulation of matching directives in form of rules, we require additional modelling primitives not provided by OWL.
We use the Semantic Web Rule Language (SWRL) [13] which allows us to combine rule approaches with OWL.
We restrict ourselves to a fragment of SWRL called DL-safe rules1 [24], which is more relevant for practical applications due to its tractability and support by inference engines such as KAON22.
For the notation of rules we rely on a standard  rst-order implication syntax.
In this section we present an ontology-based modelling approach for Web service o ers and requests which is in line with De ni-tion 1 and 2 of our abstract model.
For the reader s convenience we present the most parts of our ontological model informally via UML class diagrams, where UML classes correspond to OWL concepts, UML associations to object properties, UML inheritance to subconcept relations, UML attributes to OWL datatype properties and UML dependencies to OWL class instantiation [6].
explicitly mentioned in the ontology.
However, this restriction does not a ect the suitability of DL-safe rules in our selection scenario.
2http://kaon2.semanticweb.org/ can be split into two conceptual levels: the upper part a) captures the elements of the abstract model introduced in Section 3, while the lower part b) exemplarily captures certain available domain on-tologies that are plugged in for the matchmaking of attribute values.
Web Service Description Ontology.
Recalling de nitions 1 and 2, o ers and requests specify a set C of supported con gura-tions in our abstract model, which they map to prices and scores, respectively.
This is captured in the ontological model shown in Figure 2 a) by the classes in the two boxes for description of Web services and policies.
The classes O er and Request are introduced as subclasses of the more general Bid, by which they are connected to the policies used to de ne their pricing and scoring functions.
They represent the sets C j and Ci of con gurations for a provider or requester.
Instead of relating o ers and requests to con gurations directly, as done in the abstract model, we introduce the intermediary concept Service to capture technical service-speci c aspects.
O ers and requests are then related to a service which in turn supports various con gurations.
Referring to pairs of attributes Al and their values ale, the class Con guration represents the combinations of attribute values that a provider or customer support.
This upper part of our ontology can be seen as extensions of existing Web service description ontologies such as OWLS or WSMO by using these ontologies to de ne the type of Attributes.
For instance, by introducing the concepts Input, Output, Result, etc.
as specialisa-tion of Attribute our ontology can be aligned to the OWLS pro le.
To give an example, recall our mobile phone scenario, where our user Annika requests route planning from Karlsruhe to Munich in at most 30 seconds while she wants nearby castles to be indicated along the route.
For convenience, we illustrate the instantiation of elements for service description, such as Con guration, by an intuitive notation of pairs of attributes and their values, while we use OWL abstract syntax for details concerning the attribute values in domain ontologies.
Colon-separated namespace pre xes indicate the origin of an entity in a domain ontology.
An example of a supported con guration ci for a service that Mobifhon launches as a request based on the above parameters could look as follows.
ci = ( ServiceType = scl : RoutePlanningService StartPoint = geo : Karlsruhe EndPoint = geo : Munich Attractions = tourism : Castle ResponseTime = 30 sec ) On the other hand, an example for a con guration c j supported by an appropriate provider could look like this.
c j = ( ServiceType = ServiceSupportingNavigation StartPoint = geo : Germany EndPoint = geo : Germany Attractions = tourism : CulturalAttraction ResponseTime = 1 min ) equivalentClasses(ServiceSupportingNavigation intersectionOf( scl : Service restriction(scl : supports someValuesFrom(scl : Navigation)))) De nition 1 and 2 introduce a compact functional form for expressing pricing and scoring information.
This avoids introducing a separate class Price to model the tertiary relation between Price, Con guration and O er/Request explicitly.
Although such an approach would be most natural, it would result in a signi cant modelling overhead and does hardly scale up, as shown in our previous work [19].
For modelling functions we introduce the notion of Policies.
Generally policies are declarative rules that guide the decision making of an agent.
We use a speci c class of policies, called utility-function policies [17], which allow for representing trade-o s between di erent Web service attributes by mapping their values to a comparable quantitative measure.
Approaches on how such policies are expressed via an ontology are discussed in [20].
Namely there are three modelling techniques: Point Based Functions, Piecewise Linear Functions and Pattern-based Functions.
To illustrate the idea, the concept Point Based Function is introduced in more detail.
A Point Based Function can be used for discrete attributes and is modeled by specifying sets of Points that explicitly map attribute values ale referred to in an Attribute Value Pair to a price fil(ale) or p jl(ale).
To indicate the Attribute for which a certain Policy is applicable, the isAssignedTo-relation is introduced that points to one of the Attributes in the Web service description.
Coming back to our example, assume Annika generally prefers cultural attractions to sports events with the only exception that she hates museums.
We can model such a preference structure by instantiating a point-based policy function assigned to the attribute Attractions.
Mapping a utility of 1, 0.5 and 0 to the three alternatives results in the following speci cation of the function s component fil for this particular attribute.
ale fil(ale) CultureWithoutMuseum 1 tourism : SportsEvent
 tourism : Museum 0 equivalentClasses(CultureWithoutMuseum intersectionOf( tourism : CulturalAttraction complementOf(tourism.Museum))) The table maps alternative values for the attribute Attractions to the utility values that specify Annika s preferences.
Domain Ontologies for Attribute Values.
The attributes A1, .
.
.
, An in the abstract model represent generic characteristics of a service and can potentially originate from a given domain, depending on the kinds of services to be described.
In our framework, we support this by plugging in various domain ontologies   depicted in Figure 2 b)   that describe attribute values, such as a classi cation of service types or geographic or tourism knowledge for attributes like StartPoint or Attractions.
During the matchmaking process, this knowledge is, for example, used to detect that a service supporting navigation is equivalent to a route planning service, that Munich is in Germany, or that a castle is a historic site.
Assuming appropriate domain ontologies are available and agreed by providers and customers, they are linked to our ontology by their elements, such as the class InformationService or the individual Munich, being instances of the class AttributeValue.
The value for the attribute EndPoint would be a URI like http://geo.owl#Munich that points to a location in a geographic ontology3.
In our example, the notions of  route planning service" and  service that supports navigation" are captured in the service classi cation ontology Oscl that states them to be equivalent.
Ontology( Oscl Class(RoutePlanningService complete intersectionOf( Service restriction(supports someValuesFrom(Navigation)))) ...) Also the values  Karlsruhe",  Munich" and  Germany" are covered in a domain ontology, namely in the geographical ontology Ogeo, where the two cities are stated to be located in Germany.
Ontology( Ogeo Individual(Karlsruhe type(City) value(locatedIn Germany)) Individual(Munich type(City) value(locatedIn Germany)) ...) Moreover, the values  cultural attraction" and  castle" for the attribute Attractions are related by subsumption in the ontology Otourism that describes notions of leisure.
Ontology( Otourism subClassOf(HistoricSite CulturalAttraction) subClassOf(Castle HistoricSite) ...)
 elling, i.e. an URI can denote a class and an individual at the same time.
Although metamodelling is outside the DL formalism, KAON2 can handle such URIs to a certain extend [22].
Description of Web Service Offers/Requests Service contains Bid -WSDLreference:string(xsd) defines isValidIn Policies Context Dimension Description of Policies has Dimension supports provides Configuration requests Offer Request PointBasedFunction constitutedBy next Point -price:double(xsd) -score:double(xsd) -price:float(xsd) hasAttribute Attribute constitutedBy isAssignedTo PiecewiseLinearFunction refersTo AttributeValue AttributeValuePair hasValue attributeValue PatternBasedFunction -patternIdentifier - xsd:string -PatternParameter1 - xsd:Float -...
-patternParameterN - xsd.Float b) Service supports Activity Country locatedIn City Navigation MoneyTransfer ...
...
Attraction ...
CulturalAttraction SportsEvent ...
Germany Karlsruhe Munich ...
supports BankingService RoutePlanningService Service Classification locatedIn locatedIn Geographic Knowledge HistoricSite Museum ...
Castle Monument Tourism Knowledge Figure 2: Ontology for representing Web service o ers and requests

 Having shown how descriptions of con gurable Web services offers and requests are captured by an ontological model, we now describe how the actual selection of a service is carried out by solving LAP using logical inferencing on the ontological elements introduced above.
In order to derive a ranked list of the o er instances from the knowledge base, we formulate a query that refers to a Request instance r containing preferences and to an instance k representing the current Context.
In addition, to reduce the number of o ers that have to be ranked we can add mandatory conditions directly to the query using the SPARQL FILTER element.
This is exempli ed in Query 8, where only services that provide a guaranteed response time of less than 20 sec.
are retrieved.
PREFIX ex: < http://example.org/ns# >
 ?O ex:provides ?S .
?S ex:supports ?C .
?C ex:refersTo ?A .
?A ex:hasAttribute ex:ResponseTime ; ex:hasValue ?V .
FILTER (?V < 20) .
EVALUATE mmp(r, ?O, c, ?U) .}
(8) Conceptually answering such a query can be broken down into two highly connected parts: (i) determining matches between offers and requests by comparing the respective service attributes, and (ii) ranking the various con gurations provided in the o er according to the preferences in the request.
In the following, we  rst discuss how matching of attribute values is realized and show how these matching rules are applied to de ne variants of optimization predicate mmp used in Query 8.
Subsequently, we evaluate these algorithms in terms of performance and discuss their applicability for service selection.
The comparison between a requested attribute value and an offered attribute value is fundamental.
In the context of matchmaking in the Semantic Web, various techniques have been proposed for comparing the characteristics of two semantically annotated services.
The most widely used approach for descriptions based on OWL classes is to use DL inferencing, distinguishing between several notions of match based on subsumption or concept satis ability.
For two OWL classes CR and CO that represent attribute values of a request or an o er, the degrees of match proposed in [27] are: exact if CR and CO are equivalent, plugin if CR is a subclass of CO, subsumes if CO is a subclass of CR, intersect if the conjunction of CR and CO is satis able, and fail if the conjunction of CR and CO is unsatis able.
We support these notions of match in our framework, and also allow for others by including customisable matching predicates into the service selection algorithm.
In fact, since we use a declarative formalism to describe how attribute values are matched, a user can bring in arbitrarily complex matchmaking behaviour expressed in rules which facilitates the adaption of the selection component to changing service descriptions (e.g.
with new attributes).
Contrarily, other approaches use hard-coded algorithms to process the results of attribute matching that are speci c to e.g.
input/output matching, as done in [27].
Since we keep attributes in Web service con g-urations rather generic, the way in which two attribute values are compared strongly depends on the domain of interest they originate from and on the way in which they are represented in there.
In our example, the values of the attributes ServiceType and Indi-catedAttractions are concepts in an ontology, and thus, the formerly described degrees of match apply to them and can be used for their comparison.
The following rule de nition speci es the matching predicate for service types, requiring them to yield an exact match.
match(?P1, ?P2)   hasAttribute(?P1, ServiceType), hasValue(?P1, ?V1), hasAttribute(?P2, ServiceType), hasValue(?P2, ?V2), exact(?V1, ?V2) (9) In our example, the scl : RoutePlanningService indeed yields an exact match with the provided ServiceSupportingNavigation, since Oscl entails their equivalence.
The attribute ServiceType itself is an instance of the class Attribute in the model shown in Figure 2.
Analogously, values of the attribute Attractions could be matched using the predicate plugin(x, y) instead of exact(x, y), and again the provided attribute value would match the requested one, since Otourism |= subClassOf(Castle CulturalAttraction).
example represent individual locations in a geographic ontology and require a di erent treatment.
Here the modeller speci es the customised matching behavior for location attributes by introducing a class Location as a subclass of Attribute, of which StartPoint and EndPoint are instances.
The appropriate matching behaviour is then captured by the following rule.
match(?P1, ?P2)   hasAttribute(?P1, ?A1), hasValue(?P1, ?V1), hasAttribute(?P2, ?A2), hasValue(?P2, ?V2), Location(?A1), Location(?A2), matchLocation(?V1 , ?V2) matchLocation(x, y) = (true f alse Ogeo |= locatedIn(x, y) otherwise (10) (11) The predicate matchLocation is realized as a builtin using a separate call to a description logic reasoner, just as in exact(x, y) or plugin(x, y) before.
In the example, the o ered value would again match the request, since Karlsruhe and Munich are both located in Germany according to Ogeo.
Finally, there are attributes which do require a complex matching in terms of logical reasoning, but where a simple and e cient string comparison or arithmetic calculations are su cient.
In this case, the modeler of a matching rule can include prede ned builtin predicates de ned in SWRL.
From our example, the QoS attribute ResponseTime falls into this category, and is processed according to the following rule speci cation.
match(?P1, ?P2)   hasAttribute(?P1, ?A1), hasValue(?P1, ?V1), hasAttribute(?P2, ?A2), hasValue(?P2, ?V2), QoS Attribut(?A1 ), QoS Attribut(?A2 ), equals(?V1, ?V2) (12) Also here a subclass of Attribute, namely QoSAttribute, is introduced to enable the speci cation of the matching behavior for all QoS attributes, such as ResponseTime, by a single rule.
Based on de nitions above, we can de ne a shortcut for matching two arbitrary con gurations as follows: compare(?C1 , ?C2)   ^l=1,...,n attrCompare(Al , ?C1 , ?C2) (13) attrCompare(?A, ?C1 , ?C2)   re f ersT o(?C1, ?P1), re f ersT o(?C2, ?P2), hasAttribute(?P1, ?A), hasAttribute(?P2, ?A), match(?P1, ?P2) (14)
 In the following, we show how the matching predicates introduced in the previous section can be used within the optimization rule mmp in order to determine the utility measure for the individual attribute values.
We de ne three alternative variants of the mmp-predicate, which considerably di er in their underlying assumptions, applicability and performance characteristics.
While the  st variant [V1] implements the ranking based on enumerating the con gurations (Equation 3), [V2] solves MMP on per attribute basis using Equation 4-6.
[V3] goes a step beyond [V2] by utilizing the linear program formulation.
[V1] This variant implements Equation 3, where a ranking of all o ers and con gurations is derived by evaluating all possible con gurations for each o er according to a request.
We can model the problem purely based on DL-safe rules using some standard SWRL builtin functions.
Rule 15 calculates the di erence between score and price of each Con guration that is supported by an O er as well as asked for in the Request.
The compare-predicate de ned in Rule 14 is used to match two con gurations.
mmp(?R, ?O, ?K, ?U)   provides(?O, ?S 1), supports(?S 1, ?C1), requests(?R, ?S 2), provides(?S 2, ?C2), compare(?C1, ?C2), price(?O, ?C1, ?P), score(?R, ?C2, ?K, ?S ), sub(?S , ?P, ?U) (15) Algorithm 1 Determine optimal attribute value for two policies function  F (Policy f1, Policy f2)
 f1 constitutedBy ?P1 .
f2 constitutedBy ?P2 .
?P1 attributeValue ?V1 ; price ?X .
?P2 attributeValue ?V2 ; price ?Y .
?V1 match ?V2 .
EVALUATE ?U := dif(?X,?Y) .
return  rst element of result set all ale provided in a con guration c. Attribute values are matched by means of the matching predicate de ned in the previous section.
The price-relation is de ned analogously, but without the context-dependency represented by the relation isValidIn.
score(?R, ?C, ?K, ?U)   ^l=1,...,n (re f ersT o(?C, ?AV Pl), hasAttribute(?AV Pl, ?Al), de f ines(?R, ?Fl ), isAssignedT o(?Fl, Al), isValidIn(?Fl , ?K), constitutedBy(?Fl, ?Pl), price(?Pl, Vl), attributeValue(?Pl, ?AVl), match(?AV Pl, ?AVl)), sum(?V1, .
.
.
, ?Vn, ?U) (16) Advantages of this approach are that one can get a full ranking of all con gurations, which might be required in some applications.
Furthermore, it can be modelled purely based on standard modelling primitives provided by OWL-DL and SWRL.
However, the disadvantages are also evident.
Since the approach is based on enumerating all con gurations, a  nite number of con gurations is required and thus the approach is not suitable in the presence of continuous attributes.
As already discussed in Section 3, another fundamental problem is the complexity with respect to the number of required utility calculations.
[V2] The second variant of the mmp-predicate implements the decomposed optimization algorithm described in Equation (4-6).
In this context we utilize the additive structure of the pricing as well as scoring functions: the optimal value for each attribute is determined separately and the overall price/score is calculated based on these measures.
Equation 17 determines the utility of an o er according to request in a speci c execution context.
mmp(?R, ?O, ?K, ?U)   Request(?R), O er(?O) ^l=1,...,n (de nes(?R, ?Fl ), isValidIn(?Fl , ?K), isAssignedTo(?Fl , ?Al), de nes(?O, ?Pl), isAssignedTo(?Pl, ?Al), optFkt(?Fl , ?Pl, ?Ul )), sum(?U1 , .
.
.
, ?Un , ?U) (17) Since the calculation of the optimal value for a certain attribute requires iterating over an unknown number of attribute values (instances), the calculation cannot be directly expressed in SWRL.
We thus use a builtin function, called optFkt, to determine the attribute value ale maximizing the utility fil   g jl of attribute l. Algorithm 1 shows the implementation of the builtin-predicate speci cally for Point-based Functions.
In the predicate optFkt for each attribute the requester and provider policies are queried from the knowledge base and the attribute value leading to the maximal utility is determined.
A major advantage of the approach is that this query uses the match-predicate de ned in the ontology.
Thus, the correct matching algorithm is used for each attribute automatically and the implementation of the builtin is domain independent.
[V3] The third variant of the algorithm implements also the decomposed ranking algorithm described in Equation (4-6), but with some additional optimizations.
mmp(?R, ?O?, ?C, ?U)   Request(?R), O er(?O), optLP(?R, ?O, ?C, ?U) (18) Since pricing and scoring information are not explicitly given, the two predicates price and score are used to calculate this information based on the Policies de ned in the o er or request, respectively.
Rule 16 calculates the score Fi(c, k) by evaluating fil(ale) for This time we use a linear programm to calculate the optimal attribute value.
The calculation is encapsulated within the builtin optLP (Algorithm 2).
The builtin performs a query to get the relevant utilities for the attribute values.
This is done again by utilising function  LP(Request r, O er o, Context k) resultList := SELECT ?A, ?W, ?U WHERE { o de nes ?F1 .
r de nes ?F2 .
?F1 constitutedBy ?P1 ; isAssignedTo ?A .
?F2 constitutedBy ?P2 ; isValidIn k; isAssignedTo ?A .
?P1 attributeValue ?V1 ; price ?X .
?P2 attributeValue ?V2 ; price ?Y .
?V1 match ?V2 .
EVALUATE ?U := dif(?X,?Y) .}
U n maxl |Al | = ule with (l, e, ule)   resultList determine u by solving max{U T x| l : Pe xle = 1, x   {0, 1}} return u for given O er o and Request r the match-predicate from the ontology.
The optimization problem is constructed and solved using a standard optimization library.4 This approach has the advantage that we can use the e cient implementations for solving integer linear programs provided by standard tools.
In contrast to the  rst optimization algorithm, variant [V2] and [V3] can be easily adapted to handle continuous attributes by introducing appropriate builtins for optFkt and optLP.
However, it is not possible to get a ranked list enumerating all o ers and con gu-rations, as it is possible using the  rst approach.
Nevertheless, for most applications determining the ranked list of o ers is su cient.
In the next section we compare the di erent modelling approaches with respect to their performance in the selection process.
Having introduced an approach for preference-based selection of con gurable Web services, the question arises how this increased expressivity in uences the performance of the selection process.
In particular, we are interested in the trade-o  between performance and optimality.
Therefore, the three selection variants introduced in Section 5.2 are compared to an algorithm that randomly selects an o er and con guration.
All algorithms are evaluated for varying number of o ers in the knowledge base and varying numbers of con gurations per o er.
Each of these settings is evaluated by means of a simulation.
Only settings with string matching rules have been used.
Performance evaluations of query answering with more complex matching rules is a complementary question and has already been elaborated in [23] for KAON2.
For each setting, instances of o ers, requests and contexts are randomly generated using a uniform distribution and stored in the knowledge base.
Then SPARQL-queries are generated according to Equation 8 (without any FILTER condition) referring to a speci c execution context and request in the knowledge base.
The time between sending the query and receiving the result is measured.
In order to avoid possible network delays the simulation is done on a single machine.
For each setting the average query time is determined based on 20 simulation runs.
Using this simulation setup the following issues are addressed: How does the performance change when moving towards preference-and context-aware selection strategies?
How expensive is optimal-ity?
To investigate the additional time required for evaluating the o ers and con gurations according to preferences, we compare the most general optimal variant [V1] with a baseline algorithm that randomly selects an o er and corresponding con guration from the knowledge base.
Figure 3 shows the interrelation between the number of o ers in the knowledge base, the number of con gurations in an o er and the resulting query time.
In the  rst setting (Figure
 tion can be done in less than a second for 2000 o ers using the random algorithm, while [V1] requires about 17 seconds.
As de-
5.5 (http://lpsolve.sourceforge.net/5.5/).
picted in Figures 3(b) and 3(c), the gap increases further for more demanding settings.
However, the random approach leads to a considerable loss in utility for the requester.
Assuming a uniform distribution of the prices and scoring values in [0,1] and a reasonable number of o ers (> 50) an optimal algorithm leads to a utility of almost 1 while the random algorithm results only in a average utility of 0.
Can we improve the performance of optimal selection by constraining the bidding language?
How does the performance of the optimal selection variants di er?
Variants [V2] and [V3] of the mmp-predicate assume an additive structure of the pricing and scoring function.
As discussed above, this allows a more e cient implementation.
[V2] reduces the runtime compared to [V1] from 17 to 11 seconds in the  rst setting and from 477 to 41 in the second setting (both with 2000 o ers).
[V3] further reduces the run-time to 5 and 13 seconds, respectively.
If we now compare this improved performance to the random algorithm, the cost of opti-mality is rather moderate.
In particular, considering setting 3 with 1000 o ers and 1600 con gurations per o er, there is only a slow down by 35% when moving from random selection to [V3] (Figure
 much greater slowdowns which, at  rst glance, seems contradictory.
However, this observation can be explained by the fact that for large-scale scenarios (more that 1000 con gurations per o er) query answering becomes the predominant factor compared to the optimization in [V3].
Since query answering is required for both algorithms, variant [V3] and random selection converge.
In this section, we presented an  exible approach for assigning syntactic as well as semantic matching predicates to attributes.
These predicates are automatically applied for matching attribute values in the optimization process.
In general, the results of the performance evaluation are promising since the fastest approach allows ranking up to 2000 o ers with a reasonable number of con gurations below 15 seconds.
Considering the fact that these 2000 o ers all ful ll the mandatory conditions de ned in the FILTER condition of Query 8, this can already be seen as a very large scenario.
Moreover, we analysed the worst-case scenario where all o ers provide all possible con gurations and all attributes are discrete.
Optimization on discrete attributes is more time consuming compared to the continuous case because techniques like di eren-tiation are not applicable.
Therefore, we expect better performance in a real-world use case.
In our mobile scenario, only up to 20 di erent route planning providers might be available, whereas the number of possible con gurations may easily exceed 1000.
However, it is unlikely that all of them are o ered by all providers.
As a further result of our performance study, it becomes clear that providing expressive means for modelling preferences as done in [12, 26] is not su cient without ensuring that the way they are used allows for the implementation of e cient selection algorithms.
Comparing the results for [V2] and [V3], we can identify the absence of the additivity assumption as the major source of complexity (improvement from [V1] to [V2]).
Using an e cient implementation for solving the optimization problem provides a relatively minor improvement (improvement from [V2] to [V3]) in performance.
Therefore, in many cases, especially if service selection has to be done at runtime, restricting the expressiveness of the bidding language is a viable way to considerably increase performance.
Even if preferential independency does not hold exactly, additive functions often provide a good approximation [30].
If this simpli cation is not possible, other methods for improving the performance of [V1] can be introduced, e.g.
a caching mechanism for prices and scores that reduces the number of rule evaluations [19].
A further conclusion is that in some very demanding settings, re-

random selection




 s m n i e m i t y r e u q





 s m n i e m i t y r e u q


 random selection





 s m n i e m i t y r e u q


 random selection





 number of offers in KB











 number of offers in KB number of configurations per offer (a) 100 con gurations per o er (b) 1000 con gurations per o er (c) 1000 o ers in KB Figure 3: Performance of service selection.
ducing the set of relevant o ers is crucial.
This can be realized by adding additional mandatory conditions through FILTER expressions.
As a proof of concept, we implemented the algorithms presented in this paper in a framework consisting of two components.5 The  rst is a server component that provides a repository for service offers and requests that can be queried via a Web service interface and the DL reasoner KAON2.
KAON2 is chosen because it supports the logical fragment required for our o er and request descriptions, while being optimized for large-scale query answering [23].
This component corresponds to the service repository in Figure 1.
The second component is a client tool that facilitates the speci- cation of Web service o ers and requests by providing a GUI for specifying SPARQL-queries and utility function policies.
Generally, o ers are transferred to the server, whereas for requests the user decides whether they should also be stored as policies on the server to enable further reuse (cf.
(R4)) or formulated directly as a query.
The client is supplemented by a WS-BPEL engine [25] that allows the speci cation of service compositions.
For example, the second component could be used by the network operator in our initial example to implement its application.
In order to implement dynamic binding of services, we utilise the distinction between ports and port types in WS-BPEL.
This feature allows us to dynamically reassign end points as long as the service candidates have an identical interface, i.e. port type.
To support this, the client tool allows extending the process as follows: before each dynamic service invocation, a WS-BPEL invoke-operation for the selection service is introduced that provides the binding information for the following service.
We realize the Binding by Constraint paradigm [29] by specifying a SPARQL query (such as Query 8) that is passed to the selection service.
In this case, SPARQL provides a standardized language for identifying suitable services without referring to a concrete name or identi er.
Parts of the query are generated at development time of the process, while others can be added dynamically at runtime.
To illustrate this approach, Listing 1 shows an excerpt form the WS-BPEL process of the route planning scenario introduced in Section 2.
In lines 2-4 the user s request is received, the contained clientId is passed to the location service, where the current country of the user is determined (lines 8-10).
Then the SPARQL query, which statically refers to request ns1:RequestOperatorX containing the providers preferences, is extended by the context location (lines 12-15) and passed to the selection service which is invoked in lines 18-20.
After receiving the address of the best service, the corresponding port is assigned to the port type of the following partner link (lines 21-25) and the
 http://km.aifb.uni-karlsruhe.de/projects/kaonws/.
...
<receive name="receiveRoute" partnerLink="customer" portType="client:Process" operation="initiate" variable="routeRequest" createInstance="yes"/> <assign name="Assign_Query"> <copy> <from variable="routeRequest" part="user"/> <to variable="clientID"/> <invoke name="LocationCheck" partnerLink="LocationServicePLT" portType="ns1:LocationService" operation="executeQuery" inputVariable="clientID" outputVariable="location"/> <assign name="Assign_Query"> <copy> <from expression= "concat(string(\"SELECT ?O , ?U WHERE { EVALUATE mmp(ns1:RequestOperatorX, ?O,\" ), bpws:getVariableData( location , Country ),string(\",?U ) .
}\"))" /> <to variable="requestQuery" part="queryMessage"/> </copy> </assign> <invoke name="ServiceInvoke" partnerLink="SelectionServicePLT" portType="ns1:SelectionService" operation="executeQuery" inputVariable="requestQuery" outputVariable="responseQuery"/> <assign name="Assign_Port"> <copy> <from variable="responseQuery" part="queryResult"/> <to partnerLink="RoutePlanner"/> </copy> </assign> <invoke name="RoutePlanningInvoke" partnerLink="RoutePlanner" portType="ns1:RoutePlanningService" operation="requestRoute" inputVariable="routeRequest" outputVariable="responseRoute"/> ...
Listing 1: Flexible binding in WS-BPEL




























 route planning service is invoked by passing the original user request containing the start and end point (lines 26-28).
In case service candidates have di erent interfaces, dynamic selection requires complex interface mappings.
[29] present an approach for dynamic binding of services using re ection.
However, this cannot be used directly for WS-BPEL.
In this paper, we have provided a formal and standards-based representation of Web service con gurations and user preferences over these con gurations meeting the requirements (R1) and (R2) introduced in Section 2.
Our approach avoids enumerating of-fered/requested con gurations and thus signi cantly reduces storage requirements and increases communication e ciency (R4).
In addition, we have presented a service selection algorithm that seamlessly integrates syntactic as well as semantic matching (R3) with e cient optimization techniques.
In contrast to other work in this area, we do not restrict ourselves to logical and/or similarity-based matching approaches, but allow customisable matching predicates that can be declaratively assigned to service attributes in a very  exible way.
In order to quantify the overhead introduced by the additional expressivity and the optimality requirement, we evaluated the performance of the di erent ranking algorithms, showing lation of the optimization problem introduces only a small overhead compared to random selection.
This holds particularly for large-scale scenarios with a high number of con gurations per offer.
Another important  nding is that the performance depends crucially on the way o ers and request are modelled.
According to our evaluation, additive preference and price functions are required to dynamically select services in large-scale scenarios in a computationally tractable manner (R4).
Finally, as a proof of concept we applied our framework for dynamic Web service selection in WS-
As future work, we plan to move from selecting single services to service selection for an entire process.
This can be realized simply by adding rules and builtin predicates implementing the more complex optimization algorithms (e.g.
[40]).
In addition, we plan to integrate behavioral matching rules as presented in [1], which would allow de ning preferences over temporal properties of a service.
For example, Annika might prefer services which provide the route information before paying.
In terms of implementation, we plan to address the problem of dynamic binding in WS-BPEL beyond simple port reassignments.
Acknowledgments.
This research was partially supported by the German Research Foundation (DFG) in scope of the Research Training Group  Information Management and Market Engineering , by the European Commission under FP6-027595  NEON , FP6-507482  KnowledgeWeb , and FP6-507483  DIP , and by the German BMBF project  SmartWeb .
The expressed content is the view of the authors but not necessarily the view of any of the mentioned projects as a whole.
