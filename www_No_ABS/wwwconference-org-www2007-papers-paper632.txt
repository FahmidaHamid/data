The study of semantic similarity between words has long been an integral part of information retrieval and natural language processing.
Semantic similarity between entities changes over time and across domains.
For example, apple is frequently associated with computers on the Web.
However, this sense of apple is not listed in most general-purpose thesauri or dictionaries.
A user who searches for apple on the Web, may be interested in this sense of apple and not apple as a fruit.
New words are constantly being created as well as new senses are assigned to existing words.
Manually maintaining thesauri to capture these new words and senses is costly if not impossible.
We propose an automatic method to measure semantic similarity between words or entities using Web search engines.
Because of the vastly numerous documents and the high growth rate of the Web, it is di cult to analyze each document separately and directly.
Web search engines provide an e cient interface to this vast information.
Page counts and snippets are two useful information sources provided by most Web search engines.
Page count of a query is the number of pages that contain the query words 1.
Page count for the query P AND Q can be considered as a global measure of co-occurrence of words P and Q.
For example, the page count of the query  apple  AND  computer  in Google 2 is 288, 000, 000, whereas the same for  banana  AND  computer  is only 3, 590, 000.
The more than 80 times more numerous page counts for  apple  AND  computer  indicate that apple is more semantically similar to computer than is banana.
Despite its simplicity, using page counts alone as a measure of co-occurrence of two words presents several drawbacks.
First, page count analyses ignore the position of a word in a page.
Therefore, even though two words appear in a page, they might not be related.
Secondly, page count of a polysemous word (a word with multiple senses) might contain a combination of all its senses.
For an example, page counts for apple contains page counts for apple as a fruit and apple as a company.
Moreover, given the scale and noise in the Web, some words might occur arbitrarily, i.e. by random chance, on some pages.
For those reasons, page counts alone are unreliable when measuring semantic similarity.
quency because the queried word might appear many times on one page 2http:://www.google.com gine around the query term in a document, provide useful information regarding the local context of the query term.
Semantic similarity measures de ned over snippets, have been used in query expansion [36], personal name disambiguation [4] and community mining [6].
Processing snippets is also e cient as it obviates the trouble of downloading web pages, which might be time consuming depending on the size of the pages.
However, a widely acknowledged drawback of using snippets is that, because of the huge scale of the web and the large number of documents in the result set, only those snippets for the top-ranking results for a query can be processed e ciently.
Ranking of search results, hence snippets, is determined by a complex combination of various factors unique to the underlying search engine.
Therefore, no guarantee exists that all the information we need to measure semantic similarity between a given pair of words is contained in the top-ranking snippets.
This paper proposes a method that considers both page counts and lexico-syntactic patterns extracted from snippets, thereby overcoming the problems described above.
For example, let us consider the following snippet from Google for the query Jaguar AND cat.
 The Jaguar is the largest cat in Western Hemisphere and can subdue larger prey than can the puma  Here, the phrase is the largest indicates a hypernymic relationship between the Jaguar and the cat.
Phrases such as also known as, is a, part of, is an example of all indicate various semantic relations.
Such indicative phrases have been applied to numerous tasks with good results, such as hyponym extraction [12] and fact extraction [27].
From the previous example, we form the pattern X is the largest Y, where we replace the two words Jaguar and cat by two wildcards X and Y.
Our contributions in this paper are two fold:   We propose an automatically extracted lexico-syntactic patterns-based approach to compute semantic similarity using text snippets obtained from a Web search engine.
  We integrate di erent web-based similarity measures using WordNet synsets and support vector machines to create a robust semantic similarity measure.
The integrated measure outperforms all existing Web-based semantic similarity measures in a benchmark dataset.
To the best of our knowledge, this is the  rst attempt to combine both WordNet synsets and Web content to leverage a robust semantic similarity measure.
The remainder of the paper is organized as follows.
In section 2 we discuss previous works related to semantic similarity measures.
We then describe the proposed method in section 3.
Section 4 compares the proposed method against previous Web-based semantic similarity measures and several baselines on a benchmark data set.
In order to evaluate the ability of the proposed method in capturing semantic similarity between real-world entities, we apply it in a community mining task.
Finally, we show that the proposed method is useful for disambiguating senses in ambiguous named-entities and conclude this paper.
Semantic similarity measures are important in many Web-related tasks.
In query expansion [5, 25, 40] a user query is modi ed using synonymous words to improve the relevancy of the search.
One method to  nd appropriate words to include in a query is to compare the previous user queries using semantic similarity measures.
If there exist a previous query that is semantically related to the current query, then it can be suggested either to the user or internally used by the search engine to modify the original query.
Semantic similarity measures have been used in Semantic Web related applications such as automatic annotation of Web pages [7], community mining [23, 19], and keyword extraction for inter-entity relation representation [26].
Semantic similarity measures are necessary for various applications in natural language processing such as word-sense disambiguation [32], language modeling [34], synonym extraction [16], and automatic thesauri extraction [8].
Manually compiled taxonomies such as WordNet3 and large text corpora have been used in previous works on semantic similarity [16, 31, 13, 17].
Regarding the Web as a live corpus has become an active research topic recently.
Simple, unsupervised models demonstrably perform better when n-gram counts are obtained from the Web rather than from a large corpus [14, 15].
Resnik and Smith [33] extracted bilingual sentences from the Web to create a parallel corpora for machine translation.
Turney [38] de ned a point-wise mutual information (PMI-IR) measure using the number of hits returned by a Web search engine to recognize synonyms.
Matsuo et.
al, [20] used a similar approach to measure the similarity between words and apply their method in a graph-based word clustering algorithm.
Given a taxonomy of concepts, a straightforward method to calculate similarity between two words (concepts) is to  nd the length of the shortest path connecting the two words in the taxonomy [30].
If a word is polysemous then multiple paths might exist between the two words.
In such cases, only the shortest path between any two senses of the words is considered for calculating similarity.
A problem that is frequently acknowledged with this approach is that it relies on the notion that all links in the taxonomy represent a uniform distance.
Resnik [31] proposed a similarity measure using information content.
He de ned the similarity between two concepts C1 and C2 in the taxonomy as the maximum of the information content of all concepts C that subsume both C1 and C2.
Then the similarity between two words is de ned as the maximum of the similarity between any concepts that the words belong to.
He used WordNet as the taxonomy; information content is calculated using the Brown corpus.
Li et al., [41] combined structural semantic information from a lexical taxonomy and information content from a corpus in a nonlinear model.
They proposed a similarity measure that uses shortest path length, depth and local density in a taxonomy.
Their experiments reported a Pearson correlation coe cient of 0.8914 on the Miller and Charles [24] benchmark dataset.
They did not evaluate their method in terms of similarities among named entities.
Lin [17] de ned the similarity between two concepts as the information that is in common to both concepts and the information contained in each individual concept.
3http://wordnet.princeton.edu/ semantic similarity using Web content.
Matsuo et al., [19] proposed the use of Web hits for extracting communities on the Web.
They measured the association between two personal names using the overlap (Simpson) coe cient, which is calculated based on the number of Web hits for each individual name and their conjunction (i.e., AND query of the two names).
Sahami et al., [36] measured semantic similarity between two queries using snippets returned for those queries by a search engine.
For each query, they collect snippets from a search engine and represent each snippet as a TF-IDF-weighted term vector.
Each vector is L2 normalized and the centroid of the set of vectors is computed.
Semantic similarity between two queries is then de ned as the inner product between the corresponding centroid vectors.
They did not compare their similarity measure with taxonomy-based similarity measures.
Chen et al., [6] proposed a double-checking model using text snippets returned by a Web search engine to compute semantic similarity between words.
For two words P and Q, they collect snippets for each word from a Web search engine.
Then they count the occurrences of word P in the snippets for word Q and the occurrences of word Q in the snippets for word P .
These values are combined nonlinearly to compute the similarity between P and Q.
This method depends heavily on the search engine s ranking algorithm.
Although two words P and Q might be very similar, there is no reason to believe that one can  nd Q in the snippets for P , or vice versa.
This observation is con rmed by the experimental results in their paper which reports zero similarity scores for many pairs of words in the Miller and Charles [24] dataset.
We propose a method which integrates both page counts and snippets to measure semantic similarity between a given pair of words.
In section 3.2, we de ne four similarity scores using page counts.
We then describe an automatic lexico-syntactic pattern extraction algorithm in section 3.3.
We rank the patterns extracted by our algorithm according to their ability to express semantic similarity.
We use two-class support vector machines (SVMs) to  nd the optimal combination of page counts-based similarity scores and top-ranking patterns.
The SVM is trained to classify synonymous word-pairs and non-synonymous word-pairs.
We select synonymous word-pairs (positive training examples) from WordNet synsets4.
Non-synonymous word-pairs (negative training examples) are automatically created using a random shu ing technique.
We convert the output of SVM into a posterior probability.
We de ne the semantic similarity between two words as the posterior probability that they belong to the synonymous-words (positive) class.
Page counts for the query P AND Q, can be considered as an approximation of co-occurrence of two words (or multi-word phrases) P and Q on the Web.
However, page counts for the query P AND Q alone do not accurately express semantic similarity.
For example, Google returns 11, 300, 000 as the page count for  car  AND  automobile , whereas the same is 49, 000, 000 for  car  AND  apple .
Although, automobile is more semantically similar to car than apple is, page counts for query  car  AND  apple  are more than four times greater than those for the query  car  and  automobile .
One must consider the page counts not just for the query P AND Q, but also for the individual words P and Q to assess semantic similarity between P and Q.
We modify four popular co-occurrence measures; Jaccard, Overlap (Simpson), Dice, and PMI (Point-wise mutual information), to compute semantic similarity using page counts.
For the remainder of this paper we use the notation H(P ) to denote the page counts for the query P in a search engine.
The WebJaccard coe cient between words (or multi-word phrases) P and Q, WebJaccard(P, Q), is de ned as, WebJaccard(P, Q)

 if H(P   Q)   c otherwise.
(1) =0 Therein, P   Q denotes the conjunction query P AND Q.
Given the scale and noise in Web data, it is possible that two words may appear on some pages purely accidentally.
In order to reduce the adverse e ects attributable to random co-occurrences, we set the WebJaccard coe cient to zero if the page count for the query P   Q is less than a threshold c5.
Similarly, we de ne WebOverlap, WebOverlap(P, Q), as, WebOverlap(P, Q)
 min(H(P ),H(Q)) =0 if H(P   Q)   c otherwise.
(2) WebOverlap is a natural modi cation to the Overlap (Simpson) coe cient.
We de ne the WebDice coe cient as a variant of the Dice coe cient.
WebDice(P, Q) is de ned as, WebDice(P, Q)


 if H(P   Q)   c otherwise.
(3) We de ne WebPMI as a variant form of PMI using page counts as, =0 =&
 WebPMI(P, Q) log2(





 if H(P   Q)   c ) otherwise.
(4) Here, N is the number of documents indexed by the search engine.
Probabilities in Eq.
4 are estimated according to the maximum likelihood principle.
To calculate PMI accurately using Eq.
4, we must know N , the number of documents indexed by the search engine.
Although estimating the number of documents indexed by a search engine [2] is an interesting task itself, it is beyond the scope of this work.
In the present work, we set N = 1010 according to the number of indexed pages reported by Google.
5we set c = 5 in our experiments Snippets Text snippets are returned by search engines alongside with the search results.
They provide valuable information regarding the local context of a word.
We extract lexico-syntactic patterns that indicate various aspects of semantic similarity.
For example, consider the following text snippet returned by Google for the query  cricket  AND  sport .
Here, the phrase is a indicates a semantic relationship be Cricket is a sport played between two teams, each with eleven players.  Figure 1: Pattern Extraction Example tween cricket and sport.
Many such phrases indicate semantic relationships.
For example, also known as, is a, part of, is an example of all indicate semantic relations of di er-ent types.
In the example given above, words indicating the semantic relation between cricket and sport appear between the query words.
Replacing the query words by wildcards X and Y we can form the pattern X is a Y from the example given above.
However, in some cases the words that indicate the semantic relationship do not fall between the query words.
For example, consider the following example.
 Toyota and Nissan are two major Japanese car manufacturers.  Figure 2: Pattern Extraction Example Here, the relationship between Toyota and Nissan is that they are both car manufacturers.
Identifying the exact set of words that convey the semantic relationship between two entities is a di cult problem which requires deeper semantic analysis.
However, such an analysis is not feasible considering the numerous ill-formed sentences we need to process on the Web.
In this paper, we propose a shallow pattern extraction method to capture the semantic relationship between words in text snippets.
Our pattern extraction algorithm is illustrated in Figure 3.
Given a set S of synonymous word-pairs, GetSnippets function returns a list of text snippets for the query  A  AND  B  for each word-pair A, B in S. For each snippet found, we replace the two words in the query by two wildcards.
Let us assume these wildcards to be X and Y.
For each snippet d in the set of snippets D returned by GetSnippets, function GetNgrams extract word n-grams for n = 2, 3, 4 and 5.
We select n-grams which contain exactly one X and one Y.
For example, the snippet in Figure 2 yields patterns X and  Algorithm 3.1: ExtractPatterns(S) comment: Given a set S of word-pairs, extract patterns.
for each word-pair (A, B)   S do D   GetSnippets( A B ) N   null for each snippet d   D do N   N + GetNgrams(d, A, B) P ats   CountFreq(N ) return (P ats)  Figure 3: Extract patterns from snippets.
Table 1: Contingency table v other than v All Freq.
in snippets for synonymous word pairs pv Freq.
in snippets for non-synonymous word pairs nv P   pv N   nv

 Y, X and Y are, X and Y are two.
Finally, function Count-Freq counts the frequency of each pattern we extracted.
The procedure described above yields a set of patterns with their frequencies in text snippets obtained from a search engine.
It considers the words that fall between X and Y as well as words that precede X and succeeds Y .
To leverage the pattern extraction process, we select 5000 pairs of synonymous nouns from WordNet synsets.
For polysemous nouns we selected the synonyms for the dominant sense.
The pattern extraction algorithm described in Figure 3 yields 4, 562, 471 unique patterns.
Of those patterns,
 si er with such numerous sparse patterns.
We must measure the con dence of each pattern as an indicator of synonymy.
For that purpose, we employ the following procedure.
First, we run the pattern extraction algorithm described in Figure 3 with a non-synonymous set of word-pairs and count the frequency of the extracted patterns.
We then use a test of statistical signi cance to evaluate the probable applicability of a pattern as an indicator of synonymy.
The fundamental idea of this analysis is that, if a pattern appears a statistically signi cant number of times in snippets for synonymous words than in snippets for non-synonymous words, then it is a reliable indicator of synonymy.
To create a set of non-synonymous word-pairs, we select two nouns from WordNet arbitrarily.
If the selected two nouns do not appear in any WordNet synset then we select them as a non-synonymous word-pair.
We repeat this procedure until we obtain 5000 pairs of non-synonymous words.
For each extracted pattern v, we create a contingency table, as shown in Table 1 using its frequency pv in snippets for synonymous word pairs and nv in snippets for non-synonymous word pairs.
In Table 1, P denotes the total frequency of all patterns in snippets for synonymous word pairs (P =2v pv) and N is the same in snippets for non-synonymous word pairs (N =2v nv).
Using the information in Table 1, we calculate the  2 [18] value for each pattern as,  2 = (P + N )(pv(N   nv)   nv(P   pv))2 P N (pv + nv)(P + N   pv   nv) .
(5) We selected the top ranking 200 patterns experimentally as described in section 4.2, according to their  2 values.
Some selected patterns are shown in Table 2.
Before we proceed to the integration of patterns and page-counts-based similarity scores, it is necessary to introduce some constraints to the development of semantic similarity measures.
Evidence from psychological experiments suggest that semantic similarity can be context-dependent and even asymmetric [39, 22].
Human subjects have reportedly assigned di erent similarity ratings to word-pairs when the two words were presented in the reverse order.
However, experimental results investigating the e ects of asymmetry is less than 5 percent [22].
In this work, we assume semantic similarity to be symmetric.
This is in line with previous work on semantic similarity described in section 2.
Under this assumption, we can interchange the query word markers X and Y in the extracted patterns.
Integrating Patterns and Page Counts In section 3.2 we de ned four similarity scores using page counts.
Section 3.3 described a lexico-syntactic pattern extraction algorithm and ranked the patterns according to their ability to express synonymy.
In this section we describe leverage of a robust semantic similarity measure through integration of all the similarity scores and patterns described in previous sections.
 Algorithm 3.2: GetFeatureVector(A, B) comment: Given a word-pair A, B get its feature vector F .
D   GetSnippets( A B ) N   null for each snippetd   D do N   N + GetNgrams(d, A, B) SelP ats   SelectPatterns(N, GoodP ats) P F   Normalize(SelP ats) F   [P F, W ebJaccard, W ebOverlap, W ebDice, W ebP M I] return (F )  Figure 4: Create a feature vector F for a word-pair
 For each pair of words (A, B), we create a feature vector F as shown in Figure 4.
First, we query Google for  A  AND  B  and collect snippets.
Then we replace the query words A and B with two wildcards X and Y , respectively in each snippet.
Function GetNgrams extracts n-grams for n = 2, 3, 4 and 5 from the snippets.
We select n-grams having exactly one X and one Y as we did in the pattern extraction algorithm in Figure 3.
Let us assume the set of patterns selected based on their  2 values in section 3.3 to be GoodP ats.
Then, the function SelectPatterns selects the n-grams from N which appear in GoodP ats.
In N ormalize(SelP ats), we normalize the count of each pattern by diving it from the total number of counts of the observed patterns.
This function returns a vector of patterns where each element is the normalized frequency of the corresponding pattern in the snippets for the query  A B .
We append similarity scores calculated using page counts in section 3.2 to create the  nal feature vector F for the word-pair (A, B).
This procedure yields a 204 dimensional (4 page-counts based similarity scores and 200 lexico-syntactic patterns) feature vector F .
We form such feature vectors for all synonymous word-pairs (positive training examples) as well as for non-synonymous word-pairs (negative training examples).
We then train a two-class support vector machine with the labelled feature vectors.
Once we have trained an SVM using synonymous and non-synonymous word pairs, we can use it to compute the semantic similarity between two given words.
Following the same method we used to generate feature vectors for training, we create a feature vector F (cid:48) for the given pair of words (A(cid:48), B(cid:48)), between which we need to measure the semantic similarity.
We de ne the semantic similarity SemSim(A(cid:48), B(cid:48)) between Figure 5: Correlation vs. No of pattern features A(cid:48) and B(cid:48) as the posterior probability Prob(F (cid:48)|synonymous) that feature vector F (cid:48) belongs to the synonymous-words (positive) class.
SemSim(A (cid:48) (cid:48)
 ) = Prob(F (cid:48)|synonymous) (6) Being a large-margin classi er, the output of an SVM is the distance from the decision hyper-plane.
However, this is not a calibrated posterior probability.
We use sigmoid functions to convert this uncalibrated distance into a calibrated posterior probability (see [29] for a detailed discussion on this topic).
We conduct two sets of experiments to evaluate the proposed semantic similarity measure.
First we compare the similarity scores produced by the proposed measure against Miller-Charles benchmark dataset.
We analyze the behavior of the proposed measure with the number of patterns used as features, the number of snippets used to extract the patterns, and the size of the training dataset.
Secondly, we apply the proposed measure in two real-world applications: community mining and entity disambiguation.
We evaluate the proposed method against Miller-Charles [24] dataset, a dataset of 30 word-pairs6 rated by a group of 38 human subjects.
The word pairs are rated on a scale from
 data set is a subset of Rubenstein-Goodenough s [35] original data set of 65 word pairs.
Although Miller-Charles experiment was carried out 25 years later than Rubenstein-Goodenough s, two sets of ratings are highly correlated (pear-son correlation coe cient=0.97).
Therefore, Miller-Charles ratings can be considered as a reliable benchmark for evaluating semantic similarity measures.
We trained a linear kernel SVM with top N pattern features (ranked according to their  2 values) and calculated the correlation coe cient against the Miller-Charles benchmark dataset.
Results of the experiment are shown in Figure 5.
In Figure 5 a steep improvement of correlation with the number of top-ranking patterns is appearent; it reaches
 of WordNet, most researchers had used only 28 pairs for evaluations
 nel weights feature WebDice

 X or Y X Y for X .
the Y with X ( Y
 X and Y are X of Y  2









 SVM weight









 Table 3: Performance with di erent Kernels Kernel Type Linear Polynomial degree=2 Polynomial degree=3
 Sigmoid Correlation




 a maximum at 200 features.
With more than 200 patterns correlation drops below this maximum.
Considering that the patterns are ranked according to their ability to express semantic similarity and the majority of patterns are sparse, we selected only the top ranking 200 patterns for the remaining experiments.
Features with the highest linear kernel weights are shown in Table 2 alongside their  2 values.
The weight of a feature in the linear kernel can be considered as a rough estimate of the in uence it imparts on the  nal SVM output.
WebDice has the highest kernel weight followed by a series of pattern-based features.
WebOverlap (rank=18, weight=2.45), Web-Jaccard (rank=66, weight=0.618) and WebPMI (rank=138, weight=0.0001) are not shown in Table 2 because of space limitations.
It is noteworthy that the pattern features in Table 2 agree with intuition.
Lexical patterns (e.g., X or Y, X and Y are, X of Y ) as well as syntax patterns (e.g., bracketing, comma usage) are extracted by our method.
We experimented with di erent kernel types as shown in Table 3.
Best performance is achieved with the linear kernel.
When higher degree kernels such as quadratic (Polynomial degree=2) and cubic (Polynomial degree=3) are used, correlation with the human ratings decreases rapidly.
Second best is the Radial Basis Functions (RBFs), which reports a correlation coe cient of 0.6632.
For the rest of the experiments in this paper we use the linear kernel.
We score the word pairs in Miller-Charles  dataset using the page-count-based similarity scores de ned in section 3.2, Web-based semantic similarity measures proposed in previous work (Sahami [36], Chen [6]) and the proposed method (SemSim).
Results are shown in Table 4.
All  gures, except those for the Miller-Charles ratings, are normalized into values in [0, 1] range for ease of comparison.
Pearson s correlation coe cient is invariant against a linear transformation.
Proposed method earns the highest correlation of 0.834 in our experiments.
It shows the highest similarity score for the word-pair magician and wizard.
Lowest similarity is reported for cord and smile 7.
Our reimplementation of Co-occurrence Double Checking (CODC) measure [6] indicates the second-best correlation of 0.6936.
The CODC measure is de ned as,
 =0 elogD f(P @Q H(P )   f(Q@P ) H(Q) E  if f (P @Q) = 0 otherwise.
(7) Therein, f (P @Q) denotes the number of occurrences of P in the top-ranking snippets for the query Q in Google.
H(P ) is the page count for query P .
  is a constant in CODC model and it is set to 0.15 according to Chen et al., [6].
CODC measure reports zero similarity scores for many word-pairs in the benchmark.
One reason for this sparsity in CODC measure is that even though two words in a pair (P, Q) are semantically similar, we might not always  nd Q among the top snippets for P (and vice versa).
As might be ap-pearent from the de nition of the CODC measure in Eq.
7, it returns zero under these conditions.
Ranking of snippets, (hence the value of f (P @Q)), depends directly upon the search engine s speci cations.
A search engine considers various factors such as novelty, authority, link structure, user preferences when ranking search results.
Consequently, CODC measure is in uenced by these factors.
Similarity measure proposed by Sahami et al. [36] is placed third, re ecting a correlation of 0.5797.
This method use only those snippets when calculating semantic similarity.
Among the four page-counts-based measures, WebPMI garners the highest correlation (r = 0.5489).
Overall, the results in Table 4 suggest that similarity measures based on snippets are more accurate than the ones based on page counts in capturing semantic similarity.
Table 5: Comparison with taxonomy-based methods Method Human replication Resnik (1995) Lin (1998) Li et al. (2003) Edge-counting Information content Jiang & Conrath (1998) Proposed Correlation







 Table 5 presents a comparison of the proposed method to the WordNet-based methods.
The proposed method outperforms simple WordNet-based approaches such as Edge-counting and Information Content measures.
It is comparable with Lin (1998) [17] Jiang & Conrath (1998) [13] and Li (2003) [41] methods.
Unlike the WordNet based methods, proposed method requires no a hierarchical taxonomy of concepts or sense-tagged de nitions of words.
or their synsets for training Table 4: Semantic Similarity of Human Ratings and Baselines on Miller-Charles  dataset Sahami [36] CODC [6] Proposed SemSim Miller-Charles  Web Web Web Web Jaccard Dice Overlap PMI





 cord-smile rooster-voyage noon-string glass-magician monk-slave coast-forest monk-oracle lad-wizard forest-graveyard food-rooster coast-hill car-journey crane-implement brother-lad bird-crane bird-cock food-fruit brother-monk asylum-madhouse furnace-stove magician-wizard journey-voyage coast-shore implement-tool boy-lad automobile-car midday-noon gem-jewel Correlation

































































































































































































































 semantic similarity measure.
The experimental results are presented in Figure 6.
From Figure 6 it is appearent that overall the correlation coe cient improves with the number of snippets used for extracting patterns.
The probability of  nding better patterns increases with the number of processed snippets.
That fact enables us to represent each pair of words with a rich feature vector, resulting in better performance.
We used synonymous word pairs extracted from Word-Net synsets as positive training examples and automatically generated non-synonymous word pairs as negative training examples to train a two-class support vector machine in section 3.4.
To determine the optimum combination of positive and negative training examples, we trained a linear kernel SVM with di erent combinations of positive and negative training examples and evaluated accuracy against the human ratings in the Miller-Charles benchmark dataset.
Experimental results are summarized in Figure 7.
Maximum correlation coe cient of 0.8345 is achieved with 1900 positive training examples and 2400 negative training examples.
Moreover, Figure 7 reveals that correlation does not improve beyond 2500 positive and negative training examples.
Therefore, we can conclude that 2500 examples are su cient to leverage the proposed semantic similarity measure.
Figure 6: Correlation vs. No of snippets Therefore, in principle the proposed method could be used to calculate semantic similarity between named entities, etc, which are not listed in WordNet or other manually compiled thesauri.
However, considering the high correlation between human subjects (0.9), there is still room for improvement.
We computed the correlation with the Miller-Charles ratings for di erent numbers of snippets to investigate the e ect of the number of snippets used to extract patterns upon the
 Method Precision Recall F Measure WebJaccard WebOverlap WebDice WebPMI Sahami [36] Chen [6] Proposed




















 name in the data set and average the results over the dataset.
For each person p in our data set, let us denote the cluster that p belongs to by C(p).
Moreover, we use A(p) to denote the a liation of person p, e.g., A( Tiger Woods ) = Tennis Player .
Then we calculate precision and recall for person p as, Precision(p) = No.
of people in C(p) with a liation A(p) No.
of people in C(p) , (9) Recall(p) = No.
of people in C(p) with a liation A(p) Total No.
of people with a liation A(p) .
(10) Since, we selected 10 people from each of the  ve categories, the denominator in Formula 10 is 10 for all the names p.
Then, the F score of person p is de ned as,
 F(p) = Precision(p) + Recall(p) .
(11) Overall precision, recall and F score are computed by taking the averaged sum over all the names in the dataset.
Precision(p) Recall(p) (12) (13) Precision = Recall =

 N :p DataSet N :p DataSet N :p DataSet
 F Score = F(p) (14) Here, DataSet is the set of 50 names selected from the open directory project.
Therefore, N = 50 in our evaluations.
Experimental results are shown in Table 6.
The proposed method shows the highest entity clustering accuracy in Table 6 with a statistically signi cant (p   0.01 Tukey HSD) F score of 0.7897.
Sahami et al. [36] s snippet-based similarity measure, WebJaccard, WebDice and WebOverlap measures yield similar clustering accuracies.
Disambiguating named entities is important in various applications such as information retrieval [9], social network extraction [19, 3, 4], Word Sense Disambiguation (WSD) [21], citation matching [11] and cross-document co-reference resolution [28, 10].
Figure 7: Correlation vs. No of positive and negative training instances
 Measuring semantic similarity between named entities is vital in many applications such as query expansion [36], entity disambiguation (e.g.
namesake disambiguation) and community mining [19].
Because most named entities are not covered by WordNet, similarity measures that are based on WordNet cannot be used directly in these tasks.
Unlike common English words, named entities are being created constantly.
Manually maintaining an up-to-date taxonomy of named entities is costly, if not impossible.
The proposed semantic similarity measure is appealing for these applications because it does not require pre-compiled taxonomies.
In order to evaluate the performance of the proposed measure in capturing the semantic similarity between named-entities, we set up a community mining task.
We select 50 personal names from 5 communities: tennis players, golfers, actors, politicians and scientists , (10 names from each community) from the open directory project (DMOZ)8.
For each pair of names in our data set, we measure their similarity using the proposed method and baselines.
We use group-average agglomerative hierarchical clustering (GAAC) to cluster the names in our dataset into  ve clusters.
Initially, each name is assigned to a separate cluster.
In subsequent iterations, group average agglomerative clustering process, merges the two clusters with highest correlation.
Correlation, Corr( ) between two clusters A and B is de- ned as the following, Corr( ) =


 | |(| |   1) :(u,v)  sim(u, v) (8) Here,   is the merger of the two clusters A and B.
| | denotes the number of elements (persons) in   and sim(u, v) is the semantic similarity between two persons u and v in  .
We terminate GAAC process when exactly  ve clusters are formed.
We adopt this clustering method with di er-ent semantic similarity measures sim(u, v) to compare their accuracy in clustering people who belong to the same community.
We employed the B-CUBED metric [1] to evaluate the clustering results.
The B-CUBED evaluation metric was originally proposed for evaluating cross-document co-reference chains.
We compute precision, recall and F score for each 8http://dmoz.org
 operating system for computers.
A user who searches for Jaguar on the Web, may be interested in either one of these di erent senses of Jaguar.
However, only the  rst sense (Jaguar as a cat) is listed in WordNet.
Considering the number of new senses constantly being associated to the existing words on the Web, it is costly, if not impossible to maintain sense tagged dictionaries to cover all senses.
Contextual Hypothesis for Sense [37] states that the context in which a word appears can be used to determine its sense.
For example, a Web page discussing Jaguar as a car, is likely to talk about other types of cars, parts of cars etc.
Whereas, a Web page on Jaguar the cat, is likely to contain information about other types of cats and animals.
In this section, we utilize the clustering algorithm described in section 4.7 to cluster the top 1000 snippets returned by Google for two ambiguous entities Jaguar and Java.
We represent each snippet as a bag-of-words and calculate the similarity SIM(Sa, Sb) between two snippets Sa,Sbas follows, SIM(Sa, Sb) = sim(a, b) (15)
 |Sa||Sb| :a Sa,b Sb In Formula 15 |S| denotes the number of words in snippet S. We used di erent semantic similarity measures for sim in Formula 15 and employed the group average agglomera-tive clustering explained in section 4.7.
We manually analyzed the snippets for queries Java (3 senses: programming language, Island, co ee) and Jaguar (3 senses: cat, car, operating system) and computed precision, recall and F-score for the clusters created by the algorithm.
Our experimental results are summarized in Table 7.
Proposed method reports the best results among all the baselines compared in Table 7.
However, the experiment needs to be carried out on a much larger data set of ambiguous entities in order to obtain any statistical guarantees.
In this paper, we proposed a measure that uses both page counts and snippets to robustly calculate semantic similarity between two given words or named entities.
The method consists of four page-count-based similarity scores and automatically extracted lexico-syntactic patterns.
We integrated page-counts-based similarity scores with lexico syntactic patterns using support vector machines.
Training data were automatically generated using WordNet synsets.
Proposed method outperformed all the baselines including previously proposed Web-based semantic similarity measures on a benchmark dataset.
A high correlation (correlation co-e cient of 0.834) with human ratings was found for semantic similarity on this benchmark dataset.
Only 1900 positive examples and 2400 negative examples are necessary to leverage the proposed method, which is e cient and scalable because it only processes the snippets (no downloading of Web pages is necessary) for the top ranking results by Google.
A contrasting feature of our method compared to the WordNet based semantic similarity measures is that our method requires no taxonomies, such as WordNet, for calculation of similarity.
Therefore, the proposed method can be applied in many tasks where such taxonomies do not exist or are not up-to-date.
We employed the proposed method in community mining and entity disambiguation experiments.
Results of our experiments indicate that the proposed method can robustly capture semantic similarity between named entities.
In future research, we intend to apply the proposed semantic similarity measure in automatic synonym extraction, query suggestion and name alias recognition.
