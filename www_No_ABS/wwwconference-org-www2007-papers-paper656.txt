With the widespread use of Web services, systems on the Web are becoming more connected and integrated.
To protect the sensitive information that is often contained in these systems, there is an increased need for adequate security and privacy support.
As a result, there has been a great amount of attention to access control policy languages for web services which accommodate large, open, distributed and heterogeneous environments like the Web.
These languages aim to be  exible and extensible, with enough features to capture expressive and distributed access control Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
policies.
Currently, policy languages with the largest momentum include WS-Policy [17] (a W3C submission), which has been designed to specify the constraints and capabilities of web services, and the more general eXtensible Access Control Markup Language (XACML [7]).
The OASIS standard XACML is an expressive, general purpose XML-based language (with signi cant deployment1) that is used to specify policies on web resources.
XACML enables the use of arbitrary attributes in policies, allows for expressing negative authorization, con ict resolution algorithms and enables the use of hierarchical Role Based Access Control, among other things.
With policy languages as expressive as XACML, a new issue has emerged: users have di culty understanding the overall e ect and consequences of their security policies.
Even arguably the most important feature in access control - checking that the access control policy will not result in the leakage of permissions to an unintended or unauthorized principal, i.e., safety - has become di cult, if not impossible, to do manually.
For example, incomplete security policies might unintentionally give access to an intruder.
How can a security administrator be certain that her policy covers all corner cases?
Even if the administrator does discover a bug in the policy, and  xes it accordingly, the consequences of that  x (policy change) are di cult to analyze.
To address the above issues, there has been a great amount of attention to using logic and formal reasoning techniques for analysis and veri cation of policies.
There have been several attempts to provide a formalization of XACML [11, 4, 18, 6]   unfortunately they either support a small subset of the language, or they severely limit the analysis services o ered.
To the best of our knowledge, Margrave [6] is the only one analysis tool for XACML that provides both ver-i cation and change analysis   and it does so in a quite e cient manner.
In this paper, we provide a formalization of XACML that explores the ground between propositional logic analysis tools (such as Margrave) and full First-Order logic XACML analysis tools (like Alloy [12]).
As a basis for the XACML formalization we use description logics (DL), which are a family of languages that are decidable subsets of First-Order logic and are the basis for the Web Ontology Language (OWL) [5].
Because of the correspondence of policy analysis services to DL reasoning services (e.g., policy inclusion can be reduced to concept subsumption, whereas change impact analysis and veri cation can be reduced to concept satis ability), the framework can easily provide a variety of policy
 DL reasoners optimized for these services.
In addition to the analysis services, grounding the framework in DL (and consequently, OWL), provides other bene ts:   the web nature of OWL (it uses URIs for naming and allows for links between ontologies) is suitable for representing an access control language for web resources   with OWL we can use the framework to extend access control policies with ontology-based descriptions for objects used in the policy.
Using DL reasoners at analysis time, we are able to easily integrate these expressive descriptions of the policy domain with the policy itself, without sacri cing any of the services.
Also, being described in a standard machine process-able language allows these domain descriptions to be easily shared and reused on the web.
We emphasize that at the moment we intend these services to be used at design (or audit) time, not in a policy enforcement point (PEP) to enforce policies.
First, it is not entirely clear how useful these services would be for enforcement in today s setups.
They are not particularly designed for enforcement, and even where they could be used to optimize enforcement (e.g., by pruning redundant tests) such optimization can be done o line.
Second, these services can be computationally expensive.
Given that one requirement on a PEP is that it can handle the response requirements of applications under load, we must take care not to introduce too much overhead.
We also provide a prototype implementation of our analysis services on top of open source DL reasoner Pellet [15].
We performed preliminary evaluation of our tool on Margrave s test policy set.
While slower than Margrave (as expected), Pellet  nished all of the tests in a reasonable amount of time (veri cations took less than a second), thus exhibiting encouraging preliminary results.
Our results also show that the overhead of using OWL ontologies of di erent sizes to describe policy objects is manageable.
and Rule Combining Algorithms which have similar semantics.
For example, with the Deny-overrides Algorithm, if any of the child elements return Deny, then the  nal result is also Deny (no matter what the other children return).
Table 2.1.1 presents the most common combining algorithms.
Attributes are the most basic unit of a XACML policy.
They represent characteristics of the Subject, Resource, Action, or Environment in which the access request is made.
For example, a user s role, their name, the  le they want to access, the current date are all attribute values.
Access requests in XACML represent a list of attribute-value pairs.
We provide some datatype support for values of attributes.
More speci cally, we o er support for builtin and user-de ned XML Schema datatypes (currently we only support datetime and integer).
For example , we could state that age attribute can have value   18, or that it must be one of
 Rules are the most basic element of XACML that actually makes access decision.
Essentially, a Rule is a function that takes an access request as input and yields an access decision (Permit, Deny, or Not-Applicable).
To determine if a Rule is applicable to an access request, the Target element is used.
A Target is a set of simpli ed conditions for the Subject, Resource and Action that must be met for a Rule to apply to a given request.
These use boolean functions to compare values found in a request with those included in the Target.
Example of a rule that returns Deny for access requests that have value read value for action attribute is given below: <Rule RuleId="rule" Effect="Deny"> <Target> <Subjects><AnySubject/></Subjects> <Resources><AnyResource/></Resources> <Actions> <ActionMatch MatchId="function:string-equal"> <AttributeValue DataType="#string">read</AttributeValue> <ActionAttributeDesignator AttributeId="action" DataType="...#string"/> </ActionMatch> </Actions> </Target> </Rule> In this section we provide an overview of XACML (version 2.0 [7]), with focus on the subset of the language that we support.
At the end of the section we will discuss the XACML features that we do not support.
At the root of all XACML policies is a Policy or a PolicySet.
A PolicySet is a container that can hold other Policies or PolicySets, as well as references to policies found in remote locations.
A Policy represents a single access control policy, expressed through a set of Rules.
Each XACML policy document contains exactly one Policy or PolicySet root element.
Because a Policy or PolicySet may contain multiple policies or Rules, each of which may evaluate to di erent access control decisions, XACML needs some way of combining the decisions each makes.
This is accomplished using a collection of combining algorithms, where each algorithm represents a di erent way of combining multiple access decisions into a single one.
There are Policy Combining Algorithms As shorthand notation, we will express a XACML Rule as a triple r = (Target, AD, P ) where AD is a Permit or a Deny, and P is the parent Policy or PolicySet.
We also support the Hierarchical Role-based Access Control Pro le of XACML [3], which allows us to specify inheritance relationships between roles.
For example, Role A may be de ned to inherit all permissions associated with Role B.
In this case, Role A is considered to be senior to Role B in the role hierarchy.
As for the part of XACML that we do not support, this includes multi-subject requests, complex attribute functions, rule Conditions and some combining algorithms (see Table 2.1.1).
While some features (like complex Conditions) may be impossible to analyze at development time, there are others which we believe could be handled in our formalization (some types of Conditions, more expressive datatypes and the Only-one-applicable overriding algorithm)   this is part of our ongoing work.
Permit-overrides Deny-overrides First-applicable Only-one-applicable Ordered-permit-overrides Ordered-deny-overrides Summary If any rule evaluates to Permit, then the  nal decision is also Permit.
If any rule evaluates to Deny, then the  nal decision is also Deny.
The e ect of the  rst rule that applies is the decision of the policy.
The rules must be evaluated in the order that they are listed.
If more than one rule is applicable, return Indeterminate.
Otherwise return the access decision of the applicable rule Same as Permit-Overrides, except the order in which rules are evaluated is the same as the order in which they are in the policy.
Same as Deny-Overrides, except the order in which rules are evaluated is the same as the order in which they are in the policy.
Supported yes yes yes Table 1: Rule Combining Algorithms.
Third column indicates whether the particular combining algorithm is supported in our formalization.
the syntax and semantics of a commonly used logic (SHOIN ).
In this section we provide an overview of DL and present In DL, the domain of interest is modeled using individuals, concepts and roles2, denoting objects of the domain, unary predicates and binary predicates respectively.
Atomic concepts (C) and atomic roles (R) are elementary descriptions and complex ones can be built on top of them using constructors.
The available concept constructors determine the expressive power of the description logic in question.
For example, in SHOIN the following constructors are available: C   A| C|C1 u C2|C1 t C2| R.C| R.C| ./ nS|{a} where A is an atomic concept, a is an individual, C(i) a SHOIN concept, R a role, S a simple role3 and ./  { ,  }.
We write > and   to abbreviate C t  C and C u  C respectively.
For C, D concepts, a concept inclusion axiom is an expression of the form C v D. A TBox T is a  nite set of concept inclusion axioms.
An ABox A is a  nite set of concept assertions of the form C(a) (where C can be an arbitrary concept expression) and role assertions of the form R(a, b).
An interpretation I is a pair I = (W, .I), where W is a nonempty set, called the domain of the interpretation, and .I is the interpretation function.
The interpretation function assigns to each atomic concept A a subset of W, to each role R a subset of of W  W and to each individual a an element of W. The interpretation function is extended to complex roles and concepts as given in [10].
The satisfaction of a SHOIN axiom   in an interpretation I, denoted I |=   is de ned as follows: (1) I |= R1 v R2 i  (R1)I   (R2)I; (2) I |= T rans(R) i  for every a, b, c   W, if (a, b)   RI and (b, c)   RI, then (a, c)   RI; (3) I |= C v D i  CI   DI; The interpretation I is a model of the RBox R (respectively of the TBox T) if it satis es all the axioms in R (respectively T).
I is a model of K = (T, R), denoted by I |= K, i  I is a model of T and R.
For this work, it is important to discuss two basic reasoning services o ered by DL: satis ability and subsumption.
Determining satis ability of a concept C in a KB K amounts
 are binary predicates, and roles in access control, which are usually unary predicates.
We will refer to either of these as roles only when clear from context.
to a check whether K admits a model in which the interpretation of C is nonempty.
Subsumption between two concepts C and D in K, amounts to a check whether CI   DI for every interpretation I of K, denoted as K |= C v D. Sub-sumption is reduced to concept satis ability as follows: C is subsumed by D in K i  C u  D is not satis able in K.
In this section we will introduce an example which will be used throughout the paper to illustrate the services that our formalization provides.
In this toy example, initially there are two security roles, Manager and Developer ; one resource: Report; and two actions: read, write.
The root policy set contains two policy sets which are combined using First-applicable combining algorithm.
The policy is presented in graphical form in  gure 1.
Figure 1: Example Policy The safety property for this example is: Developers cannot write to Reports.
Checking the example policy against this property with Pellet produces a fail, with the following counter example returned: role=Manager, role=Developer, action=write, resource=report Thus, if a requester comes along that is a member of both security roles (Manager and Developer ), then she can gain write access to Report.
To prevent a Developer who is masquerading as a Manager from writing to Report, we use a both Manager and Developer role at the same time.
However, the policy fails to satisfy the property even after adding the above constraint.
This time, the counter example given is: role=Developer, action=write, action=read, resource=report Apparently, there is another way for a Developer to gain write access: if he tries to both read and write to Report at the same time.
To prevent this from happening, we can restrict R2 such that only one value (read ) is allowed for action attribute.
After adding this constraint the policy satis es the property.
With this simple policy we can also illustrate a new analysis service that we provide: policy redundancy.
A policy element is redundant if removing the element does not change the behavior of the access policy.
To understand our motivation for this service, consider Rule R4 in Figure 1.
R4 will always be overridden by R3 , since the policy combination is First-applicable, and the Target of R3 subsumes the Target of R4.
In a policy evaluation engine, R4 can be dropped without any consequences to the security policy.
This elimination of unnecessary Rules could potentially provide signi cant optimizations of the policy engine.
The above example illustrated only a subset of the services provided by our framework; a full list follows:   Constraints - We already mentioned separation of duty constraints.
In addition, we can also specify more general cardinality constraints; for example, a user cannot be a member of more than 3 security roles at a time.
Property (attribute) hierarchies are allowed as well: if X is a brother-of Y, then he is a relative-of
   Policy Comparison - For two policies (or policy sets) P1 and P2 check if whenever P1 yields a decision  , P2 will yield  , too.
If not, give a counter example.
  Policy Veri cation - Check if the policy satis es If not, give a counter-a particular policy property.
example.
  Policy Incompatibility - If for two policies P1 and P2, there cannot exist an access request where both policies apply (yield a decision), then these policies are incompatible.
  Policy Redundancy - For a policy and an access decision (Permit or Deny), check whether the policy can ever satisfy that decision (or it will be always overridden by some other policy higher up the hierarchy).
  Policy Querying - Search for policies in the document based on attribute values.
The basic unit in XACML that yields an access decision is a Rule.
To capture the behavior of XACML correctly, we need to formalize the prerequisite of the Rule (which is the Target element), and its head (the access decision).
We also need to capture how the access decision is propagated upwards toward the root PolicySet - for this, the rule and policy combining algorithms have to be taken into account.
While the Target element of Rules and Requests can be mapped to a DL concept expression (we discuss this in more detail below), the interaction of the access decision of various policy elements is di cult, if not impossible, to do using only description logics.
This is because of the semantics of the combining algorithms which requires us to use a formalism that supports preferences.
To capture the behavior of the XACML combining algorithms, we use Defeasible description logics (DDL [16]), which is a formalism that allows for expressing defeasible rules on top of description logics.
Only a limited fragment of DDL is needed to formalize the combining algorithm.
In Section 4.1 we provide the description of this fragment.
Then, we formalize the four main policy elements in XACML: Rules, Requests, Policies and PolicySets.
Considering the obvious similarities between some of them (and for better presentation), we have grouped them in two: Rules with Requests and Policies with PolicySets .
Finally, in Section 4.4 we show how it is possible to reason about XACML policies in this formalization using DL reasoners.
The subset of DDL that we use, termed DDL , is expressive enough for our purposes and at the same time has the same computational complexity as the underlying description logics [16].
We represent a rule in DDL  as P re(r) 7  Con(r), (P re(r) and Con(r) obviosly referring to the antecedent and consequent).
In DDL , we do not allow any predicates from the DL KB in the head of the rules.
Instead, for each policy or policy set P , we create two literals, which we call e ect-literals : P ermit-P, Deny-P   L. If the theory derives that P ermit-P (r) for some request r, that means we inferred a Permit access decision for policy element P to request r.
To distinguish these literals for di erent policy elements, we append the policy element id to the literal name.
Instead of denoting it as P ermit-id(P ) we abuse notation and simply write P ermit-P .
Note here that only e ect-literals are allowed in heads of rules in R.
A set of rules R can contain both strict and defeasible rules.
Strict rules cannot be overridden: whenever the body of the rule is derived, the head is derived as well.
With de-feasible rules, even though the body of the rule might be derived, the rule might still be overridden by another con icting, higher priority rule.
Following we give a de nition of strict and defeasible rules that takes into account XACML s combining algorithms.
De nition 1.
For each rule r   R, let P, Ppar correspond to the policy element and its parent in the XACML document.
r is a strict rule in the following cases:
 rithm of Ppar is Permit-overrides
 of Ppar is Deny-overrides
 and the combining algorithm of Ppar is First-applicable All other rules in R are defeasible.
where K is a DL knowledge base, R = Rs   Rd a  nite set that contains strict and defeasible rules , > a superiority relation on R, and L a set of e ect-literals used in the rules of R.
Following we provide procedural semantics for the defea-sible theory (derived from [16]).
A derivation (proof) is a  nite sequence P = (P (1), .
.
.
, P (n)) of literals that belong to L. Conclusion in a DDL  theory is a set of tagged e ect-literals.
We have only two tags: for a literal l, +l means l was derived, and l means it cannot be derived.
We use D     i  there is a derivation sequence P = (P (1), .
.
.
, P (n)) s.t.
+    P ; we say that   is provable in D.
If P (i + 1) = +l then either (1)  r   Rs s.t.
K |= P re(r) or P re(r)   P (1..i) l   Con(r) and (2)or  r   Rd s.t.
l   Con(r) and  q   (Rd   Rs) s.t.
Con(q) v  Con(r) either K |= P re(r) or P re(r)   P (1..i) K 6|= P re(q) and P re(q) 6  P (1..i) or r > q Figure 2: Derivation Procedure Figure 2 gives the procedural semantics for the derivation.
In (1), which is the strict rule case, we infer l if there exist a strict rule that concludes l and the prerequisite of that rule is either entailed by the DL knowledge base or was derived before in this proof.
The defeasible rule case is more involved: we also need to make sure that the defeasible rule that infers l is not also overridden by a con icting rule with a higher priority.
Deriving that a literal cannot be proven from a DDL  theory is similar to above, but all of the conditions are negated (de ned as strong negation in [16]).
We omit the procedural semantics here for brevity and point the interested reader to [13].
A XACML Rule is translated to a rule in R. The Target element is translated to a DL concept expression C and becomes the antecedent of the new rule.
The Effect is mapped to an e ect-literal L   L and becomes the conclusion.
The e ect-literal can be either P ermit-P or Deny-P where P is the Policy that contains the Rule.
This new rule, denoted C 7  L, is added to R. For any policy P and rules r1, r2 s.t.
P ermit-P   Con(r1) and Deny-P   Con(r2), we state that r1 and r2 are con icting.
The full mapping of the Target element to a DL concept expression is given in Table 2.
The main idea is that attribute-value pairs are mapped to existential restrictions   for example (role Developer ) would be mapped to  role.Developer.
We also allow for propositional combinations of attribute-value pairs.
Note here that we enforce a one-to-one mapping from attribute names and values used in the XACML policy to their corresponding DL roles and concepts in K (we create a DL role or a concept with the same name as the XACML attribute or value).
possible attribute values for that attribute.
For example, formalizing Any using this mapping would create 15 dis-juncts (there are 3 attributes and 5 attribute values).
By assuming that the values for role, action and resource attributes are disjoint, we can prune the search space signi -cantly (see how the Any occurring in the running example is mapped below).
Example 1.
The rules in our running example are mapped to: R1 :  role.M anager u  resource.Reportu ( action-type.read t  action-type.write) 7  P ermit-P1 R2 :  role.Developer u  action-type.readu  resource.Report 7  P ermit-P1 R3 :  role.M anager t  role.Developer t  action.W rite t  action.read t  resource.Report 7  Deny-P1 R4 :  role.Developer u  action-type.write u  resource.Report 7  P ermit-P2 XACML requests are mapped in the same manner as rules, since they also can be represented as a list of attribute value pairs.
To check whether a request r matches a rule with target T , we only need to check whether K |=  (T )(r) (equivalent to instance checking in description logics).
To propagate the access decisions from Rules to the root PolicySet, we introduce the following rules in R:
 axiom to R, R = R   { (T arget) 7  Deny-P}
 axiom to R, R = R   { (T arget) 7  P ermit-P}
 P S introduce the following axioms: P ermit-P 7  P ermit-P S Deny-P 7  Deny-P S A Policy or a PolicySet can also have a Target element.
However, we can propagate the constraints speci ed in Target down to Targets of its children.
In this manner, we propagate the constraints to the XACML Rule elements.
Thus, without loss of generality, we can assume that Policy and PolicySet elements have empty Target   all of the constraints are propagated down to the Target of their XACML Rules descendants.
ample to a DDL  theory.
In Table 3, we provide the full translation of our toy ex-For the XACML construct Any, we formalize it as a dis-junction where each disjunct corresponds to an attribute.
For each attribute, we create another disjunction from all This section provides an important result: an algorithm to reduce derivability in DDL  to concept satis ability in description logics.
In particular, for a e ect-literal   we will
 R ::= (Rule T E ect) E ect ::= Permit | Deny T ::= ((Sub) (Act) (Res)) Sub | Act | Res ::= Fcn Fcn ::= AV | Fcn   Fcn | Fcn   Fcn |   Fcn AV ::= (attr-id attr-val) attr-id attr-value    (T ) 7   (E ect) P ermit-P | Deny-P (P is parent policy)  (Sub) u  (Act) u  (Res)  (F cn)  (AV )| (F cn) u  (F cn)| (F cn) t  (F cn)| (F cn)  (attr-id). (attr-val) DL role corresponding to attr-id DL concept corresponding to attr-val Table 2: Mapping Rule to a DL class expression Diagram Formalization
 P1 : P ermit-P 1 7  P ermit-P S1, P2 : Deny-P 1 7  Deny-P S1, P3 : P ermit-P S2 7  P ermit-P S1, P4 : Deny-P S2 7  Deny-P S1, P5 : P ermit-P 2 7  P ermit-P S2, P6 : Deny-P 2 7  Deny-P S2 R1 :  role.M anager u  resource.Report u R2 :  role.Developer u  action-type.read u R3 :  role.M anager t  role.Developer t ( action.read t  action-type.write) 7  P ermit-P1  resource.Report 7  P ermit-P1  action.W rite t  action.read t  resource.Report 7  Deny-P1  resource.Report 7  P ermit-P2} R4 :  role.Developer u  action-type.write u   = {P1 > P4, P2 > P3, R1 > R3, R2 > R3} L = {P ermit-P S1, Deny-P S1, P ermit-P S2, Deny-P S2, P ermit-P 1, Deny-P 1, P ermit-P 2, Deny-P 2} Table 3: Mapping the example access control policy to a DDL  theory.
show how to generate a DL concept expression A in K s.t.
  is derivable in D i  A is satis able in K.
First we will illustrate the intuition with a simple example.
In the following DDL  theory: r1 : A 7  P ermit-1, r2 : B 7  Deny-1, r1 < r2 we have only two rules whose prerequisites are DL expressions A and B.
To check if P ermit-1 can be derived, we need to check if the concept A is satis able (since it is the only way to derive P ermit-1).
However, this alone is not enough, since r1 can be overridden by r2.
Thus, we need to check the satis ability of: A u  B.
If this expression is satis able, then there can exist an access request such that it satis es A and not B.
If this expression was unsatis able, then there would be no possibility of deriving P ermit-1 since it would always be overridden by r2.
The transformation function that takes a DDL  theory D and an e ect-literal l as input, and generates a DL concept expression is given below: De nition 3.
If a 6  L, then map(a) = a.
When a   L, there are two cases - it is a Permit e ect-literal or a Deny e ect-literal.
For a Permit e ect-literal, map(a) =F(map(C) u  (F map(J))) where   C 7  P ermit-P   R   J 7  Deny-P   R
 for some P ermit-P , Deny-P .
map(a) is de ned analogously for Deny e ect-literals.
Theorem 1.
For a DDL  theory D = (K,R, >,L) and literal     L, map( ) is satis able i  there exists a request i s.t.
D   + (i) (  is provable).
 map( ) is satis able i  there is a request j s.t.
D    (j) (  is not always provable).
Proof of this theorem is available in the accompanying report [13].
One of the distinguishing features of our mapping is that the subjects, actions and resources used in the access policies are mapped to DL concepts and roles.
As a result, we can extend the access policy with semantic descriptions of the policy domain.
In other words, we can use a domain ontology (expressed in DL) to provide a semantic description for the entities used in the access policy.
If the policy is about Managers, Developers and Reports, we can have an ontology that describes the company, and link the policy entities with concepts in the company ontology using subclass relationships.
For example, we can state that a Manager is an Employee that is a boss of at least one Person: M anager v Employee u  boss.P erson Using such ontologies, we show how common policy idioms can be expressed in description logics:
 ioms.
For example, stating that a LeadDeveloper inherits all of the access privileges of the Developer role can be expressed as:  role.LeadDeveloper v  role.Developer
 erty hierarchies in DL.
For example, to state that if a person is a CIO of a company, that means he is also an employee of that company, we write: CIO-of v employee-of To determine whether P1 v P2, we try to build a request i s.t.
D   P ermit-P1(i) and D 6  P ermit-P2(i).
If it is possible to build a request s.t.
P ermit-P1(i) was derived, and P ermit-P2(i) was not derived, then P1 6v P2.
Translating to DL expressions, this reduces to checking whether the concept map(P ermit-P1)u map(P ermit-P2) is satis able.
If the concept is satis able, such request exists.
As an example, consider adding a new security role , LeadDeveloper, to our running example.
The updated policy now contains an additional Rule:  role.LeadDev u  action.write u  resource.Report 7  P ermit-P1 Figure 3: Updated Policy (with LeadDev role)
 disjoint axioms.
To state separation of duty for two security role A and B, we use: To check whether we have given any unintended access to other roles, we use the policy subsumption algorithm, that is, we generate the following concept expressions:  role.A v  role.B
 attribute.
To state that the role attribute cannot have more than k values, we can write:   k role.> v   We can even specify maximum number of users that a security role can have, with a combination of inverses and cardinality constraints.
For example, the following says that a role cannot have more than k users:   k role .> v  

 In this section be provide an overview of the analysis services provided by our formalization.
map(P ermit-P Sold), map(Deny-P Snew), map(P ermit-P Sold), map(Deny-P Snew) Subsumption holds only both of the following hold: map(P ermit-P Sold) v map(P ermit-P Snew) map(Deny-P Sold) v map(Deny-P Snew) Pellet reports the  rst statement is true, which is obvious from looking at the Rules themselves (the Rule that we added in P Snew yields a Permit).
However, Pellet reports subsumption does not hold w.r.t.
Deny.
In cases of non-subsumption, it is useful to know what are the counter examples, i.e., to show the user a request where P Snew and P Sold would yield di erent decisions.
Since we use a tableau-based DL reasoner for policy analysis, to check whether A v B, we try to build a representation of a model for A u  B.
If such representation can be built, it means the subsumption does not hold.
In that case the completion graph (representation of the model) just built can easily be extracted from the internals of the reasoner and used as a counter example.
Here we get several counterexamples: The map function de ned above allows us to easily compare the behaviors of two policies.
For example, we can check for policy subsumption: P2 subsumes P1 (P1 v P2) if whenever P1 produces access decision  , P2 also yields the same access decision.
We can restrict our attention to P ermit, Deny or both.
action=write, resource=report

 resource=report rule), however the third counter example represents a potentially dangerous access leak to a person who is a member of role Developer.
It is possible to  x this bug by separating the roles of Developer and LeadDev:  role.LeadDev v  role.Developer We can generalize the technique used for policy subsump-tion to policy comparison.
For two policies P1 and P2, we  rst specify the access decisions we are interested in (say, Deny for the  rst policy and Permit for the second), and then check satis ability of the map expressions for those decisions : map(P ermit-P Sold) u map(Deny-P Snew) If the above expression is not satis able, then there cannot be an access request s.t.
the  rst policy yields a Deny and the second one yields a Permit.
If it is satis able, there is such an access request, and we can extract the counter example from the internals of the reasoner.
To get all counter examples, we need to retrieve all open and complete completion graphs (representations of models) that the concept expression admits; this involves saturation of the tableau, a technique for which DL reasoners are not particularly optimized.
Finally, the service of verifying changes was introduced in [6], we show here that it can be accomplished using description logics as well.
The safety properties that are to be checked are simply added to the conjunction of the map expressions.
For example, if we want to verify that there were all of the changes from Permit to Deny in the above policy involved the LeadDev role, we could test the following concept expression: map(P ermit-P Sold)umap(Deny-P Snew)u role. LeadDev
 Another service we provide is determining redundant Rules4 Intuitively, a redundant rule is one that whenever  res, it is always overridden by some other rule or policy with higher priority in the hierarchy.
It does not matter whether the rule is part of the policy document or not   in both cases, for any access request i, the evaluation engine will give identical results.
A simple way to check redundancy of a rule r is to perform change impact analysis for a policy with and without the rule.
However, there is a more optimal way of checking redundancy, by building a concept expression that ignores the policy elements that cannot override the rule we are checking.
Algorithm 1 contains the pseudo-code.
The function starts with an input Rule r and works its way up to the root policy element.
At the same time, it builds a disjunction, that consists of the concept expressions for every Policy or PolicySet that can override the access decision made by r. If the prerequisite of r is subsumed by this disjunction, then we know for certain that the access decision of r will always be overridden by some policy element.
In this case, r is redundant.
Redundant rules do not have to be evaluated, and can be safely removed from a policy  le.
This simpli es the policy and improves runtime performance of the policy evaluator because there are less rules to match requests against.
PolicySets   for brevity we focus on Rules only.
Algorithm 1 is redundant(r,D) Input: r: defeasible rule of the form T 7    D: DDL  theory D = (K,R, >,L) Output: b: returns true if r is redundant, false otherwise .
cache r .
q can override r .
request is subsumed J   J t map(P re(q)) where

 2: rold   r 3: while true do
 q   R and
 parent(q) = parent(r) and
 q > r
 if parent(r) 6= null then
 r   getP arentRule(r)



 end if 13: end while

 16: else
 18: end if return false else break return true
 We allow for speci cation and formal veri cation of properties of policies.
We admit policy properties of the same form as rules, i.e, they have a DL concept expression as body and a Deny or Permit as head.
To check whether a policy P satis es a property,  rst we compute map(P ermit-P ) and map(Deny-P ) using the techniques described in Section 4.4.
Then, we try to build a ( nite representation of a) model where a request can match both the policy property and the map concept for the e ect-literal that has the opposite access decision than the policy property.
If the expression is not satis able, then the policy is formally veri ed against the property.
If the expression is satis able, the model that is built is returned as a counter example.
When specifying properties, we can use the full expressiveness of description logics.
For example, we can state that the a user who is not a Manager and is less than 25 years old is not allowed to do perform more than one action at a time:  role. M anager u  age.
 21 u > 1action 7  Deny

 We have implemented a prototype XACML analysis tool on top of open source DL reasoner Pellet.
As a test case, we used the access policy for the conference paper manager Continue.
The authors of Margrave [6] translated this policy to XACML, used it to test their analyzer and published the policy at [1].
This realistic access policy was used to evaluate the correctness and performance of our tool as well.
Parsing the policy  le using sunxacml and loading the policy ontology took 2.1 seconds.
Converting the policies to description logics took additional 1.7 seconds.
For the purpose of this paper, we tested veri cation of properties.
There are 12 safety properties for the Continue policy.
We encoded them in description logics and used Example 2.
A sample property from the set is: If a subject is not a pc-chair or admin, then he may not set the meeting  ag.
This can be encoded in DL as: P    ( role.pc-chair t  role.admin)u  action.write u  resource.meetingF lag P can be veri ed by checking the concept satis ability of map(P ermit)uP where map(P ermit) is the concept expression corresponding to access requests that map to P ermit (details on map function in Section 4.4).
If map(P ermit)u P is not satis able, then property P holds for the policy.
It is important noting that, to improve performance, tableau reasoners reduce concept expressions to a simpli ed normal form before checking concept satis ability.
Due to the sheer size of the concept expressions returned from our mapping function (the XACML construct Any dramatically increases the size of the DL representation, and it is used liberally in Continue) this function proved to be the bottleneck of the analyzer.
To alleviate the issue we extracted the simpli cation function outside the veri cation algorithm - so once the concept expression is reduced to normal form when verifying property A, there is no need to do it again for other properties.
This produced signi cant time savings overall.
Preprocessing the concept expressions in Pellet took 10.6 seconds, while veri cation of the properties took .420 seconds on average.
For comparison, Margrave s loading and preprocessing time was 0.9 seconds, and the properties were veri ed in less than a millisecond.
Pellet s performance is worse since it is optimized for reasoning about a more expressive logic than Margrave.
Nonetheless, considering that veri cation time was still under half a second, we consider the results to be suitable for practical purposes.
Next, to evaluate the overhead of integrating the access control policy with a domain ontology, we tested Continue with three ontologies with various sizes.
For the evaluation, we simply added subclass relationship between the concepts in the access policy and random concepts from the domain ontology.
The goal was to simulate reasoning about policies when their concepts have rich domain descriptions expressed in DL.
Results are in Table 4.
Overhead is noticeable only in the cases of Galen, which is a quite large ontology.
Ontology Name no-ont koala lubm tambis galen Ontology Info





 P Classif.
Performance Initial Verif.
Table 4: Reasoning about policies with domain on-tologies.
C, P, Classif.
stand for number of DL concepts, roles and classi cation time respectively.
We added subclass relationships connecting every concept in the policy with a random concept from the ontology.
The  rst row represents the case without a domain ontology.
For future work, we intend to extend our coverage of XACML even further: adding Only-one-applicable as a combining algorithm and handling more attribute functions using speci c datatype reasoners are some of our short term goals.
We believe that Only-one-applicable can be handled simply by adding additional defeasible rules in our framework (we will need to extend the map function as well).
As for datatype reasoning, user-de ned datatypes are part of OWL 1.1 [8] and are already implemented in Pellet.
Currently, there is support for datetime and integer user-de ned XML Schema Datatypes and common datatype facets (min-Inclusive, maxInclusive).
We plan to add more expressive datetime datatype support to allow for policies with periodicity constraints.
For example: Permit access only on every other Friday form 5PM-6PM starting from today, unless it is a national holiday.
Logic programming systems seem to be a popular choice for formalization of access control policy languages, which is not surprising considering logic programming is a mature research area, with e cient implementations, and rules being the most natural way to model access control policies.
We used DL as the basis for the formalization instead because of the correspondence of policy analysis services to DL reasoning services, which allowed us to provide a variety of policy analysis services and leverage the availability of o -the-shelf DL reasoners optimized for these services.
Also, we have provided a set of services that, to the best of our knowledge, has not been o ered by rule-based policy systems.
Moving to DL based systems, Zhao et al [19] present a formalization of RBAC based on the description logic ALCQ.
They also show how RBAC policy constraints (separation of duty, security role hierarchies) can be captured with this logic.
We generalize their approach by formalizing a more expressive access control language (XACML uses overrid-ding algorithsm which are not covered by their approach) using a more expressive description logic (SHOIN ).
Massacci [14] formalizes RBAC using multi modal logic and presents a decision method based on analytic tableaux.
Because he is using tableau-based algorithms, he is able to provide services similar to ours: logical consequence, model generation and consistency checking of policies.
Again in this case, policy combining algorithms are not taken into account, so it is not applicable to XACML.
Hughes et al. [11] propose a framework for automated ver-i cation of access control policies based on relational First-Order Logic.
They introduce a formal model for systematically specifying access to resources, and show that the access control policies in XACML can be translated to a simple form which partitions the input domain to four classes: permit, deny, error, and not-applicable.
The authors show how to automatically verify policies using an existing automated analysis tool, Alloy [12].
Because using the  rst-order constructs of Alloy to model XACML policies is prohibitively expensive (in terms of performance), the authors use only the propositional constructs.
However, it is unclear from their results whether it is feasible for larger policies.
In addition, the results of policy analysis are an internal Alloy representation that can only be explored with Alloy s visualization tools.
which can be used to evaluate access control policies, and a tool which implements it.
The evaluation includes not only assessing whether the policies give legitimate users enough permissions to reach their goals, but also checking whether the policies prevent intruders from reaching their malicious goals.
Policies of the access control system and goals of agents are described in the access control description and speci cation language RW [9].
Finally, in terms of services o erred, Margrave [6] is the tool most similar to ours.
Margrave is a software suite for analyzing role-based access-control policies.
It includes a veri er that analyzes policies written in XACML, translating them into a binary decision-diagram to answer queries.
It also provides semantic di erencing information between versions of policies.
On one hand, by using description log-ics to analyze policies, we sacri ce some of the performance compared to Margrave.
Although, results show that our approach is still practical.
Also, we have not evaluated yet comprehensive change analysis, where all access requests that map to di erent access decisions are returned.
On the other hand, by having DL-based formalization we are able to provide expressive descriptions of the subjects, resources and actions that are referred to in the policies, and o er support for XML Schema datatypes.
Understanding the e ects and consequences of sets of access control policies has always been an issue for security o cers, especially with expressive policy languages.
In this paper, we addressed this issue for XACML by proposing a formalization based on a decidable fragment of FOL.
We were able to provide a similar suite of analysis services such as propositional logic-based tools, while adding extra expressiveness by describing subjects, actions and resources using ontologies.
We also showed how common policy constraints, such as role cardinality, separation of duty and role hierarchies can be easily captures by these logics.
Finally, we demonstrated through empirical evaluation that o  the shelf DL reasoners are practical as XACML analysis tools.
This work was supported in part by grants from Fujitsu, Lockheed Martin, NTT Corp., Kevric Corp., SAIC, the National Science Foundation, the National Geospatial-Intelligence Agency, DARPA, US Army Research Laboratory, and NIST.
The authors would like to thank Kathi Fisler, Christian Halaschek-Wiener, Yarden Katz and Taowei Wang and for all of their comments and feedback.
We would also like to thank the authors of [6] for translating the Continue policy example to XACML, generating the policy safety properties and making them publicly available.
