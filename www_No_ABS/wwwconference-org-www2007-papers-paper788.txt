The eXtensible Markup Language (XML) has become the standard for data exchange, particularly on the web [26, 1].
An XML document is a linear representation of hierarchically structured data.
The latter is best viewed as a tree, with the edges of the tree encoding the hierarchy.
Hierarchically structured data can be encoded into linear structures in di erent ways; XML is the popular way, where the tree is represented using open-tags and close-tags, and the paran-thesis structure de ned by the tags encodes the hierarchical information.
Naturally, the study of XML has concentrated on the tree it represents; for example, document types are represented using the parse-trees generated by specialized DTDs [22], XML query languages have modalities like  parent  and  child  that refer to the tree edges, and tree au-tomata (over unranked trees) have been used to model and solve decision problems for XML [25, 20, 9, 11, 16].
An XML document is a linear word structure, and though formalisms based on the tree representation of the document are useful, they are awkward when designing algorithms for processing XML.
While one could take an XML document, convert it into a tree, and then apply algorithms for the tree, there are several settings where such changes of representation is not feasible.
One class of applications for which building the tree representation of a document is infeasible is in the processing of streams of large XML documents.
Streaming algorithms process input data as and when they arrive (for example, streaming stock market data), and have to process them with as little time and space as possible.
Building trees representing the document would make little sense.
Not surprisingly, streaming algorithms proposed for XML do not build the tree [7, 13], and in fact theoretical algorithms for streaming XML are often based on pushdown automata (not tree automata) [13, 24, 11].
However, there are no standard automata models for streaming XML; pushdown automata are not appealing as they do not de ne a robust tractable class of languages: they are not closed under complement, inclusion is undecidable, etc.
The main thesis of this paper is that visibly pushdown au-tomata (Vpa [4]) are the right model for processing streaming XML.
A Vpa is a pushdown automaton whose stack operations are determined by the input letter it reads.
An XML document is best seen as a nested word: a linear structure (word) with a nesting relation formed by associating open-tags with their matching close-tags.
A visibly push-down automaton can reconstruct the nesting relation by pushing onto the stack on open-tags and popping from it on automata, de ne a robust class of languages.
The class is closed under all boolean operations, admits decidable procedures for problems such as inclusion and emptiness, and we can show that it is precisely as powerful as regular tree languages accepting the tree representation of the data [4].
The most important feature is that these automata are de-terminizable, which will help us in building streaming algorithms.
Furthermore, recent work on visibly pushdown languages have exposed several interesting results including a congruence based characterization and minimization results that use a modular notion of these automata.
These results a rm the view that this class is very similar in tractability and robustness to that of regular word languages.
In this paper, we argue that visibly pushdown automata are an apt model for XML by studying algorithms for streaming XML documents.
We demonstrate the use of VPAs in solving two main problems: (a) type-checking streaming XML documents against SDTDs (specialized datatype definitions) [22], and of assigning types to tags while streaming the document, and (b) in querying pre x based queries on XML streams, where the problem is to anwer the set of all positions satisfying queries that are determined by the pre x leading to a position.
An SDTD (which extends the notion of DTDs) de nes a class of XML documents using an extended context-free grammar.
The  rst result in this paper is a visibly pushdown automaton model tailored for XML: we de ne a notion of modular Vpa called XVPA (X for XML!)
that exactly corresponds to schema de ned by SDTDs.
This gives a natural machine characterization of SDTDs.
By applying results in the literature on visibly pushdown automata to XVPAs, in particular (a) determinability of VPAs [4], (b) the expressive power of deterministic single-entry modular VPAs [3], and (c) congruence-based minimization results for complete multi-entry modular VPAs [14], we derive (minimal) streaming machines.
We  rst study the problem of type-checking streaming XML documents against SDTDs.
Using the fact that Vpas can be determinized to get single-entry modular Vpas (Sevpas), we show that these automata type-check streaming XML documents against SDTD-de ned types.
Further, by combining the set of single-entry modules into a single module with multiple entries, Sevpas can be interpreted as complete multi-entry modular Vpas, for which we have recently obtained a minimization result [14].
Unlike the pushdown machines constructed in [24], we obtain provably minimal recognizers that optimize the number of states in two ways: they combine strucural conditions shared both between specializations of the same tag, and across di erent tags.
We then turn to the problem of typing a document.
For a document that conforms to an SDTD, the types associated with a tag are the specializations that admit a parsing of the document with respect to the SDTD.
Typing a document facilitates querying (for example, a query asking for all tags that have a particular specialization can be answered using such a typing).
We study the problem of assigning types to tags while reading a streaming XML document.
A tag is said to be pre-order typed if its type is unique and can be assigned as soon as meeting its open-tag; similarly, a tag is said to be post-order typed if its unique type is determined at the close-tag.
An SDTD is said to be pre-order typed if all its tags are pre-order typed in all documents that accord with the SDTD.
Pre-order typed SDTDs correspond to restrained competition grammars and have been syntactically and semantically characterized [18, 17].
We show automata-theoretic characterizations of pre- and post-order typed schemas 1.
The characterization of pre-order typed schemas is beautifully simple in terms of XVPAs: a schema is pre-order typed if and only if it can be accepted by a deterministic XVPA.
This is a very natural and intuitive characterization  when reading an open-tag, the XVPA must be able to determine the type of the tag and hence call the appropriate module deterministically.
We then turn to dynamically typing streaming documents.
Even though a schema may not be pre-order typed, some or all of its tags may be pre-order typed in a particular document.
We show that for any SDTD, we can build a deterministic VPA that reads streaming XML documents, and dynamically pre-order types the open-tags whenever possible.
More precisely, if in the current document read, the type of a tag is determined by the pre x of the document read thus far, then the automaton will determine its type when reading the open-tag.
We also prove a similar result for partially post-order typing documents at close-tags for streaming documents.
We also show that checking if a tag is pre-order typed in an SDTD (across all documents) is decidable in polynomial time.
Finally, we generalize the results on pre-order and post-order typing to pre x querying.
We consider monadic queries expressed in a sub-logic of monadic second order logic (MSO), which we call Pre-MSO.
Queries here are MSO formulas with one free variable, where all quanti ed positions are required to occur before the position denoted by the free variable.
We show that for such queries, determining if a position in a document satis es a query depends solely on the tags seen before the position.
Furthermore, for any such query we can build a deterministic VPA that can answer such queries while processing an XML document in a streaming fashion.
Since the problems of dynamically typing (pre-order and post-order) can be expressed in our logic Pre-MSO, our observations on pre-order and post-order typing can be seen as a consequence of these results.
However, our direct constructions for the pre-order and post-order typing are more e -cient in terms of the resources used by the resulting streaming algorithm.
There has been a previous characterization of queries that can be answered by a 1-pass streaming algorithm (see [19]) in terms of constraint systems and pushdown forest automata; our results in terms of Pre-MSO and VPAs can be seen a reformulation of the Neumann-Seidl result in terms of logic and pushdown machines on words.
In summary, VPAs emerge as a simple apt model for processing XML, particularly in the design of streaming algorithms.
The rich set of results obtained for visibly pushdown languages, including determinization and minimization of modular machines,  nd immediate use in designing streaming algorithms for XML.
We have already several other results which we have not reported here (including results on typability, improved complexity of static type-checking, etc.)
that we have proved using the VPA model; these and proofs of the theorems in this paper can be found in the technical report [15].
Related work in automata theory: Viewing XML doc-
by an SDTD.
We do not mean the language  XML Schema .
b  ).
A word u  b b b b uments as trees, visibly pushdown automata correspond to automata that process trees by reading them on an in x traversal, using a stack to push whenever they go down a left branch, and popping it when they return to process the right branch.
The notion of visibly pushdown automata have been used implicitly in processing XML streams in the literature (in [24, 9, 19, 10] and as XPush machines in [11]).
Note that there is only one copy of the automaton processing the tree (in contrast to tree automata).
An alternate model de ned in the literature is tree-walking automata [2, 21], which essentially has only one copy of the automaton but can walk up and down the input tree.
However these au-tomata do not have access to a stack and are strictly weaker than tree automata in expressive power [6].
In contrast, visibly pushdown automata capture the entire class of regular tree languages [4].
Let   be a  xed  nite alphabet of  open tags , and let   = {c | c    } be the corresponding alphabet of  close   = (     ).
XML documents will be treated as tags .
Let words over the input alphabet
 b b A well-matched word is any word generated by the grammar: W   cW c, W   W W , W    , where we have a rule W   cW c for every c    .
The grammars and automata we consider in this paper will always accept only languages of well-matched words.
The set of all well-matched words   is said to over have matched closing tags if there is some w   WM (  ) such that u is a pre x of w. The set of all words with matched returns (closing tags) will be denoted by MR(   will be denoted by WM (
 Document-type de nitions (DTDs) de ne restrictions on the structure of documents.
These de nitions hence describe languages over  , that correspond to the documents that accord with the document type.
Since DTDs are not powerful enough, we use in this paper an extended version of DTDs called specialized document-type de nitions (SDTDs) [22].
We give pushdown automata based descriptions of these languages, which are a subclass of context-free languages.
An SDTD is essentially a context-free grammar; however, each non-terminal of the SDTD is associated with a tag, and the idea is that every non-terminal implicitly generates the open-tag (c) and close-tag (c) whenever the non-terminal is expanded.
Non-terminals are called  specializations  in the XML context, and we will also call them  modules  in this paper.
Let M be a  nite set of specializations or modules and let   : M     be a surjective mapping.
Elements of  1(c) correspond to specializations of symbol c, and   is the mapping between the specialized alphabet M and the unspecialized alphabet  .
SDTDs will be speci ed using extended context-free grammars.
An extended context-free grammar d is a set of rules that map each m   M to a regular expression over M .
We now de ne its semantics.
Let us denote M = {m | m   M }.
For every m   M , we de ne Lspl d (m)   (M   M )  as the smallest sets such that Lspl d (m)   {m.x.m | x   Rd(w), w   d(m)} where: (1) Rd( ) = { }, and (2) Rd(m.w) = Lspl d (m).Rd(w).
The language over unspecialized symbols that m de nes d (m)}, where   is extended is then Ld(m) = { (w) | w   Lspl to words over (M   M )  in the obvious way:  (m) =  (m) and  (m.w) =  (m). (w).
Definition 1 (SDTD).
An SDTD over ( , M,  ) is a tuple (d, m0), where d is a mapping from M to regular expressions over M , and m0 is the start symbol.
The language of an SDTD (d, m0) is de ned as Ld(m0).
The size of an SDTD (d, m0) is de ned as the sum of the lengths of the regular expressions de ned by d.
Example 1.
Let   = {movie, vhs, dvd , title, lang, subtitle}, and let the specialized alphabet be M = {Movie, VHS , DVD, Title, Lang, Unisub, Multsub} where   : M     is de ned so that Unisub and Multsub are specializations of subtitle, and capitalized names are specializations of their uncapitalized counterparts.
Finally, let d be de ned as follows: d(Movie) = VHS + DVD d(VHS ) = Title.Unisub d(DVD) = Title.
(Unisub + Multsub) d(Title) =   d(Unisub) = Lang d(Multsub) = Lang.Lang + d(Lang) =   Then (d, Movie) is an SDTD over ( , M,  ) accepting words like: movie.dvd.title.title.subtitle.lang.lang .lang.lang .subtitle .dvd .movie Type-checking and typing XML documents The two problems we consider in this paper are type-checking streaming XML documents, and pre- and post-order typing of XML documents.
We de ne these notions now.
Given an SDTD, and a document that accords to the type de ned by the SDTD, a tag c in the document can get different types depending on how the document parses.
More (d, m0), and w[i] = c    , then we say that (w, i) has type m (where m is a specialization), if there exists x   Lspl d (m0) such that  (x) = w and x[i] = m.
In general, (w, i) can have many types with respect to an SDTD.
The type-checking problem is to check, given an SDTD, whether an input document belongs to the language of the SDTD.
In the streaming context, we assume that the document is presented as a word, and the type-checking must be accomplished reading the word only once, left to right, and using as little time and space as possible.
precisely, if w  b  belongs to the language of an SDTD b for all v   b An occurrence of an open (or close) tag in a document is pre x typed (with respect to a schema) if the tag s type is determined by the pre x of the document till that point.
Pre-order typing refers to open tags being pre x typed while post-order typing refers to close tags being pre x typed.
Definition 2.
For an open or close tag a    , we say a is pre x typed at position i in w   WM (  ), if w = uav, |ua| = i, and if there is a unique m    1(a) such that  , whenever uav    Ld(m0) and (uav , |ua|) has type m , then m  = m. In this case, we say that a has pre x-type m at position i in w.
A tag c     is pre-order typed (post-order typed) in an SDTD (d, m0) if for every document w   Ld(m0) and every the set of words w  b We extend the de nition of a A to words over   in the natural manner.
The language L(A) accepted by Vpa A is   such that (q0,  ) w A (q,  ) for some q   QF .
A language L is called a visibly pushdown language (Vpl) if there some Vpa A such that L = L(A).
We now review some of the basic properties of visibly pushdown automata and their languages which we will appeal to later in the paper.
To begin with, Vpls de ne a robust class of languages closed under boolean operations.
Proposition 1.
[4] If L1 and L2 are Vpls over a common alphabet ( ,  ), then L1   L2, L1   L2 and L1 are also Vpls with respect to ( ,  ).
In addition, Vpls have a logical characterization using the monadic second order theory over words augmented with a binary matching predicate  , denoted MSO  .
Proposition 2.
[4] A language L over ( ,  ) is a Vpl i  there is an MSO   sentence   over ( ,  ) that de nes L.
Unlike pushdown automata, Vpas can be determinized without any loss in expressive power.
We state this formally: Proposition 3.
[4] For any n-state Vpa M over ( ,  ), there is a deterministic Vpa M   over ( ,  ) with O(2n2 ) states and with stack alphabet of size O(2n2   | |) such that
 Finally, the inclusion problem (which is undecidable for pushdown automata) is decidable for Vpas.
Proposition 4.
[4] Given Vpas A1 and A2, the inclusion problem L(A1)   L(A2) is decidable in Exptime.
Furthermore, if A2 is deterministic, then the problem is decidable in Ptime.
Modular visibly pushdown automata We now introduce modular Vpas.
Given an SDTD (or in fact, any context-free grammar), one can associate a machine (module) with every non-terminal, which essentially checks whether the word it reads belongs to a derivation of the non-terminal.
While doing so, such a module may need to expand other non-terminals, and can do so by  calling  the modules corresponding to these non-terminals.
This intuition will lead us to capturing SDTDs precisely using a modular notion of Vpas.
We have studied modular Vpas in an earlier paper [3], where we were motivated by their natural use in program modeling: the various modules correspond to procedures of a program which can call each other.
We  rst de ne a notion of a modular Vpa, and then de ne restricted versions of it called Xvpa (XML Vpa) and Sevpa (single-entry Vpa).
The former will turn out to be the exact machine analog of SDTDs, while the latter has been studied earlier by us, and will help in proving various constructions in this paper.
Modular Vpas have states partitioned into modules, demand that the symbol pushed onto the stack is always the current state, and ensure that if a module calls another, then upon return the control returns to a state of the calling module.
Definition 4 (Modular VPA ( -VPA) ; SEVPA).
Fix  , M and   : M    .
A modular Vpa (or  -Vpa) over ( , M,  ) is a tuple A = ({(Qm, em,  m)}m M , m0, F ), where for each m   M , position i   |w| such that w[i] = c (resp.
w[i] = c), c (resp.
c) is pre x-typed at position i in w.
An SDTD (d, m0) is pre-order typed (post-order typed) if every tag is pre-order typed (resp.
post-order typed).
Said in other words, a position i is pre x-typed in w if a streaming algorithm that reads w can determine the (unique) type of (w, i) at position i.
We study three problems related to typing:   Automata characterization: which kind of Vpas capture SDTDs that are pre-order and post-order typed.
  Dynamic pre-order typing: Can we build an automaton that streams input and determines the type of open-tags (or close-tags) as soon as it meets them, provided the type has been determined by the pre x read till that point.
  Given an SDTD and a tag c, can we e ectively decide if in all documents conforming to the SDTD, the type of every occurrence of the open-tag (or close-tag) corresponding to c is pre x-typed?
Visibly pushdown automata The languages de ned by SDTDs do not encompass all context-free languages.
Viewing an SDTD as a normal grammar, a rule in the SDTD of the form ma   mb.mc, where  (ma) = a,  (mb) = b and  (mc) = c, translates to a rule ma   a.mb.mc.a.
In other words, each non-terminal is  guarded  by a tag that occurs before and after the expansion of the non-terminal.
The usual translation of this grammar into a pushdown automaton will result in a machine that pushes at the open-tags and pops at the close-tags.
Visibly pushdown automata are precisely these kind of restricted machines [4].
Since Vpas were  rst motivated in the program analysis context, the symbols on which the automaton pushes and pops are called calls and returns, instead of open-tags and close-tags.
Definition 3 (VPA).
A visibly pushdown automaton ( Vpa) over ( ,  ) is a tuple A = (Q, q0, QF ,  ,  ), where Q is a  nite set of states, q0   Q is the initial state, QF   Q is the set of  nal states,   is a  nite stack alphabet, and   =  call    ret is the transition relation, where:    call   ((Q    )   (Q    ));    ret   ((Q        )   Q).
a  b and a transition (q, c,  , q )    ret as q We denote a transition (q, c, q ,  )    call as q c/    q , c/    q .
A transition c/    q  is a push-transition, where the automaton read-q ing c changes state from q to q , pushing   onto the stack.
c/    q  is a pop-transition, where Similarly, a transition q on reading c with   on the top of the stack, the automaton pops   o  the stack and changes state from q to q .
where   is a special bottom-of-stack symbol (  /   ).
A con guration of a Vpa A is a pair (q, s)   Q   ( . ), If  , we say that (q1, s1) a A (q2, s2) if and only if one of the following conditions are true:   a = c    , s2 =  .s1 and (q1, c, q2,  )    call, or   a = c    , s1 =  .s2 and (q1, c,  , q2)    ret.
  em is a distinguished entry state of module m 3 Intuitively, the language of well-matched words that will take the automaton from pn to qn is the language de ned by the module m with  nal states Xm(pn, qn).
   m =  call m    ret m , where  call m   {qm c/qm  en | n    1(c)}  ret m   {qm tic, i.e. qn = q  q  n c/pn  qn | n    1(c)} and is determinis-c/pn  c/pn  qn and qm n whenever qm   m0   M is a distinguished start module   F   Qm0 is the set of  nal states.
A single-entry Vpa ( Sevpa) over ( , M,  ) is a  -Vpa such that the mapping   : M     is a bijection.
Note that we have de ned  -Vpas such that the return transitions are always deterministic; this is for technical convenience.
A  -Vpa A is said to be deterministic if  call m is deter-if (qm, c, en, qm), (qm, c, en  , qm)    m, ministic as well, i.e.
then en = en  .
An Sevpa is a  -Vpa that has exactly one module for each tag.
Semantics.
The semantics of a  -Vpa is de ned by its corresponding Vpa.
Let A = ({(Qm, em,  m)}m M , m0, F ) be a  -Vpa over ( , M,  ).
Then A  = (Q, q0, {qf },  ,  ) is the Vpa over ( ,  ) where Q = {q0, qf }   ( m M Qm),   = Q and [
   = ( m M  m)   {q0  (m0)/q0   em0 }   {q  (m0)/q0   qf | q   F } We de ne L(A), the language accepted by  -Vpa A, as L(A ).
Note that a  -Vpa always accepts well-matched words which are of the form  (m0)w (m0).
A  -Vpa module m intuitively accepts many well-matched word languages.
For example, a single module can distinguish two languages L1 and L2, and use return edges ( exits ) to convey the di erence to the calling module.
A specialization (non-terminal) of an SDTD, however, is more restricted: it can be utilized to capture only one language.
We will de ne Xvpas as essentially automata that have this restriction, and the concept of exit below will be useful.
Definition 5 (Exit).
Let A = ({(Qm, em,  m)}m M , m0, F ) be a  -Vpa over ( , M,  ).
A nonempty set Xm   Qm is c/pn  qn i  a (pn, qn)-exit for module m in A if  qm.
qm qm   Xm.
In other words, a nonempty set Xm is a (pn, qn)-exit if it is the exact set of states of module m from which popping pn from the stack leads to state qn.
A nonempty set Xm is an exit of module m in A if there exist states pn, qn such that Xm is a (pn, qn)-exit.
Remark 1.
Note that for every pn, qn, m, there is at most one (pn, qn)-exit for module m in a  -Vpa A.
If such an exit exists, we denote it by Xm(pn, qn).
m, etc.
will range over states in Qm.
ules, and pm, qm, q 
 every module can have multiple entries e1 m. In this paper, we will largely focus on modular Vpas that have only a single entry per module.
m, .
.
.
ek Definition 6 (XVPA).
An Xvpa over ( , M,  ) is a tuple A = ({(Qm, em, Xm,  m)}m M , m0, F ) such that ({(Qm, em,  m)}m M , m0, F ) is a  -Vpa over ( , M,  ), and the following single-exit property holds: for every m   M , Xm is the unique exit of module m An Xvpa is intuitively a  -Vpa where each module de nes only one language, no matter which state it is called from.
Recall that we require  -Vpas to be deterministic on returns; hence single-exit ensures that if we call a module m from state pn, then exiting from m we end in a unique state qn no matter which state in m we exit from.
Example 2.
An Xvpa that de nes the same language as the SDTD in Example 1 is given in Figure 1, and for example, {xmultlang } is the unique exit for module  multlang  .
Equivalence of SDTD and XVPA We now show that Xvpas are an appropriate automaton model for SDTDs, by demonstrating their equivalence.
More speci cally, we will show that for every SDTD there exists an equivalent Xvpa where the modules of the Xvpa exactly correspond to the specializations in the SDTD, and vice versa.
Intuitively, given an SDTD, we can construct an XVPA in which each module corresponds to a specialization in the SDTD, and the module checks whether a word belongs to the language of the specialization.
Theorem 1.
For every SDTD (d, m0) over ( , M,  ), there is an Xvpa A over ( , M,  ) such that L(A) = Ld(m0).
Furthermore, for every Xvpa A over ( , M,  ), there is an SDTD (d, m0) over ( , M,  ) such that L(d, m0) = L(A).
Proof.
Let (d, m0) be an SDTD over ( , M,  ).
For every m   M , let Dm be the deterministic (but perhaps incomplete)  nite automaton (DFA) obtained from the minimized automaton for the regular expression d(m) after discarding all  dead  states, i.e. states from which no  nal states can be reached.
Speci cally, let Dm = (Qm, em, QF m,  m), where   Qm is a  nite set of states, em   Qm is the initial state
 m   Qm is the set of  nal states    m is a (partial) function from Qm   M to Qm   for every q   Qm,  x   M   such that  m(q, x)   QF m (no dead states) Let A = ({(Qm, em, Xm,   where m)}m M , m0, F ) be the XVPA,   Xm = QF m for every m   M , F = QF m0   for every m   M ,   m =  call m    ret m , where:  call  ret m = {(qm,  (n), en, qm) |  m(qm, n) = pm} m = {(q,  (m), qn, pn) |  n(qn, m) = pn and q   QF m} Note that  ret tion.
Also, by de nition of  ret module m. Hence, A is indeed an Xvpa.
m is deterministic, since  n is a (partial) func-m , Xm is the unique exit of lang/emovie lang/emovie lang/emovie eunilang xunilang lang/emovie xmovie title/emultlang xmultlang emultlang lang/xmultlang lang/xmultlang title/eunilang etitle title/eunilang b ealtlang title/emultlang b b b Figure 1: XVPA for the given SDTD Further, for every well-matched word w   (M   M ) , it is easy to show by induction on the length of w, that  (w) mwm   Lspl  A (q,  ) for some q   Xm.
Since Xm0 = F , it follows that L(A) = Ld(m0).
d (m) if and only if (em,  ) Conversely, let A = ({(Qm, em, Xm,  m)}m M , m0, F ) be an Xvpa.
De ne an SDTD (d, m0) where, for every m   M , d(m) is the regular expression corresponding to the DFA Dm = (Qm, em, QF m is de ned as follows: for every qm   Qm and n   M , if (q,  (n), qm, pm)    m for some q   Xn, then   is well-de ned because A has the single-exit property.
m(qm, n) = pm.
Note that this m = Xm and   m,   m), where QF  (w)  A (q,  ) for d (m) if and only if (em,  ) Once again, for every well-matched word w   (M   M ) , it is easy to show by induction on the length of w, that mwm   Lspl some q   Xm.
Hence, L(A) = Ld(m0).
MR(b ) there exists a v such that the run can be extended Remark 2.
We will use the translation from SDTDs to XVPAs in the sequel.
For this purpose we will assume that the XVPA is trimmed: for every state q in any module m, we will assume that there is a well-matched word w that leads from q to some state in Xm.
If this wasn t the case, we can remove q and the transitions incident on q without changing the language of the XVPA.
Now observe that in such an XVPA, for every run on uc   on v such that it is accepting (showing ucv   L(A)).
This property will simplify many of our constructions.
In Section 4, we will prove that deterministic Xvpas correspond exactly to pre-order typed SDTDs.
Hence, by Theorem 1, we have: Remark 3.
If the regular expressions in SDTD1 and SDTD2 are given as deterministic  nite automata (DFA), and SDTD2 is pre-order typed, then the sub-typing problem SDTD1   SDTD2 is decidable in Ptime.
Note that a similar result was obtained in [17], for the case when both SDTD1 and SDTD2 are pre-order typed.
The sub-typing problem was also studied in [24], in the context of streaming algorithms for validating XML documents using a  nite amount of memory, under the assumption that the XML document is well-matched.
If A1 and A2 b
 are DFAs over  , then an Exptime upper bound for deciding whether L(A1)   WM (  ) was obtained by a reduction to the inclusion problem for tree automata.
It was left as an open problem whether this bound could be improved.
By Proposition 4, however, we immediately have a Ptime upper bound for this problem, even when A1 and A2 are deterministic Vpas: Theorem 2.
If A1 and A2 are DFAs (or even determin-
istic Vpas) over ( ,  ), then checking if L(A1)   WM (
  ) is decidable in Ptime.
In this section, we present several results (some of which are new) pertaining to SDTDs, that follow immediately from existing results for Vpas.
We begin with results in the streaming context, where one is required to determine whether or not an XML document belongs to the language de ned by an SDTD.
Streaming Deterministic automata working on strings are the most natural model for processing streams of data.
Since Vpls always have deterministic acceptors [4], Vpas are a convenient abstraction for studying streaming problems.
In this section we look at some known results for Vpas and examine their consequences for type checking XML documents.
The following Proposition shows that deterministic Sevpas capture the class of SDTDs.
Proposition 5.
[3] For every SDTD (d, m0) over ( , M,  ), there is a deterministic Sevpa A over ( ,  , id) 4 such that L(A) = L(d, m0).
The above proposition is true since an SDTD is always captured by an Xvpa, and results in [3] show that any language accepted by a Vpa can be accepted by a deterministic Sevpa.
Hence, deterministic Sevpas give a streaming algorithm to recognize SDTDs.
The streaming algorithm simply simulates the deterministic Sevpa on the input and checks if it 4id denotes the identity function space in addition to a stack of symbols over a  xed alphabet, where the stack height is bounded by the depth of the nesting of tags in the document (which is typically not very large when compared to the size of the document).
Such an algorithm was already observed in [24] using push-down automata; in fact the pushdown automaton they construct is essentially an Sevpa!
By combining the set of single-entry modules into a common module, any such Sevpa can be reinterpreted as a complete multi-entry  -Vpa.
We can now appeal to the following Proposition to prove that there is a minimal streaming automaton recognizing a given
 Proposition 6.
[14] For every complete multi-entry  -Vpa A, there is a unique (up to isomorphism) minimum-state deterministic multi-entry  -Vpa A  such that L(A ) =
 Hence, the minimization construction outlined in [14] gives a way to minimize the space used by a streaming type-checking algorithm that is based on pushdown automata.
Thus, unlike the result in [24], we are able to construct a provably minimal streaming recognizer for an SDTD.
In this section, we study the class of XML schema that are pre-order typed, give an automata theoretic characterization of them, develop a streaming algorithm that determines the types of open-tags whenever possible, and also show that checking whether a tag can be pre-order typed is solvable in polynomial time.
Pre-order typing has a very simple characterization in terms of the structure of Xvpa de ning the XML schema.
An SDTD is pre-order typed exactly when its Xvpa translation is deterministic: Lemma 1.
An SDTD (d, m0) is pre-order typed if and only if there is a deterministic XVPA A over the same modules such that L(A) = Ld(m0).
Proof.
Let (d, m0) over ( , M,  ) be a pre-order typed SDTD and let A = ({(Qm, em, Xm,  m)}m M , m0, F ) be the corresponding Xvpa as de ned in Theorem 1.
Recall that by de nition of Xvpa  ret m is deterministic for each m. Consider some state q of A and let u be a string such that A has some computation on u that ends up in state q.
Now since (d, m0) is pre-order typed, there is a unique specialization m associated with c in the string uc.
Thus, the state q must have only the transition to em on the symbol c. Hence,  call m is deterministic for every module m.
Conversely, suppose A = ({(Qm, em, Xm,  m)}m M , m0, F ) is a deterministic Xvpa and let (d, m0) be the SDTD corresponding to it (as de ned in Theorem 1).
Consider a string u, and let q be the state reached by A on the string u.
Since A is deterministic, for any c     there is at most one m such that q has a transition to em on symbol c. Thus, m is the unique specialization associated with c in the string uc.
Hence, (d, m0) is pre-order typed.
We now study the problem of dynamic pre-order typing.
Recall that this problem asks for an automaton that streams input and determines the type of open-tags as soon as it meets them, provided the type has been determined by the pre x read till that point.
Consider the XVPA A  = ({(Qm, em, Xm,  m)}m M , m0, F ) corresponding to (d, m0) as de ned in Theorem 1.
This XVPA is deterministic on return transitions but, in general, is non-deterministic on call symbols.
We construct a deterministic automaton A that simulates the behaviour of A  on all applicable specializations of call symbols.
After reading pre x u, if there is only one applicable specialization m of call symbol c, then A outputs m as the uniquely determined pre x-type of c at position |uc|.
For every c    , let Qc = {q   Qm |  (m) = c}.
Let A = (Q, q0, Q,  ) be a VPA without  nal states, where Q = {P   Qc | P 6=  , c    }, q0 = {em0 } and   is de ned as follows: c/P   P  , where
 P   = {em |  (m) = c and  p   P. p c/p  A  em} 6=   c/P     P  , where
 P   = {p  |  p   P, p    P  .
p c/p   A  p } 6=    1(c) and strings v, v   b v   b c/P   P   if and only Further, A outputs m on transition P if P   = {em} for some m    1(c).
We claim that for every open tag c that has pre x-type m at position |uc| in |ucv|, the Vpa A outputs m after reading the input uc.
First observe that by construction of A and by Remark 2, if uc A P and |P | > 1, then there are two distinct m, m    q0   such that ucv, ucv    Ld(m0) and (ucv, |uc|) has type m whereas (ucv , |uc|) has type m .
Hence, c is not pre x-typed at |uc| and the automaton A does not output anything on reading c after input u. However, if P = {em}, then by construction of A, for every   such that ucv    Ld(m0), (ucv , |uc|) has type m.
Therefore, c has pre x-type m at position |uc| in ucv, and A in fact outputs m on reading uc.
Theorem 3.
For any SDTD, we can e ectively construct an algorithm that dynamically pre-order types the tags in a streaming XML document.
Further, this algorithm uses only space O(s.d), where s is the size of the SDTD and d is the depth of the document.
We now consider the following problem: Given an SDTD (d, m0), which open tags are pre-order typed in every document de ned by (d, m0)?
In the procedure for converting an SDTD into an XVPA de ned in Theorem 1, we chose a deterministic  nite state automaton Dm corresponding to every regular expression d(m).
This results in an automaton that may be exponential in the size of the SDTD (d, m0).
Instead, for every m, let Dm be a non-deterministic  nite state automaton (one that is linear in the size of d(m) can be constructed e ciently).
We therefore obtain a non-deterministic VPA A = (Q, q0, F, Q,  ) such that L(A) = Ld(m0), and further, |Q| = O(n), where n is the size of (d, m0).
To e ciently determine whether an open tag c is pre-order typed or not, we search for a witness to the fact that c is not pre-order typed at some position.
Such a witness consists of words (ucv , |uc|) has type m  for some m 6= m .
Searching for such witnesses reduces to performing reachability in a VPA A  without  nal states de ned as follows: A  = (Q , q 

 Q,  ) where Q  = Q   Q   (    { }), q  0 = (q0, q0,  ) and   is de ned as follows:


 c/(q,q )  A  (p, p ,  )  A p  c/(q1,q2)  A  (p, p ,  ) (q, q ,  ) and q  c/q  (q, q ,  ) and q  c/q2 A p  c/(q,q )  A  (p, p , c) (q, q ,  ) q  c/q   A p  and p 6= p  if q c/q  A p if q c/q1 A p if q c/q  A p, Lemma 2.
For every open tag c    , c is pre-order typed in (d, m0) if and only if no state (p, p , c) is reachable from the initial state in A .
Intuitively, a state of the form (p, p , c) is reachable in A  whenever there are states q, q  reachable on some common input u in A, and there are distinct specializations m, m  of c such that module m (resp.
m ) can be called from state q (resp.
q ).
Then by Remark 2, there are strings v, v  such that ucv, ucv  witness the fact that c not pre-order typable at position |uc|.
Since A  has size O(n2) and reachability in a Vpa can be determined in cubic time, we have: Theorem 4.
Given an SDTD (of size n), the problem of checking whether c is pre-order typed in the SDTD is solvable in time polynomial in n.
In this section, we give an automata theoretic characterization of the class of XML schema that can be post-order typed.
Given a post-order typed SDTD, consider the Xvpa corresponding to it.
After reading a word u, if the Xvpa meets an open-tag c, then c need not be pre x-typed at position |uc|.
Hence, the Xvpa may call several modules m1, .
.
.
, mk.
However, since the SDTD is post-order typed, the type of c will get determined at the closing tag c, i.e. at the time of exit from these modules.
Hence it is clear that the languages accepted by these modules must be disjoint.
More formally, we say that an Xvpa A has disjoint calls if for all states q in A and open tags c    , if q c A em and q c A em  for distinct m, m     1(c), then Ld(m)   Ld(m ) =  .
We therefore have: Lemma 3.
An SDTD (d, m0) is post-order typed if and only if there is an Xvpa A with disjoint calls over the same modules such that L(A) = Ld(m0).
We now turn to the problem of dynamically post-order typing a streaming XML document.
Our construction of the deterministic Vpa A = (Q, q0, Q,  ) is as in Section 4.2 with the only modi cation that A outputs m on a return c/P     P   if and only if P   Qm for some transition P m    1(c).
Using a similar argument as before, we can show that on any input, the above Vpa outputs the type of every closing tag c at position |uc| whenever this can be uniquely determined by reading the pre x u.
Hence an algorithm analogous to that reported in Theorem dynpre follows.
We now consider the problem: Given an SDTD (d, m0), which open tags are post-order typed in every document de ned by (d, m0)?
Once again we can express this as a reachability problem on an appropriately de ned Vpa A .
Our construction is identical to the construction de ned in Section 4.3 except that the condition T3 in the de ntion of the transition function   is replaced with:
 (q, q ,  ) c/(q1,q2)  A  (p, p , c) if c/q1 A p, q  c/q2 A p  q and q   Qm, q    Qm  with m 6= m  Similar to Lemma 2, we can show that a tag c is post-order typed if and only if no state (p, p , c) is reachable.
Hence: Theorem 5.
Given an SDTD (of size n), the problem of checking whether c is post-order typed in the SDTD is solvable in time polynomial in n.
The problem of pre-order (respectively post-order) typing can be viewed abstractly as answering which open-tags (respectively close-tags) satisfy the property of being uniquely parsed as a particular specialized tag in an SDTD, provided the property of whether a tag has this property is determinable by reading the pre x of the document up till the open-tag (respectively close-tag).
In this section, we generalize this idea, by de ning a generic class of queries (formalized using monadic second-order logic) that have the property that a position in a document satisfying the query is solely determined by the pre x of the document till that point.
This class of queries is independent of the document-type de nitions used to describe input documents, and pre-order and post-order typing are simply special instances of this class of queries.
ument.
More precisely, given any document w  b The monadic second-order logic structures that we consider will be over the nested structure [5] de ned by a doc , let us   labeled structure ([1, |w|],   view the word as a linear , {Qa}a ,  ), where there are |w| elements corresponding to each letter in w,   is the linear order on this set of positions, each Qa is a unary predicate that is true on exactly the positions labeled a (i.e. Qa = {i | w[i] = a), and   is the matching binary relation that associates each open-tag with the corresponding close-tag (i.e.  (x, y) holds i  w[x]    , w[y]    , and w[x] .
.
.
w[y] is well-matched).
b Monadic second-order logic can be now de ned as the canonical logic over this structure with interpreted relations  , Qa s and  .
Since we are interested in properties that are determined by the pre x in a document, we de ne a restricted version of MSO, called Pre-MSO, which allows only quanti cation over positions that occur before the query position.
Formally,  x a  rst-order variable x.
Then the set of all Pre-MSO(x) formulas  (x) (with x being the only free variable) is de ned as:   ::= y   X | Qi(y) | y   y  |  (y, y ) |       |   |  z(z   x    ) |  X( ) where y, y , z   F V, z 6= x, X   SV.
The logic Pre-MSO is a restriction that forces any query written in the logic to depend only on the pre x of the word till the particular point of query.
Formally, for any word  , let Answers(w,  ) be the set of of all positions i, 1   i   w, such that  (x) holds in w when x is interpreted to be i.
Proposition 7.
Let  (x) be any Pre-MSO(x) formula and let i   Answers(w,  ).
Then, for any word w , |w |   i, with w[1, i] = w [1, i], i   Answers(w ,  ) as well.
Let us  rst de ne VPA with output.
Consequently the set of answers to a query  (x) in a word w, which is the set of all positions i such that  (x) is sat-is ed when x is interpreted to be i, is determined when the pre x up till i has been read.
Hence, technically, we should be able to output the answer positions i as soon as we read the i th letter in a document.
We show that indeed this is true, and there is a deterministic visibly pushdown automaton that can perform this task.
From this we obtain a streaming algorithm that uses space only linear in the depth of a document, and can output the set of all answers to any Pre-MSO(x) query.
We say such a marking VPA A working on a word w  b b word w  b
 marks position i (1   i   |w|) if there is some run of A on w which reaches a marked state in M just after reading the i th letter in w. (Note that the set of  nal states play no role in this de nition.)
Theorem 6.
Let   be a Pre-MSO(x) formula over
 Then there is a deterministic marking VPA A  that on any Definition 7 (VPA with output).
A marking visibly pushdown automaton ( Vpa) over ( ,  ) is a tuple A = (Q, q0, QF ,  ,  , M ), where (Q, q0, QF ,  ,  ) is a VPA and M   Q is a subset of marked states.
We can now show:   marks exactly the set of positions Answers(w,  ).
Proof.
Let  (x) be a Pre-MSO(x) formula.
Now, consider the set Pre xLang ( ), which is the set of all words u, not necessarily well-matched, such that |u|   Answers(u,  ), i.e. the set of all words u such that  (x) holds in u when x is interpreted to be the last letter of u.
It can be seen that Pre xLang ( ) is expressible in (full) MSO.
Using the correspondence between monadic second-order logic on nested structures and visibly pushdown automata [4,
 tively) recognized by a VPA.
Let B  = (Q, q0, QF ,  ,  ) be an automaton accepting this language.
Then the automaton which will answer the queries will be A  = (Q, q0, QF ,  ,  , M ), where M = QF .
Intuitively, when reading a word w and when at position i, the automaton B will mark i i  the pre x u uptil position i already satis es  , when i is interpreted for x.
Since we know that w satis es   when x is interpreted to be i i  u satis es   when x is interpreted to be i, the correctness follows.
We can also show the converse, namely that every marking VPA (deterministic or nondeterministic) de nes a query that is expressible by a Pre-MSO formula  (x).
The proof of this relies on the translation from VPAs to MSO, alongwith observations similar to the ones made in the above proof; we skip further details: Theorem 7.
For every query captured by a marking VPA, there is an equivalent Pre-MSO formula  (x) that de nes the same query.
As a corollary to Theorem 6 we have: Corollary 1.
For any Pre-MSO formula  (x), there is a streaming algorithm (which is e ectively constructible) that processes documents and outputs the set of all answers to the query de ned by  (x).
Moreover, this algorithm processes each letter of the document in constant time, and utilizes space at most O(d), where d is the depth of the document.
The algorithm simply simulates the deterministic VPA constructed in Theorem 6; processing a letter can be done in constant time (for a  xed formula  ) and the space required is to store the state and the stack, which is O(d).
Sequential XPath is a restricted version of XPath that has the property that a position satisfying a query is determined by the pre x till the node [8] (it however has further restrictions aimed at limiting bu ering input).
Sequential XPath has been de ned and studied precisely to facilitate one-pass querying with minimal bu ering of input.
Our result can be seen as a generalization of this idea to the much larger class of MSO-de nable queries.
A similar precise characterization of queries that can be answered by 1-pass streaming algorithms is provided in [19].
There the characterization is in terms of constraint systems and pushdown forest au-tomata.
Our results here can be seen as a reformulation of those results in terms of logic and word automata.
We conclude this section by observing that our results on dynamic pre-order and post-order typing can be seen as special cases of Theorem 6.
Proposition 8.
For any SDTD (d, m0) and specialization m, there is a Pre-MSO formula Preorderm (d,m0)(x) such that for any document w, Answers(w, Preorderm (d,m0)) is exactly the set of positions that can be pre-order typed with specialization m. Analogously, there is a Postorderm (d,m0)(x) that exactly describes the positions that can be post-order typed with specialization m.
Proof.
The construction of the VPA in Section 4.2, when restricted to only answering the positions getting type m, can be seen as a VPA with output.
Thus, the proposition follows from Theorem 7.
The proof for post-order typing is similar.
Proposition 8 can be used obtain a streaming algorithm for dynamic pre-order (and post-order) typing.
The streaming algorithm simulates the deterministic marking VPA from Theorem 6 for Preorderm (d,m0)(x)) for each specialization m simultaneously on the document w, and outputs m whenever the marking VPA for m enters a marking state.
(d,m0)(x) (or Postorderm While the results of Section 4.2 can thus be seen as a corollary to the results presented in this section, the algorithm described in the previous paragraph is likely to be more in-e cient when compared to that presented in Section 4.2.
Thus, in practice it will be more useful to use the direct construction presented earlier for determining types.
We have shown that visibly pushdown automata is a convenient and powerful model for studying problems for XML right.
Modular Vpas emerge as an elegant model to study problems such as streaming and typing XML documents, and constructions and algorithms based on modular Vpas are intuitive and simple, giving clean proofs and e cient algorithms.
Modular Vpas are useful in the program veri cation context as well, and hence our results make an unusual connection between the two  elds, which could be mutually bene- cial.
For instance, the congruence based characterizations developed in the veri cation setting have been useful in the XML setting, and the unique minimal modular Vpa result presented herein has potential uses in building minimal program models.
There are several other problems that can be addressed using the XVPA model.
In particular, checking whether SDTDs can be transformed into another which is pre-order (or post-order) typed is decidable and these results can be proved using XVPAs (we refer the reader to the technical report [15]).
Pre-order typability of SDTDs seems related to LL[1] grammars [12] and is worth studying.
Intuitively, an LL[1] grammar requires that the rule to be applied is determined when each symbol is read, which greatly resembles pre-order typing and deterministic Xvpas.
The most interesting future direction we see is in de ning querying automata using the Vpa model.
Note that while we have studied pre x querying in this paper, general querying (like general XPath queries) can select a node depending on properties of the document that lie in the future of the node.
In work not reported here, we have extended the Vpa model to a query model where the automaton is powerful enough to store fragments of the document, and hence answer all XPath/MSO queries.
In both this and the work reported in this paper, the ability to minimize Vpa seems to re ect the kind of optimizations in memory proposed by other researchers [7, 11], and we believe that minimization of visibly pushdown automata will be a formal and perhaps more e ective way to achieve space optimizations.
Finally, we plan to also study transformations of XML documents in the streaming setting using VPAs (see also [23], where visibly pushdown expressions have been used to study e ect systems on streaming XML).
