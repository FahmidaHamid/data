Approaches based on structural index, numbering scheme and subsequence matching have been studied for processing XML twig queries, among which the most e cient one is holistic twig join based on numbering scheme.
However, holistic twig join is suboptimal for those twig queries in which both Ancestor-Descendant (AD) and Parent-Child (PC) relationships are included, because it may involve huge even unbounded intermediate results.
In addition, most of existing proposals are not e cient for the GTP queries [3, 4], because to answer GTP queries they have to compute the result sets of all the nodes although a part of them will not contribute to the answer, and hence they have to eliminate those redundancies involved in the result.
To address these problems, we present some vectorial operators for the PC and AD relationships to avoid redundant intermediate results and demonstrate how to answer twig queries using these vectorial operators e ciently.
To accelerate the processing of twig queries, we propose several techniques to optimize these vectorial operators.
Although T wig2Stack[1] is proposed to process GTP queries, it is constrained by the fan-out of the XML document and thus leads to ine ciency.
We discuss how to e ciently answer GTP queries according to our vectorial operators.
To the best of our knowledge, this is the  rst paper that employs vectorial operators to process twig queries and GTP queries.
We employ a sequence to represent an XML document and answer XML queries based on the sequence.
For any node u, we construct list Iu, which keeps the elements w.r.t.
u and the positions of their occurrences in the corresponding sequence.
To check whether element ea Ia and element ed Id satisfy the AD or PC relationships, we transform Ia and Id into bit-vectors and evaluate the AD or PC relationships on the bit-vectors.
We begin by introducing three vectorial operators,   ,  and  , to transform any input list Ia into bit-vectors, V a ,V a and Va , respectively as illustrated in Table 1.
We propose three corresponding operators,  ,  , , which are similar to   ,  ,   and operate on any bit-vector (e.g., an intermediate bit-vector) as shown in Table 1.
We propose two vectorial operators  a[d] and  a/d to evaluate the PC relationship as shown in Table 1.
The two operators can evaluate whether the elements in Ia and the elements in Id satisfy a/d.
In addition, we introduce three vectorial operators  a,  a[//d] and  a//d, to evaluate the AD relationship, as shown in Table 1.
Equations (2.1-1)-(2.1-10) formally describe how to evaluate the PC or AD relationships, where P [i] denotes the element at the i-th position in the sequence and S denotes the corresponding result set.
Ra[d] =  a[d](  (Ia),   (Id)) Ra/d =  a/d(  (Ia),  (Id)) Sa[d] = {P [i]|Ra[d][i] = 1} Sa/d = {P [i]|Ra/d[i] = 1} S(a,/d) = {(P [i + 1], P [i])|Ra/d[i] = 1} Ra//d =  a//d( (Ia),  (Id)) Ra[//d] =  a[//d](  (Ia),  (Id)) Sa//d = {P [i]|Ra//d[i] = 1} Sa[//d] = {P [i]|Ra[//d][i] = 1} (2.1-1) (2.1-2) (2.1-3) (2.1-4) (2.1-5) (2.1-6) (2.1-7) (2.1-8) (2.1-9) Copyright is held by the author/owner(s).
S(a,//d) = {(P [i], P [j])| i, j, if Ra[//d][i]=1, P [i].leftmost   j < i,Ra//d[j] = 1}.
(2.1-10)
   (Ia)   (Ia)  (Ia)   (Va)  (Va) (Va)  a[d](Va,Vd)  a/d(Va,Vd)  a(Va, Vd)  a//d(Va,Vd)  a[//d](Va,Vd) Table 1: XML Vectorial Operators for AD and PC relationships   Operand Result De nition Ia Ia Ia Va Va Va Va,Vd Va,Vd Va, Vd Va,Vd Va,Vd V a V a Va V a V a Va Va[d] Va/d V a Va//d Va[//d] V a [i]=1 if  j, k,1 j |Ia|,1 k |Ia[j].occur| and i=Ia[j].occur[k]; otherwise, V a [i]=0.
V a [i]=1 if  j, k,1 j |Ia|, k=|Ia[j].occur| and i=Ia[j].occur[k]; otherwise, V a [i]=0.
Va [i]=1 if  j, k, t,1 j |Ia|,k=|Ia[j].occur|,t=Ia[j].occur[k], P [t].leftmost i t; else Va [i]=0.
V a [i]=1 if  j,1 j |Va|, Va[j]=1 and P [i]=P [j]; otherwise, V a [i]=0.
V a [i]=1 if  j i, Va[j]=1 and P [i]=P [j], but (cid:4) k>i, P [i]=P [k]; otherwise, V a [i]=0.
Va [i]=1 if  j,1 j |Va|,  (Va)[j]=1 and P [j].leftmost i j; otherwise, Va [i]=0.
Va[d] =  (   (Va)   ( (Vd)>>1) ) Va/d = (  (Va)<<1)    (Vd) V a [i]=1 if  (Va)[i] =1,  j,P [i].leftmost j<i and Vd[j]=1; otherwise, V a [i]=0.
Va//d = (Va)    (Vd) Va[//d] =  (  a(  (Va), (Va)    (Vd) ) )
 We introduce how to answer twig queries according to our operators.
Given a query Q, let Rn denote the bit-vector result of node n w.r.t.
the sub-query rooted at node n, while let Fn denote the bit-vector result of node n w.r.t.
Q.
We  rst compute Rn from the leaf to the root and then compute Fn from the root to the leaf.
Thus, we can get the result set of any query node according to Equations (2.2-1)-(2.2-5).
n =   ( c c-children(n)  (  (In)   (Rc>> 1))) Rc (2.2-1) n =   ( d d-children(n)  ( n(  (In),  (In)   Rd))) (2.2-2) Rd         if n is a leaf node if n only has c-child if n only has d-child otherwise  (In)  (Rc n)  (Rd n) n   Rd n) Rn if n is the root node if n is c-child of its parent p if n is d-child of its parent p (  (Fp)<<1)   Rn Rn = (Fp)   Rn Fn =  (Rc (2.2-3) Sn = {P [i]|Fn[i] = 1} (2.2-4) (2.2-5)
 We introduce several techniques to optimize our vectorial operators.
Let c1,c2,...,cl be the c-children (PC) of node n and d1,d2,...,dk be the d-children (AD), to optimize the computation of Rd n, we extend  a from a binary operator to a multiple operator  n: V n = n(Vn,Vd1 ,Vd2 ,...,Vdk )|=V n [i]=1, if  (Vn)[i]=1, 1 j k,  bj, P [i].leftmost bj <i and Vdj [bj]=1; otherwise, V n [i]=0.
optimize the construction of Rc n     (  (  (  (  (In) (Rc1 >> 1)) (Rc2 >> 1)) ...) (Rcl >> 1)) Rc Rd n     ( n(  (In),  (In)   Rd1 , ...,  (In)   Rdk )) (2.3-2) We introduce the following Equations (2.3-1)-(2.3-4) to n, Rn and Fn.
n, Rd (2.3-1)  (Rc n   Rd n)    (Rc n)    (Rd n) (2.3-3)  (Rd n)    n(  (In),  (In)   Rd1 , ...,  (In)   Rdk ) (2.3-4) To answer twig queries in holistic and process GTP queries e ectively, we propose an e ective algorithm T JOperator by employing the vectorial operators.
T JOperator directly computes the results and does not require a post-processing to eliminate the irrelevant elements.
T JOperator only maintains several bit-vectors and the number of these bit-vectors is no more than the number of result nodes, thus T JOperator will not involve large intermediate results.
  occur keeps the positions of e s occurrences in the sequence and leftmost is the position of the occurrence of e s leftmost descendant.
i ) s ( e m
 d e s p a l











 TJOperator Twig2Stack iTwigJoin






 Twig and GTP Queries on XMark i ) s ( e m
 d e s p a l




 TJOperator Twig2Stack iTwigJoin



 Twig and GTP Queries on TreeBank


 Figure 1: Experimental results

 We compared T JOperator with state-of-the-art methods, PRIX [5], iTwigJoin [2] and Twig2Stack [1].
All the algorithms were coded in C++ and all the experiments were conducted on a 2.4 GHz Pentium IV processor with 1GB RAM, running Microsoft Windows XP.
We used the real-world dataset DBLP and the dataset TreeBank with deep recursive structures, and employed twelve queries for our experiments.
Figure 1 shows the experimental results.
We can observe that T JOperator outperforms PRIX, iTwigJoin and Twig2Stack on various queries and datasets signi cantly.
We propose several vectorial operators to evaluate the AD and PC relationships and present how to process twig queries in holistic by employing these operators.
We demonstrate several e ective techniques to optimize these operators for processing XML twig queries and GTP queries.
This work is partly supported by the National Natural Science Foundation of China under Grant No.60573094, the National High Technology Development 863 Program of China under Grant No.2007AA01Z152 and 2006AA01A101, the National Grand Fundamental Research 973 Program of China under Grant No.2006CB303103.
