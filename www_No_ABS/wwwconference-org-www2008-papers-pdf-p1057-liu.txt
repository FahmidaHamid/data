A key aspect in Web services behavior (described by services choreography) is contracting them to (i) make all parties compatible, (ii) guarantee expected QoS parameters, and (iii) ensure every participating service to terminate in a correct state.
It is generally accepted that semantic Web services (SWS) should be based on a formalism with a well-de ned model-theoretic semantics, particularly, on some sort of logics [2].
Given that DLs are usually considered as the underpinning of many W3C standard languages, it is quite natural and promising to resort to a variant of DLs to model a semantic Web services contract (SWSc).
Our present work extends the classical DLs with concrete domain and action theory, which makes it feasible to integrate planning and process modeling into DLs yet still retain decidable reasoning ability.
Intuitively, there exist multiple-parties constraints of web services in a SWSc, which bring to existing DLs more challenges.
In particular, we consider the following aspect(s): A1.
The actions speci ed by a services contract are required to be coordinated (e.g., ordered) and all the constraints need to be represented.
Meanwhile, the underlying logic should also retain the decidable reasoning ability for all the represented "knowledge".
The case of possessing su cient expressive power for establishing QoS requirements is also analogous.
Example 1.
Consider the motivation example as in Figure 1.
Apparently, the completion of a deposit by the user should precede the computer delivery, which is followed by the completion of the en-Copyright is held by the author/owner(s).
tire payment.
Moreover, the user must complete the entire payment within 12 hours after the computer delivery.
Figure 1: Motivating Example Theoretically, combining original DLs with so-called "concrete domain" is a sound approach to satisfy the requirements as depicted in A1.
However, [3] demonstrates that in the context of general TBoxes, if the concrete domain provides a unary predicate for equality with 0, a binary equality predicate, and a binary predicate for incrementation, then concept satis ability and subsumption are undecidable.
This result actually rules out the possibility of combining general TBoxes with more powerful concrete domains.
In the sequel, we disallow general TBoxes in our framework but adopt acyclic TBoxes instead.
The concrete domain in our framework sits on the basis of [3] and [4], and is de ned as follows: D = {q De nition 1.
(Arithmetic concrete domain Q  (cid:5)   Q | q (cid:5) D = Q, and  Q  with ( Q  ) ) Our concrete domain is denoted as Q  and is a pair ((cid:3)D,  D), where (cid:3)D refers to the rational numbers Q, and  D consists of the following predicates: (1).
unary predicates Pq for each P   {(cid:2), <, =, (cid:2), >, (cid:3)} and each Pq}, two unary predicate (cid:6)Q  q   Q where (Pq) with ((cid:6)Q  )
 (2).
binary predicates Pb = {(cid:2), <, =, (cid:2), >, (cid:3)}; (3).
ternary predicates Pt = {+, , , (cid:4)} with (+) D = {(q, q )   (cid:5), q (cid:5)(cid:5) )   Q3 | q q Q3 | q+q D = {(q, q (cid:5) = (cid:5), q (cid:5) = q (cid:5)(cid:5) (cid:5)(cid:5)}, and ((cid:4)) q We denote our underlying logic as ALCQO(Q  ) with its syntax and Tarski-style semantics shown in Table 1 ( f , g and U denote abstract feature, concrete feature, and feature path, respectively).
(cid:5)(cid:5)}, ( )



 ; Theorem 1.
(Decidability) An ALCQO(Q  )concept satis ability is decidable.
Example 1 revisited.
At  rst, we introduce three types of concrete features: atTime, lBound, and rBound, whose intuitive meanings are the occurring time, the left and right bound of occurring time interval.
We denote an abstract feature c_Deli as an abbreviation for computer delivery.
Similarly, we denote c_Pay and interval as abbreviations for complete payment and the allowed time interval between c_Deli and c_Pay, respectively.
Therefore, from the perspective of computer purchase service (CP), the interactions
 Table 1: Syntax and Semantics of ALCQO(Q  Syntax Semantics {o}I   (cid:3)I, (cid:2)({o}I) = 1 {o} ( C)I = (cid:3)I \ CI
 C (cid:11) D (C (cid:11) D)I = CI   DI C (cid:13) D (C (cid:13) D)I = CI   DI

 (cid:2) nR.C (cid:3) nR.C n ( R.C)I = {a |  b.
< a, b >  RI, and b   CI} ( R.C)I = {a |  b.
(< a, b >  RI   b   CI)} ((cid:2) nR.C)I = {a | (cid:2)({b |< a, b >  RI}   CI) (cid:2) n} ((cid:3) nR.C)I = {a | (cid:2)({b |< a, b >  RI}   CI) (cid:3) n} UI = {< a, x >|  b1,  bn   (cid:3)I, x   (cid:3)ID.
(< a, b1 > ,  < bn 1, bn >  f I , and < bn, x >  gI)}   f I {a   (cid:3)I |  x   (cid:3)ID.
(< a, x >  UI, and x   P q )}
 {a   (cid:3)I |  x1, x2   (cid:3)ID.
(< a, x1 >  UI b )} < a, x2 >  UI , and < x1, x2 >  P
 {a   (cid:3)I |  x1, x2, x3   (cid:3)ID.
(< a, x1 >  UI , < a, x2 >
 t )} , and < x1, x2, x3 >  P , < a, x3 >  UI
 (g  )I = {a   (cid:3)I |  x   (cid:3)ID.
(< a, x >  gI)}

 ,



 U = f1   fng  U.Pq  U1, U2.Pb  U1, U2, U3.Pt g   among these services can be speci ed as follows: CP_Require (cid:3) ( deposit   atT ime, c_Deli   lBound.
<) (cid:11) ( c_Pay   atT ime, c_Deli   rBound.
(cid:3)) (cid:11) ( interval, c_Deli   rBound, c_Pay   atT ime.+) (cid:11)( interval.
(cid:2)12) (cid:11) ( lBound, rBound.
(cid:2))

 In this section, we start with providing some very practical scenarios to illustrate the signi cance of actions.
A2.
The so-called "state of the world" (SoW) is generally assumed to be altered through invoking a service operation, viz.
the SoW for a services contract is not permanent.
If the underlying logic can entail the current state of a contract, the e ect produced by an action should also be entailed by the "updated" SoW.
Example 2.
Consider again the CP service.
If the computer delivery is executed successfully, it will cause some e ect to the other involved parties, e.g., the computer ownership will be changed.
Therefore, the preconditions of next action should be satis ed, otherwise the entire services contract may be blocked at certain state.
Meanwhile, it also needs to ensure that the contract can actually enter into some expected state eventually.
Our action theory is based on [1].
Considering the main features of semantic Web services, an action is de ned as follows: De nition 2.
(Action): An action is a quadruple (input, pre, output, e  ), where: (1).
input and output consist of a  nite set of concepts, and each concept should have at least one instance in some particular SWSc state, so that the legality of input and output data can be preserved.
(2).
pre consists of a  nite set of ABox assertions, representing preconditions for the action; (3).
e  consists of a  nite set of conditional e ect descriptions in the form of  / , where   is a set of ABox assertions and   is a set of assertions in the form of C(a),  C(a), R(a, b),  R(a, b), g(a,x),  g(a, x), Pq(x), Pb(x, y), and Pt(x, y, z) with C being a primitive concept, R a role, and g a concrete feature w.r.t.
T .
Example 3.
Consider an ABox as {user(peter), hasDeposit(peter,A1), amount(A1,amt), =1000 (amt), computer(L3YG), vendor(CP), own(CP,L3YG), bank(Deutsche), a liated(A1,Deutsche)}, and action computer delivery can be described as follows (input and output are omitted for simplicity):  amount.
(cid:3)800)(peter), user(peter)} pre = { hasDeposit.
( a f f iliated.
{Deutsche} (cid:11) e  = {(cid:6)(peter)/(own(peter, L3YG), own(CP, L3YG)))} De nition 3.
A Semantic Web Services contract (SWSc) is represented as a triple SC =< T ,A,ACT > such that: (1).
T corresponds to a terminology box (TBox) in DLs, which describes the skeleton of the contract.
(2).
A stands for an axiom box (ABox).
(3).
ACT describes all the legal actions to be executed in SC.
These actions can "drive" a contract s state to be transitioned.
Intuitively, T plays the role of orchestrating a set of speci ed actions, A represents the current state of the entire contract, and ACT provides the descriptions of a set of actions.
The interplay among them is thus obvious and natural, since TBoxes coordinate the action set, and ABoxes can be updated through the execution of an action.
The formal semantics of our SC is de ned as follows: De nition 4.
(State) A state of a SC is a set of assertions in the form of C(a),  C(a), R(a, b),  R(a, b), g(a,x),  g(a, x), Pq(x), Pb(x, y), and Pt(x, y, z) with C being a (complex) concept name.
(cid:5) >, where s and s (cid:5) De nition 5.
(Model).
Let   be an action, a transition T  is a set of pairs < s, s are states.
A model M of a services contract is de ned as: M =< S, T >, where S is a set of states, and T is a set of transitions of states in S.
In our framework, we consider state transition as ABox updates, i.e. if a SC enforces an action successfully, it is regarded as updating the ABox from the current state to a new state.
Based on the above de nitions, we can obtain the following lemma.
Lemma 1.
(Indeterminism) The update result of an ABox after there may exist more an action is applied is indeterministic, i.e.
than one possible state to be the consequence of an update.
Lemma 2.
The amount of possible consequent states through applying an action to the current state is  nite.
With the decidability of ALCQO(Q  ) itself and the  nite consequent states due to ABoxes updating strategy, we can obtain: Theorem 2.
(Well-de ned) Given a services contract SC, checking its consistency, executability, and projection is decidable.
We restrict the underpinning of our framework to a comparatively simple yet quite expressive Description Logic, viz., ALCQO.
Meanwhile, we have incorporated concrete domain and action theory into ALCQO, so as to equip it with the abilities to describe, coordinate, and trace the dynamic behaviors of involved parties.
In future, we will try to work out the tight complexity bounds of action reasoning, and implement some practical algorithms.
