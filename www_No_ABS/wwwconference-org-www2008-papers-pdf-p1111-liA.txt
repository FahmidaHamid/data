Tagging based search systems are known to be prone to semantic errors or limitations [2].
To name a few: Di erent users may use di erent tags (maybe synonyms) to describe the same object, causing inconsistency in tagging; The existence of polysemy (single term having multiple meanings) in a query causes ambiguity, and the query is often hard to re ne; The distribution of the tags being used is usually skewed and has the long-tail characteristic.
Therefore, on one hand, images with rare tags cannot be easily found.
On the other hand, queries with rare tags may need to be expanded to larger scopes.
We propose PivotBrowser, an iterative searching and re ning prototype for tagged images.
PivotBrowser employs a novel tag-based structure called pivot to address the above problems.
Our approach is di erent from a previous work on social tag clustering [1] as we can handle both synonymy and ambiguity.
To introduce the concept of pivot, we  rst give the de ni-tion of tag atom based on the availability of a tag thesaurus.
The tag thesaurus contains lexical relevance information for all tags, such as the synonyms ( ower, bloom, blossom ), Copyright is held by the author/owner(s).
the spelling variations (plural, abbreviation, etc.
), and the other highly relevant terms ( lm  vs.  movie ).
A good example of tag thesaurus is the one used in the WordNet[3].
A tag atom bA is a set of tags that satisfy the following requirements: (1) If a tag atom bA contains a tag t, it must also contain all lexically relevant tags of t as de ned in the thesaurus; (2) For any two tags in bA, t1 and t2, they must be lexically relevant to each other.
It is important to note that one tag may possibly appear in multiple tag atoms as it can have more than one lexical meaning in the thesaurus.
Therefore, given a universe of tags {ti}, we can precompute an inverted list for all possible tag atoms based on the tag thesaurus.
Each entry in the inverted list is like following < ti, id of bAi,1, id of bAi,2,       >, where each tag atom bAi,j contains tag ti.
We refer to this inverted list as the Tag Atom Inverted List (TAIL).
A pivot atom of tag ti, denoted as P A(ti), is de ned as the union of all tag atoms which contain ti (or those in the same entry of ti in TAIL).
A pivot of n tags, P (t1, t2, .
.
.
, tn), is de ned as the set containing all pivot atoms of its tags, P (t1, t2, .
.
.
, tn) = {P A(tm)|m = 1, .
.
.
, n}.
An n-tag set {tj1 , tj2 , .
.
.
, tjn } is said to be supported by pivot P (t1, t2, .
.
.
, tn), if tjm   P A(tm) (m = 1, 2, .
.
.
, n).
Based on these de nitions, we can enumerate all tag sets supported by a pivot.
These tag sets are supposed to be semantically similar to each other.
Before any user interaction, we need to precompute some data structures required during pivot browsing.
(1) First, given the universe of all tags in the image database, we generate the TAIL based on the thesaurus.
(2) Second, we generate an inverted index for the image database, where each entry contains an image ID list for a tag.
If each image is regarded as a document, for each key (tag) of the inverted index, we check the length of its image ID list and compute the inverse document frequency (IDF) for each tag.
(3) Third, we compute a tag-to-tag a nity matrix for all tags in the database.
The tag a nity metric that we use is the well-known Jaccard coe cient over the entire image database: a (t1, t2) = |ImageSet(t1)T ImageSet(t2)| |ImageSet(t1)S ImageSet(t2)| , where ImageSet(t) indicates the set of images having tag t.
The interactive pivot browsing is an iterative process consisting of the following three phases: (1) First, when a user issues a query Q containing tags {q1, .
.
.
, qn}, the system looks up the TAIL to  nd the tag atoms for each query tag qi.
By merging the tag atoms for each query tag, we obtain a pivot P (Q) = {P A(q1), .
.
.
, P A(qn)}.
For each tag set Q  supported by P (Q), we look up the inverted index of the image database to  nd images where all tags in Q  co-occur.
These images are saved as a candidate image set Ican, and all tags associated with them are saved (except for the query tags in Q) as a candidate tag set Tcan for further consideration in the subsequent phases.
(2) Second, all candidate tags in Tcan will undergo a selection pass, and the top-K candidates relevant to P (Q) will be obtained.
Meanwhile, the relevance value of each tag is saved as its weight.
The tag selection method will be discussed in section 2.3.
(3) Third, the K tags in the output of the previous phase will be clustered on the  y using a graph-partitioning algorithm as proposed in [4].
The a nity metric for clustering is based on the precomputed tag-to-tag a nity values.
These K tags, grouped in their clusters, will then be presented to the user for a new round of tag selection/re nement.
Meanwhile, one of the tag clusters (by default the most compact one) will be used to select the images in Ican   only candidates with tags which appear in the cluster are selected.
Ranking of the output images is based on the relevance between the tag vector of each image and the weighted vector of the cluster.
The latter can be obtained from the results of phase 2.
A user can certainly choose another tag cluster for image selection and browsing.
If a user subsequently adds a new tag to or removes an old one from the query, the pivot browsing process enters the next iteration (goto phase 1).
The top-K tags are selected from the candidate tag set Tcan based on their relevance to the pivot.
The relevance between a candidate tag t and the pivot P (Q) is computed using the tagging statistics as following rel(t, P (Q)) = co(t, P (Q))   IDF (t) where co(t, P (Q)) is the number of co-occurrences of t and any tag set Q  supported by P (Q), on the entire image database.
As any image associated with Q  must appear in Ican, we can expedite the co-occurrence computation by computing the number of images having tag t in Ican.
The IDF values can be obtained from the precomputation.
We implement the PivotBrowser prototype, and evaluate its query performance on a dataset containing 523746 tagged images randomly downloaded from Flickr.
The tag universe of the dataset contains 427482 unique tags.
Figure 1 shows the PivotBrowser interface with the search results for query of tag  window .
The top-right region presents the six clusters of the K tags relevant to the pivot.
To give a few examples, cluster1 = {view, airplane, condo .
.
.
}, cluster2 = {store, f ashion, display, shopping .
.
.
}, and cluster3 = {white, green, red, nikon, canon, blue .
.
.}.
The images shown are the topmost results of cluster1, which con rm the implied semantics of  sight-view from window  in the cluster.
Figure 1: A Search Result Page for query  window  We perform 200 unique queries on the prototype.
Each query is executed for 100 times.
Table 1 presents the average CPU time for selecting the candidate image set on the inverted index of the image database (SelectI), generating the top-K relevant tags (SelectT), clustering the K tags (ClusterT), and ranking the results (Rank).
The time for creating a pivot is negligible.
The results in the table reveal that the query cost is dominated by the selection on the inverted index of the image database.
CPU Time (ms) SelectI
 SelectT ClusterT Rank


 Table 1: Run-time CPU Cost in Each Phase In conclusion, the pivot browsing scheme realizes e ective query expansion and image searching in the tag-space at a low expense of computation and storage.
Therefore, it can help users to  nd the intended results more e ectively compared to conventional methods.
We believe that pivot browsing can potentially become a general tag-space search paradigm not only limited to images.
For future work, we would conduct a usability study on PivotBrowser.
We would also consider a comprehensive study on incorporating visual feature comparison, and other tag selection and clustering strategies into it.
