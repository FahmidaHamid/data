Interoperability and manageability in the presence of heterogeneity are two very important concerns for enterprise IT system managers.
Services computing promises to ease these problems by creating an infrastructure of loosely coupled components residing in an heterogeneous framework.
This has lead to several research e orts that explore ways of increasing the level of automation in service discovery, invocation, composition and interoperation [1, 4].
However, the current services based software development model su ers from several drawbacks.
The developers are forced to take into consideration dynamics of the runtime environment since services are actively running components rather than passive function/class libraries.
Further, the developers are required to map high level service requirements to programming constructs available in current OO languages such as Java and C#.
There is a clear mismatch between the needs of services software developer and the programming models available today.
In this paper, we propose new language constructs that enable programming with services and discuss some bene ts arising from such an approach.
In this section, we build upon our previous work [3] that proposed granting a  rst class status to services.
The proposal used a semantic web services based representation Copyright is held by the author/owner(s).
model [2] that applies the abstraction principle of classi cation to services and de nes the concepts of service types and service instances [2, 1].
Service types capture the semantic description of the service primarily in terms of its interface description.
A service instance, on the other hand, provides an operational description of a service and represents an actual running instance.
Web Service S/w Development Environment Other Libraries Registry of ServiceType Definitions Compile Time Phase Developer Deployable Program (Program with Service Type variables and unbound ServiceInstance Variables) Binding Component Executable Program Limited Search Registry of Service Instances Execution Engine Web Service Runtime Execution Environment Available Services Run Time Phase Figure 1: Programming Model for Services Figure 1 shows the resulting programming model for service oriented software development that enables to split the development process across design time and runtime phases.
This is essential to shield the developers from the dynamics of runtime environment.
As shown in the  gure, the development environment provides a service types registry using which the developers could program to service interfaces without worrying about live instances.
These service oriented programs could then be deployed by binding the service variables to actual running instances available at that time.
The runtime execution environment provides access to instances registry.
To utilize this programming model, we introduce two new language constructs namely ServiceType and ServiceIn-stance.
ServiceTypes and ServiceInstances are analogous to Classes and Objects, respectively, yet di erent.
While ServiceTypes refer to de nition of a service just like a class de nes an entity and ServiceInstance refers to a live service similar to objects, the di erence lies in the fact that both ServiceTypes and ServiceInstances are  rst class entities.
Classes are typically not  rst class entities such as in C++.
The ServiceType variables can be used to encode logic applicable at compile time while ServiceInstance variables allow encoding of logic applicable at runtime.
They could be declaratively de ned as partially shown in
 functionalSpec{ interfaceTypeA{ inputTypes { .. }; outputTypes { .. }; preconditions { .. }; effects { .. }; };  .
}; modelDescription{ .. }; stateDescription { <List of types of data members> }; nonFunctionalReqmts{ ServiceInstance{ serviceTypeRef; operationalSpec{ interfaceA{ inputs {..}; outputs{..}; }  .
} state{ <list of data variables> } nonFunctionalCapability{ <QoS guarantees> } binding{ <QoS and other reqmts.> <list of protocols,ports> }; } } } Figure 2: ServiceType and ServiceInstance Fig. 2.
Alternatively, ServiceType could be de ned with the help of service type descriptions available in the types registry.
The de nition in such a case would take the form: new ServiceType(XMLFileRef FS, XMLFileRef MD, XMLFileRef SD, XMLFileRef NFR) ServiceType construct is composed of four elements - a functional speci cation containing various interface descriptions, a model description, description of State in terms of a list of data types, and constraints on nonfunctional capabilities of service instances.
Similarly, ServiceInstance could also be de ned with the help of service instance descriptions in instances registry as given below: new ServiceInstance(serviceTypeRef, XMLFileRef OS, XMLFileRef State, XMLFileRef NFC, XMLFileRef binding) The  new  operation here creates a new ServiceInstance entity and binds it to an actual running service instance, in the services registry, whose service details are provided through the XMLFile references in the parameters.
The functional speci cation in the ServiceType de nition enables the software developers to write logic that reasons upon the functionality of the service they are dealing with.
The operational speci cation in ServiceInstances allows logic that invokes the service s functionality.
Operations on Service Types are de ned based upon the notion of classi cation, composition and inheritance de ned for services in [2], -Classi cation: isEquivalentTo(ST) returns a degree of match between the current service type and the service type supplied as parameter; isBound() returns true if a service type has been instantiated or bound to at least one instance; getInstance(ST) returns an existing bound ServiceInstance or creates a new binding to an actual running service instance and returns it as a ServiceInstance; isServiceTypeOf(SI) returns a value indicating a degree of match i.e. direct type of the service instance vs a super type in chain.
- Composition: isComposedOf(ListofSTs) and isCompo-nentOf(CompositeST) return a true if the current service type is composed of the supplied list of service types and if it is a component of the supplied service type respectively.
isSuperTypeOf(ST) and isSubTypeOf(ST) return true if the current service type is a supertype and if it is a subtype of the speci ed service type respectively.
- Inheritance: Operations on Service Instance variables include the functional methods (i.e. actual functionality o ered by the instance) and others operations that are related to querying the interface descriptions or sending commands to the instance and verifying the health of the instance by invoking their management interfaces.
The functional methods are invoked by referring to the interface names (such as interfaceA in Fig. 2) through the ServiceInstance variable.
Queries for interface descriptions are supported by invoking an appropriate operation on the associated ServiceType.
Such operations on instances would help automatic agents to programmatically interpret and subsequently invoke the interface of new services.
The management commands and health check operations are dependent upon the management interfaces implemented by the instances.
ServiceJ [4] proposes extensions to Java to enable support for service oriented computing in OO languages.
Declarative language constructs are proposed to transparently deal with service selection at runtime as well as for applying a  ltering and ranking criteria.
However, their extensions deal primarily with nonfunctional aspects and it is not clear how their compiler works without having access to functional description of services available at compile time.
The ServiceType and ServiceInstance constructs proposed in this paper address the functional as well as nonfunctional aspects of services in a unifying development framework.
Zimmermann et al. [6] motivate the need for a Service Oriented Analysis and Design (SOAD) approach that leverages and builds upon existing approaches of Object Oriented Analysis and Design (OOAD), Enterprise Architecture frameworks and Business Process Modeling concepts.
Papazoglou [5] provides a detailed comparison between services in SOA and objects in OOAD.
However, they felt that concepts like polymorphism etc.
are not applicable to SOA.
The language constructs proposed by us enable such OO features by raising the programming abstraction from objects to services.
We have proposed programming language constructs to enable programming with services.
The constructs incorporate well established object oriented software development principles such as classi cation, composition and inheritance into a service oriented programming model.
We are currently in the process of developing a compiler for introducing these constructs as extensions to Java.
