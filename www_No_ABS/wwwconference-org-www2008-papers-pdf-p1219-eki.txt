The Semantic Web is an evolving extension of the World Wide Web (WWW) in which web contents can be expressed not only in natural language but also in a form that can be understood, interpreted, and used by software agents, thereby permitting such agents to  nd, share, and integrate information more easily.
In general, semistructured data are characterized by the lack of  xed and rigid schema, although, typically, the data have some implicit structure.
We propose a method of classifying XML documents and extracting XML schema from XML documents through inductive inference based on constraint logic programming; our goal is to be able to type a large collection of XML approximately but e ciently.
[4] proposed an approach to extract schema from semi-structured data.
Our research is mainly based on that study.
Constraint logic Copyright is held by the author/owner(s).
programming is a paradigm that builds a mechanism of restriction cancellation into logic programming; [3] presents a concept of constraint into a relative connotation.
[2] proposed to identify relationships between attributes or classes in di erent database schemas.
Details of our research are described in [1].
Our approach has three steps.
The  rst step is XML to predicates, the second step is predicates to rules by induction inference, and the last step is predicates to rules by using ontology.
We evaluate similarity of data type and data range by using an ontology dictionary, and XML Schema is made from results of second and last step.
The  rst step is production of constraints from XML documents.
The standard manner is to contain a link-structure and values to extract data into XML (the order of elements is not guaranteed), and to represent the XML using seven base relations de ned as follows: Here, Object is O, Class is C, FromObject is FO, ToObject is TO, Label is L, and Value is V.
class(O, C) :- The class(O, C) corresponds to O being C.
link(FO, TO, L) :- The link(FO, TO, L) corresponds to an edge labeled L from FO to TO.
There is at most one such edge labeled L.
element(O, V) :- The element(O, V) corresponds to O being element and having V.
attribute(O, V1, V2) :- The attribute(O, V1, V2) corresponds to O being an attribute and having V1 and V2.
root(O) :- The root(O) corresponds to O being a root-tag.
branch(O) :- The branch(O) corresponds to O being a branch.
leaf(O) :- The root(O) corresponds to O being a leaf tag.
Next, our approach generates predicates for the data type or data range.
In our study, we assumed that the data type and data range were similar to a tag that expresses the same meaning.
Moreover, these are expressed by the data type and the regular expression of XML schema.
The generated predicate becomes two kinds of the following.
datatype(O, V).
The data type of O is V. Type includes decimal, string, Boolean, etc.
datarange(O, V).
The data range of O is V. V records the range of character length or the value.
For instance, the numeric character data and ranges of 1000 9999, are described as follows.
xsd:minInclusive value="1000", xsd:maxInclusive value="9999" .
(cid:9496)(cid:9513)(cid:9527)(cid:9528)(cid:9444)(cid:9479)(cid:9509)(cid:9527)(cid:9513) (cid:9461) (cid:9462) (cid:9463) (cid:9495)(cid:9511)(cid:9516)(cid:9513)(cid:9521)(cid:9509) (cid:9444)(cid:9444)(cid:9444)(cid:9444)(cid:9444)(cid:9475) (cid:9501) (cid:9490) (cid:9490) (cid:9485)(cid:9521)(cid:9524)(cid:9520)(cid:9517)(cid:9527)(cid:9517)(cid:9528)(cid:9444)(cid:9495)(cid:9528)(cid:9526)(cid:9529)(cid:9511)(cid:9528)(cid:9529)(cid:9526)(cid:9513) (cid:9444)(cid:9444)(cid:9444)(cid:9444)(cid:9444)(cid:9444)(cid:9444)(cid:9444)(cid:9444)(cid:9444)(cid:9444)(cid:9475) (cid:9501) (cid:9501) (cid:9490) (cid:9485)(cid:9522)(cid:9527)(cid:9528)(cid:9509)(cid:9522)(cid:9511)(cid:9513)(cid:9444)(cid:9482)(cid:9517)(cid:9520)(cid:9513)(cid:9522)(cid:9509)(cid:9521)(cid:9513)(cid:9444) (cid:9528)(cid:9513)(cid:9527)(cid:9528)(cid:9511)(cid:9509)(cid:9527)(cid:9513)(cid:9461)(cid:9507)(cid:9461)(cid:9457)(cid:9457)(cid:9461)(cid:9460)(cid:9460)(cid:9458)(cid:9532)(cid:9521)(cid:9520) (cid:9528)(cid:9513)(cid:9527)(cid:9528)(cid:9511)(cid:9509)(cid:9527)(cid:9513)(cid:9462)(cid:9507)(cid:9461)(cid:9457)(cid:9457)(cid:9461)(cid:9460)(cid:9460)(cid:9458)(cid:9532)(cid:9521)(cid:9520) (cid:9528)(cid:9513)(cid:9527)(cid:9528)(cid:9511)(cid:9509)(cid:9527)(cid:9513)(cid:9463)(cid:9507)(cid:9461)(cid:9457)(cid:9457)(cid:9461)(cid:9460)(cid:9460)(cid:9458)(cid:9532)(cid:9521)(cid:9520) (cid:9477)(cid:9530)(cid:9513)(cid:9526)(cid:9509)(cid:9515)(cid:9513)(cid:9444)(cid:9485)(cid:9522)(cid:9527)(cid:9528)(cid:9509)(cid:9522)(cid:9511)(cid:9513)(cid:9444)(cid:9495)(cid:9517)(cid:9534)(cid:9513) (cid:9444)(cid:9444)(cid:9444)(cid:9444)(cid:9444)(cid:9444)(cid:9444)(cid:9452)(cid:9487)(cid:9510)(cid:9533)(cid:9528)(cid:9513)(cid:9527)(cid:9453) (cid:9462)(cid:9462) (cid:9462)(cid:9461) (cid:9462)(cid:9462) (cid:9477)(cid:9530)(cid:9513)(cid:9526)(cid:9509)(cid:9515)(cid:9513)(cid:9444)(cid:9490)(cid:9529)(cid:9521)(cid:9510)(cid:9513)(cid:9526)(cid:9444) (cid:9444)(cid:9444)(cid:9444)(cid:9444)(cid:9444)(cid:9523)(cid:9514)(cid:9444)(cid:9490)(cid:9523)(cid:9512)(cid:9513)(cid:9527) (cid:9461)(cid:9461)(cid:9462) (cid:9461)(cid:9461)(cid:9462) (cid:9461)(cid:9461)(cid:9462)
 We use Progol, which is a system of typical induction logic programming, to analyze classi cation rules.
The background knowledge used for the inductive inference is a hierarchical relation of the amount of the multistep  oor features and the connotation relation between the amount of characteristics.
In this case, two classi cation rules were derived using a study that addressed both data of a negative example and a positive example.
It is impossible to detect di erences from the study data even a little, but the accuracy of the classi ed category generation is high because usual studies that use data of both a positive example negative example suggest a classi cation rule that the restriction is strong compared to studies that use only a positive example.
The accuracy of the category generation worsens because the restriction of a study that uses only a positive example is weak and one-sided, although it is possible to correspond when using only study data with little di erence.
Our approach to improving case-sensitive matching is taken by obtaining the retrieval result because the detection results by the restriction of study that uses only a positive example are integrated based on the restriction of a usual study that uses both data of the positive example and the negative example in this study.
The dataset comprises 300 collected XML  les, e.g., News-ML and weblogs, from which 81 unique XML documents were made.
The results of running our typing algorithm for several synthetic data sets are presented in Table 2.
We conducted 100 experiments per test case.
Here, XML data were acquired from about a 110-node instance size.
 Schema?  in Table 1 shows whether the test case has a scheme, e.g.
DTD.
 Implicit Structure?  in Table 1 shows whether the test case has implicit structures.
Evaluation Value is a ratio that uses data of both the positive example and negative example; for the negative example, in the case of 0.8, the data only of 80% and a positive example takes the meaning of 20%.
Here, the value of the Evaluation Value has three patterns: 0.8, 0.6, and 0.4 for each Test Case.
The results of experiments are presented in Table 2.
Their corresponding graphs are shown in Fig. 1.
Test Number in Table 2 and Test Number on the horizontal axis of Fig. 1 mutually correspond.
When the Evaluation Value was one or less, it did not become 100%, although Test Case1 with the schema was a very high recall ratio in this experiment (The result shown in Table 2 is displayed to three signi cant digits).
In the experiment, the generated restriction was queried, and a method of obtaining the set of necessary data was described.
Results con rmed whether man was correct for the relevance ratio and the recall ratio.
Test Case
 relevance ratio is about 60% when the recall ratio is about 74%.
Furthermore, it is low when the Evaluation Value is improving.
The prevailing purpose of this study is Test Case 2.
Future studies are intended to design a technique for displaying the relevance ratio with high accuracy simultaneously to boosting the recall ratio of this case as high as possible.
Table 2: Experimental Results A.
(cid:9481)(cid:9530)(cid:9509)(cid:9520)(cid:9529)(cid:9509)(cid:9528)(cid:9517)(cid:9523)(cid:9522) (cid:9444)(cid:9444)(cid:9498)(cid:9509)(cid:9520)(cid:9529)(cid:9513)(cid:9444) (cid:9460)(cid:9458)(cid:9468) (cid:9460)(cid:9458)(cid:9466) (cid:9460)(cid:9458)(cid:9464) (cid:9460)(cid:9458)(cid:9468) (cid:9460)(cid:9458)(cid:9466) (cid:9460)(cid:9458)(cid:9464) (cid:9460)(cid:9458)(cid:9468) (cid:9460)(cid:9458)(cid:9466) (cid:9460)(cid:9458)(cid:9464) (cid:9477)(cid:9530)(cid:9513)(cid:9526)(cid:9509)(cid:9515)(cid:9513)(cid:9444)(cid:9479)(cid:9523)(cid:9522)(cid:9527)(cid:9528)(cid:9526)(cid:9509)(cid:9517)(cid:9522)(cid:9528) (cid:9444)(cid:9444)(cid:9444)(cid:9444)(cid:9444)(cid:9444)(cid:9444)(cid:9444)(cid:9444)(cid:9479)(cid:9523)(cid:9529)(cid:9522)(cid:9528) (cid:9461)(cid:9461) (cid:9461)(cid:9461) (cid:9461)(cid:9461) (cid:9462)(cid:9461) (cid:9462)(cid:9461) (cid:9462)(cid:9461) (cid:9463)(cid:9465) (cid:9463)(cid:9465) (cid:9463)(cid:9465) (cid:9477)(cid:9530)(cid:9513)(cid:9526)(cid:9509)(cid:9515)(cid:9513) (cid:9492)(cid:9526)(cid:9513)(cid:9511)(cid:9517)(cid:9527)(cid:9517)(cid:9523)(cid:9522)(cid:9452)(cid:9449)(cid:9453) (cid:9469)(cid:9461)(cid:9458)(cid:9460) (cid:9467)(cid:9468)(cid:9458)(cid:9468) (cid:9467)(cid:9468)(cid:9458)(cid:9466) (cid:9468)(cid:9460)(cid:9458)(cid:9462) (cid:9466)(cid:9464)(cid:9458)(cid:9467) (cid:9465)(cid:9469)(cid:9458)(cid:9467) (cid:9463)(cid:9468)(cid:9458)(cid:9466) (cid:9463)(cid:9465)(cid:9458)(cid:9464) (cid:9462)(cid:9462)(cid:9458)(cid:9467) (cid:9477)(cid:9530)(cid:9513)(cid:9526)(cid:9509)(cid:9515)(cid:9513) (cid:9494)(cid:9513)(cid:9511)(cid:9509)(cid:9520)(cid:9520)(cid:9452)(cid:9449)(cid:9453) (cid:9461)(cid:9460)(cid:9460) (cid:9461)(cid:9460)(cid:9460) (cid:9461)(cid:9460)(cid:9460) (cid:9467)(cid:9464)(cid:9458)(cid:9461) (cid:9468)(cid:9462)(cid:9458)(cid:9463) (cid:9468)(cid:9463)(cid:9458)(cid:9469) (cid:9462)(cid:9465)(cid:9458)(cid:9466) (cid:9463)(cid:9462)(cid:9458)(cid:9465) (cid:9464)(cid:9469)(cid:9458)(cid:9462) (cid:9496)(cid:9513)(cid:9527)(cid:9528)(cid:9444)(cid:9490)(cid:9529)(cid:9521)(cid:9510)(cid:9513)(cid:9526) (cid:9496)(cid:9513)(cid:9527)(cid:9528)(cid:9444)(cid:9479)(cid:9509)(cid:9527)(cid:9513) (cid:9461) (cid:9461) (cid:9461) (cid:9462) (cid:9462) (cid:9462) (cid:9463) (cid:9463) (cid:9463) (cid:9461) (cid:9462) (cid:9463) (cid:9464) (cid:9465) (cid:9466) (cid:9467) (cid:9468) (cid:9469)











 Precision Recall


 Figure 1: Experimental Results B.
To summarize, this paper proposes a framework for XML retrieval which can  nd similar meanings of XML within di erent XML structures.
Our approach uses syntax and semantics search; it also uses predicate logic.
Results of experiments using real and synthetic data con rmed that our system can compare many kinds of XML documents.
The veri cation of e ectiveness for processing the tag structures which have only small di erences is a task of future studies, although the present study achieved a highly accurate classi cation and retrieval for tag structures with a large di er-ence of features.
