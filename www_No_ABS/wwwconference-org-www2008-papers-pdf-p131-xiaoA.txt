One of the issues accompanying the rapid growth of data on the Internet and the growing need to integrating data from heterogeneous sources is the existence of near duplicate data.
Near duplicate data bear high similarity to each other, yet they are not bitwise identical.
There are many causes for the existence of near duplicate data: typographical errors, versioned, mirrored, or plagiarized documents, multiple representations of the same physical object, spam emails generated from the same template, etc.
As a concrete example, a sizeable percentage of the Web pages are found to be near-duplicates by several studies [6, 14, 18].
These studies suggest that around 1.7% to 7% of the Web pages visited by crawlers are near duplicate pages.
Identifying all the near duplicate objects bene ts many applications.
For example,   For Web search engines, identifying near duplicate Web pages helps to perform focused crawling, increase the quality and diversity of query results, and identify spams [14,
   Many Web mining applications rely on the ability to accurately and e ciently identify near-duplicate objects.
They Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
include document clustering [6],  nding replicated Web collections [9], detecting plagiarism [20], community mining in a social network site [25], collaborative  ltering [3] and discovering large dense graphs [15].
A quantitative way to de ning that two objects are near duplicates is to use a similarity function.
The similarity function measures degree of similarity between two objects and will return a value in [0, 1].
A higher similarity value indicates that the objects are more similar.
Thus we can treat pairs of objects with high similarity value as near duplicates.
A similarity join will  nd all pairs of objects whose similarities are above a given threshold.
An algorithmic challenge is how to perform the similarity join in an e cient and scalable way.
A na ve algorithm is to compare every pair of objects, thus bearing a prohibitively O(n2) time complexity.
In view of such high cost, the prevalent approach in the past is to solve an approximate version of the problem, i.e.,  nding most of, if not all, similar objects.
Several synopsis-based schemes have been proposed and widely adopted [5, 7, 10].
A recent trend is to investigate algorithms that compute the similarity join exactly.
Recent advances include inverted index-based methods [24], pre x  ltering-based methods [8,
 cently proposed All-Pairs algorithm [3] was demonstrated to be highly e cient and be scalable to tens of millions of records.
Nevertheless, we show that the All-Pairs algorithm, as well as other pre x  ltering-based methods, usually generates a huge amount of candidate pairs, all of which need to be veri ed by the similarity function.
Empirical evidence on several real datasets shows that its candidate size grows at a fast quadratic rate with the size of the data.
Another inherent problem is that it hinges on the hypothesis that similar objects are likely to share rare  features  (e.g., rare words in a collection of documents).
This hypothesis might be weakened for problems with a low similarity threshold or with a restricted feature domain.
In this paper, we propose new exact similarity join algorithms with application to near duplicate detection.
We propose a positional  ltering principle, which exploits the ordering of tokens in a record and leads to upper bound estimates of similarity scores.
We show that it is complementary to the existing pre x  ltering method and can work on tokens both in the pre xes and the su xes.
We conduct an extensive experimental study using several real datasets, and demonstrate that the proposed algorithms outperform previous ones.
We also show that the new algorithms can be adapted or combined with existing approaches to pro-
e ciency in detecting near duplicate Web pages.
The rest of the paper is organized as follows: Section 2 presents the problem de nition and preliminaries.
Section 3 summarizes the existing pre x  ltering-based approaches.
Sections 4 and 5 give our proposed algorithms that integrate positional  ltering method on the pre xes and su xes of the records, respectively.
Generalization to other commonly used similarity measures is presented in Section 6.
We present our experimental results in Section 7.
Related work is covered in Section 8 and Section 9 concludes the paper.
We de ne a record as a set of tokens taken from a  -nite universe U = { w1, w2, .
.
.
, w|U| }.
A similarity function, sim, returns a similarity value in [0, 1] for two records.
Given a collection of records, a similarity function sim(), and a similarity threshold t, the similarity join problem is to  nd all pairs of records, hx, yi, such that their similarities are no smaller than the given threshold t, i.e, sim(x, y)   t.
Consider the task of identifying near duplicate Web pages for example.
Each Web page is parsed, cleaned, and transformed into a multiset of tokens: tokens could be stemmed words, q-grams, or shingles [5].
Since tokens may occur multiple times in a record, we will convert a multiset of tokens into a set of tokens by treating each subsequent occurrence of the same token as a new token [8].
We can evaluate the similarity of two Web pages as the Jaccard similarity between their corresponding sets of tokens.
We denote the size of a record x as |x|, which is the number of tokens in x.
The document frequency of a token is the number of records that contain the token.
We can canon-icalize a record by sorting its tokens according to a global ordering O de ned on U .
A document frequency ordering Odf arranges tokens in U according to the increasing order of tokens  document frequencies.
A record x can also be represented as a |U|-dimensional vector, ~x, where xi = 1 if wi   x and xi = 0 otherwise.
The choice of the similarity function is highly dependent on the application domain and thus is out of the scope of this paper.
We do consider several widely used similarity functions.
Consider two records x and y,   Jaccard similarity is de ned as J(x, y) = |x y| |x y|   Cosine similarity is de ned as C(x, y) = ~x ~y k~xk k~yk   Overlap similarity is de ned as O(x, y) = |x   y|.1 .
A closely related concept is the notion of distance, which can be evaluated by a distance function.
Intuitively, a pair of records with high similarity score should have a small distance between them.
The following distance functions are considered in this work.
  Hamming distance between x and y is de ned as the size of their symmetric di erence: H(x, y) = |(x  y) (y  x)|.
  Edit distance, also known as Levenshtein distance, measures the minimum number of edit operations needed to = Pi xiyi  |x| |y|
 similarity to [0, 1].
transform one string into the other, where an edit operation is an insertion, deletion, or substitution of a single character.
It can be calculated via dynamic programming [26].
Note that the above similarity and distance functions are interrelated.
We discuss some important relationships in Section 2.2, and others in Section 6.
In this paper, we will focus on the Jaccard similarity, a commonly used function for de ning similarity between sets.
Extension of our algorithms to handle other similarity or distance functions appears in Section 6.
Therefore, in the rest of the paper, sim(x, y) by default denotes J(x, y), unless otherwise stated.
Example 1.
Consider two text document, Dx and Dy as: Dx = yes as soon as possible  Dy = as soon as possible please  They can be transformed into the following two records x ={ A, B, C, D, E } y ={ B, C, D, E, F } with the following word-to-token mapping table: Word Token Doc.
Freq.
yes

 as

 soon

 as1

 possible please



 Note that the second  as  has been transformed into a token  as1  in both records.
Records can be canonicalized according to the document frequency ordering Odf into the following ordered sequences (denoted as [.
.
.])
x =[ A, B, C, D, E ] y =[ F, B, C, D, E ] The Jaccard similarity of x and y is 4 cosine similarity is = 0.80.
6 = 0.67, and the

 Similarity joins essentially evaluate every pair of records against a similarity constraint of J(x, y)   t. This constraint can be transformed into several equivalent forms on the overlap similarity or the Hamming distance as follows: J(x, y)   t   O(x, y)     = O(x, y)       H(x, y)   |x| + |y|   2  1 + t   (|x| + |y|) t (1) (2) .
We can also infer the following constraint on the relative sizes of a pair of records that meets a Jaccard constraint.
J(x, y)   t =  t   |x|   |y| (3)

 A na ve algorithm to compute t-similarity join result is to enumerate and compare every pair of records.
This method is obviously prohibitively expensive for large datasets, as the total number of comparisons is O(n2).
E cient algorithms exist by converting the Jaccard similarity constraint into an equivalent overlap constraint due to Equation (1).
An e cient way to  nd records that overlap with a given record is to use inverted indices [2].
An
 records that contain w. After inverted indices for all tokens in the record set are built, we can scan each record x, probe the indices using every token in x, and obtain a set of candidates; merging these candidates together gives us their actual overlap with the current record x;  nal results can be extracted by removing records whose overlap with x is less than   t
 of this approach is that the inverted lists of some tokens, often known as  stop words , can be very long.
These long inverted lists incur signi cant overhead for building and accessing them.
In addition, computing the actual overlap by probing indices essentially requires memorizing all pairs of records that share at least one token, a number that is often prohibitively large.
Several existing work takes this approach with optimization by pushing the overlap constraint into the similarity value calculation phase.
For example, [24] employs sequential access on short inverted lists but switches to binary search on the     1 longest inverted lists.
Another approach is based on the intuition that if two canonicalized records are similar, some fragments of them should overlap with each other, as otherwise the two records won t have enough overlap.
This intuition can be formally captured by the pre x ltering principle [8, Lemma 1] rephrased below.
Lemma 1 (Prefix Filtering Principle).
Consider an ordering O of the token universe U and a set of records, each with tokens sorted in the order of O.
Let the p-pre x of a record x be the  rst p tokens of x.
If O(x, y)    , then the (|x|    + 1)-pre x of x and the (|y|    + 1)-pre x of y must share at least one token.
Since pre x  ltering is a necessary but not su cient condition for the corresponding overlap constraint, we can design an algorithm accordingly as: we  rst build inverted indices on tokens that appear in the pre x of each record in an indexing phase.
We then generate a set of candidate pairs by merging record identi ers returned by probing the inverted indices for tokens in the pre x of each record in a candidate generation phase.
The candidate pairs are those that have the potential of meeting the similarity threshold and are guaranteed to be a superset of the  nal answer due to the pre x  ltering principle.
Finally, in a veri cation phase, we evaluate the similarity of each candidate pair and add it to the  nal result if it meets the similarity threshold.
A subtle technical issue is that the pre x of a record depends on the sizes of the other record to be compared and thus cannot be determined before hand.
The solution is to index the longest possible pre xes for a record x.
It can be shown that we only need to index a pre x of length |x| t |x| +1 for every record x to ensure the pre x  ltering-based method does not miss any similarity join result.
The major bene t of this approach is that only smaller inverted indices need to be built and accessed (by a approximately (1   t) reduction).
Of course, if the  ltering is not e ective and a large number of candidates are generated, the e ciency of this approach might be diluted.
We later show that this is indeed the case and propose additional  ltering methods to alleviate this problem.
There are several enhancements on the basic pre x ltering scheme.
[8] considers implementing the pre x  ltering method on top of a commercial database system, while [3] further improves the method by utilizing several other  ltering techniques in candidate generation phase and veri cation phase.
Example 2.
Consider a collection of four canonicalized records based on the document frequency ordering, and the Jaccard similarity threshold of t = 0.8: w = [ C, D, F ] z = [ G, A, B, E, F ] y = [ A, B, C, D, E ] x = [ B, C, D, E, F ] Pre x length of each record u is calculated as |u| t |u| +1.
Tokens in the pre xes are underlined and are indexed.
For example, the inverted list for token C is [ w, x ].
Consider the record x.
To generate its candidates, we need to pair x with all records returned by inverted lists of tokens B and C. Hence, candidate pairs formed for x are {hx, yi,hx, wi}.
The All-Pairs algorithm [3] also includes several other  l-tering techniques to further reduce the candidate size.
For example, it won t consider hx, wi as a candidate pair, as |w| < 4 and can be pruned due to Equation (3).
This  l-tering method is known as size  ltering [1].
We now describe our solution to solve the exact similarity join problem.
We  rst introduce the positional  ltering, and then propose a new algorithm, ppjoin, that combines positional  ltering with the pre x  ltering-based algorithm.
Algorithm 1: ppjoin (R, t) Input : R is a multiset of records sorted by the increasing order of their sizes; each record has been canonicalized by a global ordering O; a Jaccard similarity threshold t Output : All pairs of records hx, yi, such that sim(x, y)   t
 Ii     (1   i   |U |); for each x   R do A   empty map from record id to int; p   |x|    t   |x|  + 1; for i = 1 to p do w   x[i]; for each (y, j)   Iw such that |y|   t   |x| do /* size filtering on |y| */ 1+t (|x| + |y|) ;       t ubound   1 + min(|x|   i, |y|   j); if A[y] + ubound     then A[y]   A[y] + 1; else A[y]   0; /* prune y */; Iw   Iw   {(x, i)}; /* index the current prefix */; Verify(x, A,  );
















 return S Although a global ordering is a prerequisite of pre x  lter-ing, no existing algorithm fully exploits it when generating the candidate pairs.
We observe that positional information can be utilized in several ways to further reduce the
 sition a token in a canonicalized record (starting from 1).
We illustrate the observation in the following example.
Example 3.
Consider x and y from the previous example and the same similarity threshold t = 0.8 y = [ A, B, C, D, E ] x = [ B, C, D, E, F ] The pair, hx, yi, does not meet the equivalent overlap constraint of O(x, y)   5, hence is not in the  nal result.
However, since they share a common token, B, in their pre xes, pre x  ltering-based methods will select y as a candidate for x.
However, if we look at the positions of the common token B in the pre xes of x and y, we can obtain an estimate of the maximum possible overlap as the sum of current overlap amount and the minimum number of unseen tokens in x and y, i.e., 1 + min(3, 4) = 4.
Since this upper bound of the overlap is already smaller than the threshold of 5, we can safely prune hx, yi.
We now formally state the positional  ltering principle in Lemma 2.
Lemma 2 (Positional Filtering Principle).
Consider an ordering O of the token universe U and a set of records, each with tokens sorted in the order of O.
Let token w = x[i], w partitions the record into the left partition xl(w) = x[1 .
.
(i   1)] and the right partition xr(w) = x[i .
.|x|].
If O(x, y)    , then for every token w   x   y, O(xl(w), yl(w)) + min(|xr(w)|,|yr(w)|)    .
A natural idea to utilize the positional  ltering principle is to combine it with the existing pre x  ltering method, which already keeps tracks of the current overlap of candidate pairs and thus gives us O(xl(w), yl(w)).
Algorithm 1 describes our ppjoin algorithm, an extension to the All-Pairs algorithm [3], to combine positional  ltering and pre x ltering.
Like the All-Pairs algorithm, ppjoin algorithm takes as input a collection of canonicalized record already sorted in the ascending ordered of their sizes.
It then sequentially scans each record x,  nds candidates that intersect x s pre x (x[1 .
.
p], Line 5) and accumulates the overlap in a hash map A (Line 12).
The generated candidates are further veri ed against the similarity threshold (Line 16) to return the correct join result.
Note that the internal threshold used in the algorithm is an equivalent overlap threshold   computed from the given Jaccard similarity threshold t. The document frequency ordering Odf is often used to canonicalize the records.
It favors rare tokens in the pre xes and hence results in a small candidate size and fast execution speed.
Readers are referred to [3] for further details on the All-Pairs algorithm.
Now we will elaborate on several novel aspects of our extension: (i) the inverted indices used (Algorithm 1, Line
 Lines 9 14), and (iii) the optimized veri cation algorithm (Algorithm 2).
In Line 15, we index both tokens and their positions for tokens in the pre xes so that our positional  ltering can utilize the positional information.
In Lines 9 14, we compute an upper bound of the overlap between x and y, and only admit this pair as a candidate pair if its upper bound is no less than the threshold  . Speci cally,   is computed according to Equation (1); ubound is an upper bound of the overlap between right partitions of x and y with respect to the current token w, which is derived from the number of unseen tokens in x and y with the help of the positional information in the index Iw; A[y] is the current overlap for left partitions of x and y.
It is then obvious that if A[y]+ubound is smaller than  , we can prune the current candidate y (Line 14).
Algorithm 2: Verify(x, A,  ) Input : px is the pre x length of x and py is the pre x length of y for each y such that A[y] > 0 do wx   the last token in the pre x of x; wy   the last token in the pre x of y; O   A[y]; if wx < wy then ubound   A[y] + |x|   px; if ubound     then
  x[(px + 1) .
.
|x|] T y[(A[y] + 1) .
.
|y|]   ; else ubound   A[y] + |y|   py; if ubound     then
  x[(A[y] + 1) .
.
|x|] T y[(py + 1) .
.
|y|]   ; if O     then S   S   (x, y);













 Algorithm 2 is designed to verify whether the actual overlap between x and candidates y in the current candidate set, { y | A[y] > 0}, meets the threshold  .
Notice that we ve already accumulated in A[y] the amount of overlaps that occur in the pre xes of x and y.
An optimization is to  rst compare the last token in both pre xes, and only the su x of the record with the smaller token (denoted the record as u) needs to be intersected with the entire other record (denoted as v).
This is because the pre x of u consists of tokens that are smaller than wu (the last token in u s pre x) in the global ordering and v s su x consists of tokens that are larger than wv.
Since wu   wv, u s pre x won t intersect with v s su x.
In fact, the workload can still be reduced: we can skip the  rst A[y] number of tokens in v since at least A[y] tokens have overlapped with u s pre x and hence won t contribute to any overlap with u s su x.
The above method is implemented through Lines 4, 5, 8, and 12 in Algorithm 2.
This optimization in calculating the actual overlap immediately gives rise to a pruning method.
We can estimate the upper bound of the overlap as the length of the su x of u (which is either |x|   px or |y|   py).
Lines 6 and 10 in the algorithm perform the estimation and the subsequent lines test whether the upper bound will meet the threshold   and prune away unpromising candidate pairs directly.
Experimental results show that utilizing positional information can achieve substantial pruning e ects on real data-sets.
For example, we show the sizes of the candidates generated by ppjoin algorithm and All-Pairs algorithm for the DBLP dataset in Table 1.
The following Lemma allows us to further reduce the number of tokens to be indexed and hence accessed.
t All-Pairs ppjoin ppjoin+











 e z
 e t a d d n a
 i i f o t o o
 e r a u q
 DBLP, Jaccard Similarity, t = 0.90 Result PPJoin+ PPJoin All-Pairs












 Scale Factor Figure 1: Quadratic Growth of Candidate Size Lemma 3.
Given a record x, we only need to index its
 (|x|     2t rect join result.
This optimization requires us to change Line 15 in Algorithm 1 such that it only index the current token w if the current token position i is no larger than |x|  2t 1+t  |x|  + 1.
Note that the length of the pre x used for probing into the indices remains the same.
In this section, we  rst motivate the need to looking for further  ltering method, and then introduce a divide-and-conquer based su x  ltering method, which is a generalization of the positional  ltering to the su xes of the records.
Let s consider the asymptotic behavior of the size of the candidate size generated by the pre x  ltering-base methods.
The candidate size is O(n2) in the worst case.
Our empirical evidence on several real datasets suggests that the growth is indeed quadratic.
For example, we show the square root of query result size and candidate sizes of the All-Pairs algorithm and our ppjoin algorithm in Figure 1.
It can be observed that while positional  ltering helps to further reduce the size of the candidates, it is still growing quadratically (albeit with a much slower rate than All-Pairs).
Given the empirical observation about the quadratic growth rate of the candidate size, it is desirable to  nd additional pruning method in order to tackle really large datasets.
Our goal is to develop additional  ltering method that prunes candidates that survive the pre x and positional  l-tering.
Our basic idea is to generalize the positional  l-tering principle to work on the su xes of candidate pairs.
However, the challenge is that the su xes of records are not indexed nor their partial overlap has been calculated.
Therefore, we face the following two technical issues: (i) how to establish an upper bound in the absence of indices or partial overlap results?
(ii) how to  nd the position of a token without tokens being indexed?
We solve the  rst issue by converting an overlap constraint to an equivalent Hamming distance constraint, according to Equation (2).
We then lower bound the Hamming distance by partitioning the su xes in an coordinated way.
We denote the su x of a record x as xs.
Consider a pair of records, hx, yi, that meets the Jaccard similarity threshold t, and without loss of generality, |y|   |x|.
Since their overlap in their pre xes is at most the minimum length of the pre xes, we can derive the following upper bound in terms of the Hamming distance of their su xes.
H(xs, ys)   Hmax = 2|x|   2  t 1 + t   (|x| + |y|)    ( t   |x|     t   |y| ) (4) In order to check whether H(xs, ys) exceeds the maximum allowable value, we provide an estimate of the lower bound of H(xs, ys) below.
First we choose an arbitrary token w from ys, and divide ys into two partitions: the left partition yl and the right partition yr.
The criterion for the partitioning is that the left partition contains all the tokens in ys that precede w in the global ordering and the right partition contains w (if any) and tokens in ys that succeed w in the global ordering.
Similarly, we divide xs into xl and xr using w too (even though w might not occur in x).
Since xl (xr) shares no common token with yr (yl), H(xs, ys) = H(xl, yl) + H(xr, yr).
The lower bound of H(xl, yl) can be estimated as the di erence between |xl| and |yl|, and similarly for the right partitions.
Therefore, H(xs, ys)   abs(|xl|   |yl|) + abs(|xr|   |yr|) Finally, we can safely prune away candidates whose lower bound Hamming distance is already larger than the allowable threshold Hmax.
We can generalize the above method to more than one probing token and repeat the test several times independently to improve the  ltering rate.
However, we will show that if the probings are arranged in a more coordinated way, results from former probings can be taken into account and make subsequent probings more e ective.
We illustrate this idea in the example below.
Example 4.
Consider the following two su xes of length
 those cells and do not know their contents yet.
pos xs







 xll xlr xr ys ?
?
yll ylr yr Assume the allowable Hamming distance is 2.
If we probe the 4th token in ys ( F  ), we have the following two partitions of ys: yl = ys[1 .
.
3] and yr = ys[4 .
.
6].
Assuming a magical  partition  function, we can partition xs into xs[1 .
.
4] and xs[5 .
.
6] using F .
The lower bound of Hamming distance is abs(3   4) + abs(3   2) = 2.
If we perform the same test independently, say, using the
 is still 2.
Therefore, hx, yi is not pruned away.
However, we can actually utilize the previous test result.
The result of the second probing can be viewed as a recursive
 the total absolute di erences of the sizes of the three partitions from two su xes is an lower bound of their Hamming distance, which is abs(|xll|   |yll|) + abs(|xlr|   |ylr|) + abs(|xr|   |yr|) = abs(1   2) + abs(3   1) + abs(2   3) = 4 Therefore, hx, yi can be safely pruned.
Algorithm 3: Su xFilter(x, y, Hmax, d) Input : Two set of tokens x and y, the maximum allowable hamming distance Hmax between x and y, and current recursive depth d Output : The lower bound of hamming distance between x and y



















 /* always divisible */; if d > MAXDEPTH then return abs(|x|   |y|) ; mid     |y|2  ; w   y[mid]; o   Hmax abs(|x| |y|) if |x| < |y| then ol   1, or   0 else ol   0, or   1; (yl, yr, f, di )   Partition(y, w, mid, mid); (xl, xr, f, di )   Partition(x, w, mid   o   abs(|x|   |y|)   ol, mid + o + abs(|x|   |y|)   or); if f = 0 then ; return Hmax + 1 H   abs(|xl|   |yl|) + abs(|xr|   |yr|) + di ; if H > Hmax then return H else Hl   Su xFilter(xl, yl, Hmax abs(|xr| |yr|) di , d+1) ; H   Hl + abs(|xr|   |yr|) + di ; if H   Hmax then Hr   Su xFilter(xr, yr, Hmax   Hl   di , d + 1) ; return Hl + Hr + di  else return H The algorithm we designed to utilize above observations is a divide-and-conquer one (Algorithm 3).
First, the token in the middle of y is chosen, and x and y are partitioned into two parts respectively.
The lower bounds of Hamming distance on both left and right partitions are computed and summed up to judge if the overall hamming distance is within the allowable threshold (Lines 9 10).
Then we call the Su xFilter function recursively  rst on the left and then on the right partition (Lines 13 19).
Probing results in the previous tests are used to help reduce the maximum allowable Hamming distance (Line 16) and to break the recursion if the Hamming distance lower bound has exceeded the threshold Hmax (Lines 14 15 and 19).
Finally, only those pairs such that their lower bounding Hamming distance meets the threshold will be considered as candidate pairs.
We also use a parameter MAXDEPTH to limit the maximum level of recursion (Line 1); this is aimed to strike a balance between  ltering power and  ltering overhead.
The second technical issue is how to perform the partition e ciently, especially for xs.
A straightforward approach is to perform binary search on the whole su x, an idea which was also adopted by the ProbeCount algorithm [24].
The partitioning cost will be O(log |xs|).
Instead, we found that the search only needs to be performed in a much smaller area approximately centered around the position of the partitioning token w in y, due to the Hamming distance constraint.
We illustrate this using the following example.
Example 5.
Continuing the previous example, consider partitioning xs according to the probing token F .
The only possible area where F (for simplicity, assume F exists in xs) can occur is within xs[3 .
.
5], as otherwise, the Hamming distance between xs and ys will exceed 2.
We only need to perform binary search within xs[3 .
.
5] to  nd the  rst token that is no smaller than F .
The above method can be generalized to the general case where xs and ys have di erent lengths.
This is described in Lines 4 6 in Algorithm 3.
The size of the search range is bounded by Hmax, and is likely to be smaller within the subsequent recursive calls.
Algorithm 4 implements the partitioning process using a partitioning token w. One thing that deviates from Example 4 is that the right partition now does not include the partitioning token, if any (Line 7).
This is mainly to simplify the pseudocode while still ensuring a tight bound on the Hamming distance when the token w cannot be found in xs.
Algorithm 4: Partition(s, w, l, r) : A set of tokens s, a token Input w, left and right bounds of searching range l, r Output : Two subsets of s: sl and sr, a  ag f indicating whether w is in the searching range, and a  ag di  indicating whether the probing token w is not found in y sl    ; sr    ; if s[l] > w or s[r] < w then return ( ,  , 0, 1) p   binary search for the position of the  rst token in s that is no smaller than w in the global ordering within s[l .
.
r]; sl   s[1 .
.
p   1]; if s[p] = w then /* skip the token w */; sr   s[(p + 1) .
.
|s|]; di    0; else sr   s[p .
.
|s|]; di    1; return (sl, sr, 1, di ) Algorithm 5: Replacement of Line 12 in Algorithm 1 if A[y] = 0 then Hmax   |x| + |y|   2     t H   Su xFilter(x[(i + 1) .
.
|x|], y[(j + 1) .
.
|y|], Hmax, 1); if H   Hmax then 1+t   (|x| + |y|)    (i + j   2); A[y]   A[y] + 1; else A[y]    ; /* avoid considering y again */;


















 Finally, we can integrate the su x  ltering into the ppjoin algorithm and we name the new algorithm ppjoin+.
To that end, we only need to replace the original Line 12 in Algorithm 1 with the lines shown in Algorithm 5.
We choose to perform su x  ltering only once for each candidate pair on the  rst occasion that it is formed.
This is because su x  ltering probes the unindexed part of the records, and is relative expensive to carry out.
An additional optimization opportunity enabled by this design is that we can further reduce the initial allowable Hamming distance threshold to |x| +|y|  2  t 1+t   (|x| +|y|)  (i + j   2), where i and j stand for the positions of the  rst common token w in x and y,
 to the fact that x[1 .
.
(i   1)]   y[1 .
.
(j   1)] =   since the current token is the  rst common token between them.
The su x  ltering employed by the ppjoin+ algorithm is orthogonal and complementary to the pre x and positional  ltering, and thus helps further reduce the candidate size.
Its e ect on the DBLP dataset can be seen in Table 1 and Figure 1.
In this section, we brie y comment on necessary modi cations to adapt both ppjoin and ppjoin+ algorithms to other commonly used similarity measures.
The major changes are related to the length of the pre xes used for indexing (Line
 the threshold used by size  ltering (Line 8, Algorithm 1) and positional  ltering (Line 9, Algorithm 1), and the Hamming distance threshold calculation (Line 2, Algorithm 5).
Overlap Similarity O(x, y)     is inherently supported in our algorithms.
The pre x length for a record x will be x     + 1.
The size  ltering threshold is  .
It can be shown that positional  ltering will not help pruning candidates, but su x  ltering is still useful.
The Hamming distance threshold, Hmax, for su x  ltering will be |x|+|y| 2 (i+j 2).
Edit Distance Edit distance is a common distance measure for strings.
An edit distance constraint can be converted into weaker constraints on the overlap between the q-gram sets of the two strings.
Speci cally, let |u| be the length of the string u, a necessary condition for two strings to have less than   edit distance is that their corresponding q-gram sets must have overlap no less than   = (max(|u|,|v|) + q   1)   q  [17].
The pre x length of a record x (which is now a set of q-grams) is q  + 1.
The size  ltering threshold is |x|   . Positional  ltering will use an overlap threshold   = |x|   q .
The Hamming distance threshold, Hmax, for su x  ltering will be |y|   |x| + 2q    (i + j   2).
Cosine Similarity We can convert a constraint on cosine similarity to an equivalent overlap constraint as: C(x, y)   t   O(x, y)   lt   p|x|   |y|m The length of the pre x for a record x is |x| t2  |x|  + 1, yet the length of the tokens to be indexed can be optimized to |x|    t   |x|  + 1.
The size  ltering threshold is  t2   |x| .2 Positional  ltering will use an overlap threshold   = lt   p|x|   |y|m.
The Hamming distance threshold, Hmax, for su x  ltering will be |x| +|y|  2lt   p|x|   |y|m  (i + j   2).
In this section, we present our experimental results.
We implemented and used the following algorithms in the experiment.
All-Pairs is an e cient pre x  ltering-based algorithm capable of scaling up to tens of millions of records [3].
Dataset n avg len






 TREC-Shingle










 Figure 2: Statistics of Datasets ppjoin, ppjoin+ are our proposed algorithms.
ppjoin integrates positional  ltering into the All-Pairs algorithm, while ppjoin+ further employes su x  ltering.
All algorithms were implemented in C++.
To make fair comparisons, all algorithms use Google s dense_hash_map class for accumulating overlap values for candidates, as suggested in [3].
All-Pairs has been shown to consistently outperform alternative algorithms such as ProbeCount-Sort [24], PartEnum [1] and LSH [16], and therefore we didn t consider them [3].
All experiments were performed on a PC with Pentium D
 bian 4.1.
The algorithms were compiled using GCC 4.1.2 with -O3  ag.
We measured both the size of the candidate pairs and the running time for all the experiments.
Our experiments covered the following similarity measures: Jaccard similarity, and Cosine similarity.
We used several publicly available real datasets in the experiment.
They were selected to cover a wide spectrum of di erent characteristics (See Figure 2).
DBLP This dataset is a snapshot of the bibliography records from the DBLP Web site.
It contains almost 0.9M records; each record is a concatenation of author name(s) and the title of a publication.
We tokenized each record using white spaces and punctuations.
The same DBLP dataset (with smaller size) was also used in previous studies [1, 3].
DBLP-3GRAM This is the same DBLP dataset, but further tokenized into 3-grams.
Speci cally, tokens in a record are concatenated with a single whitespace, and then every 3 consecutive letters is extract as a 3-gram.
ENRON This dataset is from the Enron email collection3.
It contains about 0.5M emails from about 150 users, mostly senior management of Enron.
We tokenize the email title and body into words using the same tokenization procedure as DBLP.
TREC-4GRAM This dataset is from TREC-9 Filtering Track Collections.4 It contains 0.35M references from the MEDLINE database.
We extracted author, title, and abstract  elds to from records.
Records are subsequently tokenized as in DBLP.
TREC-Shingle We applied Broder s shingling method [5] on TREC-4GRAM to generate 32 shingles of 4 bytes per record, using min-wise independent permutations.
TREC-
on near duplicate Web page detection (Section 7.5).
Some important statistics about the datasets are listed in Figure 2.
Enron
 i e z
 e t a d d n a
 i





 Result PPJoin+ PPJoin All-Pairs


 Jaccard Similarity i e z
 e t a d d n a
 i 1e+09 1e+08 1e+07 1e+06
 Result PPJoin+ PPJoin All-Pairs


 Jaccard Similarity i e z
 e t a d d n a
 i









 Result PPJoin+ PPJoin All-Pairs


 Jaccard Similarity (a) Jaccard, DBLP, Candidate Size (b) Jaccard, Enron, Candidate Size (c) Jaccard, DBLP-3GRAM, Candidate Size
 Enron
 ) s d n o c e s ( e m
 i








 PPJoin+ PPJoin All-Pairs ) s d n o c e s ( e m
 i







 PPJoin+ PPJoin All-Pairs







 Jaccard Similarity Jaccard Similarity


 ) s d n o c e
 ( e m
 i

 PPJoin+ PPJoin All-Pairs


 Jaccard Similarity (d) Jaccard, DBLP, Time (e) Jaccard, Enron, Time (f) Jaccard, DBLP-3GRAM, Time
 Enron
 i e z
 e t i a d d n a
 ) s d n o c e s ( e m
 i






 Result PPJoin+ PPJoin All-Pairs i e z
 e t i a d d n a



 Cosine Similarity 1e+09 1e+08 1e+07 1e+06
 Result PPJoin+ PPJoin All-Pairs


 Cosine Similarity




 ) s d n o c e s ( e m
 i

 PPJoin+ PPJoin All-Pairs


 Cosine Similarity (g) Cosine, DBLP, Candidate Size (h) Cosine, Enron, Candidate Size (i) Cosine, DBLP, Time Enron PPJoin+ PPJoin All-Pairs












 ) s d n o c e
 ( e m
 i f o t o o
 e r a u q








 DBLP, Jaccard Similarity, t = 0.90 PPJoin+ PPJoin All-Pairs




 ) s d n o c e
 ( e m
 i f o t o o
 e r a u q











 Enron, Cosine Similarity, t = 0.90 PPJoin+ PPJoin All-Pairs




 Cosine Similarity Scale Factor Scale Factor (j) Cosine, Enron, Time (k) Jaccard, DBLP, Time (l) Cosine, Enron, Time Figure 3: Experimental Results
 Candidate Size Figures 3(a) to 3(c) show the sizes of candidate pairs generated by the algorithms and the size of the join result on the DBLP, Enron, and DBLP-3GRAM datasets, with varying similarity thresholds from 0.80 to
 Several observations can be made: ilarity threshold decreases.
  The size of the join result grows modestly when the sim  All algorithms generate more candidate pairs with the decrease of the similarity threshold.
Obviously, the candidate size of All-Pairs grows the fastest.
ppjoin has a decent reduction on the candidate size of All-Pairs, as the positional  ltering prunes many candidates.
ppjoin+ produces the fewest candidates thanks to the additional su x  l-tering.
  The candidate sizes of ppjoin+ are usually in the same order of magnitude as the sizes of the join result for a wide range of similarity thresholds.
The only outlier is the Enron dataset, where ppjoin+ only produces modestly smaller candidate set than ppjoin.
There are at least two reasons: (a) the average record size of the enron dataset is large; this allows for a larger initial Hamming distance threshold Hmax for the su x  ltering.
Yet we only use MAXDEPTH = 2 (for e ciency reasons; also see the Enron s true positive rate below).
(b) Unlike other datasets used, an extraordinary high percentage of candidates of ppjoin are join results.
The ratio of sizes of query result over candidate size by ppjoin algorithm is 38.1%, 4.9%, and 0.03% for Enron, DBLP, and DBLP-3GRAM, respectively.
In other words, ppjoin has already removed the majority of false positive candidate pairs on Enron and hence it is hard for su x  ltering to further reduce the candidate set.
Running Time Figures 3(d) to 3(f) show the running time of all algorithms on the three datasets with varying Jaccard similarity thresholds.
In all the settings, ppjoin+ is the most e cent algorithm, followed by ppjoin.
Both algorithms outperform the All-Pairs algorithm.
The general trend is that the speedup increases
 cause (i) index construction, probing, and other overheads are more noticeable with a high similarity threshold, as the result is small and easy to compute.
(ii) inverted lists in the indices are longer for a lower similarity threshold; this increases the candidate size which in turn slows down the All-Pairs algorithm as it does not have any other additional  l-tering mechanism.
In contrast, many candidates are quickly discarded by failing the positional or su x  ltering used in ppjoin and ppjoin+ algorithms.
The speedup that our algorithms can achieve against the All-Pairs algorithm is also dependent on the dataset.
At the 0.8 threshold, ppjoin can achieve up to 3x speedup against All-Pairs on both Enron and DBLP-3GRAM, and up to 2x speedup on DBLP.
At the same threshold, ppjoin+ can achieve 5x speedup on DBLP-3GRAM, 4x speedup on Enron, and 2.6x speedup on DBLP.
This trend can be explained as All-Pairs algorithm is not good at dealing with long records and/or a small token domain.
The performance between ppjoin and ppjoin+ is most substantial on DBLP-3GRAM, where  ltering on the su xes helps to improve the performance drastically.
The reason why ppjoin+ has only modest performance gain over ppjoin on Enron is because 38% of the candidates are  nal results, hence the additional  ltering employed in ppjoin+ won t contribute to much runtime reduction.
The di erence of the two is also moderate on DBLP.
This is mainly because the average size of DBLP records is only 14 and even a brute-force veri cation using the entire su x is likely to be fast, especially in modern computer architectures.
We ran all three algorithms on the DBLP and ENRON datasets using the cosine similarity function, and plot the candidate sizes in Figures 3(g) to 3(h) and running times in Figures 3(i) to 3(j).
For both metrics, the general trends are similar to those using Jaccard similarity.
A major di erence is that all algorithms now run slower for the same similarity threshold, mainly because a cosine similarity constraint is inherently looser than the corresponding Jaccard similarity constraint.
At the 0.8 threshold, the speedups of the ppjoin and ppjoin+ algorithm is 2x and 3x on DBLP, respectively; on Enron, the speedups are 1.6 and 1.7, respectively.
We performed the similarity join using Jaccard similarity on subsets of the DBLP dataset and measured running times.5 We randomly sampled about 20% to 100% of the records.
We scaled down the data so that the data and result distribution could remain approximately the same.
We show the square root of the running time with Jaccard similarity for the DLBP dataset and cosine similarity for the Enron dataset in Figures 3(k) and 3(l) (both thresholds are  xed at 0.9).
It is clear that the running time of all three algorithms grow quadratically.
This is not surprising given the fact that the actual result size already grows quadratically (e.g., See Figure 1).
Our proposed algorithms have demonstrated a slower growth rate than the All-Pairs algorithm for both similarity functions and datasets.
We also investigate a speci c application of the similarity join: near duplicate Web page detection.
A traditional method is based on performing approximate similarity join on shingles computed from each record [6].
Later work proposed further approximations mainly to gain more e ciency at the cost of result quality.
Instead, we designed and tested three algorithms that perform exact similarity join on q-grams or shingles.
(i) qp algorithm where we use the ppjoin+ algorithm to join directly on the set of 4-grams of each record.
(ii) qa algorithm is similar to qp except that All-Pairs algorithm is used as the exact similarity join algorithm.
(iii) sp algorithm where we use the ppjoin+ algorithm to join on the set of shingles.
The metrics we measured are: running times, precision and recall of the join result.
Since algorithm qp returns exact answer based on the q-grams of the records, its result is a good candidate for the correct set of near duplicate documents.
Hence, we de ne precision and recall as follows: Recall = |Rsp|   |Rqp| Precision = |Rsp|   |Rqp| where Rx is the set of result returned by algorithm x.
We show the results in Table 2 with varying similarity threshold values.
|Rsp| |Rqp| Table 2: Quality vs. Time Trade-o  of Approximate and Exact Similarity Join Precision Recall timeqp timeap timesp t























 Several observations can be made   Shingling-based methods will mainly su er from low recalls in the result, meaning that only a small fraction of truly similar Web pages will be returned.
We manually examined some similar pairs missing from Rsp (t = 0.95), and most of the sampled pairs are likely to be near duplicates (e.g., they di er only by typos, punctuations, or additional annotations).
Note that other variants of the basic shingling method, e.g., systematic sampling of shingles or super-shingling [6] were designed to trade result quality for e ciency, and are most likely to have even worse precision and recall values.
In contrast, exact similarity join algorithms (qp or qa) have the appealing advantage of  nding all the near duplicates given a similarity function.
  qp, while enjoying good result quality, requires longer running time.
However, with reasonably high similarity threshold (0.90+), qp can  nish the join in less than 45 seconds.
On the other hand, qa takes substantially longer time to perform the same join.
  sp combines the shingling and ppjoin+ together and is extremely fast even for modest similarity threshold of 0.80.
This method is likely to o er better result quality than, e.g., super-shingling, while still o ering high e ciency.
In summary, ppjoin+ algorithm can be combined with q-grams or shingles to provide appealing alternative solutions to tackle the near duplicate Web page detection tasks.
Near Duplicate Object Detection Near duplicate object detection has been studied under di erent names in several areas, including record linkage [27], merge-purge [19], data deduplication [23], name matching [4], just to name a few.
[12] is a recent survey on this topic.
Similarity functions are the key to the near duplicate detection task.
For text documents, edit distance [26] and Jaccard similarity on q-grams [17] are commonly used.
Due to the huge size of Web documents, similarity among documents is evaluated by Jaccard or overlap similarity on small or  x sized sketches [5, 10].
Soundex is a commonly used phonetic similarity measures for names [22].
Exact Near Duplicate Detection Algorithm Existing methods for exact near duplicate detection usually convert constraints de ned using one similarity function into equivalent or weaker constraints de ned on another similarity measure.
[17] converts edit distance constraints to overlap constraints on q-grams.
Jaccard similarity constraints and 1/2-sided normalized overlap constraints can be converted to overlap constraints [24, 8].
Constraints on overlap, dice and Jaccard similarity measures can be coverted to constraints on cosine similarity [3].
[1] transforms Jaccard and edit distance constraints to Hamming distance constraints.
The techniques proposed in previous work fall into two categories.
In the  rst category, exact near duplicate detection problems are addressed by inverted list based approaches [3, 8, 24], as discussed above.
The second category of work [1] is based on the pigeon hole principle.
The records are carefully divided into partitions and then hashed into signatures, with which candidate pairs are generated, followed by a post ltering step to eliminate false positives.
Approximate Near Duplicate Object Detection Several previous work [6, 7, 10, 16] has concentrated on the problem of retrieving approximate answers to similarity functions.
LSH (Locality Sensitive Hashing) [16] is a well-known approximate algorithm for the problem.
It regards each record as a vector and generates signatures for each record with random projections on the set of dimensions.
Broder et al.
[6] addressed the problem of identifying near duplicate Web pages approximately by compressing document records with a sketching function based on min-wise independent permutations.
The near duplicate object detection problem is also a generalization of the well-known nearest neighbor problem, which is studied by a wide body of work, with many approximation techniques considered by recent work [7, 13, 16, 21].
In this paper, we propose e cient similarity join algorithms by exploiting the ordering of tokens in the records.
The algorithms provide e cient solutions for an array of applications, such as duplicate Web page detection on the Web.
We show that positional  ltering and su x  ltering are complementary to the existing pre x  ltering technique.
They successfully alleviate the problem of quadratic growth of candidate pairs when the data grows in size.
We demonstrate the superior performance of our proposed algorithms to the existing pre x  ltering-based algorithms on several real datasets under a wide range of parameter settings.
The proposed methods can also be adapted or integrated with existing near duplicate Web page detection methods to improve the result quality or accelerate the execution speed.
