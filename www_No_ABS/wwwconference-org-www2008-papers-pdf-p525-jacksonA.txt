HTTPS is designed to be secure against both eavesdroppers and active network attackers.
In practice, however, all modern web browsers are willing to compromise the security of sites that use HTTPS in order to be compatible with sites that deploy HTTPS incorrectly.
For example, if an active attacker presents a self-signed certi cate, web browsers permit the user to click through a warning message and access the site despite the error.
This behavior compromises the con dentiality of the site s Secure cookies, which often store a second factor of authentication, and allows the attacker to hijack a legitimate user s session, potentially letting the attacker to transfer money out of the user s bank account or Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
Adam Barth Stanford University abarth@cs.stanford.edu perform other misdeeds.
Browsers accept broken certi cates and allow embedding of insecure scripts for two reasons:   Compatibility.
Many web sites have incorrectly con gured certi cates and embed insecure scripts.
A browser that enforces strict error processing is incompatible with these sites and will lose users to a more permissive browser.
  Unknown Intent.
Some site owners intentionally use self-signed certi cates and host portions of their site over HTTP because these mechanisms provide protection from passive attackers and they believe the risk of an active attack is outweighed by the cost of implementing HTTPS fully.
Although a security-conscious site owner, such as a bank, might aim to implement a high-security site, he or she currently has no mechanism for communicating this intent to the browser.
Other site owners that are less security-conscious, desiring protection only from passive network attackers, implement low-security sites by deploying certi cates that are self-signed or have incorrect common names.
The browser has no mechanism for di erentiating these two kinds of sites and cannot distinguish between a legitimate miscon gura-tion in a low-security site and an attack on a high-security site.
Without guidance, a browser does not have the context to make an useful risk-management decision about whether to trade o  security for compatibility on a particular site.
We propose ForceHTTPS, a simple mechanism that security-conscious sites can use to opt in to stricter error processing by the browser, essentially giving the browser guidance to be more secure.
By setting a ForceHTTPS cookie, a site owner asks the browser to treat HTTPS errors as attacks, not as simple con guration mistakes.
Speci cally, enabling ForceHTTPS causes the brower to modify its behavior as follows:
 HTTPS, preventing contact to the site without TLS.
common-name mismatches, terminate the TLS session.
the site fail with network errors.
This stricter error handling has several bene ts, including protecting the URL parameters, fragments, and Secure cookies from network attackers and users who click through security warnings.
ForceHTTPS blocks participating sites from
 sheets, and SWF movies, in order to secure the user s session with buggy sites that would otherwise allow an active network attacker to steal the user s password and second factor of authentication by silently replacing SWF movie embedded in the login page.
By enabling ForceHTTPS, a site protects itself from careless mistakes by its own web developers.
ForceHTTPS also o ers a  developer mode  that explains these errors so that the site s web developer can  nd and  x vulnerabilities.
Used in concert with a phishing defense, such as Bank of America s SiteKey [1], ForceHTTPS lets a site protect itself from pharming.
Previously proposed anti-pharming defenses [6, 20, 15] are di cult to implement and face major challenges to deployment.
By contrast, ForceHTTPS is easy to implement because browsers already detect the errors sites wish to block and easy to deploy because sites need only set a single cookie.
To demonstrate the feasibility of our approach, we provide a prototype of ForceHTTPS as a Firefox browser extension [12].
ForceHTTPS also enables  power users  to upgrade the security of sites that implement HTTPS insecurely by setting a ForceHTTPS cookie on the site s behalf.
This approach follows a recent trend in which sophisticated users have taken web security into their own hands.
The NoScript [18] browser extension enables users to  x cross-site scripting vulnerabilities in sites they visit by disabling or limiting the capabilities of scripts on that site, albeit at the cost of functionality.
Other client side tools for mitigating web site vulnerabilities include Noxes [16] and NoMoXSS [28].
The GMailSecure user script (which has had over 25,000 downloads) enables users to force secure connections to Gmail, mitigating eavesdropping attacks without any reduction in functionality.
In fact, this paper arose largely out of a desire by the authors to secure their Gmail sessions while using the wireless networks at security conferences after witnessing an alarmingly e ective attack demonstration at Black Hat 2007 [10].
Securing Gmail without Google s cooperation is challenging because Gmail s session identi er is stored in an insecure cookie that is transmitted whenever a user visits any other Google property.
By setting the ForceHTTPS cookie, a Gmail user upgrades the session cookie to a Secure cookie that is protected from both eavesdropping and active attackers.
The rest of this paper is organized as follows.
In Section 2 we describe the threats that ForceHTTPS is designed to protect against.
In Section 3 we survey existing techniques that attempt to defend against these threats.
In Section 4 we provide a speci cation of our proposal.
In Section 5 we discuss design decisions and implementation details.
We conclude in Section 6.
ForceHTTPS is concerned with three threats: passive network attackers, active network attackers, and imperfect web developers.
  Passive Network Attackers.
When a user browses the web on a wireless network, a nearby attacker can eavesdrop on unencrypted connections, such as HTTP requests.
Such a passive network attacker can steal session identi ers and hijack the user s session.
These eavesdropping attacks can be performed easily using wireless sni ng toolkits [29, 10].
Some sites, such as Gmail, permit access over HTTPS, leading a user to believe that accessing such a service over HTTPS protects them from an passive network attacker.
Unfortunately, this is often not the case as session identi- ers are typically stored in insecure cookies to permit interoperability with HTTP versions of the service.
For example, the session identi er for Gmail is usually stored in a non-Secure cookie, permitting an attacker to hijack the user s Gmail session if the user makes a single HTTP request to Gmail.
Additionally, the subjects and snippets of the one hundred most recent email messages can be retrieved using the user s .google.com session cookie, which is sent in the clear during every Google search request.
  Active Network Attackers.
A more determined attacker can mount an active attack, either by impersonating a user s DNS server or, in a wireless network, by spoo ng network frames or o ering a similarly-named  evil twin  access point.
If the user is behind a wireless home router, the attacker can attempt to recon gure the router using default passwords and other vulnerabilities [26, 27, 25].
Some sites, such as banks, rely on HTTPS to protect them from these active attackers.
Unfortunately, browsers allow their users to opt-out of these protections in order to be compatible with sites that incorrectly deploy HTTPS.
These sites wish to be protected from active network attackers even if users do not understand the security warnings provided by their browsers.
  Honest but Imperfect Web Developers.
Large web sites are constructed by numerous developers, who occasionally make mistakes and are not all security experts.
One simple mistake, such as embedding a cascading style sheet or a SWF movie over HTTP, can allow an active attacker to compromise the security of an HTTPS site completely.1 Even if the site s developers carefully scrutinize their login page for mixed content, a single insecure embedding anywhere on the site compromises the security of their login page because the attacker can script (control) the login page by injecting script into the page with mixed content.
Both the site s owner and the site s users could wish the site to be secure despite its developers making mistakes.
  Phishing.
Phishing attacks [7] occur when an attacker solicits authentication credentials from the user by hosting a fake site located on a di erent domain than the real site, perhaps driving tra c to the fake
 embedding page, to the surprise of many web developers.
Most browsers do not issue mixed content warnings when insecure SWF  les are embedded.
be very e ective because users  nd it di cult to distinguish the real site from a fake site [5].
ForceHTTPS is not a defense against phishing, but it complements many existing phishing defenses, such as SiteKey [1], the Yahoo!
Sign-in Seal [30], and Chase s Activation Code [4], by instructing the browser to protect session integrity and long-lived authentication tokens.
  Malware and Browser Vulnerabilities.
Because ForceHTTPS is implemented as a browser security mechanism, it relies on the trustworthiness of the user s system to protect the session.
Malicious code executing on the user s system can compromise a browser session, regardless of whether ForceHTTPS is used.
Previously known defenses to the threats described in Section 2 are shown in Table 1 and summarized in this section.
  User-enforced HTTPS.
Many web sites serve the same content over both HTTP and HTTPS, taking care to use HTTPS on the login or credit card entry page and HTTP elsewhere.
This protects the user s long-lived authentication credentials and  nancial details from being stolen by eavesdroppers while retaining the performance bene ts of unencrypted HTTP tra c.
Unfortunately, many such sites set an non-Secure cookie containing the user s session identi er.
This cookie is sent in the clear over HTTP and can be used by an eavesdropper to hijack the user s session.
Security-conscious users can mitigate this vulnerability by attempting to visit the site using HTTPS, to the exclusion of HTTP.
For example, the user can diligently type HTTPS URLs into the address bar and check the status bar before clicking on links.
Unfortunately, even a single insecure HTTP request by the web site can lead to a compromise of the session cookies.
If the insecure request is the result of a redirect or button click, the user could be unaware of the request until their credentials have already been compromised.
For example, Gmail serves its content to authenticated users both over HTTPS and HTTP.
The login form, however, is served exclusively over HTTPS.
Users that want to check sensitive mail using Gmail can access the Gmail site over HTTPS instead of HTTP.
In fact, many users install GMailSecure [21] to automatically redirect them to HTTPS pages when using Gmail.
Unfortunately, GMailSecure does not actually protect the session cookie on mail.google.com because it performs the redirect after the browser has already sent the HTTP request (which contains the cookie) in the clear.
  Certi cate Errors.
Incorrectly con gured web servers can cause a number of HTTPS certi cate errors:   Common-Name Mismatch.
HTTPS requires that a server present a certi cate whose common name matches the server s host name.
Many web servers erroneously present certi cates with incorrect common names.
Figure 1: This account has only ever been accessed over HTTPS, but the con dentiality of this user s email has already been compromised because Firefox leaked the user s cookie in an automatic request for anti-phishing data from Google.
  Self-Signed.
Many site owners wish to use HTTPS but are unable or unwilling to purchase certi -cates from certi cate authorities.
Instead, these owners deploy self-signed certi cates that provide security against passive attackers.
  Expired.
Certi cates are valid only for a limited time period.
Many web servers present certi -cates that have either not yet become valid or whose validity period has expired.
When it encounters a certi cate error, the browser presents the user with a security warning dialog, giving the user the option to continue despite the error.
Browsers permit users to override these security errors in order to be compatible with miscon g-ured servers.
Unfortunately, the warnings have become commonplace, with approximately 63% of cer-ti cates causing errors [24].
Although the user is in control, many users do not understand these warnings and are trained to ignore them by the multitude of miscon gured sites [23].
ForceHTTPS lets sites force these certi cate errors to be treated as fatal.
  Extended Validation.
Many certi cate authorities issue  extended validation  (EV) certi cates that require more extensive investigation by the certi cate authority before being issued [9].
Like certi cate warnings, EV certi cates are used to present information about the connection security to the user.
For example, Internet Explorer 7 and Firefox 3 highlight the site s identity in green if the site supplies a valid EV certi cate.
Extended validation certi cates have no e ect on the browser s defenses against network attackers.
A site that uses EV can still be contacted via HTTP and mix insecure content into secure pages.
Moreover, the user is still able to accept a broken cer-ti cate for the host, putting primary control over enforcement in the hands of the user.
ForceHTTPS allows the site to make a security commitment to the browser, rather than to the user.
  Firefox 3.
Firefox 3 contains a new user interface for dealing with certi cate errors.
Early versions of this interface required ten clicks to accept certi cate errors and asked the user to type the domain name
 Site-controlled Passive Attacker GMailSecure Secure cookies Threat Model Active Attacker Certi cate warnings Locked same-origin policy, HTTPSSR Imperfect Developer Mixed content warnings Content restrictions Table 1: Current attempts to defend against the threats that ForceHTTPS addresses.
manually in the hopes that this process would discourage users from giving up their security.
This proposal was controversial [11] and was eventually scaled back to require only four clicks [3] as a compromise for site owners that use HTTPS with self-signed certi -cates.
ForceHTTPS avoids compromising security for usability by a ecting only those sites that are security-conscious.
  Mixed Content Warnings.
Many sites serve the same content over both HTTP and HTTPS.
If the developer expected some of the content to be served over HTTP only, the developer is likely to embed scripts using absolute paths containing the http scheme: <script src="http://a.com/foo.js"></script> Unfortunately, this compromises the security of HTTPS on the entire site because an active attacker can navigate the user s browser to the broken page over HTTPS, replace the insecure script with his own, and invade the security context of the secure site.
These mistakes can easily be corrected by using scheme-relative paths [8]: <script src="//a.com/foo.js"></script> These paths cause the browser to load the script over HTTP when the page is viewed over HTTP and over HTTPS when the page is viewed over HTTPS.
Using this technique, a site can bene t from caching and increased performance when the page is viewed over HTTP but retain security when the page is viewed over HTTPS.
Unfortunately, many web developers are unaware of scheme-relative paths and often accidentally embed insecure scripts into secure pages.
Browsers warn the user about these insecure embeddings in different ways:   Internet Explorer displays a  mixed content  dialog that asks the user s permission before continuing.
Insecure SWF movies and Java applets are loaded automatically without any warnings.
  Firefox automatically accepts the mixed content, but draws a red slash over the browser s lock icon.
Insecure images, SWF movies, and Java applets do not trigger the slash.
  Opera automatically accepts the mixed content, but replaces the lock icon with a question mark.
  Safari does not attempt to detect mixed content.
As with certi cate warnings, many users do not understand mixed content warnings, and some browsers do not even give users the option of remaining secure.
Users have been trained to ignore these warnings because many HTTPS pages, such as the Gmail login Figure 2: Users have been trained to click through mixed content warnings at sites such as Gmail.
page shown in Figure 2, embed mixed content.
Force-HTTPS lets security-conscious sites block unwanted mixed content inadvertently introduced by their imperfect developers.
  Secure Cookies.
A security-conscious site can mark a cookie as Secure, instructing the browser to refrain from transmitting the cookie over an insecure connection.
To use these cookies, the site must ensure that all authenticated web tra c occurs over HTTPS.
Many sites, including those that have deployed anti-phishing defenses such as SiteKey, also use a long-lived Secure cookie to store a second factor of authentication.
  Passive Attackers.
Secure cookies defend well against passive eavesdroppers.
We recommend that sites use Secure cookies as they prevent a passive attacker from learning the con dential information they store.
  Active Attackers.
Unfortunately, active attackers can use invalid certi cates to steal Secure cookies if users click through certi cate warning dialog boxes.
ForceHTTPS expands the usefulness of Secure cookies to defend against active attackers by recording the web site s intent to use a correct HTTPS certi cate.
When the attacker presents an invalid certi cate for the site, the browser terminates the connection and does not reveal the site s Secure cookies.
  Locked Same-Origin.
Web Server Key Enabled Cookies [20] proposes restricting access to cookies based on
 to prevent a pharming attacker from accessing HTTPS cookies set by the victim server.
Karlof et.
al. [15] extend this work to defend against dynamic pharming through the use of two locked same-origin policies for browsers.
These policies augment the browser s security policy to isolate web pages based on the security of the connection from which they were loaded.
Unfortunately, both locked same-origin policies face major deployment challenges.
  Weak.
The weak locked same-origin policy isolates pages loaded over broken HTTPS connections from those loaded over unbroken connections.
To be secure against an active attacker, a site must not embed any scripts, cascading style sheets, applets, or SWF movies (instead, the site must inline all scripts and style sheets) [15], but this requires virtually all web sites to implement major changes in order to meet this condition.
  Strong.
The strong locked same-origin policy segregates two pages if they where loaded over HTTPS connections with di erent public keys.
To enable the strong policy, a site must deploy a pk.txt  le that speci es the public keys with which it intends to interact.
This  le is di cult to deploy correctly and must be maintained as servers refresh their keys, likely resulting in a similar miscon guration rate to that of deploying cer-ti cates for HTTPS.
ForceHTTPS also isolates broken and unbroken pages by allowing security-conscious sites to forbid the browser from loading broken sites, but ForceHTTP is easier for sites to deploy: the site can opt in to ForceHTTPS by simply setting a cookie.
  Content Restrictions.
Using content restrictions, web servers can transmit metadata to browsers instructing them to impose certain restrictions on the web site s content, such as which scripts are allowed to run.
Content restrictions can limit the damage caused by a cross-site scripting attack in which the developer incorrectly sanitizes malicious input.
Content restrictions can be communicated in HTTP headers or <meta> tags [19].
Other proposals include whitelists written in JavaScript, or using a special noexecute property of DOM nodes [13].
ForceHTTPS is another set of content restrictions, but instead of defending against a web developer who inadvertently exposes the session to cross-site scripting attacks, it defends against a web developer who inadvertently exposes the site to network attacks via mixed content.
ForceHTTPS can be enabled in two ways:   Site.
A security-conscious site can enable ForceHTTPS by setting a cookie with the name ForceHTTPS using a Set-Cookie header in an error-free HTTPS response.
The browser will enable ForceHTTPS for that site as long as the cookie has not expired.
The domain and path attributes of the cookie are ignored.
  User.
A security-conscious user can enable Force-HTTPS for a host through the browser user interface.
The browser gives them the option of con guring custom HTTP-to-HTTPS redirection rules and non-Secure-to-Secure cookie upgrades for that domain.
ForceHTTPS can be disabled only by an error-free HTTPS response or by the browser s user interface.
When ForceHTTPS is enabled for a host, the browser modi es its behavior as follows:   Attempts to connect over a non-HTTPS protocol are redirected to HTTPS.
  TLS errors during connections are treated as fatal.
  Attempts to embed insecure content in pages fail.
These rules prevent an active attacker from injecting script into the host s security origin.
This section contains a discussion of design decisions, error handling scenarios, limitations, and alternate policy advertisement mechanisms.
Although the ForceHTTPS mechanism is simple, a number of subtle decisions were made during its design.
  Redirecting URLs.
When ForceHTTPS is enabled for a host, the browser redirects HTTP requests to that host to HTTPS.
For example, if the user types www.paypal.com in the location bar, the browser connects to https://www.paypal.com/ instead, preventing a network attacker from intercepting the HTTP request and redirecting the user to a phishing web site.
Additionally, this browser-side redirection transparently corrects a common mixed content scenario in which a site embeds active content from itself over HTTP.
To retro t security onto sites like Google that do not serve all of their content over HTTPS, Force-HTTPS lets power users con gure custom rewrite rules.
  State Exhaustion.
Because the browser has limited state, the browser s cookie eviction policy is critical to the security of ForceHTTPS.
An attacker who is able to force the browser to evict the ForceHTTPS cookie is e ectively able to  unforce  HTTPS.
Moreover, if the browser evicts the ForceHTTPS cookie before other cookies for the same host, the attacker can potentially use the non-evicted cookies (which might store session tokens or second factors of authentication) as part of an attack.
To prevent these state exhaustion attacks, the browser should reserve space for ForceHTTPS cookies and limit the rate at which it accepts new ForceHTTPS cookies.
If the browser uses an rate-limiting scheme with exponential back-o , the browser can typically prevent an attacker from  ood-ing its ForceHTTPS cookie store in a single session.
A concerted attacker, however, can eventually over ow the state limit over many successive sessions.
To prevent the other cookies from being stolen, the browser should evict all other cookies for a domain if it evicts the ForceHTTPS cookie.
ForceHTTPS is that of denial of service.
An attacker who can set a ForceHTTPS cookie for a victim host can prevent users from using that site if the site requires broken HTTPS to function properly.
There are two restrictions on when a site can set a ForceHTTPS cookie to mitigate this issue:   The server must set the ForceHTTPS cookie during a non-broken HTTPS session.
By establishing a non-broken HTTPS session, the host has demonstrated the ability to conduct secure HTTPS.
If the browser permitted ForceHTTPS cookies to be set over HTTP, an active attacker could conduct denial of service beyond his ability to control the user s network.
  The server must set the ForceHTTPS cookie using the Set-Cookie header, rather than using script to set the document.cookie property.
If script were permitted to set ForceHTTPS cookie, a transient cross-site scripting vulnerability could result in a long-lasting denial of service.
Even with these restrictions, a shared domain Force-HTTPS cookie could still be used for denial of service: A student hosting content on https://www.stanford.edu/ could set a ForceHTTPS cookie for .stanford.edu, denying service to many Stanford web sites.
To prevent this scenario, a ForceHTTPS cookie enables Force-HTTPS only for the host that sent the cookie.
  Policy Expressiveness.
When a site enables Force-HTTPS, the browser makes several modi cations to its behavior at once.
Instead, the browser could respect  ner-grained policies capable of expressing more spe-ci c behavior changes, for example allowing a site to require HTTPS without disavowing mixed content or certi cate errors.
However, exposing a more expressive policy interface increases the burden on site developers to select the appropriate policy and on browser developers to correctly implement each policy permutation.
We reserve the value of the ForceHTTPS cookie for future enhancements to the mechanism.
Although it provides stricter error handling, ForceHTTPS must be prepared to handle miscon gured clients and servers.
If ForceHTTPS simply were to provide a click-through error dialog box, the bene ts of the mechanism would be lost.
Many users consider clicking through security dialog boxes to be a routine task.
  Wireless HotSpot.
The most common client error occurs when a user  rst connects their computer to a wireless hotspot.
Before allowing access to the Internet, the hotspot typically redirects all network requests to its registration page.
If the user attempts to navigate to an HTTPS site, the hotspot will be unable to present a valid certi cate and the connection will generate a certi cate error.
In this situation, the two options o ered by current browsers are both poor.
The user can either abandon the request (and not join the network) or can accept the broken certi cate, sending their secure cookies to the hotspot registration page.
To better recover from this error condition, the browser could attempt to connect to a known HTTP page on the browser vendor s web site and compare its contents to a known value.
If a redirect is encountered or the contents of the page do not match the expected value, the browser could ask the user if they would like to connect to the wireless network registration page (which consists of the redirected content).
This technique permits the registration page to successfully redirect the user without compromising the user s cookies and without revealing any sensitive query parameters (as used by PHP sites that set session.use_trans_sid to true and session.use_cookies to false).
  Embedded Content.
When ForceHTTPS is enabled for a host, the browser prevents pages on that host from embedding non-HTTPS content.
The security of the site can still be compromised, however, if the site embeds content from an HTTPS connection that encountered a certi cate error.
For this reason, certi -cate errors are treated as fatal network errors during any dependent load on a ForceHTTPS page.
For content that would appear in a frame, the broken content is replaced with a message indicating that the content could not be loaded securely.
  Opting Out.
If a ForceHTTPS site persists in being miscon gured, the user can remove the ForceHTTPS cookie through the same user interface used to enable ForceHTTPS.
This process requires several steps, i.e. not a single mouse click, and both clears the user s cookies and restarts the browser to prevent any existing browser state from being compromised.
We expect that the rate of ForceHTTPS hosts miscon g-uration will be signi cantly lower than the general HTTPS miscon guration rate because the owners of the ForceHTTPS hosts have indicated (by enabling ForceHTTPS) that they take seriously the security of their sites and do not wish to allow users to connect over broken HTTPS connections.
In contrast, users will need to become familiar with the browser s mechanism to bypass standard certi cate errors in order to access many miscon gured sites.
Although ForceHTTPS has numerous security bene ts, it cannot prevent all attacks.
In this section, we describe some vulnerabilities that ForceHTTPS does not address.
  Attacks on Initialization.
If a user is unable to establish a secure connection to a server, then that server cannot set a ForceHTTPS cookie.
An attacker who controls the user s network on every visit to a target site can prevent the ForceHTTPS cookie at that site from ever being set.
Although the user will be exposed to a large number of warnings, ForceHTTPS will not yet be enabled and thus cannot force the user to make the correct security decision.
However, if the user does ever connect to the site securely, the browser enforce security until the ForceHTTPS cookie expires.
  Privacy.
Like any cookie, ForceHTTPS leaves a trace on the user s system for each ForceHTTPS site visited.
Users who are concerned about privacy from
 tem often reject or frequently clear their cookies.
By clearing cookies, these users can remove all evidence of the ForceHTTPS cookie.
Although they lose Force-HTTPS protection their next visit, the user s decision to purge all browser state associated with the site will make it unlikely that the browser will have second factor authentication tokens for a future attacker to steal.
(Note that the precon gured ForceHTTPS cookies and rewrite rules are the same for each user and do not reveal the user s browsing behavior other than to identify them as a ForceHTTPS user.)
  Developer Errors Other Than Mixed Content.
By enabling ForceHTTPS, the web developer opts in to more stringent error processing, but the developer still compromise the security of his or her site by making mistakes.
We list a few common mistakes of this sort to remind the reader that ForceHTTPS (and more generally encryption) is not a panacea.
  Cross-Site Scripting (XSS).
ForceHTTPS provides no protection if the site contains a cross-site scripting vulnerability.
Such a site is completely vulnerable to a web attacker.
  Cross-Site Request Forgery (CSRF).
Similarly, ForceHTTPS does not protect a site that contains a cross-site request forgery vulnerability [14].
CSRF vulnerabilities often give attackers the ability to issue commands from the user s browser.
  HTTP Response Splitting.
If the server does not properly sanitize carriage returns and other whitespace in input included in HTTP response headers, an attacker can inject headers (and potentially scripts) into HTTP responses.
An HTTP response splitting vulnerability can often be used to manipulate ForceHTTPS cookies.
  document.domain.
A site that sets its domain to a value must trust all the hosts with that value as a su x.
These hosts can enter the site s security sandbox and script its pages.
  Plugins.
Analysis of browser security features must take plugins into account because plugins such as Flash Player and Java are widely deployed and can often provide attackers an alternate route to circumventing a security mechanism.
ForceHTTPS must ensure that browser network requests on behalf of plugins, which carry the user s cookies, enforce the Force-HTTPS restrictions.
Furthermore, all cookie management by plugins must respect the ForceHTTPS policy.
If the plugin allows the site to make direct network requests using raw sockets, it cannot be forced to use HTTPS without breaking backwards compatibility.
We consider it the web site s responsibility to provide appropriate encryption of the raw socket tra c if necessary; ForceHTTPS does not provide protection from the imperfect developer in this case.
  Complexity of Rewrite Rules.
As we describe in Section 5.5, the rewrite rules required to enable Force-HTTPS at a legacy web site can range from very simple to impossible.
A site could become vulnerable if rewrite rules are introduced that redirect sensitive information to an attacker.
Rewrite rules can also break functionality at the web site, rendering certain pages inaccessible or issuing unauthorized transactions.
If the web site changes signi cantly, or the site decides to change its support for HTTPS, the rewrite rules might need to be updated.
We consider the installation and editing of rewrite rules to be a decision with serious security consequences, similar to installing a browser plugin.
The addition of new rewrite rules is a feature primarily for advanced users.
Other mechanisms that could be used for advertising a ForceHTTPS policy include DNS records and XML  les.
  DNS.
In the HTTP Service Security Requirements (HTTPSSR) proposal [22], a site can indicate its desire for HTTPS by including an HTTPSSR record in DNS.
The proposal relies on DNSSEC to prevent a network attacker from manipulating this record.
Although the HTTPSSR proposal does not address mixed content, certi cate error user interfaces, or cookie security, it could be extended to do so.
The DNS policy advertisement mechanism has a number of advantages:
 browser can obtain the ForceHTTPS policy on the  rst visit to the site, even if the network is compromised.
sistent state associated for each host, preventing state exhaustion attacks.
attacker to manipulate ForceHTTPS policies.
Unfortunately, DNSSEC is not widely deployed.
Without DNSSEC, sites can store their ForceHTTPS policies in DNS using the stateful, secure-initialization approach of ForceHTTPS cookies.
To support this approach, HTTPSSR records would need to include an  expires   eld.
The Time-To-Live (TTL) supplied by DNS is not suitable for storing policy expiry because it provides a maximum, rather than a minimum, duration for the validity of the record.
  XML.
Using the XML paradigm, a site can advertise its ForceHTTPS policy in an XML document hosted over HTTPS at a well-known location.
This technique is used by Adobe Flash Player to determine if a server is willing to receive cross-domain URL requests.
Adobe s crossdomain.xml policy  le could be extended to advertise a ForceHTTPS policy: <?xml version="1.0" ?> <cross-domain-policy xmlns:f="http://www.forcehttps.com/"> <allow-access-from domain="*.stanford.edu" /> <f:forcehttps expires="Mon, 11 Feb 2009 23:39:27 GMT"/> </cross-domain-policy>
 the duration speci ed by the expires attribute of this element.
This element can be included in existing crossdomain.xml  les using a unique XML names-pace for the element.
This approach has the advantage that a site must already control the contents of its crossdomain.xml  le in order to be secure against attacks using the Flash plugin.
Additionally, using XML to store policy information makes it possible to extend this policy advertisement mechanism to include future security policies.
In creating our prototype implementation of ForceHTTPS, we developed rewrite rules for seven popular sites to understand the subtleties in deploying ForceHTTPS.
To develop the rewrite rules, we installed the ForceHTTPS extension and enabled ForceHTTPS for each site we wanted to support.
We then turned on client-side error logging and tried to log in and log out on each site.
Using the error messages we identi ed HTTP content that could be served over HTTPS and used rewrite rules to transform those HTTP requests into HTTPS.
The results are summarized below.
  PayPal.
We did not need specialized rewrite rules for paypal.com, which serves all content on its main site over HTTPS.
We also enabled ForceHTTPS for paypalobjects.com, where PayPal s static scripts and stylesheets are hosted.
This precaution is necessary for Firefox 2, which prompts users to override certi cate errors for embedded content, but is no longer necessary in Firefox 3, which blocks such content automatically.
  American Express.
American Express uses SWF movies to load HTTP  les to display advertisements, but the insecure  les are served from a di erent domain (doubleclick.net) and cannot script the main American Express page.
  Fidelity.
Fidelity uses SWF movies that load HTTP  les to display stock quotes, but these requests do not require cookies, so no rewrite rules are necessary.
Fidelity hosts a crossdomain.xml  le that allows access from *.fidelity.com and *.fmr.com.
Thus, to be protected from network attackers, Fidelity needs a ForceHTTPS cookie for both .fidelity.com and .fmr.com.
  Bank of America.
Bank of America uses both HTTP and HTTPS on its main home page, and certain pages require cookies to be sent over HTTP.
However, the login page and online banking are handled on subdo-mains, such as sitekey.bankofamerica.com.
These subdomains use HTTPS exclusively, so we set Force-HTTPS cookies for the online banking subdomains.
  Gmail.
Google s Gmail web site, mail.google.com, presents a challenge because the site sets a domain-wide .google.com cookie.
We enabled ForceHTTPS for the entire Google site and wrote rewrite rules to redirect all Google pages to HTTPS except the search page (which cannot be accessed over HTTPS).
Additionally, we rewrote a query parameter for the login page to indicate that we wished Google to mark its session cookies Secure.
It is important to redirect all pages (except search) to HTTPS because Google s login page sometimes transmits sensitive authentication information in URL parameters.
With ForceHTTPS enabled, search tra c at Google is not protected from eavesdropping, but no cookies are sent with this tra c, keeping the user s session identi er secure.
  Chase.
Chase refuses to serve its home page over HTTPS.
We chose to redirect http://www.chase.com/ to https://chaseonline.chase.com, allowing the user to log in securely, but preventing access to any news or special o ers that appear only on the Chase home page.
ForceHTTPS also automatically repairs mixed content on Chase s login page by redirecting an insecure SWF movie to HTTPS.
  Yahoo!
Mail.
We were unable to develop rewrite rules for the Yahoo!
Mail site because Yahoo!
Mail does not support HTTPS.
We enabled ForceHTTPS for the Yahoo!
login page, with the goal of protecting the user s password (rather than the session) from active attacks.
Because the Yahoo!
Sign-in Seal [30] is revealed by an insecure cookie, an active attacker could display the sign-in seal on an HTTP page without requiring the user to click through a security warning dialog.
With ForceHTTPS installed, the attacker cannot display the Sign-in Seal, upgrading Yahoo! s phishing defense to a pharming defense as well.
ForceHTTPS lets users and web sites to opt in to stricter error processing by the browser.
For users, ForceHTTPS can  x vulnerabilities in web sites and enable sites that were not designed to be used over hostile networks to be browsed securely over such networks.
For web sites, ForceHTTPS protects Secure cookies from active network attackers and remediates accidental embedding of insecure content.
Previous anti-pharming proposals required either overhauling DNS or the deployment of complex, digitally signed policy  les encoding the frequently-changing trust relationships between domains.
By contrast, ForceHTTPS merely requires setting a cookie, a procedure that many sites already handle with every new session.
ForceHTTPS is a useful mitigation for mixed content, but sites should strive to  x these bugs by removing insecure em-beddings.
Developers have trouble detecting mixed content because all the major browsers have signi cant bugs in their mixed content detection mechanisms.
In future work, we plan to collaborate with web application vulnerability scanner vendors to build a mixed content scanner that spiders a web site and reports its mixed content vulnerabilities.
ForceHTTPS has already proven itself useful to its authors, who now check their email at security conferences without fear of eavesdropping and other network attacks.
We look forward to extending this protection to other users.
We thank Michael Barrett, Dan Boneh, John C. Mitchell, Umesh Shankar, and Andy Steingruebl for their helpful suggestions and feedback.
This work is supported by grants from the National Science Foundation and the US Department of Homeland Security.
