Ontologies are nowadays used in disciplines as diverse as biology [20], medicine[18], astronomy [4], and agriculture [21].
A de facto standard for ontology modeling is the Web Ontology Language (OWL),1 so most ontologies in these domains were either developed from the start using OWL or translated into OWL from other formalisms.
OWL is an expressive language capable of supporting diverse applications.
Its logical underpinning is given by description logics (DLs), which provide OWL with a clean model-theoretic semantics, well-understood reasoning problems, and powerful reasoners.
of the decidable languages of the OWL family.
Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
Structured objects that is, objects composed of other, possibly interrelated objects pose some well-known problems to OWL and DLs [3, 1, 19].
Such objects abound, for example, in molecular biology and the clinical sciences.
Clinical ontologies such as GALEN [22], the Foundation Model of Anatomy (FMA) [18], the National Cancer Institute (NCI) Thesaurus [7], and SNOMED CT [23] are currently being used in large-scale applications, and they describe numerous structured objects.
For example, GALEN models the heart as consisting of the left and the right ventricles, the two atria, and the valves, all of which participate in complex relationships, such as  the two ventricles of a heart are separated by the intraventricular septum.  OWL can be used to describe domains consisting of an arbitrary or even in nite number of objects, but it only allows for axioms that can connect these objects in a certain treelike manner.
In other words, OWL enjoys (a variant of) the tree model property [24]: if an OWL ontology has a model, then it has a model with a treelike (or forest-like) relational structure as well.
This property is responsible for the decidability of OWL reasoning [24]; however, it prevents su ciently accurate description of complex structured objects, since schema-level axioms in OWL cannot describe arbitrary relational structures.
Consider the previously mentioned diamond-shaped structure involving a heart, its right and left ventricles, and a septum.
In addition to a model that corresponds to the structure in which the objects are connected as expected, each schema-level description of the heart in OWL will also have a model where one heart has two septa, each as a part of the left and the right ventricle, respectively.
Thus, certain consequences of the diamond-shaped structure cannot be drawn from its formulation in OWL.
For example, we cannot conclude that, if the right ventricle has a perforated septum, the left ventricle has a perforated septum as well.
To address this lack of expressive power, in Section 4 we propose an extension of OWL for modeling structured objects using description graphs.
Such graphs consist of vertices labeled with atomic concepts and edges labeled with atomic roles.
According to our proposed model-theoretic semantics, these graphs are class-level statements that specify general patterns of connections between objects.
In addition, we allow for SWRL-like rules [8] to enable the description of conditional statements about graphs.
Extending DLs with axioms that can enforce arbitrary structures easily leads to undecidability [12].
Our formalism, however, is decidable because it can represent only structured objects whose number of parts is bounded.
In prac-
level of granularity, which naturally determines this bound.
In Section 5, we present a reasoning algorithm for the case where the OWL part is expressed in SHIQ [10]; it should, however, be possible to extended the algorithm to SHOIQ [9] and hence cover OWL DL.
We thus obtain a powerful, decidable, and practicable language that combines two complementary formalisms: unbounded but treelike structures can be described using standard OWL axioms, and the naturally bounded structured parts can be described using arbitrarily connected description graphs and rules.
We have implemented our algorithm in the DL reasoner HermiT [16].2 The validation of our approach is currently di cult due to the lack of test data.
Thus, we have devised an algorithm that extracts description graphs from OWL ontologies, and have applied it to GALEN and FMA.
The resulting ontologies should be treated with caution; however, domain experts have con rmed that substantial parts of the ontologies re ect the actual human anatomy.
Our transformation can thus be a starting point for a more comprehensive remodeling using description graphs.
Finally, the ontologies are su ciently complex to allow us to estimate the practicability of reasoning.
We present the transformation algorithm in Section 6.
In Section 7, we discuss the results obtained by classifying the transformed ontologies.
Our transformation allowed us to discover a modeling error in GALEN, which we take as indication that our formalism can indeed be useful in practice.
Furthermore, classi cation times for the transformed ontologies are of similar orders of magnitude as for the original ontologies despite the fact that our formalism adds considerable expressive power to OWL.
Due to lack of space, proofs and certain technical details are included in the accompanying technical report [13].
A SHIQ signature is a triple   = (NC , NR, NI ) consisting of mutually disjoint sets of atomic concepts NC , atomic roles NR, and individuals NI .
Let S be an atomic role, A an atomic concept, and n a nonnegative integer.
SHIQ roles and concepts are de ned using the following grammar:

   n R.C |   n R.C A TBox T is a  nite set of role inclusions R1   R2, transitivity axioms Trans(R), and general concept inclusions (GCIs) C1   C2.
An extensionally reduced ABox A is a  nite set of assertions ( )A(a), S(a, b), a   b, and a 6  b.
A knowledge base K is a pair (T , A).
To ensure decidability of reasoning, certain restrictions apply on the usage of roles in at-most and at-least concepts   n R.C and   n R.C [10].
An interpretation I is a  rst-order relational structure.
The de nition of satisfaction of axioms in I can be found in [10].
I is a model of K, written I |= K, if it satis es all axioms of K. The basic inference problem for SHIQ is checking satis ability of K that is, checking whether a model of K exists.
The principles for extending DLs with rules can be found in [12, 5, 8].
For a SHIQ signature  , let NV be a countably in nite set of variables disjoint from NI .
A predicate is a concept, a role, or the equality predicate  .
Concepts have
 http://web.comlab.ox.ac.uk/oucl/work/boris.motik/HermiT/ arity one, and roles and   have arity two.
An atom over   has the form P (x1, .
.
.
, xn), where P is a predicate of arity n and xi are variables.
Atoms with the equality predicate are written as t1   t2.
A rule r is an expression of the form B1   .
.
.
  Bn   H1   .
.
.
  Hm (1) where n   0, m   0, and Bi and Hj are atoms.
The set of atoms {B1, .
.
.
, Bn} is called the antecedent, and the set of atoms {H1, .
.
.
, Hm} is called the consequent.
A program P is a  nite set of rules.
A rule r is interpreted in an interpretation I as a standard  rst-order implication.
To understand the limitations of modeling structured objects in OWL, let us consider modeling the anatomy of the heart shown in Figure 1(a).
This example has been derived by reconstructing the intention behind the axioms describing the heart in GALEN.
We next consider possibilities for a logical interpretation of the  gure.
Figure 1(a) could be represented in OWL using an ABox A. ABox assertions, however, represent concrete data; thus, A would represent the structure of one particular heart.
In this paper, we are concerned with modeling structured objects at the schema level  that is, we want to describe the general structure of all hearts.
We should be able to instantiate such a description many times.
For example, if we say that each patient has a heart, then, for each concrete patient, we should instantiate a di erent heart, each of the structure shown in Figure 1(a).
This clearly cannot be achieved if we describe the structure of the heart using ABox assertions.
Consequently, GALEN, SNOMED CT, and NCI contain only schema-level axioms and no ABox assertions.
We can give a logical, schema-level interpretation to Figure 1(a) by treating vertices as concepts and arrows as participation constraints specifying relationships between concepts.
For example, LeftSideOfHeart and AorticValve are concepts and the arrow between them states that each left side of the heart has an aortic valve as a structural component.
Participation constraints can be represented using existential quanti cation, which can be encoded in OWL using axioms of the form (2).
Let K be a DL knowledge base containing the following axioms.
LeftSideOfHeart    hasStructuralComponent .AorticValve AorticValve    hasAlphaConnection .LeftVentricle LeftSideOfHeart    hasSolidDivsion.LeftVentricle (2) (3) (4) Let I be an interpretation that corresponds to Figure 1(a) in the obvious way.
Clearly, I is a model of K, which justi es the formalization of Figure 1(a) by axioms (2) (4).
Such a schema-level representation of a heart can be put to use in many ways.
We might represent knowledge about various heart conditions; for example, if the aortic valve suffers from aortic regurgitation (AR), then the left ventricle su ers from left ventricular hypertrophy (LVH): AorticValve   HasAR    hasAlphaConnection .HasLVH (5) We might expect to derive from (2) (5) that, if the aortic valve of the left side of the heart su ers from aortic regur-
(b) Unintended Tree Structure (c) Unintended In nite Structure Figure 1: Di erent Models of the Heart in GALEN gitation, then the left ventricle su ers from hypertrophy: LeftSideOfHeart    hasStructuralComponent .
(AorticValve   HasAR)    hasSolidDivision.HasLVH (6) Unfortunately, (6) does not follow from K: axioms (3) and (4) imply the existence of two left ventricles, but no axiom in K states that these two ventricles are necessarily the same object.
Thus, an interpretation I   corresponding to Figure
 aortic regurgitation, the second left ventricle is una ected.
Hence, I   6|= (6), so K 6|= (6) as well.
The knowledge base K is thus underconstrained: some models of K do not correspond to the actual structure of the heart shown in Figure 1(a).
This discrepancy can prevent us from drawing some quite reasonable conclusions, such as (6).
Furthermore, it can also cause problems with the performance of reasoning.
For example, we might use axioms (4) and (7) (8) to describe the relationships between the left side of the heart, the left ventricle, and the mitral valve.
LeftVentricle    isBetaConnectionOf .MitralValve (7) MitralValve    isStructuralComponentOf .LeftSideOfHeart (8) While admitting a model corresponding to Figure 1(a), these axioms do not state that the mitral valve in (7) is a structural component of the  initial  left side of the heart.
Hence, the interpretation from Figure 1(c) is also a model of these axioms.
In fact, the latter model is  canonical  in the sense that it re ects the least amount of information derivable from the axioms.
In order to disprove an entailment from these axioms, an OWL reasoner will try to construct such a  canonical  model.
In practice, such models can be highly repetitive and much larger than the intended models, which, according to our experience, is the main reason why OWL reasoners still cannot process ontologies such as FMA and certain versions of GALEN.
To avoid such problems, we need to extend K with additional axioms that make all models of K correspond as much as possible to the intended conceptualization shown in Figure 1(a).
Such axioms, however, cannot be stated in OWL, for reasons we explain next.
OWL can represent unbounded or even in nite domains, which is appropriate in many cases.
For example, in the domain of people, we should not make any assumptions about the number of people in the world.
In other words, the domain of all people does not exhibit a natural bound on its size.
Thus, we can represent the fact that every person has exactly two parents who are persons: Person     2 hasParent .Person     2 hasParent .  (9) Reasoning with such axioms is not straightforward.
A model containing one person   must contain two parents  1 and  2, each of which requires the existence of two additional parents and so on.
E ectively, we obtain a model that is similar to the one shown in Figure 1(c).
To ensure termination of the model construction outlined in the previous paragraph, the structure of the axioms allowed in OWL is restricted such that the language exhibits (a variant of) the tree model property [24]: whenever a knowledge base K has a model, it also has a model of a certain tree shape.
The relationship between the left side of the heart, the aortic valve, and the left ventricle in Figure 1(a) is, however, triangular and cannot be represented as a tree.
Hence, if we want to ensure that the ventricles whose existence is implied by (3) and (4) are the same in every model of K, we must leave the con nes of OWL and DLs.
Certain rule formalisms can axiomatize nontree structures.
make the two ventricles from Figure 1(b) the same: LeftSideOfHeart (x)  hasStructuralComponent (x, y)   hasAlphaConnection (y, z)   LeftVentricle(z)   hasSolidDivsion(x, w)   LeftVentricle(w)   z   w (10) This, however, has signi cant drawbacks.
From the standpoint of modeling, such a solution is quite complex, as it requires the modeler to anticipate which objects need to be made the same.
The fact that the two left ventricles are the same follows from the complex interaction between axioms (2) (4) and (10), and is thus not represented explicitly.
Clearly, such a modeling formalism is likely to be hard to use and susceptible to modeling errors.
From the standpoint of automated reasoning, the extension of OWL with SWRL is undecidable [8], which is a signi cant impediment to the adoption of SWRL in practice.
SWRL-like rules can, however, naturally express certain conditional aspects of structured objects.
For example, if the septum has a ventricular septal defect, then there is a blood  ow from the left to the right ventricle: IntraventricularSeptum (x)   HasVSD (x)   hasLayer (y1, x)   LeftVentricle (y1)   hasLayer (y2, x)   RightVentricle (y2)   (11) hasBloodFlow (y1, y2) The variables in the antecedent of this rule are connected in a non-tree-like way, so such a rule cannot be expressed in OWL.
If we, however, deal with arbitrarily connected structures, such as the one shown in Figure 1(a), non-tree-like antecedents are essential for drawing the correct inferences.
Various decidable combinations of DLs and rules cannot be used for schema modeling.
For example, the DL-safe rules [15] are syntactically restricted such that they apply only to the explicitly named objects.
Role-safe [12] and weakly safe [17] rules also impose restrictions that prevent the application of the rules to arbitrary elements of the domain, and similar restrictions are also employed by various nonmono-tonic rule extensions of OWL [6, 17, 14].
While these are quite useful in query answering, they cannot be used to derive new conclusions from the schema.
The DL SROIQ [11] and the OWL 1.1 extension of OWL DL extend OWL with complex role inclusions of the form R1   .
.
.
  Rn   S, restricted appropriately to ensure decid-ability.
Such axiom solve some of the problems; however, they still cannot axiomatize arbitrary structures such as the one in Figure 1(a) or express axioms such as (11).
We now present an extension of OWL that addresses the problems from Section 3.
The main aspect of a description of a structured object is the connection between the object s parts, which can naturally be represented as a graph.
Hence, we introduce the notion of a description graph G = (V, E,  ) a directed graph in which each vertex i   V is labeled with a set of atomic concepts  hii and each edge hi, ji   E is labeled with a set of atomic roles  hi, ji.
For example, Figure 1(a) can be understood as a description graph that describes the heart.
Semantically, G = (V, E,  ) should be understood as a  template  for a fragment of a model.
Let I be a model and A an atomic concept labeling some graph vertex i   V .
If I contains an object   such that     AI , then I must also contain an instance of G in which   corresponds to i.
For example, if I contains an instance   of the Heart concept, then I must contain a relational structure corresponding to Figure 1(a) in which   corresponds to the topmost vertex.
As discussed in Section 3, extending DLs with constructs that allow the description of arbitrarily connected structures of unbounded size easily leads to undecidability.
In practice, structured objects are usually modeled up to a certain level of granularity, which naturally determines this bound.
For example, a human body consists of a certain number of organs.
These organs might be decomposed into smaller parts; however, each such decomposition is bounded, so the entire model of human anatomy requires a bounded number of objects.
Even though the number of required objects may be large and di cult to determine by hand, the fact that the domain is bounded is intrinsic to the modeling problem.
The reasoning algorithm presented in Section 5 uses this bound to ensure termination even on arbitrarily connected, non-tree-like structures.
We assume that the set of atomic roles is divided into a set of atomic tree roles NRt and a set of atomic graph roles NRg .
A graph-extended DL knowledge base is a 4-tuple K = (T , G, P, A) where T is a DL TBox, G is a description graph, P is a set of rules, and A is an ABox.
Furthermore, T is allowed to refer only to tree roles, G and P are allowed to refer only to the graph roles, and A is allowed to refer to both graph and tree roles.
For example, let K = (T , G, P, A) be a graph-extended DL knowledge base with the following components.
Let T contain the axioms (12) (14).
Intuitively, axiom (12) says that each person has a parent and a heart; axiom (13) ensures that the heart of each su erer from aortic regurgitation is an instance of HasAR; and axiom (14) says that, on each aortic valve su ering from aortic regurgitation, some person is performing a surgery on it.
Person    hasParent .Person    hasHeart .Heart AR Su erer    hasHeart .HasAR AorticValve   HasAR    performsSurgeryOn  .Person (12) (13) (14) Let G correspond to Figure 1(a), let P contain the rule (15) that propagates the HasAR concept over the structural components of the heart, and let A contain the assertions Person(a) and AR Su erer (a).
HasAR(x)   hasStructuralComponent (x, y)   HasAR(y) (15) The semantics of graph-extended KBs ensures that each model I of K is of the form shown in Figure 2.
I consists of two distinct parts.
The tree backbone consists of objects (shown as large squares) connected through tree roles (shown using thick lines), and it is constructed using the standard DL axioms in T .
As discussed in Section (3), the number of persons is not naturally bounded so, if we want a decidable formalism, we must employ standard DL restrictions.
Apart from the tree backbone, I also contains arbitrarily connected but naturally bounded graph instances, such as the structure of the heart of each person.
Unlike
 and ( iii)   labels each vertex i   V with a set of atomic concepts  hii   NC , and each edge hi, ji   E with a set of atomic graph roles  hi, ji   NRg .
For an atomic concept A, VA is the set of vertices that contain A in their label: VA = {k   V | A    hki}.
We now de ne the notion of graph-extended DL knowledge bases.
The de nition of graph-regular rules ensures that each such rule can become applicable only to objects from the same instance of the description graph G, which is required to obtain a decidable formalism.
Definition 3.
A rule of the form (1) is graph-regular if it uses only atomic concepts and graph roles and, for each pair of variables x1 and x2 occurring in r, some antecedent atom of r contains both x1 and x2.
A graph-extended DL knowledge base K = (T , G, P, A) is a 4-tuple where ( i) T is DL TBox over the signature (NC , NRt , NI ), ( ii) G is a description graph with   vertices, ( iii) P is a  nite set of graph-regular rules, and ( iv) A is an extensionally-reduced ABox over (NC , NRt , NRg , NI ) that, apart from standard assertions, can also contain graph assertions of the form G(a1, .
.
.
, a ) for ai   NI .
Graph-regular rules can express conjunctive queries over G, so we do not consider query answering separately.
We now formalize the semantics of description graphs.
Definition 4.
An interpretation I = ( I ,  I ) interprets a description graph G = (V, E,  ) with   vertices as an  -ary relation GI   ( I ) .
An interpretation I satis es G, written I |= G, if all of the following conditions hold.
i-key property: for each 1   i    ,  x1, .
.
.
, x , y1, .
.
.
, y     I : hx1, .
.
.
, x i   GI   hy1, .
.
.
, y i   GI   xi = yi   V xj = yj 1 j  Disjointness property:  x1, .
.
.
, x , y1, .
.
.
, y     I : hx1, .
.
.
, x i   GI   hy1, .
.
.
, y i   GI   V xi 6= yj 1 i<j n A-start property: for each atomic conceptA with VA 6=  ,  x    I : x   AI    x1, .
.
.
, x     I : hx1, .
.
.
, x i   GI   W x = xk k VA Vertex layout property: for each i   V and A    hii,  x1, .
.
.
, x     I : hx1, .
.
.
, x i   GI   xi   AI Edge layout property: for each hi, ji   E and R    hi, ji,  x1, .
.
.
, x     I : hx1, .
.
.
, x i   GI   hxi, xji   RI The intuition behind this de nition is as follows.
Each tuple in the  -ary relation GI corresponds to one instance of the description graph G.
The i-key properties and the disjointness property ensure that no two instances of G can share an object, which essentially captures the idea behind natural boundedness.
Consider the axiom B   A and a graph G consisting of two vertices 1 and 2 such that  h1i = {A},  h2i = {B}, and  h1, 2i = {R}.
Without the i-key and the disjointness properties, we could build a model I of G where  1   AI , Figure 2: A Typical Model of K in the case of axioms (2) (4) and Figure 1(b), each graph instance is necessarily of the form as speci ed by G in each such model I.
Note that the tree backbone of I need not be contiguous: the bottom-most AorticValve object av can be connected to other objects through tree roles.
To summarize, for a graph-extended knowledge base K, we can consider only models that consist of graph instances, connected among themselves and with other objects through tree roles.
Decidability of the formalism is now ensured by the separation of the roles into tree and graph ones.
The axioms in T can propagate constraints across tree roles just like in standard DLs; however, we can adapt the blocking technique [10] to ensure termination of model construction.
Furthermore, the rules in P can propagate constraints within a graph; however, the size of the graph is naturally bounded, so this does not cause termination problems either.
Our way of obtaining decidability is related to fusions of abstract description systems (ADSs) [2], which allow for the combination of di erent modal and description logics.
The component ADSs can share concepts; however, the interaction between them through roles is restricted to ensure decidability.
Our separation of roles into graph and tree ones is similar in spirit.
Bounded structures and rules, however, cannot directly be expressed as an ADS.
In addition, we present a practical decision procedure.
We now de ne of our language formally.
We start by de ning a signature that separates tree from graph roles.
All subsequent de nitions in this paper are implicitly pa-rameterized with such a signature.
Definition 1.
A graph-extended DL signature is a 4-tuple   = (NC , NRt , NRg , NI ) consisting of pairwise disjoint sets of atomic concepts NC , atomic tree roles NRt , atomic graph roles NRg , and individuals NI .
We now de ne description graphs formally.
We make the technical assumption that the vertices of G are consecutive integers, as this allows us to use vertices as indices.
Definition 2.
A description graph G = (V, E,  ) is a directed labeled graph where ( i) V = {1, .
.
.
,  } is a  nite set
 also set  2   AI ; but then, we must instantiate G for  2, which clearly leads to a cyclic computation.
The i-key and the disjointness properties ensure that such a model I cannot exist: each object occurring in a graph part of I occurs in exactly one tuple of GI .
Since this tuple is bounded in size, each graph part of I is bounded as well, which can be used to ensure termination of model construction.
The A-start property ensures that I contains an appropriate instance of G whenever I contains an instance   of a concept A labeling a vertex of G. If A labels more than one vertex of G, the A-start property  guesses  the vertex of G that   should be matched to.
Consider, for example, a graph containing a vertex labeled with Hand and  ve vertices labeled with Finger .
If some object   is an instance of Finger , without further information we cannot disambiguate which of the  ve  ngers   stands for.
Therefore, we need to make a  guess  and examine all  ve possibilities independently.
Note that no other property requires guessing; hence, unless we label two vertices in G with the same concept A, the semantic properties of graphs allow for deterministic reasoning.
Finally, the vertex and edge layout properties simply ensure that each instance of G indeed contains the appropriate relational structure of G.
To support reasoning over graph-extended KBs, we extend the hypertableau algorithm for SHIQ from [16].
This algorithm provides the basis for the HermiT reasoner, which is currently the only reasoner that can classify the original version of GALEN.
Our algorithm decides satis ability of K = (T , G, P, A) with T expressed in SHIQ.
The algorithm proceeds in two phases.
In the preprocessing phase, T and G are translated into equisatis able sets of rules.
In the hypertableau phase, an attempt is made to construct a model of A, P, and the rules from preprocessing.
The TBox T is preprocessed into a set of rules  (T ) of the form (1) exactly as it is done in [16].
Due to lack of space, we refer the reader for details to [16, 13].
After this transformation,  R.C is treated as a synonym for   1 R.C.
Translation of G into a set of rules  (G) uses concepts  G|k, which represent objects occurring in an instance of G at position k. Their interpretation is de ned as ( G|i)I = {s |  t1, .
.
.
, t  : ht1, .
.
.
, t i   GI   s = ti}.
The set  (G) is computed as shown in De nition 5.
It is easy to see that  (G) encodes conditions from De nition 4 in a straightforward way; hence, I |= G i  I |=  (G).
Definition 5.
For a description graph G = (V, E,  ), the set  (G) consists of the following rules, for   = |V |: G(x1, .
.
.
, x )   G(y1, .
.
.
, yi 1, xi, yi+1, .
.
.
, y )   xj   yj for each i, j   V such that j 6= i G(x1, .
.
.
, x )   G(y1, .
.
.
, yj 1, xi, yj+1, .
.
.
, y )     A(x)   Wk VA  G|k(x) G(x1, .
.
.
, x )   A(xi) G(x1, .
.
.
, x )   R(xi, xj) for each 1   i < j     for each A such that VA 6=   for each i   V and A    hii for hi, ji   E and R    hi, ji The set of rules R =  (T )    (G)   P produced by pre-processing is equisatis able with (T , G, P), so we check sat-is ability of K by checking satis ability of (R, A).
The hy-pertableau algorithm, however, can be applied to any set of rules R that is admissible according to De nition 6.
It is easy to see that  (T )    (G)   P is admissible.
Definition 6.
A set of rules R is admissible if it can be represented as a disjoint union of two subsets Rt and Rg.
The set Rg can contain only graph-regular rules and, for each description graph G, it must contain all rules from the  rst two items of De nition 5.
Let denote R an atomic tree role, A an atomic concept, and C a concept of the form   n S.A or   n S. A with S a tree role.
For each r   Rt, it must be possible to separate the variables of r into one center variable x and the set of leaf variables {yi} such that ( i) each atom in the antecedent of r is of the form A(x), A(yi), R(x, yi), or R(yi, x), ( ii) each atom in the consequent is of the form A(x), A(yi), C(x), C(yi), R(x, yi), R(yi, x), or yi   yj, and ( iii) each variable yi in the rule occurs in some binary atom in the antecedent.
De nition 7 summarizes the calculus for checking satis- ability of (R, A) for R an admissible set of rules.
This algorithm di ers from the one in [16] in two main points.
First, our algorithm contains the  G-rule that generates an instance of G for an assertion  G|i(s).
In spirit, the  G-rule is similar to the  rule that expands assertions of the form   n R.C(s) by introducing fresh successors of s. Second, our algorithm contains an appropriately modi ed version of blocking [10] to ensure termination.
The idea behind blocking is the following: if two individuals s and s  occur in the same concepts in an ABox A, then s  behaves  just like s that is, we do not expand s any further.
To use this idea in our setting, we separate the individuals in each ABox A into named, tree, and graph individuals.
The named individuals occur in the original graph-extended knowledge base, the tree individuals are introduced by the  rule, and the graph individuals are introduced by the  G-rule.
We use this distinction in the de nition of blocking: only tree individuals can be blocked, and the blocking individual must also be a tree individual.
Our derivation rules generate only models of the form as shown in Figure 2.
There, the individual a is named.
The individual h1 is generated by deriving  hasHeart .Heart (a) by (12) and then expanding it by the  rule; hence, h1 is a tree individual.
All other individuals that correspond to the structure of the heart (including av) are created by instantiating G, so they are graph individuals.
To ensure termination, we apply the  G-rule with the lowest priority.
The rules in R ensure that no two instances of G can share an individual.
Hence, for each tree individual t (such as h1) that  enters  an instance of G, we can establish a bound on the number of graph individuals occurring generated for t; these individuals are said to be from the same graph cluster.
Definition 7.
Generalized Individuals.
Let T and   be two disjoint countably in nite sets of tree and graph symbols.
A generalized individual is a  nite string of symbols  0. 1.
.
.
.
. n such that  0   NI ,  i   T     for 1   i   n, and  i 1     implies  i 6   .
If  n   NI , the individual is named; if  n   T, the individual is a tree individual; and if  n    , the individual is a graph individual.
Successors and Predecessors.
A generalized individual x.  is a successor of x, predecessor is the inverse of successor, and descendant and ancestor are the transitive closures of successor and predecessor, respectively.
the same graph clusters if either ( i) s is either a named individual or a graph successor of a named individual, and t is also either a named individual or a graph successor of a named individual, ( ii) both s and t are graph successors of the same tree individual, or ( iii) one individual is a graph successor of the other individual.
Generalized ABox.
In the rest of this paper, we allow ABoxes to contain generalized individuals and the assertion   which is false in all interpretations, and we take a   b (a 6  b) to also stand for b   a (b 6  a).
Initial ABox.
An ABox is initial if it is extensionally reduced and nonempty and contains only named individuals.
Pairwise Anywhere Blocking.
A concept is blocking-relevant if it is of the form A,   n R.A,   n R. A, or  G|i, for A an atomic concept, R a (not necessarily atomic) role, and G a description graph.
The labels of an individual and of an individual pair in an ABox A are de ned as follows: LA(s) = {C | C(s)   A and C is blocking-relevant} LA(s, t) = {R | R(s, t)   A} Let   be a a transitive and irre exive relation on the generalized individuals such that, if s  is an ancestor of s, then s    s. By induction on  , we assign to each individual s in A a status as follows:   s is directly blocked by an individual s  i  ( i) both s and s  are tree individuals, ( ii) s  is not blocked, ( iii) s    s, ( iv) LA(s) = LA(s ) and LA(t) = LA(t ), and ( v) LA(s, t) = LA(s , t ) and LA(t, s) = LA(t , s ), for t and t  the predecessors of s and s , respectively.
  s is indirectly blocked i  its predecessor is blocked.
  s is blocked i  it is either directly or indirectly blocked.
Pruning.
The ABox pruneA(s) is obtained from A by removing all assertions that contain a descendant of s.
Merging.
The ABox mergeA(s   t) is obtained from the ABox pruneA(s) by replacing s with t in all assertions.
Clash.
An ABox A contains a clash if and only if     A; otherwise, A is clash-free.
Derivation Rules.
Table 1 speci es derivation rules that, given a clash-free ABox A and a set of rules R, derive the ABoxes hA1, .
.
.
, Ani.
In the Hyp-rule,   is a mapping from the set of variables NV to the individuals in A, and  (U ) is obtained from U by replacing each variable x with  (x).
Rule Priority.
The  G-rule is applicable only if no other rule is applicable.
Derivation.
A derivation for a set of admissible rules R and an initial ABox A is a pair (T,  ) where T is a  nitely branching tree and   labels the nodes of T with ABoxes such that ( i)  ( ) = A for   the root of the tree, and ( ii) for each node t, if one or more derivation rules are applicable to  (t) and R, then t has children t1, .
.
.
, tn such that the ABoxes h (t1), .
.
.
,  (tn)i are the result of applying one applicable derivation rule chosen by respecting the rule priority.
A derivation is clash-free if it has a leaf node labeled with a clash-free ABox.
Theorem 1.
For an admissible set of rules R and an initial ABox A, ( i) if (R, A) is satis able, then each derivation for R and A is clash-free, ( ii) if a clash-free derivation for R and A exists, then (R, A) is satis able, and ( iii) each derivation for R and A is  nite.
The proof is given in the technical report [13].
As a consequence of the theorem, subsumption checking, concept sat-is ability, and query answering are decidable as well.
The evaluation of the adequacy of our approach is rather di cult due to lack of adequate test data.
Furthermore, remodeling existing ontologies using a new modeling paradigm may require considerable e ort.
In order to both obtain test data for our reasoner and make the adoption of our approach in practice easier, we have developed an algorithm that automatically transforms a TBox T into a graph-extended knowledge base K. For example, our algorithm can automatically construct the graph shown in Figure 1(a) from the axioms such as (2) (4).
Clearly, the knowledge base K is only a rough approximation; however, it can be used as a starting point for a more comprehensive remodeling of T into a proper graph-extended KB.
Our transformation of a TBox T1 into a graph-extended KB K = (T , G, P, A) is based on two assumptions.
The  rst assumption is that only some concepts and roles from T1 are relevant for G. For example, the Heart concept is clearly relevant to the description graph of human anatomy; in contrast, the Disease concept is not relevant because it does not represent the structure of a human body.
Similarly, the hasStructuralComponent role clearly belongs to the graph, while the hasAge role does not.
Our second assumption is that each concept relevant to G should be represented by one vertex in G, and that edges in G can be decoded from axioms of the form A    R.B.
Our assumption is that, by writing axioms such as (2) (4), modelers actually wanted to say  the aortic valve has an alpha connection to the left ventricle, and the left side of heart has the same left ventricle as a solid division.  We use these two assumptions in the core part of our algorithm, which is parameterized with a DL TBox T1, a set of relevant concepts NCg , and a set of relevant roles NRg .
The latter set actually de nes the set of graph roles, and all other roles are considered to be tree roles.
Our algorithm  rst normalizes T1 in a certain way.
Then, it creates a vertex i in V for each concept A   NCg and sets  hii = {A}.
Then, it processes each axiom     T1 as follows:   If   is of the form A    R.B where {A, B}   NCg and R   NRg , then, for i and j vertices such that  hii = {A} and  hji = {B}, the algorithm adds the edge hi, ji to E and extends   such that R    hi, ji.
  If   does not contain a role from NRg , the algorithm simply copies   to the resulting TBox T .
  If   contains only roles from NRg and no existential quanti er, the algorithm translates   into a graph-regular rule and adds it to P.
  If   is not of the above form, then either it involves a graph and a tree role simultaneously, or it is of the form A    R.B but some of A, B, or R are not relevant for the graph.
Such an axiom either invalidates the syntactic restrictions of our formalism or it does not have a natural interpretation; hence, our algorithm simply ignores such an axiom  .
Hyp-rule If 1.
U1   ...   Um   V1   ...   Vn   R,


  (Ui)   A for each 1   i   m and  (Vj ) 6  A for each 1   j   n, then A1 = A   { } if n = 0; or Aj := A   { (Vj )} for 1   j   n if n > 0.
 rule s   t   A and s 6= t If then A1 := mergeA(s   t) if t is a named individual or if s is a descendant of t; or A1 := mergeA(t   s) otherwise.
 rule  rule If 1.
  n R.C(s)   A,
 3. there are no individuals u1, .
.
.
, un such that {ar(R, s, ui), C(ui) | 1   i   n}   {ui 6  uj | 1   i < j   n}   A, then A1 := A   {ar(R, s, ti), C(ti) | 1   i   n}   {ti 6  tj | 1   i < j   n} where t1, .
.
.
, tn are fresh pairwise distinct tree successors of s.
 G-rule If 1.
 G|i(s)   A for G a description graph with   vertices,
 3. there are no individuals u1, .
.
.
, ui 1, ui+1, .
.
.
, u  such that G(u1, .
.
.
, ui 1, s, ui+1, .
.
.
, u )   A s 6  s   A or {A(s),  A(s)}   A If then A1 := A   { }.
Note: A is a generalized ABox, R is a set of admissible rules, and NA is the set of individuals occurring in A.
then A1 := A   {G(t1, .
.
.
, ti 1, s, ti+1, .
.
.
, t )} where t1, .
.
.
, ti 1, ti+1, .
.
.
, t  are fresh pairwise distinct graph individuals from the same graph cluster as s.
Our translation cannot correctly handle axioms of the form A     n R.B with n   2.
Intuitively, such axioms might be handled by creating n vertices in G, labeling all of them with B, and then connecting the vertex of A with all the vertices of B using the role R. The situation, however, is not so simple if, in addition, we also have the axiom B     m R.A.
It is now not clear which vertices of the description graph labeled with A to  reuse  to satisfy this axiom.
Therefore, we decided to ignore such axioms.
This is partly justi ed by the fact that GALEN and FMA our main sources of inspiration and test data do not contain   n R.B concepts with n   2.
In human anatomy, di erent objects of the domain are naturally given di erent names.
For example, instead of an axiom Heart     2 hasStructuralComponent .SideOfHeart , (16) GALEN introduces explicit names for the left and the right side of the heart: Heart    hasStructuralComponent .LeftSideOfHeart (17) Heart    hasStructuralComponent .RightSideOfHeart (18) On ontologies with at-least restrictions, our algorithm simply treats each   n R.B as  R.B.
It is natural to use number restrictions for modeling symmetric organs such as the kidney.
On such an ontology, our algorithm produces a description graph containing just one copy of the object, and the graph can then be corrected by the modeler.
Determining the sets NCg and NRg manually is not easy.
According to our experience with GALEN and FMA, a good strategy is to manually identify a set of roles N   Rg that naturally belong to the graph, and then to take NRg as the closure of N   Rg w.r.t.
the explicit role inclusions from T1.
Then, we take NCg as the set of all concepts A and B occurring in an axiom A    R.B   T1 such that R   NRg .
Intuitively, if A and B are connected by a role that should be included into the graph, then it is likely that A and B should be included into the graph as well.
This idea, however, requires some re nement.
For example, GALEN contains the following axioms: LeftVentricle   Ventricle RightVentricle   Ventricle (19) (20) Let us assume that NCg contains Ventricle, LeftVentricle , and RightVentricle.
The core transformation then generates a description graph G containing three di erent vertices, each labeled with one of these concepts.
It is, however, coun-terintuitive for G to contain a Ventricle vertex: no ventricle as such exists on its own; rather, each concrete ventricle is either the left of the right ventricle.
In fact, such a description graph G is unsatis able.
Assume that an object x as instance of LeftVentricle; due to (19), x is also an instance of Ventricle.
To satisfy the A-start property for LeftVentricle, x must correspond to the i-th vertex of some instance of G; similarly, to satisfy the A-start property for Ventricle, x must also correspond to the j-th vertex of some instance of G. Finally, because LeftVentricle and Ventricle label di er-ent vertices of G, we have i 6= j, which then invalidates the disjointness property of De nition 4.
The concept Ventricle is thus an abstract concept: it is not meant to be instantiated directly, but only through a subclass.
Such concepts clearly do not belong into a description graph.
Hence, after computing NCg as described in the previous paragraph, our algorithm classi es the input TBox T1 using standard DL reasoning; then, it removes from NCg all concepts that are not leaves in the resulting classi cation.
Intuitively, if A is not a leaf concept in the classi cation of T1, then A is likely to be an abstract concept, so it should not be added to G.
A pseudo-code of the algorithm is given in [13], and the tool can be downloaded from HermiT s Web site.
We applied the algorithm from Section 6.1 to the original version of GALEN; furthermore, FMA is a very large ontology, so we have applied our algorithm to a fragment of FMA that describes the heart.
Both ontologies can be downloaded from HermiT s Web page.
Table 2 summarizes information about the original and the transformed ontologies.
Our transformation clearly leads to a change in the semantics of the ontology, and some information is lost in the process.
Many parts of the resulting description graph, however, correspond with the intuitive descriptions of the anatomy of the body.
For example, the graph shown in Figure 1(a) has been extracted from the transformed ontology.
To evaluate our approach, we have classi ed the original ontologies using HermiT, transformed them using the algorithm from Section 6 into graph-extended KBs, and clas-si ed the resulting KBs using the reasoning algorithm pre-




Translated GCIs: Into the description graph: Into rules over the graph: Into the DL TBox: Total number of concepts: Total number of roles: Total number of GCIs: GCIs discarded in the transformation: With both a tree and a graph role: With existentials on abstract concepts: Table 2: Information about Test Ontologies





















 With existentials on tree roles: With universals on tree roles: Involving concept names only: Vertices in the description graph: Edges in the description graph: sented in Section 5.
We now present the performance results and discuss the classi cation results.
We performed the experiments using a standard laptop with 1 GB of RAM.
The classi cation of the original version of GALEN and the fragment of FMA took 129 s and 57 s, respectively; furthermore, the classi cation of the transformed ontologies took 781 s and 6 s, respectively.
The increase in the classi cation time for GALEN is partly due to the fact that our implementation of the reasoning algorithm in Section 5 is still very prototypical.
In the case of FMA, the classi cation times are substantially lower because most of the original ontology is translated into the graph, so the generated models are much smaller.
Our performance results show that, even with a very prototypical implementation, we can process complex ontolo-gies, which we take as indication that our approach is practically feasible.
The transformed ontologies are more constrained than the original ones, so we expect to obtain new entailments.
In the case of GALEN, we discovered a concept that is sat-is able in the original version of the ontology, but is unsatis- able in the transformed ontology, which revealed a modeling error in GALEN.
The problem occurs in the representation of the patella a bone that is connected to certain tendons through two retinacula, represented using the concepts LateralPatellaRetinaculum and MedialPatellaRetinaculum.
GALEN describes the relationship between the patella and the two retinacula as follows: LateralPatellaRetinaculum    hasOtherEndAt .Patella   (.
.
.)
MedialPatellaRetinaculum    hasOtherEndAt .Patella   (.
.
.)
hasOtherEndAt   isAtOtherEndOf         1 isAtOtherEndOf (21) (22) (23) (24) According to the axioms above, each patella is connected to both the lateral and the medial retinacula, but due to functionality of isAtOtherEndOf , the two must be the same objects.
Intuitively, this is an undesirable consequence, since the two retunaculae are in reality di erent objects; in other words, isAtOtherEndOf should probably not have been declared functional.
Since GALEN is underconstrained, this does not cause the inconsistency of either concept, so this error has not been detected so far.
The description graph produced by our transformation, however, contains one node for the patella and one for each retinaculum; furthermore, both retinacula are connected through isAtOtherEndOf to the same patella.
Since isAtOtherEndOf is functional, the retinacula should be the same, which invalidates the dis-jointness property for the graph (see De nition 4) and makes Patella unsatis able.
In the case of FMA, we did not obtain any new subsump-tion relationships.
This is due to the fact that most of the subsumption relationships in FMA are represented explicitly as axioms of the form A   B where A and B are atomic concepts.
For example, the fact that the heart is an organ is represented explicitly with the axiom Heart   Organ, and it is not derived from the structure of the heart; clearly, such inferences are performed in the same way on both treelike and nontree structures.
As explained in Section 6, our algorithm discards some axioms from the ontology.
We compared the class hierarchies of the original and the graph-extended versions of GALEN.
In total, 361 subsumption relationships were lost, such as Femur   BodySpace (the femur is a body space), and InteratrialSeptum   TwoAndAHalfDimensionalStructure (the interatrial septum of the heart is a structure with two and a half dimensions).
All these entailments involve an abstract concept, so their loss is not surprising since the transformation algorithm discards GCIs that involve an abstract concept and an existential on a graph role.
No information about concrete concepts has been lost, though.
In contrast, in the case of FMA we did not lose any sub-sumption relationships.
As explained before, the reason is that the structural information in FMA largely does not in uence subsumption.
Our experience with GALEN and the discussions we had with the authors of GALEN lead us to conclude that our formalism represents the anatomical structures in the human body in a way that is closer to the modelers  intention than the original OWL axioms.3 The fact that we found a modeling error in GALEN leads us to believe that our formalism and its semantics are based on  reasonable  assumptions.
Furthermore, capturing the semantics of abstract concepts and axioms involving them properly is likely to be the most important open problem.
We brie y discuss possibilities for addressing it.
Consider the following axiom in GALEN that is eliminated by the transformation algorithm because both AtrioventricularValve and Ventricle are abstract concepts: AtrioventricularValve    hasAlphaConnection .Ventricle (25) Since both concepts in (25) are abstract, this axiom does not say anything about the structure of the concrete objects (i.e., the objects that are likely to be included into a description graph).
Thus, one might expect the actual relationship between valves and ventricles to be described for the concrete subclasses of AtrioventricularValve and Ventricle.
Axiom (25) can then be interpreted as a check which makes

 level.
Another possibility is to interpret Ventricle disjunc-tively over its subclasses: each valve is connected to either left or the right ventricle, but we do not know which.
Currently, it is not clear which interpretation is appropriate; in fact, the proper interpretation of abstract concepts is made more di cult by the fact that whether a concept is abstract or concrete depends on the level of granularity.
We have extended OWL with description graphs, which can be used to describe structured objects objects consisting of parts connected in a complex, arbitrary way.
We also allow for arbitrary SWRL-like rules over description graphs.
Unlike most existing combinations of DLs and rules in which rules can be used only for query answering [12, 15, 17, 6, 14], our rules also fully participate in schema reasoning.
Based on an observation that many structured objects exhibit a natural bound on their size, we derived a hypertableau reasoning algorithm for our formalism, which we implemented in the HermiT reasoner.
To obtain suitable test data, we extracted description graphs out of GALEN and FMA medical terminologies.
We successfully classi ed the resulting ontologies and even detected a modeling error.
We see three open problems for future research.
First, graph-extended KBs should provide for several and not just one description graph, as this would allow breaking up a large graph into several more manageable parts.
The main challenge is to identify an appropriate paradigm for specifying relationships between di erent description graphs.
Second, an adequate semantics for modeling abstract concepts at di erent levels of granularity is needed.
Third, to allow for a wider users  community, we would need to extend ontology editors such as Prot eg e with description graphs.
Acknowledgments We thank Alan Rector and Sebastian Brandt for providing us with comments from the domain experts  perspective.
