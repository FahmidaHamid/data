Fuzzy ontologies are envisioned to be useful in the Web.
On the one hand, ontologies serve as basic semantic infrastructure, providing shared understanding of certain domain across di erent applications, so as to facilitate machine understanding of Web resources.
On the other hand, being able to handle fuzzy and imprecise information is crucial to the Web.
Web data are likely to be uncertain or con icting and could raise trust issues.
It has been argued that uncertainty representation and reasoning could help to harmonise and integrate Web data from di erent sources.
To this end,  This paper is based on a poster titled  Expressive Querying over Fuzzy DL-Lite Ontologies  presented in the 2007 International Workshop on Description Logics (DL2007).
Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
W3C has recently set up an incubator group on Uncertainty Reasoning for the Web1.
Although recently there have been quite a lot of work on Description Logics (DLs) based fuzzy ontology languages, e.g., [27, 26, 17, 12, 2, 25], there exist no fuzzy ontology reasoners that could be e cient and/or scalable enough to handle the scale of data that the Web provides.
Interestingly, there currently exist two fuzzy ontology reasoners, namely the tableaux based fuzzy reasoner FiRE2 [25, 24], which supports a nominal and datatype-free subset of fuzzy-OWL DL, i.e. fuzzy-SHIN , and the mixed integer programming fuzzy reasoner fuzzyDL3, which supports fuzzy-OWL Lite, namely fuzzy-SHIf (D) [28].
Like their crisp counterparts, fuzzy-SHIN and fuzzy-SHIf (D) come with (at least) EX-PTIME computational complexity, thus the scalability of the above systems is doubtful.
Following current research developments in crisp DLs, there is an e ort on lightweight fuzzy ontology languages.
In particular, Straccia [29] extended the DL-Lite ontology language [5] to fuzzy DL-Lite.
DL-Lite, which is expressive enough to represent most features of UML class diagrams, enables highly e cient query answering procedures by making use of database technologies.
There are major limitations on Straccia s query language for fuzzy DL-Lite: the proposed query language has the same syntax as the query language of the crisp DL-Lite, and thus does not allow one to specify either thresholds for query atoms (such as  tell me e-shops that are popular [with degrees at least 0.8] and sell good books [with degrees at least 0.9] ), or weights and preferences on query atoms (such as  get me all cars that are fast and fancy but consider speed more important [with weight 0.7] than design [with weight 0.3] ), so as to exploit fuzzy assertions in fuzzy ontologies.
To the best of our knowledge, there exist no report on scal-able query engines for fuzzy DL-Lite, let alone supporting more expressive fuzzy query languages.
This paper makes the following major contributions:
 old queries and general fuzzy queries (Section 3.1), for querying over fuzzy ontologies, covering all the existing query languages for fuzzy ontologies as well as some new ones that can be customised by users.
Comparing with Straccia s query language, the threshold query language is  exible as it allows one to specify a threshold for each query atom (as shown in the above ex-
2http://www.image.ece.ntua.gr/~nsimou 3http://gaia.isti.cnr.it/~straccia
 alises the entailment problem of fuzzy assertions.
On the other hand, the general fuzzy query language is a general form of the fuzzy threshold query language, which in turn is a general form of Straccia s query language.
General fuzzy queries are motivated by the  eld of fuzzy information retrieval [8] where weighted Boolean queries [33] have been proposed for retrieving fuzzy information from fuzzy relational databases.
Our general fuzzy query language generalises most former approaches of weighted Boolean queries [20, 3, 34, 4] and several new approaches, like the p-norm approach [21], the geometric mean approach [6], the so called fuzzy weighted t-norm queries from Chor-taras et.
al. [7], which in turn generalise weighted min queries [23], and aggregation queries from Vojtas [32].
Thus, the main strength of the general fuzzy query language is the openness of the use of semantics of conjunction and that of the degree-associated atoms.
Consequently, the framework can accommodate di er-ent intuitive meaning on the associated degrees, like preferences, degrees of importance, fuzzy thresholds and more.
for the proposed framework, but also shows how to extend the SPARQL (a well known Semantic Web query language) syntax for the proposed query languages in the framework (Section 3.2).
Our extension uses specially formatted SPARQL comments, thus the fuzzy queries are still valid SPARQL queries, and it does not a ect current SPARQL tools and implementations.
also provides semantics (Section 3.1) and algorithms for answering such queries over arbitrary fuzzy DL-Lite ontologies together with sound and complete proofs (w.r.t.
the semantics); and the algorithms cover all the mentioned languages in the framework (Section 3.3).
scalable query engine for fuzzy ontologies, based on the ONTOSEARCH2 system4 [16], which consists of, among others, a query engine for DL-Lite and one for fuzzy DL-Lite.
The performance of the fuzzy DL-Lite query engine is evaluated against a benchmark (a fuzzy variant of the Lehigh University Benchmark (LUBM) [10], called f-LUBM) that we propose, which is the  rst of its kind and against which future implementations can also be evaluated.
The query engine is able to handle millions of individuals, according to the preliminary but encouraging evaluation (Section 4).
on keyword-plus-entailment searches, so as to show how to apply our e cient querying support for fuzzy ontologies.
The use case application is available online (Section 5).
4http://www.ontosearch.org/


 ing Due to the limitation of space, we do not provide a formal introduction of Description Logics (DLs), but rather point the reader to [1].
It should be noted that, even for the smallest propositionally closed DL ALC (which only provides the class constructors  C, C   D, C   D,  R.C and  R.C), the complexity of logical entailment is Exptime.
Recently, Cal-vanese et.
al. proposed DL-Lite, which has a low reasoning overhead (worst case polynomial time) [5].
A DL-Lite ontology (O) is a set of axioms of the following forms:
 B := A |  R |  R  and C is a general class C := B |  B | C1   C2 (where A denotes an named class and R denotes a named property);
 R is a named property;
 named individuals.
Description Logics have a well-de ned model-theoretic semantics, which are provided in terms of interpretations.
An interpretation I is a pair ( I,  I ), where  I is a nonempty set of objects and  I is an interpretation function, which maps each class C to a subset C I    I and each property R to a subset RI    I    I.
Typical reasoning ontology services include ontology consistency checking (i.e., whether there exists an interpretation of an ontology), subsumption checking (i.e., whether the interpretation of a class C1 is a subset of the interpretation of a class C2 in all interpretations of the ontology), instance checking (i.e. whether an assertion is logically implied by an ontology) and query answering.
In this paper, we will focus on query answering.
A conjunctive query (CQ) q is of the form q(X)    Y .conj(X, Y ) (1) or simply q(X)   conj(X, Y ), where q(X) is called the head, conj(X, Y ) is called the body, X are called the distinguished variables, Y are existentially quanti ed variables called the non-distinguished variables, and conj(X, Y ) is a conjunction of atoms of the form A(v), R(v1, v2), where A, R are respectively named classes and named properties, v, v1 and v2 are individual variables in X and Y or individual names in O.
As usual, an interpretation I satis es an ontology O if it satis es all the axioms in O; in this case, we say I is a model of O.
Given an evaluation [X 7  S] (where S is a set of individuals), if every model I of O satis es q[X 7 S], we say O entails q[X 7 S]; in this case, S is called a solution of q.
A disjunctive query (DQ) is a set of conjunctive queries sharing the same head.
Theoretically, allowing only named classes and properties as atoms is not a restriction, as we can always de ne such named classes and properties in ontologies.
Practically, this should not be an issue as querying against named relations is a usual practice when people query over relational databases.
After some careful query rewriting by DL-Lite reasoners [5], query answering over DL-Lite ontologies can be carried out by an SQL engine, so as to take advantage of exist-
by modern database management systems.
Straccia [29] proposed fuzzy DL-Lite (or f-DL-Lite for short), which extends DL-Lite core with fuzzy assertions of the forms B(a)   n, R(a, b)   n, where B is basic class, R is a property, a and b are individuals and n is a real number in the range [0, 1].
The semantics of f-DL-Lite ontologies is de ned in terms of fuzzy interpretations [27].
A fuzzy interpretation is a pair I = ( I,  I ) where the domain  I is a nonempty set of objects and  I is a fuzzy interpretation function, which maps:   an individual a to an element of aI    I,   a named class A to a membership function AI :  I   [0, 1], and   a named property R to a membership function RI :
 Using the fuzzy set theoretic operations [11], fuzzy interpretations can be extended to interpret f-DL-Lite class and property descriptions.
Following Straccia [29], we use the Lukasiewicz negation, c(a) = 1   a and the G odel t-norm for interpreting conjunctions, t(a, b) = min(a, b).
The semantics of f-DL-Lite class and property descriptions, and f-DL-Lite axioms are depicted in Table 1.
Given the above semantics, it is obvious that crisp assertions B(a), R(a, b) are special forms of fuzzy assertions where n = 1.
Syntax Semantics ( R)I(o1) = sup o2 I {RI (o1, o2)}




 ( B)I (o) = 1   B I (o) (C1   C2)I(o) = t(C I (R )I(o2, o1) = RI(o1, o2)  o    I , B I (o)   C I (o)  o1    I,  {o2 | RI(o1, o2) > 0} = 1 B I (aI)   n 2 (o))
 Func(R) B(a)   n R(a, b)   n RI (aI, bI )   n of the DL-Lite speci ed in the OWL1.1 member submission (an extension of OWL DL) in the tractable fragments document [9].
It is slightly di erent from that in the OWL 1.1 document, mainly due to the fact that it uses the OWL DL syntax (which is slightly di erent from that of OWL 1.1) and RDF/XML serialisation.
Besides disallowing several expressive OWL DL constructors, DL-Lite restricts the use of several of the allowed constructors and especially w.r.t.
which side of class axioms they can appear.
Thus, the de nition of an abstract syntax is slightly trickier than that of OWL.
In OWL DL, for example, disjointness, equivalence and subclass axioms are de ned by the following abstract syntax: axiom ::=  DisjointClasses(  description description { description }  )  |  EquivalentClasses(  description { description }  )  |  SubClassOf(  description description  )  where  description  can be any OWL DL class description.
In DL-Lite, only basic classes are allowed on the left-hand side of axioms, while general classes are allowed only on the right-hand side.
Thus, the above abstract syntax should be adjusted to: axiom ::=  DisjointClasses(  basicClass basicClass { basicClass }  )  |  EquivalentClasses(  basicClass { basicClass }  )  |  SubClassOf(  basicClass generalClass  )  where  basicClass  and  generalClass  represent the basic and general classes of DL-Lite, respectively.
The abstract syntax for these two elements should also follow the restrictions of DL-Lite; e.g., a  generalClass  can be an intersection of classes while a basic class is not.
By using the RDF/XML serialisation mapping described for OWL DL, one is able to obtain DL-Lite and f-DL-Lite ontologies in RDF/XML syntax.
For example, the following class axiom in RDF/XML syntax is a valid DL-Lite axiom, Table 1: Semantics of f-DL-Lite class and property descriptions, and f-DL-Lite axioms Similarly to crisp DL lite, fuzzy-DL-Lite, provides means to specify role-typing and participation constraints but interestingly it assigns fuzzy meaning on them.
More precisely, a role-typing assertion of the form  R   A1 (resp.
 R    A2) states that the  rst (resp.
second) component of R belongs to A1 (resp.
A2) at-least to the membership degree that the relation R holds, i.e. RI(aI, bI)   AI
 (resp.
(R )I(bI , aI ) = RI(aI, bI)   AI

 Since DL-Lite (resp.
f-DL-Lite) is a sub-language of OWL (resp.
f-OWL DL), we provide an abstract and RDF/XML syntax for DL-Lite and f-DL-Lite ontologies in this subsection, following the paradigm of OWL DL [18].
OWL DL ontologies in RDF/XML syntax can be generated from those written in the abstract syntax, using the o cial mapping between the two kind of syntax provided in [18].
Our proposed abstract syntax for DL-Lite core is based on that <owl:Class rdf:ID="C"> <rdfs:subClassOf> <owl:Class> <owl:intersectionOf rdf:parseType="Collection"> <owl:Class> <owl:complementOf> <owl:Restriction> <owl:onProperty rdf:resource="#R"/> <owl:someValuesFrom rdf:resource="&owl;Thing"/> </owl:Restriction> </owl:complementOf> </owl:Class> <owl:Class> <owl:complementOf rdf:resource="#A"/> </owl:Class> </owl:intersectionOf> </owl:Class> </rdfs:subClassOf> </owl:Class> which corresponds to the axiom C    R    A.
Finally, fuzziness in the individual axioms of f-DL-Lite is de ned by a restriction of the abstract syntax of facts of f-OWL DL presented in [26], since we are only allowing the inequality  .
The abstract syntax is the following:
 { type ( type  )  [ineqType] [degree]} {value [ineqType] [degree] }  )  ineqType ::=  >=  degree ::= real-number-between-0-and-1-inclusive Similarly, we can follow the RDF/XML serialization proposed in [26] to have fuzzy individual axioms in a f-DL-Lite  le.
For example, stating that o is Heavy to degree at-least
 <Heavy rdf:about="o" owlx:ineqType=" " owlx:degree="0.7"/> The full speci cation of the f-DL-Lite (and consequently DL-Lite) abstract syntax can be found in the Appendix.
The ONTOSEARCH2 system allows users to submit their crisp and fuzzy ontologies to its repository.
Furthermore, it provides an RDF/XML syntax checker for DL-Lite.
In this section, we present a general framework for representing expressive fuzzy queries over f-DL-Lite ontologies.
More precisely, we will introduce two query languages for f-DL-Lite ontologies.
The  rst language extends conjunctive queries with thresholds for atoms in queries.
Entailment of threshold queries generalises the entailment problem of fuzzy assertions.
The second language is a general fuzzy query language, motivated by the  eld of fuzzy information retrieval [8], where weighted Boolean queries have been proposed [33,
 could be represented under a general framework using general fuzzy operators, like t-norms and fuzzy implications.
Our general fuzzy query language extends these results by allowing more fuzzy operators and thus generalising many of the recent approaches like the query language proposed in [29] for fuzzy DL-Lite, weighted t-norm queries [7], which in turn generalise weighted min queries [23], p-norms [21], fuzzy aggregations [32] and the geometric mean [6].
In order to enable such types of queries in the Semantic Web, we also propose the extension of the SPARQL [19] query language, so as to represent the queries in our general framework.
In what follows, we  rst introduce these new query languages, providing their syntax and semantics.
We then present the extension of SPARQL, and  nally we provide algorithms of query answering for queries in the proposed query languages.
As noted in [5] in DL-Lite the instance checking problem is a special case of conjunctive queries.
Since f-DL-Lite extends DL-Lite with fuzzy assertions, it would be natural to de ne a query language so that the entailment of such queries could generalise entailment checking of fuzzy assertions.
Accordingly, we de ne conjunctive threshold queries (CTQ) which extend atoms A(v), R(v1, v2) in conjunctive queries of the form (1) into the following forms A(v)   t1, R(v1, v2)   t2, where t1, t2   (0, 1] are thresholds.
It turns out that threshold queries are very important types of queries since in [13] the authors used them in order to devise a reasoning algorithm for the fuzzy language fuzzy-CARIN.
Example 1.
We can query models who are tall with a degree no less than 0.7 and light with a degree no less than 0.8 with the following conjunctive threshold query: q(v)   Model(v)   1, Tall(v)   0.7, Light(v)   0.8.
It is obvious that threshold queries are more  exible than queries of the form (1) in that users can specify di erent thresholds for di erent atoms in their queries.
Formally, given an f-DL-Lite ontology O, a conjunctive threshold query qT and an evaluation [X 7  S], we say O entails qT (denoted as O |= qT ) if every interpretation I of O satis es the following condition: for each atom A(v)   t1 (R(v1, v2)   t2) of qT , we have AI (v)X 7 S   t1 (resp.
RI(v1, v2)X 7 S   t2).
In this case, S is called a solution of qT .
A disjunctive threshold query (DTQ) is a set of conjunctive threshold queries sharing the same head.
Since f-DL-Lite associates assertions with degrees of truth, another useful feature for its query language is to associate degrees of truth with answers in answer sets of queries over f-DL-Lite ontologies.
In threshold queries, an evaluation [X 7  S] either satis es the query entailment or not; hence, answers of such queries are crisp.
In this subsection, we introduce general fuzzy queries which allow fuzzy answers.
Syntactically, like the query language proposed in [33] and threshold queries, general fuzzy conjunctive queries (GFCQ) extend the atoms A(v), R(v1, v2) of conjunctive queries of the form (1) into ones with the following form A(v) : k1, R(v1, v2) : k2, where k1, k2   (0, 1] are degrees.
.
The strength of the general fuzzy query language is the openness of the use of fuzzy operations.
Indeed, as many theoretical and practical studies [32, 4] have pointed out, the choice of fuzzy operations is usually context dependent.
Following the style of the semantics of fuzzy-SWRL [17] the existential quanti er is interpreted as sup, while we leave the semantics of the conjunction (G) and that of the degree-associated atoms (a) open.
To simplify the presentation of the semantics, we use a uni ed representation atomi( v) for atoms in general fuzzy conjunctive queries.
Given an f-DL-Lite ontology O, an interpretation I of O, a general fuzzy conjunctive query qF and an evaluation [X 7  S], the degree of truth of qF under I is d = sup
 {Gn i=1 a(ki, atomI i ( v)[X 7 S,Y 7 S  ])} where ki   (0, 1] are degrees ( 1   i   n), atomi are atoms in the query, G is the semantic function for conjunctions and a is the semantic function for degree-associated atoms.
S : d is called a candidate solution of qF .
When d > 0, S : d is called a solution of qF .
Furthermore, the semantic functions should satisfy the following condition: If atomI i ( v)[X 7 S,Y 7 S  ]) = 0 for all possible S  , d = 0.
(2) A general fuzzy disjunctive query (GFDQ) is a set of general fuzzy conjunctive queries sharing the same head.
The disjunction is interpreted as the s-norm (u) of disjuncts.
In what follows, we give some examples of the semantic functions for conjunctions and degree-associated atoms.
semantic function for conjunctions and R-implications ( t) [11] as the semantic function for degree-associated
 degree of truth of qF under I is d = sup
 {tn i=1  t(ki, atomI i ( v)[X 7 S,Y 7 S  ])}.
Given some S  , if for all atoms we have atomI i ( v)[X 7 S, Y 7 S  ]   ki, since  t(x, y) = 1 when y   x [11], we have d = 1; this corresponds to threshold queries introduced earlier.
On the other hand, di erent from threshold queries, if 0 < atomI i ( v)[X 7 S,Y 7 S  ] < ki, then d 6= 0 because of use of the R-implication which  lters (pe-nalises) the degree atomI i ( v)[X 7 S,Y 7 S  ] against the fuzzy threshold ki.
As it was shown in [4] many of the approaches for weighted Boolean queries that have been proposed [3, 20] are actually special cases of fuzzy threshold queries.
of the fuzzy threshold query language, where all ki = 1.
Since  t(1, y) = y [11], the degree of truth of qF under I is d = sup
 {tn i=1 atomI i ( v)[X 7 S,Y 7 S  ]}.
functions [11], such as G(x) = P n P n
 , for conjunctions and a(ki, y) = ki   y as the semantic function for degree-associated atoms, we get fuzzy aggregation queries, in which the degree of truth of qF under I is i=1 xi i=1 ki d = S  I  I Pn sup i=1 ki   atomI i ( v)[X 7 S,Y 7 S  ] .
i=1 ki Pn Moreover, we can show that many existing approaches of weighted Boolean queries could be represented under the framework of fuzzy aggregation queries.
More precisely, Salton, Fox and Wu [21] proposed the model of p-norms where the semantic function is given by the following equation: d = S  I  I Pn sup i=1 (atomI i ( v)[X 7 S,Y 7 S  ])w n !1/w where w1 = w2 = .
.
.
= wn = w and w   (0, + ].
On the other hand, S.J.
Chen and S.M.
Chen [6] propose the geometric mean [11] as a semantic function for weighted Boolean queries: d = sup S  I  I n Yi=1 atomI i ( v)[X 7 S,Y 7 S  ]!1/w .
Under the framework of fuzzy aggregation functions both these equations are special cases of the generalized mean function which is given by the equation dw = (cid:17)1/w i=1 aw i (cid:16)P n n where w   R .
If w   (0, + ] then we have the approach of Salton et.
al.
[21], while if w   0, then function d converges to the geometric mean [11].
weighted t-norms [7] as the semantic function for conjunction, we get fuzzy weighted queries, in which the degree of truth of qF under I is d = sup
 n { min i=1 u(k ki, t(k, atomI i ( v)[X 7 S,Y 7 S  ]))}, where k = maxn i=1 ki.
The main idea of this type of queries is that they provide an aggregation type of operation, on the other hand an entry with a low value for a low-weighted criterion should not be critically penalized.
Moreover, lowering the weight of a criterion in the query should not lead to a decrease of the relevance score, which should mainly be determined by the high-weighted criteria (see [7] for more details).
Yager [34], proposes the use of and S-implication [11] (in contrast to R-implications of fuzzy threshold queries), i.e. the function: d = sup
 n { min i=1 u(1 ki, atomI i ( v)[X 7 S,Y 7 S  ])}, This is a special case of fuzzy weighted t-norms, where k = 1, since t(1, a) = a.
A similar approach was proposed by Sanchez [23].
It is easy to show that all the above four speci c fuzzy query languages satisfy the condition (2).
After presenting the abstract syntax and semantics of our proposed languages, in this section, we show how to extend the syntax of SPARQL [19], a well known Semantic Web query language, for the proposed languages.
We call our extension f-SPARQL.
SPARQL is a query language (candidate recommendation from the W3C Data Access Working Group) for getting information from RDF graphs.
SPARQL allows for a query to constitute of triple patterns, conjunctions, disjunctions and optional patterns.
A SPARQL query is a quadruple Q = (V, P, DS, SM ), where V is a result form, P is a graph pattern, DS a data set and SM a set of solution modi ers.
Among others, SPARQL allows for select queries, formed in a SELECT-FROM-WHERE manner.
The result form represents the set of variables appearing in the SELECT, the dataset forms the FROM part, constituted by a set of IRIs of RDF documents, while the graph pattern forms the WHERE part which is constituted by a set of RDF triples.
Query ::= Prologue ( SelectQuery | ConstructQuery | DescribeQuery | AskQuery ) SelectQuery
 (Var+ |  * ) DatasetClause* WhereClause SolutionModi er WhereClause GroupGraphPattern ::=  {  TriplesBlock?
( ( GraphPatternNotTriples ::=  WHERE  ?
GroupGraphPattern | Filter )  .  ?
TriplesBlock?
)*  }  In order to maintain backward compatibility with existing SPARQL tools, we propose to use specially formatted SPARQL comments to specify extra information needed in our proposed languages (see Table 2).
Firstly, one should declare the query type before a select query.
For example, #TQ# declares a threshold query, while #GFCQ:SEM=FUZZY THRESHOLD# declares a general fuzzy query, with the fuzzy threshold semantic functions.
Secondly, following each triple in the WHERE clause, one can use #TH# (resp.
#DG#) to specify a threshold in a threshold query (resp.
a degree in
 ::= Prologue ( QueryType SelectQuery | ConstructQuery | DescribeQuery | AskQuery ) TriplesBlock QueryType FuzzySemantics ::= TriplesSameSubject (  .  TripleWeight Degree TriplesBlock?
)?
::=  #TQ# \n  |  #GFCQ:SEM=  FuzzySemantics  # \n 

 TripleWeight degree
 ::= real-number-between-0-and-1-upper-inclusive Table 2: Syntax of Fuzzy SPARQL a general fuzzy query).
For instance, the threshold query presented in Example 1 (Section 3.1) can be represented by the following f-SPARQL query:
 SELECT ?x WHERE { ?x rdf:type Model .
?x rdf:type Tall .
?x rdf:type Light .
} In the case of general fuzzy queries, one must specify the semantic functions (i.e. a and G).
Below is an example fuzzy threshold query.
SELECT ?x WHERE { ?x rdf:type Model .
?x rdf:type Tall .
?x rdf:type Light .
} Table 2 presents the f-SPARQL syntax.
f-SPARQL extends two of SPARQL s elements, namely the  Query  and the  TriplesBlock  element.
As illustrated above, each select query is extended with the element QueryType.
In particular, for general fuzzy queries, the declaration  #GFCQ:SEM=  is followed by the element FuzzySemantics, which is used to specify the semantic functions, such as the ones we presented in the previous section.
More precisely, we use the keywords  FUZZYTHRESHOLD ,  FUZZYTHRESHOLD-
 AGGREGATION  and  FUZZYWEIGHTEDNORMS  to indicate the four fuzzy general queries we introduced in Section 3.1.2.
When one uses  FUZZYTHRESHOLD-1 , the fuzzy threshold is set as 1, and the values speci ed by the #TH# comments are ignored.
Finally, the  TriplesBlock  element is extended with the elements TripleWeight and Degree, which are used to associated a threshold or weight with each triple of the SPARQL query.
It should be noted that the query languages in the previous sections can be used with any fuzzy ontology languages.
In order to provide e cient query answering services using our proposed query languages, we choose f-DL-Lite as our fuzzy ontology language.
This subsection provides algorithm to answer threshold queries and general fuzzy queries over f-DL-Lite ontologies.
Algorithms for answering queries in f-DL-Lite mainly consist of four steps (like the algorithm for crisp DL-Lite [5]): (i) normalisation of the set T of the class axioms of O by the procedure Normalise(T ), which returns the normalised set T   of class axioms; (ii) normalisation and storage of the set A of individual axioms in O by the procedure Store(A) that normalise A and returns the relational database DB(A) of A, as well as checking the consistency of O by the procedure Consistency(O, T  ); (iii) reformulation of the input query q against the normalised set T of the class axioms by the procedure PerfectRef(q, T  ), which returns a set Q of (conjunctive) queries; (iv) transformation of the set Q of (conjunctive) queries into SQL queries by the procedure SQL(Q), as well as the evaluation of SQL(Q) by the procedure Eval(SQL(Q), DB(A)).
As steps (i) and (ii) are very similar to those for the crisp case, here we focus on steps (iii) and (iv) on answering conjunctive threshold queries and general fuzzy queries.
Given an f-DL-Lite ontology O, a conjunctive threshold query qT , the procedure AnswerT(O, qT ) computes the solutions of qT w.r.t.
O, following the above steps (i) - (iv).
Algorithm A-1: AnswerT(O, qT )



 axioms return inconsistent //O is inconsistent

 7: end if
 Algorithm A-2: SQLT(Q)





 sc:=Select-Clause(q) //construct the select-clause of q fc:=From-Clause(q) //construct the from-clause of q wc1:=WC-Binding(q) //construct the part of the where-clause about binding wc2:=WC-Threshold(q) //construct the part of the where-clause that relates to thresholds QS := QS   Construct-SQL(sc,fc,wc1,wc2)

 8: end for
 The algorithms need some explanations.
Firstly, if O is inconsistent, query answering is meaningless, since every tuple is a solution of every query w.r.t.
O.
Secondly, the procedure PerfectRefT(qT ,T  ) of reformulating an input conjunctive threshold query qT (into a set of conjunctive queries) is essentially the same as the PerfectRef (q,T  ) for DL-Lite [5].
Here we do not repeat PerfectRef(q,T  ) but explain its main ideas instead.
PerfectRefT(qT ,T  ) rewrites atoms in qT based on positive inclusions (PIs) in T  .
For example, given a PI B   B1, if B1(v)   k is an atom of
 the form  R ), B1(v)   k can be rewritten as A(v)   k (resp.
R(v, )   k, or R( , v)   k, where represent non-distinguished non-shared variables5).
The generated query can be further written, based on the PIs in T  .
It can be shown that such rewriting process always terminates [5], and it produces a set of generated conjunctive queries from the input query qT Q.
Thirdly, the procedure SQLT(Q) transforms a set of conjunctive threshold queries into SQL queries in an obvious way, taking into accounts the thresholds.
Namely, it use Select-Clause, From-Clause, WC-Binding and WC-Threshold to construct the select-clauses, from-clauses and where-clauses of SQL queries, respectively.
Due to limitation of space, we do not provide full details of these procedures but illustrate them with the following example.
Given the query q(v)   Model(v)   1, Tall(v)   0.7, Light(v)   0.8, Select-Clause(q) returns the select-clause  SELECT tabModel[0] , From-Clause(q) returns the from-clause  FROM tabModel, tabTall, tabLight , WC-Binding(q) returns the binding part of the where-clause  WHERE tabModel[0] = tabTall[0], tabModel[0] = tabLight[0]  and WC-Threshold(q) returns the threshold-related part of the where-clause  tabModel[1]   1, tabTall[1]   0.7, tabLight[1]   0.8 .
Construct-SQL puts all these together and returns the corresponding SQL query  SELECT tabModel[0] FROM tabModel, tabTall, tabLight WHERE tabModel[0] = tabTall[0], tabModel[0] = tabLight[0], tabModel[1]   1, tabTall[1]   0.7, tabLight[1]   0.8 .
Theorem 1.
Let O be an f-DL-Lite ontology, qT a conjunctive threshold query and S a tuple of constants.
S is a solution of qT w.r.t.
O i  S   AnswerT(O, qT ).
Proof: (Sketch) The proof of correctness is straight forward.
The procedure AnswerT di ers from that of DL-Lite mainly in that it needs to take care of the thresholds (line 6 of Algorithm A-2) when constructing SQL queries.
Given an evaluation [X 7  S] an atom A(v)   t1 (R(v1, v2)   t2), if tabA[X7 S][1]   t1 (resp.
tabR[X7 S][2]   t2), then we have AI (v)[X 7 S]   t1 (resp.
RI(v1, v2)[X 7 S]   t2).
The proof for the other direction is similar.
Similarly, given an f-DL-Lite ontology O, a general fuzzy conjunctive query qF , the procedure AnswerF(O, qF ) computes the solutions of qF w.r.t.
O.
Algorithm A-3: AnswerF(O, qF , a, G)



 axioms return inconsistent //O is inconsistent

 7: end if
 moving the degrees from qF
 Algorithm A-4: Cal(qF , SS, a, G)



 of the query for more than once.
AN S := AN S  Cal-Soln(qF , S, a, G) //Calculate the solution S : d based on the semantic functions a and G 4: end for
 The main tasks of AnswerF are (i) to look for candidate solutions in which the degree is larger than 0, and then (ii) to calculate the precise degree.
The task (i) can be performed by the DL-Lite query engine, since in the crisp case, the degree is either 0 or 1 (larger than 0).
In other words, the DL-Lite procedures Eval, SQL, PerfectRef can be reused here (line 9 of Algorithm A-3).
The task (ii) is done by the procedure Cal, which is a general algorithm to calculate the degree of each tuple S in the answer set SS returned by the DL-Lite engine, based on the chosen semantic functions a and G. Accordingly, we have the following theorem.
Theorem 2.
Let O be an f-DL-Lite ontology, qF a general fuzzy conjunctive query and S : d a pair of a tuple of constants together with a truth degree, a a semantic function for conjunctions and G a semantic function for degree-associated atoms.
S : d is a solution of qF w.r.t.
O i  (S : d)   AnswerF(O, qF ,a,G).
Our implementation is based on the ONTOSEARCH2 sys-tem6 [16, 31], which is an infrastructure for supporting ontology searching and query answering.
The f-DL-Lite query engine is implemented as an extension of the crisp DL-Lite query engine in ONTOSEARCH2 [15], so as to support threshold queries and general fuzzy queries.
The core part of the f-DL-Lite query engine includes implementations of Algorithms A-1 to A-4, which are presented in Section 3.3.
The system was written in Java 5 and uses PostgreSQL
 setup with default installation, no additional con guration was performed.
Users of the f-DL-Lite query engine can submit f-DL-Lite ontologies via the Web interface of ONTOSEARCH26, and then submit f-SPARQL queries against their target ontolo-gies.
The fuzzy query engine operates in two modes: TQ mode (for threshold queries) and GFCQ mode (for general fuzzy queries).
When users submit an f-SPARQL query, the fuzzy query engine parses it, so as to determine the query type (whether the query is a threshold query or a general fuzzy query), as well as the thresholds (for threshold queries) or degrees (for general fuzzy queries), depending on the query types.
Accordingly, the fuzzy query engine operates in either TQ mode (Algorithms A-1 and A2) or GFCQ mode (Algorithms A-3 and A-4).
Besides the DL-Lite query engine and the f-DL-Lite query engine, the ONTOSEARCH2 system consists of other components, such as the ontology search engine.
In Section 5, we will show how the ontology search engine uses the f-DL-Lite query engine to perform keyword-plus-entailment searches.
In this section, we present some preliminary evaluation of the f-DL-Lite query engine presented in Section 4.1.
We will  rst discuss the benchmark that we used in the evaluation, and then present the the evaluation results.
6http://www.ontosearch.org/
 for query answering over fuzzy ontologies that we could use to evaluate our f-DL-Lite query engine.
Accordingly, we propose a fuzzy variant of the well known Lehigh University Benchmark (LUBM), called f-LUBM, which is the  rst of its kind and against which future implementation of f-DL-Lite query engines can also be evaluated.
f-LUBM allows the use of fuzzy classes and restricts the expressive power of the underlying ontology to that of f-DL-Lite.
More precisely, we added two fuzzy classes to the LUBM University ontology, namely  Busy  and  Famous .
The former one is determined by the number of courses taught or taken by a member of sta  or student, while the latter one is determined by the number of papers published.
The values are calculated using the s-shaped curve functions kf (n) to calculate the fuzzy value for fame given n papers published, and kb(n) to calculate the fuzzy value for busyness given n courses taken: kf (n) =
 1+exp( 0.1n)   1, kb(n) =
 1+exp( 0.4n)   1 Based on the above two fuzzy classes, 4 extra queries are introduced to f-LUBM (there are 14 queries in LUBM).
The  rst two are simple queries that ask for famous ones.
f-LUBM-Q15(v)   Famous(v)   0.5 f-LUBM-Q16(v)   Famous(v) : 0.5 f-LUBM-15 is a threshold query, while f-LUBM-16 is a general fuzzy query.
The other two queries ask for all busy students which were taught by famous members of sta .
f-LUBM-Q17 (v1)   Student(v1), Buzy(v1)   0.5, Faculty(v2), f-LUBM-Q18 (v1)   Student(v1), Buzy(v1) : 0.5, Faculty(v2), Famous(v2)   0.5, teacherOf (v2, v3), takesCourse(v1, v3) Famous(v2) : 0.5, teacherOf (v2, v3), takesCourse(v1, v3) Like in LUBM, it is possible to create arbitrarily large datasets for individual axioms, generated by a Java program in f-LUBM (http://www.csd.abdn.ac.uk/ sttaylor/f-LUBM.zip).
To test the f-DL-Lite query engine, we created datasets containing 1, 10 and 50 universities, with the largest data set (for 50 universities) containing 6,888,642 individuals.
We used fuzzy aggregation queries as representatives for GFCQs in our test.
In order to investigate the overhead of fuzzy queries, we compare the performance in the f-DL-Lite query engine with the DL-Lite query engine, which is used to answer the following two crisp queries.
crisp-1(v)   Famous(v) crisp-2(v1)   Student(v1), Buzy(v1), Faculty(v2), Famous(v2), teacherOf (v2, v3), takesCourse(v1, v3) The results are shown in Table 3.
The  rst column lists the queries used in the test.
The second (resp.
third and fourth) column show the time (in millisecond) needed to answer the queries for 1 university (resp.
10 and 50 universities).
In general, the evaluations match nicely with our expectation: crisp queries are faster than CTQs as the system needs to take care of more joins due to the thresholds, while CTQs are faster than GFCQs as the former ones do not require post-processing to calculate the degrees.
Furthermore, it is encouraging to see that the performance of the fuzzy query engine is in most cases close to the performance of the crisp query engine.
With the smallest data Table 3: Results of some f-LUBM queries Query T [1] (ms) T [10] (ms) T [50] (ms) f-LUBM-Q15 (TQ) f-LUBM-Q16 (GFCQ) crisp-1 f-LUBM-Q17 (TQ) f-LUBM-Q18 (GFCQ) crisp-2

















 set, it is has almost identical performance, particularly on the more complex queries.
As more data must be evaluated, the performance drops slightly.
For the largest data set (containing 6,888,642 individuals), it only took the f-DL-Lite query engine (up to) a few seconds to answer each of the tested queries.
This section presents an online application6, the ontology search engine in the ONTOSEARCH2 system, of the f-DL-Lite query engine presented in Section 4.
One of the major limitations of existing ontology search engines is that searching is only based on keywords and metadata information of ontologies, rather than semantic entailments of ontologies (e.g., one wants to search for ontologies in which BassClarinet is a subclass of Woodwind).
On the other hand, searching only based on semantic entailments might not be ideal either, as synonyms appearing in the metadata could not be exploited.
By making use of the f-DL-Lite query engine, our ontology search engine supports keyword-plus-entailment searches, such as searching for ontologies in which class X is a subclass of class Y, and class X is associated with the keywords  Bass  and  Clarinet , while class Y is associated with the keyword  Woodwind .
The search could be represented as the following threshold query:






 ?x hasKeyword i-bass .
#TH# 0.6 ?x hasKeyword i-clarinet .
#TH# 0.6 ?x rdfs:subClassOf ?y .
?y hasKeyword i-woodwind .
#TH# 0.7} where i-bass, i-clarinet and i-woodwind are representative individuals for keywords  Bass ,  Clarinet  and Woodwind , resp.
The thresholds 0.6 and 0.7 can be speci ed by users.
In order to support keyword-plus-entailment searches, our ontology search engine, for each indexed ontology, stores its semantic approximation (in DL-Lite) [15] and accompanies each ontology in its repository with an f-DL-Lite meta-ontology, which (i) materialises all TBox reasoning based on the semantic approximation and, most importantly, (ii) uses fuzzy assertions to represent associations of each class (property) and keywords7 appearing in the metadata of the ontology, with some degrees.
Keywords appearing in the ontology metadata are associated with scores based on ranking factors8.
We use these scores to calculate the tf   idf [22] for
 sentative individuals.
8http://www.seomoz.org/article/search-ranking-factors
 such as the one shown in (3) to a degree between 0 and 1.
