Data reuse and integration is the basic idea behind the Semantic Web e ort.
However, the extremely large and highly distributed setting of the Web makes reuse and integration a di cult task.
Although the basic technologies of the semantic web (URIs to denote things, shared ontologies) are well suited for a distributed environment, data reuse and integration today usually takes place in centralized settings.
For example, the book mashup1 and DBPedia2 connect various sets of semantic data.
Although both services are based on semantic web technologies and use freely available data, integration is done by replicating all data to a single repository and connecting data sources using procedural code.
The semantic web su ers from a lack of user generated content and from a lack of services to kick-start wide adoption.
One of the reasons for these de ciencies is a missing mechanism for easy, distributed data reuse and integration: As we are talking about quite large datasets in the examples listed above, already the necessary infrastructure for holding the resulting amounts of data keeps many people from o ering such services.
In order to encourage people to build new services based on existing data, a more  exible and distributed mechanism is needed.
There are two main approaches to data reuse on the semantic web: replication plus procedural code and rule languages.
Procedural code is harder to exchange than declarative rules and its semantics is implicit.
Replication leads to problems with 1. staleness, as data is frequently updated, 2. scalability, as (combinations of multiple) large datasets can not easily be handled, 3. access rights, as not all data will be available for copy ing and 4. information exchange, as information sources are con nected through programs having implicit semantics, which can not be transferred easily (Webservers do usually not provide the software used along with the content they deliver.
).
Rule languages such as the Semantic Web Rule Language SWRL [10], N3 [3] and the upcoming Rule Interchange For-1http://sites.wiwiss.fu-berlin.de/suhl/bizer/bookmashup/ 2http://dbpedia.org/
 ative way.
However, they work best in a centralized setting, because apart from N3, none of them allows users to specify where the data to reason on comes from and which dataset the result should belong to.
Additionally, these languages are unfamiliar for people without a background in logics   and most people using semantic web technologies now and in the future can be assumed not to have such a background.
Finally, they have not been designed to gracefully handle recursion and negation in a dynamic environment like the web.
As we will see in our use case, these properties are already desirable for simple scenarios.
We propose Networked Graphs as a declarative mechanism to de ne RDF graphs both extensionally, by listing statements, and intensionally using views on other graphs.
SPARQL and a small syntactic extension to RDF are used to de ne views.
The proposed mechanism is very powerful and  exible, as it allows one to use almost all of the expressiveness of SPARQL CONSTRUCT queries, including negation, and   when used inside Networked Graphs   recursive views.
Networked Graphs are designed to be evaluated in a distributed setting and are easily exchangeable.
Users of Networked Graphs do not need to learn a new rule language, but can use the standard language SPARQL   which we expect to be widely adopted soon.
Contribution In this paper we de ne a syntactic extension to RDF which allows for expressing views in RDF graphs in a declarative way in section 4.
We de ne the semantics of NGs through an extension of the SPARQL semantics in section 5.
We describe a prototypical implementation in section 6 and  -nally shortly discuss the complexity of reasoning with NGs is in section 7.
Foundations and extensions are illustrated using a running example.
We start our description in the following Section 2 with a use case from which we derive requirements, and which serves as a running example in the remainder of the paper.
We introducw existing formalisms in Section 3.
In the following we use  NG  to abbreviate  Networked Graph .
Mike is project manager of a new semantic web research project.
As with most new projects, he needs to build a project website containing information about the people working in the project.
We talk about a Semantic Web project, so all information shall be available in RDF.
All project members are Semantic Web enthusiasts and provide information about themselves in their personal foaf3  les on the web.
Mike would like to avoid replicating this information.
He also does not want to have to update the project website, whenever one of the members changes her personal information.
Mike thinks a view mechanism for RDF would be ideal to extract the information he needs.
Reusing Information.
Mike s  rst task is to build a page containing contact information of all project members.
He sets up a graph mikesProject.
He de nes a view feeding into mikesProject based on the foaf  les of the project members.
It imports names, email addresses, phone numbers and employers of all people working in the project.
Importing third-party data.
After a couple of months, Mike is asked to include all publications done within the project to mikesProject.
All project members work full time for the project.
Therefore Mike can assume that all their publications done during the lifetime of the project are relevant.
He adds a view based on the DBLP RDF map-ping4, including all publications by project members listed in mikesProject within the time period of 2007-2009.
Whenever anything relevant is newly published, it will be included in the project website automatically.
Negation.
Mike thinks, it will be nice, if the project acknowledges all those authors who have contributed to publications done in the project, but who do not work in the project themselves.
He sets up a new view, adding acknowl-edgements to all those authors of papers, which have creators from the project, but where the persons acknowledged are not listed as project members in mikesProject.
Mike uses the Semantic Web query language SPARQL, which allows to formalize this rule using negation by failure.
Recursion.
Bob works in the project.
He  nds the information on the project website very useful.
As the project is rather small, he assumes he knows everybody in the project.
For this reason he adds a view to his foaf  le bobFOAF, which creates a foaf:knows relation between Bob and every person listed as a project member in mikesProject.
This results in a circular dependency between bobFOAF and mikesProject.
Exchange of NGs.
Mandy manages a similar project.
Today she is faced with the task of creating a new project website.
Mandy likes Mike s website a lot and would like to set up something similar.
Usually, her semantic web browser immediately computes all views.
She did not even notice that Mike uses them.
Today, however, she looks at mike-sProject with a text editor and sees all the view de nitions.
She replaces the datasets of the views such that the foaf  les of her own project s members are used.
After only  ve minutes of work she has created a rich project description in graph alicesProject.
Requirements We observe the following requirements from the presented use case:
 our use case, and/or through views on other graphs, like mikesProject of bobFOAF, which is a mixture of both.
tic Web, it is di cult to avoid circular dependencies among NGs, which therefore must be supported by the semantics.
in SPARQL and as used here for the de nition of ac-knowledgements.
include all and, hence, must be self-describing, i.e.
necessary view de nitions.
it should be based on existing Semantic Web building 3http://www.foaf-project.org/ 4http://www4.wiwiss.fu-berlin.de/dblp/
 isting RDF technology from working in the foreseen, standardized way.
Further Possibilities for Applications Apart from the rather simple use case we will use throughout this paper, we have recognized several other application areas, where NGs, will be extremely useful for describing rules, views and data integration.
Linking Dataspaces.
A new line of research in databases aims at creating and linking dataspaces [6], i.e. heterogeneous spaces of information, such as available in small databases and on PC desktops.
While the gist of this work is related to our objectives, they pursue their goals with idiosyncratic mechanisms rather than by standardized languages as we do with our minor extension of RDF and SPARQL towards NGs.
Distributed Rules for Policies.
Alves et al. propose a distributed, rule based policy mechanism [2].
Their language extends Prolog in a proprietary way.
Using NGs an elegant integration of the policy mechanism with the semantic web could be achieved.
Decentralized Data Integration.
DBPedia integrates various datasets, which are available in RDF.
Among others, links to the geonames ontology5 and to DBLP are included.
An aggregated dataset is published in irregular intervals.
This data could directly be integrated using networked graphs, immediately including changes from any of these datasets.
In this section we brie y describe existing foundations of NGs.
RDF is a graph based knowledge representation language.
The nodes in a graph are URIs, blank nodes (a kind of existentially quanti ed variables) or literals.
Arcs between the nodes, labeled with URIs, represent their relationships.
We simplify the RDF graph model [14] here slightly in order to come up with a more concise formal characterization.
Analogous to the SPARQL speci cation [4] we allow literals as subjects of statements.
Definition 1 (RDF Graph).
Let U be the set of URIs, L the set of RDF Literals and B the set of Blank Nodes as de ned in [14].
U, L and B are pairwise disjoint.
Let R = U   L   B.
A statement is a triple in R   U   R. If S = (s, p, o) is a statement, s is called the subject, p the predicate and o the object of S. An RDF graph G is a set of statements.
For every two RDF graphs G1 and G2 the sets of blank nodes used in G1 and in G2 are disjoint.
[14] de nes a model theoretic semantics for RDF graphs and the RDF Schema Language RDFS.
RDFS includes, for example, transitivity of class subsumption, the instanceOf relationship and others.
We refer the reader to [14] for a detailed description of RDF and the RDF Schema language
 5http://www.geonames.org/
 While the RDF recommendation does not allow referring to whole RDF graphs, named graphs introduced in [11] o er means to group a set of statements in a graph and to refer to this graph using a URI.
This way information about the graph can be expressed in RDF using its name as a subject or object: Definition 2 (Named Graph).
A named graph is a pair (n, G) of a URI n, called the name, and an RDF graph G, called the extension.
The following example illustrates the triple structure of RDF and the concept of named graphs using Trig notation6 The statements in a named graph are listed in curly brackets, prepended by the name of the graph.
Due to space constraints we will use abbreviated URIs without names-paces.
Example 1.
:DBLP {:NGPaper dc:creator :Alice.
:NGPaper dc:creator :Bob. }
:bobFOAF { :bobFOAF foaf:primaryTopic :Bob :Bob :K-Space foaf:fundedBy :Bob foaf:phone foaf:name foaf:currentProject :K-Space.
:Bob.
"Bob"^^xsd:String.
"+49-261-287-2868".}
:MikesProject { :SemWebProj foaf:name "Networked Graphs".}
SPARQL is a query language for RDF based on graph pattern matching, which is de ned in [4].
In this paper we are only interested in SPARQL CONSTRUCT queries.
A CONSTRUCT query matches a graph pattern against one or more input graphs.
The resulting variable bindings are embedded into a graph template in order to generate new RDF data.
To further restrict the bindings produced by pattern matching,  lter expressions can be used, for example to check for (in-)equality of variables, datatypes of literals etc.
A SPARQL query is evaluated against a dataset consisting of a set of named graphs (declared using FROM NAMED clauses) and a default graph, which is the union of one or more named graphs (declared using FROM clauses).
A query returning foaf:currentProject triples for all persons with some foaf document in the dataset is shown in example 2.
It selects all persons from all foaf  les Mike uses to built mikesProject.
Additionally, their phone numbers are included, if available.
Example 2.
CONSTRUCT {?member foaf:currentProject ?project.
?member foaf:phone ?phone} FROM NAMED :bobFOAF FROM NAMED :chrisFOAF FROM NAMED...
GRAPH ?foafFile { ?foafFile foaf:primaryTopic ?member OPTIONAL { ?member foaf:phone ?phone } } } SPARQL can be used to model negation by failure using a combination of OPTIONAL graph patterns and the BOUND  lter, which checks whether a variable has been bound during graph pattern matching.
We will call such a construct in a query bound negation.
Example 3 illustrates

 members, whom Mike wants to thank for contributing to papers.
In this query we  rst  nd all coauthors of project members.
We then try to  nd an (optional) foaf:current-Project relation between the project and the coauthors.
If this fails (i.e. the coauthor is not a project member), the variable ?x is left unbound, and the  lter expression at the end of the query succeeds.
The obtained variable bindings are embedded in the CONSTRUCT template to add an ac-knowledgement to the co-author7.
Example 3.
CONSTRUCT {:SemWebProject :acknowledges ?author}
 FROM NAMED :mikesProject

 ?paper dc:creator ?author.
?paper dc:creator ?member }.
GRAPH :mikesProject { ?member foaf:currentProject :SemWebProject OPTIONAL { ?x foaf:currentProject :SemWebProject FILTER (?x = ?author) } FILTER (!BOUND(?x)) } }


 We propose NGs to ful l the requirements listed in section 2 by extending the technologies listed in the previous sec tion.
To address requirement (1) on expressing RDF graphs by extensional and intensional means, we extend RDF with a SPARQL based view mechanism.
To support exchange-ability and backwards compatibility (requirements 4 and 5), we de ne a syntax based on named graphs.
By this extension it becomes possible to de ne the meaning of such a network of graphs by the way they reference each other.
To deal with negation and cycles (requirements 2 and 3), we adapt a suitable semantics from logic programming in section 5 and explain how it can be computed in a distributed setting in section 6.
In this section we start by de ning NGs using an abstract syntax, before we introduce the RDF and SPARQL based syntax for NGs.
In the previous section we have seen how SPARQL can be used to express a single view in a dataset.
What is still missing is a link between the view de nition and the graph, which shall include the view.
This link is given be NGs: A NG is a quadruple GW = (n, G, GW graph,  GW
   is a list of NGs and v is a mapping where n is a URI called the name of the NG, G is an RDF (Networked Graph).
Definition 3

 n from a list of NGs to an RDF graph called the view de ni-tion of GW .
n We de ne a function deref to access the contents of a NG given a NG de nition.
deref carries out dereferencing
 user.
As negation is available in SPARQL, it should be available in an easily understandable way   unlike it is speci ed today.
We do not target at new language constructs for negation in SPARQL here, but we must still show how to deal with the existing speci cation.
Thereby, negation adds substantially to the complexity of the formalism.
A future improvement of SPARQL in this direction would be bene -cial for the syntactic clarity of Networked Graphs.
of NGs as a logical operation, i.e. given a NG it computes the content of the NG.
This logical operation is opposed to dereferencing as an addressing operation, i.e. given a URI, accessing the corresponding  le or SPARQL endpoint.
In contrast to named graphs, NGs are not necessarily listed in a single  le or at a single endpoint, as parts of them are inferred.
In Section 5 we will describe, how deref can be computed for a set of NGs.
Let V = (n, G, GW Definition 4   , v) be a NG.
(deref).
n into a set of statements, i.e. a graph: Then deref is a function mapping from networked graphs deref(GW ) = G   v(deref(GW
 n )) From these de nitions it is clear, that named graphs are a special case of NGs with GW = (n, G, [], ).
In our use case scenario, the graph mikesProject could be formalized as follows: Example 4.
Let bobFOAF, chrisFOAF and DBLP be NGs.
Then mike-sProject is a NG: mikesProject = (:mikesProject, {(:SemWebProj foaf:name "Networked Graphs")}, [bobFOAF, chrisFOAF, DBLP, mikesProject], v), with v(bobFOAF, chrisFOAF, DBLP, mikesProject) = {(:Bob foaf:currentProject :SemWebProject), (:Bob foaf:phone "+49-261-287-2868"), (:Chris foaf:currentProject :SemWebProject), (:SemWebProject :acknowledges :Alice)} For reasons of simplicity, we will use the name of a NG interchangeably with the NG itself.
From the context it will be clear, whether the name or the NG is meant.
Networked Graphs We now provide an RDF syntax for NGs based on named graphs for the extensional de nitions and SPARQL for the intensional de nitions.
Definition 5 (Networked Graphs Syntax).
n ], v) is de ned in a named A NG GW = (n,G,[GW graph with name n and extension G. The view de nition is included in statements of the form:

 n g:definedBy <query>.8 where <query> is a literal containing a CONSTRUCT query.
The datatype of <query> is g:query.
We call <query> a sub-query of v. We call such a statement a view de nition statement.
In general, a named graph may contain a number m of such view de nition statements.
The overall view is then de ned by v(GW n ), where vi is the evaluation function of the i-th subquery.
vi(GW mS n ) = i=1 definedBy statements are intended to carry two meanings.
First, there is the extensional meaning that the statements exists.
Second, there is the intensional meaning, i.e.
the evaluation of the view it de nes.
The second meaning will only be incurred, if the graph in which a definedBy statement occurs is identical with the subject of this statement.
Existing machinery for working with named graphs can be used for serialization and exchange of NGs.
A non NG aware repository can still interpret the extensionally
 http://isweb.uni-koblenz.de/ontologies/2006/11/ng# the NG vocabulary we propose
 ity.
Using this syntax, the de nitions of bobFOAF and mike-sProject are listed in example 5.
In both cases, a named graph holds the extensions introduced in example 1 and the view de nitions.
In bobFOAF, foaf:knows relations are created from Bob to all project members listed in mikesProject, except for Bob himself.
mikesProject contains view de ni-tions encoded in three queries.
The  rst one adds project members and their phone numbers, if available.
The second one analogously imports publications from DBLP, so we only sketch it here.
The third one adds acknowledge-ments to all authors listed in DBLP, such that one of their publications has an author, who is listed as project member in mikesProject, but the acknowledged person herself is not a project member, as explained in example 3.
Example 5.
:bobFOAF { :bobFOAF foaf:primaryTopic :Bob :Bob :K-Space foaf:fundedBy foaf:phone :Bob :bobFOAF g:definedBy foaf:name foaf:currentProject :K-Space.
:Bob.
"Bob"^^xsd:String.
"+49-261-287-2868".
"CONSTRUCT {:Bob foaf:knows ?person} FROM :mikesProject WHERE { ?person foaf:currentProject :SemWebProject FILTER (?person != :Bob) }"^^g:query.
} } :mikesProject { :SemWebProj foaf:name "Networked Graphs".
:mikesProject g:definedBy "CONSTRUCT {?member foaf:currentProject ?project.
?member foaf:phone ?phone} FROM NAMED :bobFOAF WHERE { GRAPH ?foafFile { FROM NAMED :chrisFOAF ...
?foafFile foaf:primaryTopic ?member OPTIONAL {?member foaf:phone ?phone}}}"^^g:query.
:mikesProject g:definedBy :mikesProject g:definedBy "CONSTRUCT {?paper dc:creator ?author}..."^^g:query.
"CONSTRUCT {:SemWebProject :acknowledges ?author}
 FROM NAMED :mikesProject
 GRAPH :DBLP { ?paper dc:creator ?author.
?paper dc:creator ?member}.
GRAPH :mikesProject { ?member foaf:currentProject :SemWebProject OPTIONAL { ?x foaf:currentProject :SemWebProject FILTER (?x = ?author) } FILTER (!BOUND(?x)) } }"^^g:query.
Figure 1: An Interdependence Set Figure 1 illustrates the interdependencies of NGs resulting from the de nitions in example 5.
We call such a set of interdependent graphs an interdependence set.
We now revisit the requirements from our use case to discuss requirements on the NGs semantics.
Afterwards we give an overview of the semantics.
A detailed de nition is given in the appendix.
For the understanding of the detailed semantics, some knowledge of the SPARQL algebra [4] and of the well founded semantics for logic programs [20] is required.
Unfortunately we do not have enough space to repeat the these foundations in detail here.
As we have pointed out when describing the use case, we envision NGs to be a mechanism used by a broad range of agents on the semantic web to recombine RDF data.
In this environment, it is not possible to pose restrictions on the use of NGs (requirement 2), for example to ensure hierarchical dependencies between NGs or strati ed use of negation (i.e.
no view using negation directly or indirectly depends on itself).
Cyclic De nitions of Networked Graphs.
A scenario that may lead to problems with naive interpretations is given when you assume that Mikes assistant Anna persuades all acknowledged authors to join the project.
She adds a view to mikesProject saying that everybody acknowledged has :SemWebProject as a foaf:currentProject.
Now obviously nothing can be inferred about acknowledged authors anymore, because they are only acknowledged if they are not members of the project.
However, we still want to have contact information and literature of everybody else available on the website, as they are not a ected by this contradiction.
The semantics of NGs must be able to handle such mutual dependencies via negated premises.
SPARQL, Rules and Logic Programs.
Networked Graphs are quite similar to logic programs.
In fact we show how SPARQL can be mapped to acyclic Datalog with negation in [17].
Independently, Polleres de nes a mapping to logic programs under the stable model semantics [16].
We de ne the semantics of NGs analogously to a  xpoint semantics for logic programs.
From a high level point of view we treat SPARQL CONSTRUCT queries as rules with negation.
While the encapsulation of SPARQL algebra expressions into a  xpoint semantics may seem a bit complicated at  rst, it has two clear advantages: First, it allows for using existing SPARQL endpoints.
Second, NGs can automatically bene t from future extensions of SPARQL such as aggregates or user de ned  lter functions.
RDF Schema.
SPARQL de nes entailment regimes under which a query can be evaluated.
The standard entailment regime is simple RDF entailment.
However, more complex regimes like RDFS are possible, the only requirement being monotonicity of the entailment regime.
Using a more complex entailment regime, NGs can be evaluated taking RDFS into account, without additional extensions to NGs.
(Note that NGs are expressive enough to alternatively model the RDFS inference rules as view de nitions.)
Sirin and Par-sia propose an entailment regime for a subset of SPARQL, which can be used to query OWL ontologies taking into account OWL DL semantics [5].
Using such an entailment regime could even bring the power of OWL to a subset of NGs.
Interaction with OWL, however, would need a detailed investigation of the resulting combined language.
In the following we assume a basic RDF entailment regime.
worked Graphs We address the requirements on the semantics, especially
 adapting the well founded semantics (WFS) for logic programs [20] to NGs.
In this section we describe the core idea of the WFS.
Details are given in the appendix.
Fixpoint Model for Well-founded Semantics.
The WFS is based on a three valued logic with truth values of true, false and unknown.
It assigns truth values of true and false to as many facts as possible.
For facts, where such an assignment is not possible, the truth value assigned is unknown.
This is the case for non-strati able negation as sketched above.
The WFS treats true and false facts symmetrically, and is de ned using the  xpoint of a direct consequence operator T , which we brie y explain in the following paragraphs.
The WFS for NGs assumes all extensionally listed statements and everything we can follow from these statements without using bound negation to be true and by assuming all statements in the so called greatest unfounded set to be false.
To explain the unfounded set, we need the notion of ground instantiated views.
A view is ground instantiated by replacing every variable in the view with an element of the set of RDF Resources R. Hence, the statement patterns in a ground instantiated view do not contain variables any more.
We say an optional statement used in bound negation like (?x foaf:currentProject :SemWebProject) in example 3 is matched negatively.
All other statements are matched positively.
A statement S is in an unfounded set U, if for all ground instantiated views v with S in the CONSTRUCT pattern one of the following holds: (1) All negatively matched statements in v are known to be true or (2) Some positively matched statement in v is known to be false or (3) Some positively matched statement in v is in U.
The greatest unfounded set is the union of all unfounded sets.
The third condition applies to mutually dependent ground instantiated views, where none of the views can be established to be true or false  rst.
The sets of true and false statements are extended itera-tively by computing the direct consequences of the known true and false statements until a  xpoint is reached.
The direct true consequences are statements in the CONSTRUCT patterns of ground instantiated views, which match the known true and false statements from the previous iteration.
A new unfounded set based on the knowledge from the previous iteration is determined.
All statements in the new unfounded set are direct false consequences.
Statements that are not assigned a value of true or false, when the  xpoint is reached, are assigned a truth value of unknown statements.
We de ne the semantics of a NG GW , deref (GW ), as the set of true statements in the graph when reaching the  xpoint.
Example.
In our example, after Anna has added her new view, all ground instantiations of this new view together with the view de ning the acknowledgements form an unfounded set: every statement of the form (:semWebProject :acknowledges sbd) negatively depends on a statement of the form (sbd foaf:currentProject :SemWebProject), which in turn depends on the  rst statement.
Hence, no statements about acknowledged authors are inferred.
However, all views, which are not directly a ected, are not in uenced by the contradiction, because the statements they generate are not part of an unfounded set.
Procedural Semantics.
Obviously it is di cult to work with all possible ground instantiated statements and to guess an unfounded set, because of combinatorial explosion and non-determinism.
A procedural semantics is available, however, which we shortly explain in the next section.
and test are data We have implemented a NG reasoner as an extension for the Sesame 2 RDF repository.
Implementation, public prototype at http://isweb.uni-koblenz.de/Research/NetworkedGraphs.
available The implementation uses a variation of the alternating  xpoint algorithm for computing the WFS [7], which does not require to guess an unfounded set.
The algorithm is initiated with true statements in an interdependence set.
It then alternates between an overestimation of the set of true, inferred statements and an underestimation of this set.
Eventually, this alternation converges to the set of true statements in the interdependency set.
In some more details, the procedure starts with the true statements, which are extensionally listed, or which can be derived from views, which do not use negation.
We call this underestimate U1.
Statements in U1 are known to be true.
U1 is used to compute an overestimate O1 by evaluating all views against this set of true statements.
The result will be an overestimate, because U1 was still incomplete and therefore bound negation will succeed in too many cases.
O1 represents the set of potentially true statements.
We do not know for every statement in O1, whether it really is true, but at least it is not de nitely false.
Now we compute a new underestimate, using O1 to match negatively matched statements and U1 to match all positively matched statements.
The result U2 is an underestimate of true statements that is larger than U1.
When after some iterations we come up with the same under and overestimates as in the previous iteration, a  x-point has been reached.
The underestimate then equals the true statements under the WFS, i.e. it represents the semantics of the interdependence set.
The algorithm is combined with tabling to reduce the amount of redundant work.
Tabling means we save intermediary results during the iterative computation, instead of recomputing them when needed.
Apart from saving redundant work, this also reduces network tra c during distributed evaluation.
Additionally, we apply heuristics to  lter out irrelevant parts of interdependence sets.
NGs evaluation takes place at query time in the current prototype.
Initial Experiments First tests have shown that the prototype works well with medium sized datasets of up to 200,000 statements.
Queries against sets of 20 to 60 NGs with 20 to 60 views could be answered within 3 to 120 seconds (depending on the size and complexity of the problem) on a 2GHz Pentium M. A scenario like our use case can be evaluated in three iterations.
To improve scaleability, we will improve integration with the Sesame query engine and the pruning of the search space in future work.
Every view, together with its table of interim results and some status information used for the detection of cycles, is represented as a single  QueryNode  object.
This allows to distribute NG reasoning by distributing QueryNodes to the
 between QueryNodes is done using the existing SPARQL protocol, with small extensions for control data.
The extensions are threefold: First, when involving multiple endpoints in NG evaluation, we need to detect and avoid cycles.
Hence, we extend the SPARQL query protocol with a list of queryIDs.
Whenever a QueryNode forwards a query to evaluate some view, it generates a new queryID and appends it to the list.
Upon receiving a query, a QueryNode compares the list of queryIDs in the query message with the list of the queryIDs it has generated itself.
If a cycle is detected, subsequent queries are not forwarded to other peers.
The received query is only evaluated on local data and the result is returned.
Using this extension, an iteration of the alternating  xpoint procedure is started by a single QueryNode and triggered on other nodes in a tree shaped hierarchy.
After every iteration, every QueryNode updates its table of results.
Only new results are returned to other nodes.
Second, through indirect dependencies it may happen that the same QueryNode is triggered twice in the same iteration.
To avoid duplicate work or errors in the tables, each queryID is augmented by an iteration number.
If an already computed combination of queryID and iteration number is received, the query is answered from the local table.
Finally, the query result message is extended with a  ag signalling that the answering node considers the evaluation of its view done   either because all views it depends on are also done, or because it is the root of a subtree of the QueryNode network, for which a  xpoint has been reached.
This last extension is only used to improve performance, as it can save the last iteration of the alternating  xpoint algorithm.
The  xpoint could also be detected by the node which started the evaluation.
The protocol is de ned as an extension to the SPARQL protocol speci cation9 and available from the implementation webpage.
As the mechanism is based on existing standards, it allows the usage of existing SPARQL endpoints when de ning NGs.
When dealing with non NG aware repositories, one may fall back to standard SPARQL.
We brie y investigate the data complexity of NG evaluation.
The data complexity is de ned as the complexity of computing a model for a variable extensional knowledge base given a  xed query.
Data complexity is of particular interest here, as usually the view de nitions are short compared to the knowledge base.
Further we expect view de nitions to be rather stable, while the extensionally de ned statements might frequently change.
If blank nodes are created in the CONSTRUCT patterns of views and these views are used recursively, evaluating NGs becomes undecidable in general.
In this case, we could have in nitely many ground instances of statement patterns.
For this reason we limit the discussion to NGs without blank node creation.
Theorem 1.
The data complexity of NG evaluation without blank node creation is quadratic in the size of the NGs in the interdependence set.
If negation is not used in recursive view de nitions, we can give a tighter bound:
 Theorem 2.
The data complexity of NG evaluation without value creation and with strati able negation is linear in the size of the NGs in the interdependence set.
The combined complexity is the complexity of computing a model for both variable queries and knowledge bases.
Theorem 3.
The combined complexity of NG evaluation without value creation is in EXPTIME.
All proofs are based on mappings to fragments of logic programming and their well known complexity.
Proofs for theorems 1 and 2 and can be found in [18].
The proof of theorem 3 is derived from the facts that NGs can be mapped to datalog with well founded negation [18], which has EX-PTIME combined complexity (implicit in [20]).
NGs creating blank nodes correspond to logic programs with function symbols, which are undecidable in general under the WFS.
Related work comes from several areas, especially from rules and views for the semantic web.
OWL Contextualization.
For the Web Ontology Language OWL, which is based on RDF, declarative approaches for import and contextualisaton have been proposed: owl:imports is a mechanism for OWL which includes a whole OWL  le in another one.
It is a rather coarse mechanism, not  exible enough for the use case presented here.
COWL [13] is an extension of OWL with local contexts connected with bridge rules.
COWL aims at translations between local contexts, not at reuse of RDF/OWL data.
Rules to deal with (variations of) named graphs.
Approaches for dealing with RDF graphs with either a declarative or a procedural semantics include the following: Stoermer et al. use named graphs plus semantic extensions of RDF to implement a system using modal logic for statements in RDF graphs [8].
The RDF semantics is extended, such that statements are only true in the context of a graph called a context.
Between these graphs compatibility relations can be de ned and inferred.
The focus lies on describing relationships among graphs.
Reuse of RDF data, for example by importing statements, is not possible.
The NEPOMUK Representation Language NRL [19] is used in the context of a Social Semantic Desktop to allow for a kind of views and to apply various di erent semantics to RDF graphs.
NRL allows for various ways to specify  views , which are de ned with a procedural semantics in contrast to the declarative semantics of NGs.
Applied in a heterogeneous and distributed web environment, we expect problems with this procedural semantics, because implications will become hard to understand.
N3Logic [3] is a rule language built around RDF.
Its expressive power is comparable to NGs for positive rules.
Only a weaker form of negation is supported by N3Logic.
N3Logic de nes several builtins, e.g.
cryptographic functions, which are not available in NGs, but could be modeled using user de ned  lter functions in SPARQL.
An advantage of NGs in our opinion is its foundation on SPARQL   both to save users the e ort of learning a new language and to directly bene t from SPARQL implementations and extensions.
Views.
[21] and [12] propose declarative view mechanisms for RDF.
They can be used to de ne  virtual  classes, properties and instances based on graph patterns.
RDFS semantics is employed to ensure that necessary class relations are also included in the view.
The purpose is to provide a view
 graph contents based on other graphs.
These classical views are not oriented towards reuse and exchange of views across the borders of single RDF repositories.
Semantic Web Pipes10 can be used to de ne RDF documents as views on other documents.
An XML syntax is used and cyclic dependencies are not supported.
Semantic Web Pipes are designed rather as a web service than as a declarative mechanism.
ActiveXML Abiteboul et al. describe ActiveXML documents [1], which represent a concept very similar to NGs, but based on XML.
ActiveXML documents may contain inten-sional subtrees de ned through web service calls or XPath queries.
The semantics of ActiveXML documents is also de ned using a  xpoint, but unlike NGs, ActiveXML documents are in nite in general.
In contrast to ActiveXML, NGs support a powerful kind of negation.
While NGs can support various entailment regimes through the use of SPARQL, ActiveXML documents have weaker semantics based on XML.
We have introduced Networked Graphs as a means for describing RDF graphs that are partially derived from other graphs using a declarative view mechanism.
We base Networked Graphs on work on SPARQL and Named Graphs.
Extensions allow for recursive view de nitions, i.e. a kind of rules, and easy exchange of self describing Networked Graphs.
Thus, Networked Graphs allow for de ning, exchanging and executing SPARQL rules, SPARQL views and RDF data integration in a decentralized fashion.
We have shown that the complexity of our extension allows for use at web scale, especially if negation is used carefully.
Thus, we propose a mechanism for easy information reuse and recombination and have ful lled the requirements derived from our running use case   which is just one of the many cases that will bene t from dynamic networking between RDF graphs.
