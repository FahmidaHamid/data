Integrating and reusing Semantic Web data becomes more and more fruitful and worthwhile in order to answer questions and deliver results.
Typically, engines like Swoogle provide points of access for RDF data, crawlers may fetch relevant RDF data, and Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
query languages like SPARQL with their corresponding query engines allow for selecting and reusing data in the appropriate format.
With the arrival of more and more data in the Semantic Web and more sophisticated processing through query and reasoning engines, one now, however, encounters challenging questions linked to meta knowledge about the data like:   Where is this data from?
  Who provided the data?
  When was this data provided?
  Was the provider certain about the truth of this data?
  Was the data believed by others, too?
For instance, when querying the Semantic Web with the help of SPARQL for the a liation of a person named of  James Hendler , one  nds (at least) two answers, i.e.  University of Maryland  and  Rensselaer Polytechnic Institute .
Without further indication as to where, by whom, when, etc.
such information was given, it is impossible to decide which of the two a liations is still valid.
The problem might be remedied in several ways.
First, an ideosyn-cratic solution by the search engine, such as returning the corresponding RDF  les or links to sources of knowledge extraction (say http://www.cs.umd.edu/survey.pdf and http://www.rpi.
edu/report.doc), might help in this special case.
However, an ideosyncratic solution may not be appropriate in a second case in which the  when  was more relevant than the  where  or in a third case where such a piece of information had to be aggregated from several resources.
Second, the person or system requesting the meta knowledge might manually extend the SPARQL query formalizing the request for the a liation in order to return the where, the who and the when.
Such a modi cation will, however, be very tedious, as it will include a number of additional optional statements, and expressing it manually will be error prone.
Also, it will not help in delivering meta knowledge that arises from joining several statements, e.g.
meta knowledge about uncertainty that was based on several meta knowledge statements with di erent values of uncertainty.
Therefore, querying Semantic Web data requires a principled, generic approach to the treatment of meta knowledge that is able to adapt to many dimensions of meta knowledge and that is open to accommodate to new dimensions when the need arises.
Such a principled, original framework is given in this paper.
We start to
 in section 2.
We model meta knowledge in existing RDF structures by embedding a slightly more expressive language, which we call RDF+, into RDF1.
We de ne the abstract syntax of RDF+, its semantics and its embedding in RDF in Section 4.
In Section 5, we extend the SPARQL syntax and semantics to work on data and meta knowledge of RDF+.
The extension allows the user to extend a given conventional SPARQL query by a keyword for meta knowledge triggering the construction of meta knowledge by the query processor.
Section 6 summarizes the overall use and processing of SPARQL queries with meta knowledge.
Section 7 reports on initial graceful results for meta knowledge processing from a theoretic point of view and Section 8 provides pointers to the prototype implementation of the system.
In our sample application scenario, we assume that the user utilizes knowledge which has been initially extracted from Web pages of Computer Science departments and stored in form of RDF triples in his personal  active space" [16], backed by a local RDF repository.
Example 2.1 shows the relevant facts that may have been obtained from departments of di erent universities.
For better readability, we use for our examples in this paper the RDF triple language TriG [1] with Named Graphs [2] in a simpli ed form that abstracts from default namespaces.
Example 2.1.
Extracted Knowledge and SPARQL query G1 { JamesHendler researchTopic SemanticWeb .
JamesHendler affiliatedWith RensselaerPI } G2 { JamesHendler researchTopic Robotics .
JamesHendler affiliatedWith UnivMaryland .
RudiStuder researchTopic SemanticWeb .
RudiStuder affiliatedWith UnivKarlsruhe } The extracted knowledge comes from di erent sources, at di er-ent timepoints, and with di erent degrees of extraction con dence.
This information is also captured and stored into the same RDF repository as shown in example 2.2, using the notion of Named RDF Graphs [2, 5].
Example 2.2.
Associated meta knowledge G3 { G1 mk:source <www.rpi.edu/report.doc> .
G1 mk:certainty "0.9" .
G1 mk:timestamp "5/5/2007" } G4 { G2 mk:source <www.cs.umd.edu/survey.pdf> .
G2 mk:certainty "0.6" .
G2 mk:timestamp "6/6/2001" } In our scenario, the sample user aims to explore the knowledge and meta knowledge using the RDF query language SPARQL.
We assume that he aims to  nd experts in the domain of Semantic Web and their a liations.
The corresponding SPARQL query is shown in example 2.3.
In addition, the user wants to exploit meta knowledge from example 2.2 for obtaining results with best certainty and for analyzing contradictive answers (e.g.
di erent a liations for the same person  James Hendler  in example 2.1).
jor revisions include a novel formal model, discussion of the design space, complexity analysis, and prototype implementation.
Example 2.3.
Extracted Knowledge and SPARQL query CONSTRUCT {?x worksAt ?z}

 WHERE { GRAPH ?g {?x affiliatedWith ?z .
?x researchTopic SemanticWeb} }

 This section summarizes and shortly motivates the design choices for our meta knowledge framework.
Rei cation.
Establishing relationships between knowledge and meta knowledge requires appropriate rei cation mechanisms for supporting statements about statements.
Our general objective is to execute queries on original data (i.e. without meta knowledge) directly, without complex transformations.
For compliance with existing applications that access the repository in a common way (e.g.
using SPARQL queries), we do not modify existing user data.
This requirement does not allow us to use mechanisms like RDF rei cation, which decompose existing triples and fully change the representational model.
In our framework described in section 4, we adopt the notion of Named RDF Graphs for meta knowledge representation [2, 5].
Storage mechanisms.
Following the overall philosophy of RDF, we do not separate meta knowledge from  normal  user knowledge in the repository.
Following this paradigm, a user or developer has unlimited access to all contents of the triple store and can manipulate meta knowledge directly.
In other words, the user can directly access meta knowledge (e.g.
using suitable SPARQL queries).
Beyond explicitly designed queries for meta knowledge access, in Section 5 we describe the extension of SPARQL that allows us to access meta knowledge about the result set automatically without user intervention.
Dimensions of Meta Knowledge.
An important point for the application design is the de nition of relevant meta knowledge properties and their suitable interpretation for arbitrary complex query patterns.
In general, these properties are application dependent and must be carefully chosen by the system administrator.
In our scenario (sections 2 and 6) we discuss common and widely used properties, such as timestamp, source, and (un)certainty, and show ways of de ning and utilizing them in our framework.
Syntax extensions.
Seamlessly integrated access to meta knowledge requires corresponding extensions of existing querying mechanisms.
These can be realized at di erent levels, for instance at the level of query languages (e.g.
SPARQL) or at the level of applica-tion-speci c interfaces (e.g.
Sesame API).
In Section 5 we describe our SPARQL extension for constructing query results with associated meta knowledge.
It is system-independent and not related to some particular implementation of the RDF repository.
Furthermore, it fully supports the existing SPARQL syntax and semantics.
Compliance with existing established standards makes the integration with existing applications and interfaces substantially easier.
In the course of representing and reasoning with meta knowledge we embed a language with meta knowledge reasoning, i.e.
RDF+, in a language without such speci c facilities, i.e. in RDF.
This embedding implies that we may consider an RDF snippet in
 knowledge statement.
Embedding meta knowledge in RDF is not the most expressive means to deal with all needs of meta knowledge processing, but it retains upward compatibility with existing usage of the language and corresponding tools and methods, which is a major concern for Semantic Web approaches.
Though we denote meta knowledge in RDF, we must distinguish the notation of RDF with only implicit notation of meta knowledge, but no semantic consequences speci cally due to this meta knowledge, from a formally extended model of RDF with explicit notation of meta knowledge.
The following de nition of RDF+ helps us to draw this line very clearly and concisely.
The abstract syntax for this embedded language, RDF+, is given in Section 4.1 and its semantics in Section 4.2.
Eventually in this section, we show how to embed RDF+ in RDF with named graphs.
The abstract syntax of RDF+ is based on the same building blocks as RDF:   U are Uniform Resource Identi ers (URIs).
  L are all RDF literals.
  G   U is the set of graph names.
  P   U is the set of properties.
In addition, we must be able to refer to statements directly without use of rei cation.
For this purpose, we introduce statement identi- ers:     is a set of statement identi ers, which is disjoint from U and L.
Now, we may de ne RDF+ literal statements that are placed in named graphs and have, in addition to RDF, a globally unique statement identity.
Definition 4.1 (RDF+ Literal Statements).
The set of all RDF+ literal statements, S, is de ned as quintuples by: S := {(g, s, p, o,  ) | g   G, s   U, p   P, o   U   L,      }.
Thereby,   and (g, s, p, o) are keys such that there exists a bijec-tion f1 with f1(g, s, p, o) =     f4( ) := f  1( ) = (g, s, p, o).
Moreover, we de ne the overloaded function f5 to return the complete quintuple given either   or (g, s, p, o), i.e. f5( ) := (g, s, p, o,  ) =: f5(g, s, p, o), when f1(g, s, p, o) =  .
The reader may note that we assume that f1 is  xed and given before any statement is de ned.
Furthermore, this de nition of literal statements and the rest of this paper abstracts from RDF blank nodes in order to keep the formalization more concise.
However, we do not see any conceptual problem in extending our treatments to blank notes, too.
The two statements of Graph G1 of Example 2.1 may now be represented in RDF+ in the following way.
Example 4.1.
(G1, JamesHendler, researchTopic, SemanticWeb,  1), (G1, JamesHendler, affiliatedWith, RensselaerPI,  2) } Thereby, the exact form of statement identi ers in   is up to the implementation, as they are only used for internal processing.
Having represented the literal interpretation of RDF statements in RDF+, we may now address the representation of selected RDF statements as RDF+ meta knowledge.
This is done using a structure of RDF+ meta knowledge statements, M, that is separate from the set of RDF+ literal statements: Definition 4.2 (RDF+ Meta Knowledge Statements).
Let     P be the set of meta knowledge properties.
Let  , with      , be sets providing possible value ranges for the meta knowledge properties      .
Then, the set of all RDF+ meta knowledge statements, M, is de- ned by: M := {( ,  ,  ) |      ,      ,      )}.
The following example partially demonstrates the target representation of the  rst two meta knowledge statements of graph G3 from Example 2.2.
Example 4.2.
( 1, mk:source, {<www.rpi.edu/report.doc>}), ( 1, mk:certainty, 0.9)} Together we may now de ne a RDF+ theory.
Definition 4.3 (RDF+ Theory).
A RDF+ theory of literal statements and associated meta knowledge statements is a pair (K, M) referring to a set of literal statements K   S and a set of meta knowledge statements M   M.
A (partial) example for such a theory is given by the pair (K, M) with de nitions for K and M as given in examples 4.1 and 4.2, respectively.
We now have an abstract syntax for representing RDF triples like JamesHendler researchTopic SemanticWeb as part of G1 and meta knowledge statements like the source of the statement that James Hendler s research topic is Semantic Web is found in the document <www.rpi.edu/report.doc>.
However, such an abstract syntax may remain remarkably ambiguous if it cannot be linked to a formal semantics.
Assume two meta knowledge statements: ( 1, mk:source, {<www.rpi.edu/draftReport.doc>}) and ( 1, mk:source,{<www.rpi.edu/finalReport.doc>}) for the same literal statement identi ed by  1, the question may arise whether this means a disjunction, i.e. one of the two documents has provided the fact, or a conjunction, i.e. both documents have provided the fact, or a collective reading, i.e. the two documents together gave rise to the fact, or whether this situation constitutes invalid meta knowledge.
In order to prevent such ambiguities we introduce a generic semantic framework for meta knowledge in RDF+.
However, the framework must also be able to reproduce the literal interpretations found in RDF.
For the latter purpose, we  rst de ne a  standard  model for a RDF+ theory.
Definition 4.4 A standard interpretation Is : S   {(cid:8), } for a structure (K, M) assigns truth values to all statements2 in K.
(Standard Interpretation and Model).
A standard interpretation is a standard model if and only if it makes all statements in K become true.
there (g, s, p, o,  1), (g, s, p, o,  2), where  1 (cid:2)  2.
standard interpretation is independent of the identi ers  1,  2.
because  xed that f1 is no are This implies that two tuples the
 include (G1, JamesHendler, researchTopic, SemanticWeb,  1) in its set of literal statements evaluating to (cid:8).
In order to address the level of meta knowledge we foresee an additional model layer that provides a di erent interpretation to each meta knowledge property.
Note that this step is necessary in order to achieve upward and   limited   downward compatibility between RDF+ and RDF.
The interpretation of statements, like the ones found in G3, also require an interpretation as meta knowledge.
This is achieved by mapping RDF statements with designated properties from   like mk:source and mk:certainty to the additional meta knowledge layer: ( Interpretation and Model).
Definition 4.5 A  interpretation I  : S (cid:5)   for a property       is a partial function mapping statements into the allowed value range of  .
A  interpretation I  is a  model for (K, M) if and only if for all meta knowledge statements ( ,  ,  )   M where f1( ) = (g, s, p, o) the value of the interpretation coincides with  , i.e. I ((g, s, p, o,  )) =  .
As an example, consider the certainty interpretation Icertainty of the literal statement (G1, JamesHendler, researchTopic, SemanticWeb,  1) from Examples 4.1 and 4.2.
A model I would map this literal statement using Icertainty onto 0.9.
The literal and the meta knowledge interpretations may now be combined to de ne what an overall, unambiguous model is: Definition 4.6 (meta knowledge Interpretation and Model).
A meta knowledge interpretation I is a set including a standard interpretation Is and the  interpretations I  for all meta knowledge properties      .
A meta knowledge interpretation I is a model for a theory (K, M) if and only if all its interpretations I   I are a standard model or  models for (K, M).
The mapping between RDF and RDF+ needs to be de ned in two directions.
First, one must be able to map from RDF as given in the examples from Section 2 to RDF+.
Second, one must be able to map from RDF+ to RDF.
Because RDF+ is more  ne-grained than RDF the  rst direction will be easy.
For the second a compromise on the granularity of the representation has to be made.
The examples of Section 2 reify groups of statements, i.e. the ones found in G1 and G2, in order to associate meta knowledge, such as given in G3 and G4.
In order to allow for an interpretation of the meta knowledge as de ned in the preceding section, we map RDF into RDF+.
For all RDF statements, including statements in graphs G1 and G2 of Example 2.1, the mapping performed is close to an identity mapping.
One only needs to add statement identi ers.
The result for G1 in RDF+ is: Example 4.3.
K   { (G1, JamesHendler, researchTopic, SemanticWeb,  1), (G1, JamesHendler, affiliatedWith, RensselaerPI,  2) }, with  1 := f1(G1, JamesHendler, researchTopic, SemanticWeb) and  2 := f1(G1, JamesHendler, affiliatedWith, RensselaerPI) The same mapping   close to the identity mapping   is performed for meta knowledge statements like statements of graph G3, resulting in their representation as literal statements: Example 4.4.
(G3, G1, mk:source, <www.rpi.edu/report.doc>,  3), (G3, G1, mk:certainty, "0.9",  4), ...} Example 4.5.
( 1, mk:certainty, "0.9"), ( 1, mk:source, {<www.rpi.edu/report.doc>}), .
.
.}
The mapping of predicates of these meta knowledge statements from RDF to RDF+ is obvious, they are mapped to itself.
Objects are mapped to the corresponding elements of the value ranges  .
For the subjects, however, there arise modeling choices.
For instance, if mk:certainty were interpreted using probability theory, one might assign a distributive or a collective reading.
In the distributive reading, each fact in G1 receives the probability value of 0.9 and, eventually, the distributive reading will assign a joint prob ability of close to 0 for a large number of n stochastically independent facts, i.e. the joint probability 0.9n.
In the collective reading, the collection of facts in G1 as a whole will receive the probability value 0.9.
Therefore, the collective reading will assign an individual certainty close to 1 for each individual fact, when the number   of facts is high and each fact is independent from the others, i.e.
the individual probability would be n
 two (and more) modeling choices is better than the other, but they constitute di erent modeling targets.
The mapping from RDF to RDF+ for the distributive reading of a meta property   is easy to achieve.
Definition 4.7 (Distributive Embedding).
Given an RDF statement  G {S P O}  and an RDF meta knowledge statement  H {G    } , a distributive embedding of RDF+ in RDF adds the meta knowledge statement {( ,  ,  ) |   = f1(G, s, p, o)   f5( )   K} to M.
This means that such a meta knowledge statement is applied individually to all statements in the graph to which it refers in RDF, as indicated in the example above.
For certain   there might be several RDF meta knowledge statements H {G    i} which attach di er-ent values  i to a graph G via a single meta knowledge property  .
In that case a set-valued range   has to be used in order to be consistent with De nition 4.5.
The serialization of RDF+ data in the knowledge base K is straightforward.
Each quintuple (g, s, p, o,  ) is realized as a corresponding triple in a named graph and the tuple identi er   is discarded.
Example 4.6.
(G5, JamesHendler, researchTopic, SemanticWeb,  ) is mapped to G5 {JamesHendler researchTopic SemanticWeb } For meta knowledge statements the situation is more challenging, because literal statements with di erent statement identi ers may belong to only one named graph.
Their corresponding meta knowledge statements may di er, but the realization of the meta knowledge statements in RDF does not allow for retaining these  ne-grained distinctions   unless one chooses to change the modeling approach drastically, e.g.
by assigning each literal statement
 sion in Section 3).
We have preferred to pursue a more conventional modeling strategy for RDF with named graphs.
Therefore, we weaken the association between meta knowledge statements and their corresponding literal statements when mapping to RDF.
I.e. we group sets of meta knowledge property values into one complex value.
Definition 4.8 (Generating Grouped meta knowledge).
Given an RDF+ theory (K, M), RDF meta knowledge is generated by grouping RDF+ meta knowledge statements as follows: Add the triple (g    (cid:11) := hashGraph(g) for each (cid:11) ) to the RDF graph g :=  1   .
.
.
   n ,  (cid:11) where ( ,  ,  i)   M   (g, S , P, O,  )   K. Further, hashGraph is a function mapping existing graph names onto graph names suitable for associating meta knowledge and   is an operation de ned on  .
If  (cid:11) in order to represent  (cid:11) .
The suitability of hashGraph may be application spe-ci c.
A general strategy may map graph names g to graph names pre xed by <http://metaknowledge.semanticweb.org> in a deterministic manner.
Operations on meta knowledge properties are discussed in section 5.2.
(cid:11) is set-valued then a set of triples is added to g compute and output all the meta knowledge statements deriveable by successful matches of RDF+ literal statements with the WHERE pattern.
In order to determine which literal statements should be considered we introduce a second modi cation.
We do not process FROM expressions with our meta knowledge framework, but only FROM NAMED.
The reason is that FROM g expressions replicate all RDF triples of g into the default triple space of the query.
Thereby, they remove the links between the RDF statements of g and possible meta knowledge.
Hence, FROM expressions are not relevant for our treatment of meta knowledge, but of course they may still be processed using the standard SPARQL semantics.
Thus, SPARQL queries on RDF+ have one of the two following overall forms: Definition 5.1 (SPARQL SELECT Query).
The structure of a SPARQL SELECT query has the following form: SELECT SelectExpression (WITH META MetaList)?
(FROM NAMED GraphName)+
 Definition 5.2 (SPARQL CONSTRUCT Query).
The structure of a SPARQL CONSTRUCT query has the following form: In the following example the grouping of meta knowledge values is illustrated.
Example 4.7.
CONSTRUCT ConstructExpression (WITH META MetaList)?
(FROM NAMED GraphName)+

 (G5, JamesHendler, researchTopic, SemanticWeb,  1), (G5, JamesHendler, affiliatedWith, UnivMaryland,  2) },
 ( 1, mk:source, {<www.rpi.edu/report.doc>}), ( 2, mk:source, {<www.cs.umd.edu/survey.pdf>}) } is mapped to G5 { JamesHendler researchTopic SemanticWeb .
JamesHendler affiliatedWith UnivMaryland } G6 { G5 mk:source <www.rpi.edu/report.doc>, <www.cs.umd.edu/survey.pdf>.}
In Example 4.7, the resulting grouped value is the set consisting of the two documents <report.doc> and <survey.pdf> which is represented by two triples.
For speci c meta knowledge properties, an additional function may be necessary to provide a mechanism for representing grouped values in an appropriate RDF data structure.
In this section we  rst introduce a small extension to standard SPARQL syntax [15] and then de ne how SPARQL can be applied to an RDF+ knowledge base.
The objective of our considerations is the derivation of meta knowledge about query results.
When using SPARQL to query RDF+ we propose only two mod-i cations to obtain meta knowledge.
First, we introduce one additional expression  WITH META MetaList .
This expression includes the named graphs speci ed in MetaList for treatment as meta knowledge.
This statement is optional.
When it is present the SPARQL processor may digest the RDF+ meta knowledge statements derivable from the RDF named graphs appearing in the Meta-List.
The SPARQL processor will then use this meta knowledge to In these de nitions, P refers to a graph pattern that explains how RDF+ literal statements from named graphs speci ed using FROM NAMED statements are matched.
Matches bind variables that are used for providing results according to the SelectExpression or the ConstructExpression.
In this subsection we de ne the semantics of SPARQL queries evaluated on an RDF+ theory.
For our de nitions we use two building blocks: algebraic semantics of SPARQL [11, 13] and the how-provenance calculated via annotated relations (cf.
[8]).
The algebraic semantics of SPARQL queries are given based on set-theoretic operations for sets of variable assignments (cf.
[11,
 U   L, where V is the set of variables given in a SPARQL query.
A set of variable assignments can be represented by a relation   over the domain (U   L) , where the variables V are the attributes and assignments are the tuples of this relation.
Such a set of assignments may be assigned information about the so called how-provenance [8], i.e. the assignments may be annotated with for-mulae describing the individual derivation tree used to assign the variables.
The how-provenance annotation may be represented by a function   : (U   L) is the set of all tuples of the length |V| over the domain U   L and F is the set of formulae annotating variable assignments.
The set of formulae F is given by all Boolean formulas constructed over the set of literal statements S and including a bottom element   and a top element (cid:8).
The formulae constitute an algebra (F, , , , ,(cid:8)).
The special element   is used as annotation of variable assignments which are not in the relation  .
The special element (cid:8) may be omitted, but it allows for simpli cation of complex formulas.
|V|   F, where (U   L)
 Assume the following SPARQL query to be evaluated on the RDF+ knowledge base K:
 SELECT ?g ?x ?y


 GRAPH ?g {?x researchTopic ?y} } Example 5.2.
(G1, JamesHendler,researchTopic,SemanticWeb,  1), (G1, JamesHendler,affiliatedWith,RensselaerPI,  2), (G2, JamesHendler,researchTopic,Robotics,  3), (G2, JamesHendler,affiliatedWith,UnivMaryland,  4), (G2, RudiStuder,researchTopic,SemanticWeb  5), (G2, RudiStuder,affiliatedWith,UnivKarlsruhe  6) } For the query of example 5.1, we may  nd the following variable assignments using standard SPARQL processing and we may indicate, which atomic formulae, i.e. RDF+ quintuples in this simple example, led to these variable assignments.
This indication is given by the statement identi ers representing their statements.
Example 5.3.
?g


 ?x JamesHendler JamesHendler RudiStuder ?y SemanticWeb Robotics SemanticWeb
  1  3  5 This simple example of how a set of variable bindings has been produced is generalized to SPARQL queries of arbitrary complexity by a recursive de nition of simultaneous query evaluation and computation of the annotations.
The  rst step in evaluating a graph pattern is to  nd matches for the triple pattern contained in the query.
Because the RDF+ knowledge base K consists of quintuples, we need to adapt the SPARQL evaluation procedures.
The statement identi ers do not need to be matched, as they depend functionally on graph name, subject, predicate and object.
Therefore, we consider matching of quadruple patterns ( ,  ,  ,  ).
As a simpli cation of our formalization we assume that the keyword GRAPH together with a URI or a graph variable is used in any given SPARQL query.
If it is not used, we may expand a given SPARQL query to include it.
Definition 5.3 (Basic Quadruple Pattern Matching).
Let K be a knowledge base of RDF+ literal statements and   be a variable assignment.
The evaluation of the SPARQL query  GRAPH   {     }  over K, denoted by [[GRAPH   {     }]]K is de ned by the annotated relation  , dom( ) = { | dom( ) = vars(GRAPH   {     })}, if r( , ( ,  ,  ,  )) = (g, s, p, o)  (g, s, p, o,  )   K   f1(g, s, p, o) =  ,  ( ) =       else where vars(P) denotes the variables contained in a pattern P and r( , ( ,  ,  ,  )) is the quadruple obtained by replacing the variables in ( ,  ,  ,  ) according to  .
An example for this de nition is given by evaluating the query from Example 5.1 on the dataset of Example 5.2 delivering the result as indicated in example 5.3.
Basic quadruple pattern matching is not directly applicable, if an expression  GRAPH   appears outside a complex triple pattern.
In such a case, we  rst need to distribute the expression  GRAPH   appropriately to atomic triple patterns in order to prescribe atomic SPARQL expressions accessible by basic quadruple pattern matching.
Because named graphs cannot be nested, this distribution is always possible and unambiguous.
In the following we use the function quads(P) to denote the query resulting from this transformation.
In example 5.4 this transformation is demonstrated on a conjunction of two triple patterns.
Example 5.4.
GRAPH ?src { { ?x researchTopic ?y .}
{ ?x affiliatedWith ?z .}
} quads(P1) = GRAPH ?src { ?x researchTopic ?y .}
GRAPH ?src { ?x affiliatedWith ?z .}
Now we de ne the evaluation of complex graph patterns by operations on sets of variable assignments similar to [11, 13].
Definition 5.4 (Complex graph pattern matching).
Let P1, P2 be complex graph patterns.
The evaluation of graph patterns over K, denoted by [[ ]]K, is de ned recursively:


 (a) [[P1 AND P2]]K = [[P1]]K  [[P2]]K, (b) [[P1 OPT P2]]K = [[P1]]K =(cid:11)(cid:12) [[P2]]K, (c) [[P1 UNION P2]]K = [[P1]]K   [[P2]]K,
 The de nition uses the operation AND.
In standard SPARQL the operation AND is denoted by the absence of an operator.
Like [11,
 encing to this operator.
The recursion in the SPARQL query evaluation de ned here is indeed identical to [11, 13].
Only the basic pattern matching has been changed slightly.
Basic pattern matching now considers quadruples and it annotates variable assignments from basic matches with atomic statements from S and variable assignments from complex matches with Boolean formulae F   F over S .
As an example, consider the query from Example 5.5 evaluated on the knowledge base from Example 5.2.
Example 5.5.
SELECT ?h1 ?h2 ?x ?y


 {GRAPH ?h1 {?x affiliatedWith ?y}} AND {GRAPH ?h2 {?x researchTopic SemanticWeb}} FILTER {?x=JamesHendler} } Let P be the graph pattern contained in the WHERE clause of the query.
Then the evaluation of P is de ned by an algebraic expression: [[P]]K = [[{P1 AND P2} FILTER {?x = JamesHendler}]]K =  ?x=JamesHendler([[P1 AND P2]]K) =  ?x=JamesHendler([[P1]]K  [[P2]]K) =  ?x=JamesHendler( 1   2)
 and their annotations.
In this example and in the preceding de ni-tion we have used algebraic operations on sets of annotated bindings.
However, we have not yet explained how these operations are used to construct formulas representing the how-provenance.
The following de nition will specify how complex formulae from F, which serve as annotations for results of matching complex graph pattern, will be derived.
(cid:8) Definition 5.5 (Algebra of Annotated Relations).
Let  ,  1 and  2 be sets of annotated variable assignments.
We de ne ,  , \ and  , =(cid:11)(cid:12) via operations on the annotations of the assignments as following:  i,  2( i)(cid:2)   2( i) , where  x     ( 1   2)( ) =  1( 1)    2( 2), where  x   dom( 1)   dom( 2) :  1(x) =  2(x) and   =  1    2,   ( 1    2)( ) =  1( )    2( ),   ( 1 \  2)( ) =  1( )     (cid:6)(cid:7) dom( i)   dom( ) :  i(x) =  (x).
  ( c( ))( ) =  ( )   fc( ), where fc( ) denotes a function mapping   to either (cid:8) or   according the condition c.
  ( 1 =  2)( ) = ( 1   2)( )   ( 1 \  2)( ).
Let us now continue the evaluation of the query speci ed in Example 5.5.
In order to evaluate the expression  ?x=JamesHendler( 1   2) we need to determine  1 and  2 using de nition 5.3.
The intermediate result is shown in example 5.6.
To evaluate the conjunction of two quadruple patterns the operation  is applied, the result is shown in example 5.7.
The annotation  1    2 of the  rst row represents that this assignment has been derived from the conjunction of the two literal statements  1 and  2 (see example 5.2).
Application of the  operation to the intermediate results gives the annotated relation shown in example 5.8.
Example 5.6.
?x JamesHendler JamesHendler UnivMaryland RudiStuder UnivKarlsruhe ?y RensselaerPI ?h1




  2  4  6
 ?h2

 ?y JamesHendler RudiStuder
  1  5 Example 5.7.
?h1



 Example 5.8.
?h2


 ?x JamesHendler JamesHendler UnivMaryland UnivKarlsruhe RudiStuder ?y RensselaerPI
  1    2  1    4  5    6  ?x=JamesHendler( 1   2) = ?h1

 ?h2

 ?x JamesHendler JamesHendler UnivMaryland ?y RensselaerPI
 ( 1    2)   (cid:8) ( 1    4)   (cid:8) The annotations  ( ) can now be used to assign truth values for  .
Is (see de nition 4.4) assigns truth values to all atomic statements si   K   S. We extend the interpretation Is to capture all the Boolean formulae over statements S.
(Standard Interpretation of Formulae).
Definition 5.6 Let F, F1, F2   F be Boolean formulae over S, let Fa   S be an atomic formula.
We de ne the standard interpretation of formulae I f s as follows:   I f   I f   I f   I f s (Fa) := Is(Fa); s ( F) :=   if I f s (F1   F2) is (cid:8) if I f s (F1   F2) is (cid:8) if I f s (F) = (cid:8); I f s (F1) = I f s (F1) = (cid:8) or I f s ( F) := (cid:8) if I f s (F) =  ; s (F2) = (cid:8), otherwise   s (F2) = (cid:8), otherwise  .
s returns (cid:8) for the assignment shown in the  rst row For instance, I f of  1   2 from example 5.7, because the statements  1 and  2 are in the knowledge base.
Analogously to I f s , we can extend a  interpretation I  over RDF+ statements to a  interpretation I f   over formulae.
Remember that meta knowledge interpretations allow for only one   per       and       (De nition 4.5).
In order to make use of the how-provenance represented by the annotations we require that for each meta knowledge property   an algebra ( , , , ,(cid:8) , ) with three operations  , ,  and two special elements (cid:8) ,      is de ned.
The de nition of the algebras can be supplied by a modeler according to the intended semantics of the di erent meta knowledge properties.
Definition 5.7 Let F, F1, F2   F be Boolean formulae over S, let Fa   S be an atomic formula.
We de ne the interpretation I f ( Interpretation of Formulae).
  as follows:   I f   I f   I f   I f   (Fa) := I (Fa);   ( F) is  I f   (F);   (F1   F2) is I f   (F1)   I f   (F1)   I f   (F1   F2) is I f   (F2);   (F2); For illustration we consider in Example 5.9 the de nition of fuzzy logic operations to calculate a possibility measure on variable assignments, operations de ned on timestamps which calculate the time of the last modi cation, and set operations de ned for source documents that construct the combined provenance.
Example 5.9.
certainty(x2)) certainty(x2)) certainty(x1) certainty(x1), I f certainty(x1), I f certainty(x1   x2) = min(I f I f certainty(x1   x2) = max(I f I f certainty( x1) = 1   I f I f  certainty = [0, 1] time(x1   x2) = max(I f I f time(x1   x2) = min(I f I f time( x1) = 0 I f  time = [0, ) source(x1   x2) = I f I f source(x1   x2) = I f I f source( x1) = {} I f  source = 2D, D the set of document URIs source(x1)   I f source(x1)   I f time(x1), I f time(x1), I f time(x2)) time(x2)) source(x2) source(x2)
 LECT and CONSTRUCT, allow to specify how resulting variable bindings or RDF graphs, respectively, are formed based on the solutions from graph pattern matching [15].
Modi ers, e.g.
for projection and ordering, can be applied.
The evaluation of SPARQL queries on RDF+ data di ers in that meta knowledge is attached to the results.
The evaluation of SELECT queries on an RDF+ dataset is based on projectX([[P]]K), where X denotes the set of variables speci ed in the SelectExpression and project is de ned as following: Definition 5.8 (Projection).
Let   be a set of annotated variable assignments and X be a set of variables, then (projectX( ))( ) =   (cid:7)  x X: (x)= (x),  ( )(cid:2)   ( ), function de ned only on X,  , else if   is a partial If X forms a proper subset of the variables used in the graph pattern then the annotations of all bindings   are aggregated.
This aggregation is analog to the generation of grouped meta knowledge described in De nition 4.8.
As an example consider the query shown in Example 5.10, which is a slight modi cation of the query from Example 5.5, applied to the data shown in Example 5.2.
For the result see Example 5.11.
In contrast to Example 5.7 there is only one row for JamesHendler.
Example 5.10.
SELECT ?x



 {GRAPH ?h1 {?x affiliatedWith ?y}} AND {GRAPH ?h2 {?x researchTopic "SemanticWeb"}} } Example 5.11.
project{?x}( 1   2) = ?x JamesHendler RudiStuder
 ( 1    2)   ( 1    4)  5    6 The result of a SELECT query is a set of extended bindings.
Such an extended binding contains values for the speci ed variables and values for each meta knowledge property       which can be regarded as additional variables.
For each binding   these variables   are bound to I f   (projectX([[P]]K)( i)), see Example 5.12.
For this result the meta knowledge from Example 5.13 has been certainty(( 1    2)   ( 1    4)) = 0.9.
If no meta used.
For instance I f knowledge statement ( ,  ,  ) exists for a particular RDF+ literal statement f5( ) and a particular meta knowledge property   then   serves as default value.
For the result of a SELECT query all bindings from projectX([[P]]K) are extended in this way.
Example 5.12.
?x JamesHendler RudiStuder certainty

 time

 Example 5.13.
( 1, mk:certainty, 0.9), ( 1, mk:time, "5/5/2007"), ( 2, mk:certainty, 0.9), ( 2, mk:time, "5/5/2007"), ( 3, mk:certainty, 0.6), ( 3, mk:time, "6/6/2001"), ( 4, mk:certainty, 0.6), ( 4, mk:time, "6/6/2001"), ( 5, mk:certainty, 0.6), ( 5, mk:time, "6/6/2001"), ( 6, mk:certainty, 0.6), ( 6, mk:time, "6/6/2001")} Analogously to standard evaluation, the evaluation of a CONSTRUCT query on an RDF+ dataset results in a single RDF+ graph which is built using the graph template speci ed in the Construct-Expression (see De nition 5.2).
This is in line with the fact that the graph template consists of a conjunction of triple patterns and thus quadruple patterns cannot be stated.3 Similar to the evaluation of SELECT queries the evaluation of CONSTRUCT queries is based on projectX([[P]]K), where X denotes the set of variables speci ed in the ConstructExpression.
The RDF+ graph is constructed as described in the following: Let t j denote triple pattern j speci ed in the ConstructExpres-sion, P denote the graph pattern speci ed in the WHERE-clause, (si, j, pi, j, oi, j) denote the triple obtained by replacing the variables in t j according to a mapping  i and  g denote a new graph name.
Then, for each binding  i   projectX([[P]]K) and for each t j the quintuple ( g, si, j, pi, j, oi, j,  i, j) is added to S, where  i, j is the statement identi er f1( g, si, j, pi, j, oi, j).
Further ( i, j,  ,  i, j) is added to M, where  i, j = I f   (projectX([[P]]K)( i)).
Each new quintuple inherits the meta knowledge properties   associated with the binding which has been used to create that quintuple.
The value of  i, j is determined by applying I f   to the formula which annotates the binding.
Note that since projectX([[P]]K) and the interpretations I f   are functions and further the graph template in ConstructExpression is a set of triples the meta knowledge properties ( i, j,  ,  i, j) are unique for a given  i, j.
As an example for a CONSTRUCT statement consider Example
 in example 5.2 is speci ed in example 5.13.
For graph pattern P contained in this query the result of projectX([[P]]K) is identical to the annotated relation shown in Example 5.7 except for the  rst two columns.
Based on the single triple pattern ?x worksAt ?y contained in the graph template and the two bindings contained in projectX([[P]]K) two quintuples are constructed and added to the RDF+ literal statements Kres as shown in Example 5.15.
Mres contains the corresponding meta knowledge statements resulting from I f   (projectX([[P]]K)( i)).
Example 5.14.
CONSTRUCT {?x worksAt ?y}



 {GRAPH ?h1 {?x affiliatedWith ?y}} AND {GRAPH ?h2 {?x researchTopic SemanticWeb}} }
 to associate meta knowledge, multiple named graphs as outputs are convenient.
In order to remain standard compliant, the SPARQL engine may however also return data and meta knowledge in two di erent batches distinguished by some implementation-speci c mechanism.
Kres = { (Gnew, JamesHendler, worksAt, RensselaerPI,  new1) (Gnew, JamesHendler, worksAt, UnivMaryland,  new2)} (Gnew, RudiStuder, worksAt, UnivKarlsruhe,  new3)} Mres = { ( new1, mk:certainty, 0.9), ( new1, mk:time, "5/5/2007"), ( new2, mk:certainty, 0.6), ( new2, mk:time, "6/6/2001") ( new3, mk:certainty, 0.6), ( new3, mk:time, "6/6/2001") }

 This section summarizes the discussed steps of meta knowledge representation and utilization for the sample scenario that was introduced in section 2.
In order to represent and utilize meta knowledge, the system administrator has to make some design choices.
In particular, the application-speci c meta knowledge properties must be de ned.
In our sample scenario, we consider three meta knowledge properties: source, certainty, and timestamp.
In the next step, the administrator de nes the intended semantics of these properties in order to facilitate query processing with complex expressions and pattern combinations.
Using the notion from Section 5.1, we assume that corresponding de nitions for meta knowledge properties are de ned according to previously discussed Example 5.9.
Finally, data and available associated meta knowledge are represented in RDF using named graphs [2, 5], and imported into our RDF+-based repository.
We assume that the administrator manages the small sample knowledge base introduced in section 2.
The knowledge base is transformed into the RDF+ quintuples shown in Example 5.2 as discussed in section 4.
Associated meta knowledge is transformed into further RDF+ literal statements and RDF+ meta knowledge statements.
For the properties mk:time and mk:certainty the latter are shown in Example 5.13.
Following our sample scenario, the query from Example 2.3 can be reformulated as the query from Example 5.14 which retrieves names of Semantic Web experts together with their a liations.
Internally, the query processor evaluates this query using graph patterns as discussed in 5.1.
If P denotes the graph pattern from this query then all matches for all variables in P are given by [[P]]K.
The resulting set of annotated variable assignments is shown in Example 5.7.
It contains possible variable assignments, and the how-provenance (A3) that explains how these source statements have been used.
By combining this information with de nitions for meta knowledge properties and available meta knowledge statements, the query processor constructs the result shown in Example 5.15.
This result is then serialized in RDF.
The user or application developer can access the knowledge stored in the RDF+-based repository in di erent ways.
On one hand, the repository does not change the existing SPARQL semantics and thus fully supports common SPARQL queries.
This is an important advantage for compatibility with existing applications and interfaces.
On the other hand, the repository supports the advanced SPARQL syntax with metaknowledge support (section 5.1).
Thus, the user obtains additional access to valuable meta knowledge that can be used for relevance ranking, con ict resolution, or other applications in connection with retrieved knowledge.
In our application scenario, the user may realize that the query answer is potentially contradictive (James Hendler is a liated with Rensselaer PI and University of Maryland).
By inspecting the associated meta knowledge, he would realize that the second fact was generated by mistake.
In fact, it is based on outdated information (knowledge from the document survey.pdf with times-tamp 6/6/2001) that was wrongly combined with knowledge from a more recent source (namely document report.doc with timestamp
 ally changed from U Maryland to Rensselaer PI, and the erroneous tuple can be safely excluded from further processing.
In this section we analyze how the construction of the annotations in uences the complexity of the decision problem related to SPARQL.
The decision problem associated with the evaluation of a SPARQL query can be stated as following [11]: Given an RDF dataset D, a graph pattern P and a mapping  , determine whether   is in the result of P applied to D. For this decision problem, which we denote by Eval, an analysis of the complexity is presented in [11, 12].
In the context of RDF+ datasets and annotated variable assignments we have a slightly di erent decision problem: Given an RDF+ dataset D+, an RDF+ graph pattern P+, a variable assignment   and an annotation   determine whether   is the correct annotation of  .
We denote this problem by Eval+.
An annotation is correct i  it is identical to the formula obtained by evaluating P+ as de ned in section 5.
Since   must have an annotation   (cid:2)   i    is in the result the second decision problem includes the  rst one.
The key di er-ence is to construct di erent annotations for mappings which are in the result.
With the following two theorems we show that for pattern which do not use the OPTIONAL operator Eval+ has the same complexity as Eval.
For both theorems the same complexity results have been reported for processing RDF without meta knowledge [11, 12].
Theorem 7.1.
Eval+ can be solved in time O(|P| |D|) for graph pattern expressions constructed by using only AND and FILTER operators.
Theorem 7.2.
Eval+ is NP-complete for graph pattern expressions constructed by using only AND, FILTER and UNION operators.
The theorems indicate that our treatment of meta knowledge does not add to the computational complexity of SPARQL.
A proof for each of the theorems can be found at http://isweb.uni-koblenz.de/Research/MetaKnowledge.
The framework described in this paper has been implemented and is available as an initial prototype.
The prototype is available as an open source implementation at http://isweb.uni-koblenz.de/Research/MetaKnowledge together with example queries using arti cial data from the LeHigh benchmark4.
4available at http://swat.cse.lehigh.edu/projects/lubm/
 Data Provenance: Some Basic Issues.
20th Conference on Foundations of Software Technology and Theoretical Computer Science (FSTTCS), New Delhi, India, pages
 [4] Peter Buneman, Sanjeev Khanna, and Wang Chiew Tan.
Why and Where: A Characterization of Data Provenance.
Proc.
of ICDT, pages 316 330, 2001.
[5] Jeremy J. Carroll and Patrick Stickler.
TriX: RDF triples in XML.
In Proceedings of the Extreme Markup Languages
 [6] Y. Cui and J. Widom.
Practical Lineage Tracing in Data Warehouses.
Proc.
of ICDE, pages 367 378, 2000.
[7] Li Ding, Pranam Kolari, Tim Finin, Anupam Joshi, Yun Peng, and Yelena Yesha.
On Homeland Security and the Semantic Web: A Provenance and Trust Aware Inference Framework.
In Proceedings of the AAAI Spring Symposium on AI Technologies for Homeland Security, 2005.
[8] Todd J.
Green, Gregory Karvounarakis, and Val Tannen.
Provenance Semirings.
In PODS, pages 31 40, 2007.
[9] D. McGuinness and P. Pinheiro da Silva.
Explaining Answers from the Semantic Web: the Inference Web Approach.
J.
Web Sem., 1(4):397 413, 2004.
[10] W. Murdock, D. McGuinness, P. Pinheiro da Silva, C. Welty, and D. Ferrucci.
Explaining Conclusions from Diverse Knowledge Sources.
International Semantic Web Conference (ISWC), Athens, USA, pages 861 872, 2006.
[11] Jorge Perez, Marcelo Arenas, and Claudio Gutierrez.
Semantics and Complexity of SPARQL.
In Proc.
of ISWC, pages 30 43, 2006.
[12] Jorge Perez, Marcelo Arenas, and Claudio Gutierrez.
Semantics and Complexity of SPARQL.
arXiv:cs/0605124v1 [cs.DB], May 2006.
[13] Jorge Perez, Marcelo Arenas, and Claudio Gutierrez.
Semantics of SPARQL.
Technical Report TR/DCC-2006-17, Universidad de Chile, October 2006.
[14] P. Pinheiro da Silva, D. McGuinness, and R. Fikes.
A Proof Markup Language for Semantic Web services.
Inf.
Syst.,
 [15] Eric Prud hommeaux and Andy Seaborne.
SPARQL query language for RDF.
Working draft, W3C, March 2007.
http://www.w3.org/TR/rdf-sparql-query/.
[16] M. Schraefel, N. Shadbolt, N. Gibbins, S. Harris, and H. Glaser.
CS AKTive Space: Representing Computer Science in the Semantic Web.
Proc.
of WWW, pages
 [17] Bernhard Schueler, Sergej Sizov, and Ste en Staab.
Management of Meta Knowledge for RDF Repositories.
In Int.
Conf.
on Semantic Computing (ICSC), pages 543 550, Irvine, CA, September 2007.
The importance of better understanding the ways by which the result came about is fundamental to many Semantic Web applications and scenarios.
The speci cation of the Semantic Web proof layer was discussed in [10, 14, 9].
Our approach is focused on a di erent language model (RDF) and provides  ne-grained meta knowledge management for retrieval queries with SPARQL that is not directly comparable with proof traces for OWL reasoning.
In the area of database systems, meta knowledge is often represented using an extension of the relational data model, coined annotated relations.
Its purpose is primarily the description of data origins (provenance) and the process by which it arrived as a query answer [6, 3, 4, 7].
Basically, our methodology follows the same idea.
However, our approach is specially designed for RDF graph models and not directly comparable to metadata models for relational database systems.
The same holds for the query language (SPARQL instead of SQL) and its semantics.
An important difference to isolated database solutions is the serialization ability of RDF and thus seamless exchanging and utilization of meta knowledge from our framework across the Semantic Web.
In this paper, we presented an original, generic, formalized and implemented approach for the management of many dimensions of meta knowledge, like source, authorship, certainty, and others, for RDF repositories.
Our method reuses existing RDF modeling possibilities in order to represent meta knowledge.
Then, it extends SPARQL query processing in such a way that given a SPARQL query for data, one may request meta knowledge without modifying the query proper.
We achieve highly  exible and automatically coordinated querying for data and meta knowledge, while completely separating the two areas of concern.
Our approach remains compatible to existing standards and query languages and can be easily integrated with existing applications and interfaces.
In the future, we will investigate the meta knowledge support for OWL-based knowledge bases with advanced reasoning capabilities.
Due to the substantially higher complexity of inferencing and retrieval algorithms (e.g.
reasoning in OWL-DL vs. RDF querying with SPARQL) and the distributed nature of knowledge sources in the Semantic Web, the notion of meta knowledge will require further, nontrivial justi cation.
Another interesting research issue is the support for nested meta knowledge (i.e. construction of meta knowledge for the result with respect to additional information about meta knowledge of its origins).
Our long-term objective is the generic, e cient and e ective infrastructure for meta knowledge management as an integral part of the proof layer of the Semantic Web.
project (www.x-media-project.org) funded by the European Commission under EC grant number IST-FP6-026978 and by the project WeKnowIt (www.weknowit.eu) funded by the European Commission under EC grant number FP7-215453.
