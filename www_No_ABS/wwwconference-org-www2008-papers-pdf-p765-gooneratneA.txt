Web services are autonomous and modular applications that are located, accessed and executed over the Internet.
Service discovery enables such services to be located based on functional requirements [2], nonfunctional requirements [12] or both [10].
It employs matching techniques to compare Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
Figure 1: A Composite Service Locating a composite service (like the one shown in Figure 1) would require accurate speci cations of both service descriptions and user requests.
Constraints are used in user requests to accurately describe the services that need to be located [2].
They are of two types: local and global constraints.
The former restricts the values of a particular attribute of a single service (e.g.
type.Computer = MACINTOSH), whereas the latter simultaneously restricts the values of two or more attributes of multiple constituent services.
Global constraints can be classi ed based on the complexity of solving them (i.e. determining the values that should be assigned to their attributes) as either strictly dependent or
 the values that should be assigned to all the remaining restricted attributes can be uniquely determined once a value is assigned to one.
location.Dispatch = location.Pickup   validRegion.Insurance is an example of a strictly dependent global constraint.
Once MELBOURNE is assigned to lo-cation.Dispatch, the same value has to be assigned to lo-cation.Pickup and included in the set of values assigned to validRegion.Insurance.
Services that conform to strictly dependent global constraints can be easily located in polynomial time [5].
Any global constraint that is not strictly dependent, is independent.
For example, availableDate.Computer   ap-provalDate.Insurance   date.Pickup is an independent global constraint.
In our opinion, the class of composite services that conform to independent global constraints is probably the  most  interesting to study, as their location is known to be NP-hard [3, 12].
Indeed, if a given independent global constraint restricts q attributes, and if service descriptions assign p values to each attribute, then a technique locating a conforming service may have to consider pq combinations of values.
As a consequence most of the existing matching techniques (for locating composite services) do not consider independent global constraints [1, 8].
Nonetheless, there are some that consider them [9, 11, 12] and they use integer programming solutions focusing on local optimisations [12] and AI planners [9, 11] to e ciently locate conforming composite services.
However, all the techniques of the latter type are syntactic-based approaches.
None of the current semantic-based composite matching approaches consider independent global constraints.
This paper proposes a semantic-based matching technique that locates services conforming to independent global constraints.
A two dimensional data structure, called a slot list, is designed to e ciently  nd services.
Available services are indexed based on the values they assign to the attributes restricted by a global constraint.
This index enables the quick retrieval of services that assign a particular value to their restricted attribute.
Then, tuples of conforming values are determined using either a greedy approach or derived using domain rules [2].
Finally, services that assign these conforming values to their restricted attributes are retrieved from the slot list and combined to form conforming composite services.
Experiments were performed to compare the proposed techniques against a syntactic-based composite matching technique [11] and a relevant semantic-based matching technique [2].
The proposed technique that incorporates a greedy algorithm performs 76% better than the existing techniques.
Experimental results also show that the proposed approaches achieve a higher recall than syntactic-based approaches.
The rest of his paper is organized as follows.
In the remaining sections we will refer to composite services simply as  services  (because the focus of this paper is only on the discovery of such services).
Section 2 overviews some background needed to understand the various parts of the paper.
In Section 3 we provide concise guidelines on how requests for services should be speci ed.
Section 4 details the proposed composite matching techniques and Section 5 provides a summary of advantages/limitations of the proposed approaches.
Details of the experiments are given in Section 6.
In Section 7, we review existing composite matching techniques.
Finally, we summarize and conclude in Section 8.
Meta-Ontology In this paper we will use the meta-ontology proposed by Elgedawy et al.
in [2].
As pointed out in [5], in this ontological structure relationships can be accurately modeled and reasoned using a  simple  mechanism.
A meta-ontology consists of four types of elements (i.e. concepts, operations, roles and rules).
Concepts are basic entities of a domain.
Domain elements with common attributes are abstracted into concepts (e.g.
- Computer, Finance, Insurance).
Transactions that are permitted in a domain are speci ed with operations (e.g.
- Sales(), Insure(), Ship()).
Roles are used to specify the actors such as Sales Assistant, Telemarketer.
A description of rules will be provided later in this section.
The relationships between the elements of an ontology are speci ed with substitution graphs and transformation graphs.
In a substitution graph, the contextual aspect of a relationship is speci ed with a substitution condition.
Each (substitution) graph de nes a set of attribute mappings.
Figure 2 depicts an example of a substitution graph which speci es the relationship between Computer and Laptop.
A transformation graph models a relationship requiring the meta-model of an element to be changed.
It is speci ed with one or more consecutive operations.
Figure 3 shows a transformation graph modeling the relationship between Dell and Intel (which are brand names of a Computer and a Processor).
This is speci ed with an operation that lists components and another that returns the type of one.
battery.Laptop = NOT_REQUIRED Computer Laptop price processor size memory networking options hard disk battery price processor display memory networking options hard disk input devices optical drives sound system Figure 2: Substitution graph
 Component:list(Computer) ComponentType:typesOf(Component)
 Figure 3: Transformation graph
 substitution and transformation graphs) are speci ed for every element of an ontology (i.e. concept, operations, roles).
The meta-ontology requires any transitive relationship to be explicitly speci ed with the data structures.
For example, if Calculator can be substituted with Laptop, and Laptop can be substituted with Computer, there is a transitive substitution relationship between Calculator and Computer.
Then, a substitution graph which allows the concept Calculator to be substituted with Computer should be explicitly included in the ontological descriptions.
The proposed composite matching technique assumes that the functional descriptions of services are speci ed with WS-
In such a language, the functionality of a service is described by three elements; its purpose (goal), state transitions and data transformations.
Current description frameworks represent the purpose with an operation [2, 6].
The state transitions are described with preconditions (describing the state that the execution environment of a service needs to be in before commencing its execution) and post-conditions (describing the state after its execution has been successfully completed).
States are described by the values that can be assigned to the attributes of a service according to the preconditions or the post-conditions.
Data transformations are described with inputs and outputs.
Unlike other functional description frameworks, WS-ALUE models all three functional aspects together [6].
For the approach proposed in this paper, descriptions that specify the purpose and the state transition performed by services would be suf- cient.
However, WS-ALUE is selected because we intend to develop techniques that verify the composability [7] and compatibility [7] of (composite) services, in the future.
An WS-ALUE s operation (used to describe the purpose of a service) is constrained by the role it performs in a domain and the concepts it a ects.
For example, a Computer Sales service performs the operation Sales(), a ects the concept Computer and performs the role of an Sales Assistant.
The data transformations are described with inputs and outputs.
 in-constraints  and  out-constraints  restrict the values used as inputs and outputs.
State transitions are described with preconditions and post-conditions.
The conditions (specifying the in-constraints, out-constra-ints, preconditions and post-conditions) model a relationship between an attribute and a value.
A condition explicitly reduces the scope of an attribute to a particular domain.
The scope of an attribute is the set of values that can be assigned to the attribute.
It is de ned by associating an attribute with a concept.
For example, the scope of the attribute dispatchTime cannot be determined unless it is speci ed as dispatchTime.Computer.
Then any value (specifying the time taken to dispatch a computer) can be assigned to the attribute dispatchTime.
When an attribute is used in a condition, its scope is reduced to a particular domain.
For example, in a condition of the form dispatchTime.Computer<24 HOURS, the scope of dispatc-hTime.Computer is reduced to a value less than 24 hours.
Rules Rules of a meta-ontology [2] de ne the legitimate derivations of a domain (e.g. Insurance should be approved immediately according to standard procedures ,  A computer should be picked up a day after it is made available according to standard procedures ,  A customer is categorized as VIP if more than 100 purchases are made within a week ).
The second matching approach proposed in this paper will use these rules to derive values that conform to independent global constraints.
An exact speci cation of how these rules are represented is not provided in [2].
Therefore, we assume that a rule is speci ed as a function, which derives a value that should be assigned to a derived attribute based on a value that is assigned to a determinant attribute.
The context in which these assignments should be made to the attributes is speci ed with an operation, an a ected concept and a role.
Figure 4 depicts graphical representations of the  rst two sample rules described above.
availableDate.Computer [Sales(), Computer, Sales_Assistant] approvalDate.Insurance [Insure(), Computer, Sales_Representative]
 standardProcedure()
 standardProcedure() approvalDate.Insurance [Insure(), Computer, Sales_Representative] date.Pickup [Ship(), Computer, Shipping_Agent] Figure 4: Sample Rules Context Matching Technique Elgedawy s approach [2] matches the contexts of two similar goals.
Their notion of  semantically related attributes  will be used in the proposed technique to identify the list of attributes related to a given attribute according to ontological relationships.
Definition 1 (Semantically Related Attributes).
Given two attributes ai and ay where their scopes are de ned with the concepts ci and cy respectively, ai is semantically related to ay if cy can be substituted with ci using either a substitution graph or a transformation graph, and the substitution results in ai being mapped to ay.
The attribute Computer.display is semantically related to Laptop.size according to the substitution graph given in Figure 2, because Computer substitutes Laptop and the substitution results in display being mapped to size.
Concise guidelines (for creating requests for composite services) are given in this section.
The proposed matching technique assumes that a request is structured according the given guidelines.
A request consists of a composite service template and a constraint model.
The former speci es the types of services that need to be aggregated to form a composite service.
It is de ned as a collection of service types.
A service type is described with the triplet [O, C, R], where O is an operation, C is an a ected concept and R is a role.
A description of the composite service template of the service given in Figure 1 follows.
{[Sales(), Computer, Sales Assistant], [Ship(), Computer, Shipping Agent], [Insure(), Computer, Sales Representative]} Constraints are included in a request to provide an accurate description of the required services.
For example, the constraint  type.Computer = Macintosh  (which is applied on
 Macintosh computers are required.
The constraint model described here contains an independent global constraint.
Such constraints are formed with a collection of binary attribute comparisons (binary constraints).
For example, avail-ableDate.Computer   approvalDate.Insurance   date.Pickup is an independent global constraint.
Typically, a global constraint is speci ed with a nonempty set of attributes.
Additionally, a type which indicates whether a constraint restricts attributes that describe either preconditions (of services), post-conditions or both is included in a speci cation.
The proposed approach employs both a local optimisa-tion technique and derivation-based technique (that uses domain rules) to determine values that conform to a given constraint.
The reasons for using these techniques will be described in the next section.
Both of these techniques determine the values that should be assigned to all the attributes based on a value assigned to one.
Hence, they use the values assigned to one particular attribute as a starting point.
This attribute is referred to as the  free attribute .
Unlike the values assigned to the non-free attributes, all the values assigned to this attribute will be considered by the proposed approach when determining conforming values.
Since an independent global constraint is a collection of binary attribute comparisons, the relationships between the attributes are speci ed with a set of binary operators.
Each one of them is speci ed with two attributes and relational operator, which can be either =, <, >,  ,  , 6=,  ,  ,   or / .
Following is the description of availableDate.Computer   approvalDate.Insurance   date.Pickup.
{availableDate.Computer, approvalDate.Insurance, date.P ickup}, P OST, availableDate.Computer {availableDate.Computer   approvalDate.Insurance, approvalDate.Insurance   date.P ickup},

 This section provides details of the proposed composite matching technique.
This technique requires: (i) WS-ALUE [6] service descriptions, (ii) user requests structured according to the guidelines given in Section 3, and (iii) the terms in descriptions (service descriptions and user requests) to be de ned in a meta-ontology [2].
It locates services that conform to independent global constraints.
Let gc be a constraint that restricts the attributes [a1, .
.
.
, an] of services of types [S1, .
.
.
, Sm].
A service tuple [s1, .
.
.
, sm] is a composite service that conforms to gc if:
 2.
 si, si is described using an attribute a  i, where a  i  {a1, .
.
.
, an}, and 3.
[v1, .
.
.
, vn] assigned to [a  1, .
.
.
, a  n] of [sx, .
.
.
, sy] conform to gc.
[a  1, .
.
.
, a  attributes.
n] of [s1, .
.
.
, sy] are referred to as restricted The proposed approach consists of three phases: (1) candidate acquisition, (2) service indexing and (3) composite service acquisition.
The  rst phase locates services of the di erent types in a composite service template.
The second phase identi es restricted attributes of services and indexes them based on the assigned values.
The  nal phase retrieves the values that conform to a given constraint and combines services that assign those values to their restricted attributes (to form conforming composite services).
(1) Candidate Acquisition This phase describes a way of locating candidate services.
A candidate service is a service of a particular type, and the proposed approach locates such services for all the types in a composite service template.
By locating candidate services, it ensures that the constituent services of a composite service are of appropriate types.
Let Sm be a service type and sn a given service.
We also denote by om, cm and rm the operation, the a ected concept and the role that describe Sm.
For sn we denote its elements by on, cn and rn.
The service sn is a candidate of type Sm if on substitutes om, cn substitutes cm, and rn substitutes rm.
The substitutions are performed with the substitution graphs in a meta-ontology [2].
Each candidate si of type Si is placed in a list of candidates candidates(Si).
Given the available services W and a composite service template CST (de ned with the service types Sx, .
.
.
, Sy), this phase generates a set of candidate lists Candidates, where Candidates={candidates(Sx), .
.
.
, candidates(Sy)}.
(2) Service Indexing Phase This phase identi es the restricted attributes of candidate services and indexes them in a two dimensional structure based on the values they assign to these attributes.
An attribute is restricted, if the assigned values are restricted by a user constraint.
Such attributes need to be identi ed because whether a particular candidate service can be included in a conforming composite service is determined based on the values assigned to them.
Since this technique is semantic-based, an attribute of a service is considered as a restricted attribute if it is semantically related to one that is used to specify a global constraint.
Consider the constraint availableDate.Computer   appro-valDate.Insurance   date.Pickup described in Section 3.
This restricts the attributes availableDate.Computer, approval-Date.Insurance and date.Pickup of services of types Sales(C-omputer), Insure(Computer) and Ship(Computer)1.
A service ComputerSales-I of type Sales(Computer) described with date.Dispatch exists.
date.Dispatch is semantically related to availableDate.Computer according to the ontological relationships.
In such a situation, the restricted attribute time.Assemble of ComputerSales-I is a restricted attribute, because the values assigned to it are restricted by date.Dispa-tch   approvalDate.Insurance   date.Pickup.
Candidate services need to be indexed based on the values assigned to such attributes because of two reasons.
conform to a given constraint.
Then, it combines services that assign those values to their restricted attributes to form composite services.
Such an approach requires the list of values assigned to each restricted attribute by the candidate services.
These lists can be easily obtained by indexing services based on the assigned values.
Let us assume we have the services described in Table 1.
If these services are indexed in the way shown in Figure 5, then the lists of values assigned to the restricted attributes can be easily obtained.
We assume that the values assigned to the attributes avail-the
 are [Sales(), Computer, Sales Assistant], [Insure(), Computer, Sales Representative] and [Ship(), Computer, Shipping Agent] respectively.
abbreviated forms of
 Pickup are speci ed in date format and that the required ontological descriptions are available.
be assigned to a particular attribute and the number of attributes semantically related to a particular attribute are bounded.
Table 1: Sample services Service ComputerSales-I ComputerSales-II Insurance-I Insurance-II Type Sales(Computer) Sales(Computer) Insure(Computer) Insure(Computer) Shipping-I Shipping-II Shipping(Computer) Shipping(Computer) Assigned Values










 availableDate.
approvalDate.
Computer Insurance date.Pickup
 Insurance-I Shipping-I
 Insurance-II
 Insurance-I Shipping-II



 Insurance-II Shipping-I Figure 5: Indexed Services
 those that assign a particular value to a restricted attribute can be retrieved quickly.
Let us assume that tuple [3RD JULY, 3RD JULY, 4TH JULY] of conforming values is given for the above scenario.
In such a situation if the available services are not indexed, 10 operations (3+4+3) may have to be performed to locate those services that assign these values to their restricted attributes.
However, it would only take 3 operations if the services are indexed (see Figure 5).
The proposed approach generates a set of Slot Lists to index candidate services based on the values they assign to restricted attributes.
Figure 6 provides a global view of this data structure.
It depicts a set of Slot Lists {L1, L2, L3, L4} generated for a global constraint that restricts the attributes [a1, a2, a3, a4].
Note that a Slot List Li is generated for every attribute ai.
A slot lij is included in a list Li for each value vij that can be assigned to attribute ai.
Each slot contains a set of services.
A service sk is included in a slot lij if it is able to assign the value vij to ai.
That means, the service description of sk is speci ed using either   ai: vij is assigned to ai, or   an attribute a  ij is assigned: a  i to which a value v  i is semantically related to ai and the relationship causes v  ij to be mapped to vij .
in Shipping-I in Table 1 the restricted at-For example, tribute is date.Dispatch and the assigned values are not spec-i ed in  date-month  format.
However, since the ontological relationships semantically relate date.Dispatch to available-Date.Computer, and map the assigned values to 3RD JULY and 5TH JULY, Shipping-I is placed in the slots that correspond to havailableDate.Computer, 3RD JULYi and havaila-bleDate.Computer, 5TH JULYi.
When generating a set of Slot Lists it is assumed that the domain of values that can Slot Lists


 Slots l11 l12 l13 l14 l15 l21 l31 l41 sx sa sy sz Services sp sq Figure 6: Set of Slot Lists (3) Composite Service Acquisition The task performed in this phase is divided into two steps.
First, values that conform to a given independent global constraint are identi ed.
Then, services that assign these conforming values are combined to form composite services.
The proposed approach models an independent global constraint as a directed acyclic graph G=(V, E), where V is a set of nodes and E is a set of arcs.
The nodes of such a graph represent the attributes and the arcs model the relationships between the attributes.
Each arc and the two connected attributes model a binary attribute comparison of a constraint.
Figure 7 depicts a graph modeling a constraint that restricts a1-a6, where the binary attribute comparison are speci ed with the operators {o12, o13, o24, o34, o35, o46}.
o
 a 2 o
 a1 o
 a
 o
 o
 a
 a
 o
 a
 Figure 7: Directed Acyclic Graph modeling an Independent Global Constraint Values that conform to a constraint are identi ed by generating instances of such graphs.
A tuple of values assigned to the nodes of a graph is an instance.
For example, the values [v1, v2, v3, v4, v5, v6], where each value vi is assigned to an attribute ai, forms an instance of the graph depicted in Figure 7.
Such an instance conforms to a given constraint if each of its values conform to the binary attribute comparisons represented by the arcs.
A value that conforms to the binary attribute comparisons is referred to as an Arc Consistent Value.
Definition 2 (Arc Consistent Value).
Let gc be an independent global constraint that restricts the values assigned to attributes {a1, .
.
.
, an}, where ai is a non-free attribute and ai  {a1, .
.
.
, an}.
{aj , .
.
.
, ak} is the set of attributes connected to ai with arcs {oij , .
.
.
, oik}, where {aj , .
.
.
, ak} {a1, .
.
.
, an}.
[vj , .
.
.
, vk] is a tuple of values
 consistent, if the relationships represented by the arcs {oij , .
.
.
, oik} exist between vi and the values in {vj , .
.
.
, vk}.
An instance of a graph that consists of arc consistent values is a tuple of conforming values.
Such tuples are referred to as Arc Consistent Instances.
Definition 3 (Arc Consistent Instance).
Let gc be an independent global constraint that restricts the values assigned to attributes {a1, .
.
.
, an}, where ai is a non-free attribute and ai  {a1, .
.
.
, an}.
A tuple of values [v1, .
.
.
, vn] assigned to {aj , .
.
.
, ak} is an arc consistent instance if each value vj in {aj , .
.
.
, ak} is locally arc consistent.
Identifying an arc consistent instance is NP-Hard.
If a given relational constraint restricts n attributes and m arc consistent values can be assigned to each attribute, then mn combinations of values may have to be considered to identify an arc consistent instance.
The proposed technique de nes two separate approaches to perform this task.
The  rst approach uses a basic greedy algorithm (backtrack-free search algorithm [3]) to identify arc consistent instances.
The second approach derives them using domain rules [2].
The reason for proposing two separate approaches will be given later.
We will refer to the  rst one as the optimised approach, and the second as the derivation-based approach.
(1) The Optimised Approach This approach employs a greedy algorithm to locate arc consistent instances in polynomial time.
It attempts to generate an arc consistent instance for each value that is assigned to the free attribute.
When generating these instances,  rst, a value assigned to the free attribute is selected.
Then, based on that value, arc consistent values are selected for the remaining attributes.
If such a value cannot be located for a particular attribute, then the technique moves to the next value that is assigned to the free attribute.
It does not perform any backtrack to consider alternative (arc consistent) values for attributes.
Figure 8 shows the way in which values are selected by this approach when services are indexed as in Figure 5.
A solid line indicates an arc consistent instance, whereas a dashed line indicates that the assignments have led to a dead-end (i.e. an arc consistent instance is not located for the corresponding value that is assigned to free attribute).
When 3RD JULY is selected for availableDate.Computer, the arc consistent instance [3RD JULY, 3RD JULY, 3RD JULY] is located.
However, when 5TH JULY is considered, an arc consistent value cannot be located for date.Pickup.
Once an instance is located, the services in the slots that correspond to the arc consistent values are combined.
Let us consider a constraint gc that restricts the attributes a1, .
.
.
, an of services of types S1, .
.
.
, Sn.
We also assume that a set of Slot Lists SL has been generated for gc.
A slot at a location hai, vii, which corresponds to an attribute ai and a value vj , contains services of type Si which assign the value vj to attribute ai.
Therefore, .
.
.
, vn] is an arc consistent instance, then the services at the slots ha1, v1i, .
.
.
, han, vni would form conforming composite services.
In the above scenario, when [3RD JULY,
 havailableDate.Computer.3RD JULYi, happrovalDate.Insura-nce.3RD JULYi and hdate.Pickup.3RD JULYi are combined to form the conforming composite service [ComputerSale-I, Insurance-I, Shipping-I].
if [v1, Constraint availableDate.
Computer   approvalDate.
Insurance   date.Pickup











 Assigned Values







 Figure 8: Value Selection The algorithm for the optimised approach is given in Algorithm 1.
This requires a set of Slot Lists and an independent global constraint.
locateServices(SL[][], gc) removeEmptySlots(SL); {c0.a0, .
.
.
, cn.an}  restrictedAttributes(gc); {atcp, .
.
.
, atcq}  attributeComparisons(gc) ; for i 0; i<SL[0].length; i++ do values[0] SL[0][i].getValue(); for j 1; j<SL.length; j++ do {atcx, .
.
.
, atcy}  includes(cj .aj , {atcp, .
.
.
, atcq}); for k 0; k<SL[ j].length; k++ do values[j] SL[j][k].getValue(); if isArcConsistent(hvalues[0], .
.
.
, values[j]i, {actx, .
.
.
, acty}) then break; end else reset(values[j]); end end end if containsInitialV alues(values) then continue; end for each service s0 in SL[0][values[0]].getServices() do for each service s... in SL[.
.
.
][values[.
.
.
]].getServices() do for each service sn in SL[n][values[n]].getServices() do conforming services.add(s0, .
.
.
, sn); end end end end Algorithm 1: Locating Services - Greedy Approach First, the empty slots are removed from the Slot Lists (line 2).
These slots need to be removed because the corresponding values are not assigned to the relevant restricted attributes by any candidate service.
Then, this algorithm attempts to generate an arc consistent instance for each value that is assigned to the free attribute (lines 5-17).
Once the instances are generated, the services at the indicated slots are retrieved (lines 20-22) and combined to conforming composite services (lines 23-28).
The time complexity of Algo-
tributes, there are m conforming value tuples, and each slot (in the set of Slot Lists) contains q services, then m*(pq) composite services would be generated.
However, this technique is  generally  polynomial since Algorithm 1 does not retrieve any nonconforming composite services.
This algorithm identi es tuples of arc consistent values in polynomial time and only combines services that assign those values to their restrict attributes.
Those that do not assign arc consistent values are not considered.
The main drawback of this approach is that it may return false negatives.
That means, it may not retrieve all the conforming composite services.
In the scenario described in Figure 5, [ComputerSale-I, Insurance-I, Shipping-I], [Compute-rSale-I, Insurance-I, Shipping-II] and [ComputerSale-II, Ins-urance-I, Shipping-II] are conforming composite services, because [3RD JULY, 3RD JULY, 3RD JULY], [3RD JULY,

 ULY] and [4TH JULY, 4TH JULY, 4TH JULY] are consistent instances.
However, only [3RD JULY, 3RD JULY,
 employs a greedy algorithm.
(2) The Derivation-based Approach This approach uses domain rules to derive arc consistent instances.
Like the previous approach, this one may also return false negatives.
However, this approach returns the used domain rules along with each composite service so that the context in which it is located can be understood by a user.
Let us consider the constraint availableDate.Computer   approvalDate.Insurance   date.Pickup and the services given in Table 1.
If the technique that identi es arc consistent instances selects 3RD JULY for availableDate.Compu-ter, then the rules in Figure 4 can be used to derive the tuple [3RD JULY, 3RD JULY, 4TH JULY]2.
Even though the discovery technique only returns [ComputerSale-I, Insurance-I, Shipping-I] (and not [ComputerSale-I, Insurance-I, Shippi-ng-I] and[ComputerSale-II, Insurance-I, Shipping-II]), a user would be able to understand the context in which it was retrieved if the rules in Figure 4 are returned.
When generating an arc consistent instance, values are derived for the non-free attributes based on one that is assigned to the free attribute.
Since we assume that a rule is a function that derives a value for a derived attribute based on one that is assigned to a determinant attribute, a set of rules can be used to uniquely determine the values that should be assigned to the non-free attributes based on one that is assigned to the free attribute.
That means, the domain rules are used to approximate an independent global constraint to a strictly dependent global constraint.
Definition 4 (Approximatable Constraint).
Let gc be an independent global constraint which restricts the values assigned to attributes {ax, .
.
.
, ay}, where ax is its free attribute and Vx is the set of values assigned to ax.
{rm, .
.
.
, rn} is the set of available rules.
gc is approximatable if  vx  Vx and  {rp, .
.
.
, rq} {rm, .
.
.
, rn}, which can derive the values vx+1, .
.
.
, vy based on vx, such that [vx, vx+1, .
.
.
, vy] forms an arc consistent instance.
Let us consider the constraint depicted in Figure 7.
This
 approved on the same day and computers have to be picked up a day later for shipping.
could be considered as an approximatable (see Figure 9).
The constraint is approximatable if the values [v2-v6] assigned to the attributes [a2-a6] are derived using the rules {r12, r13, r14, r35, r46}, based on the value v1 assigned to a1, and [v1-v6] form an arc consistent instance.
r
 r
 r
 o
 a 2   2 o
 o
   1 a1
 a r   4
 o
 o
 a   3
 a   6
 o
 r
 a   5
 Figure 9: Approximatable Constraint Approximating an independent global constraint using domain rules is NP-hard.
Let us consider a constraint gc that restricts the attributes {ax, .
.
.
, ay}, where ax is its free attribute and |x, .
.
.
, y|=m.
For each attribute ai in {ax+1, .
.
.
, ay} there is a set of rules Ri where each ri is able to derive a value vi for ai based on a value vx assigned ax.
In such a situation (m-1)n combinations of rules may have to be considered to establish if gc is approximatable.
Hence, the proposed, uses a greedy approach to select rules.
If a particular rule ri is able to derive a value vi for an attribute ai in {ax+1, .
.
.
, ay} based on a value vx assigned to ax, such that vi is arc consistent, then it is selected.
Then, the technique proceeds to select a rule that derives a value for ai+1 in {ax+1, .
.
.
, ay}.
Any other rule that derives a value for ai based on value vx assigned to ax is not considered.
The algorithm that determines whether a given constraint is approximatable is given below (see Algorithm 2).
This algorithm requires an independent global constraint, the available domain rules and a set of Slot Lists.
A given constraint is considered to be approximatable if at-least one value tuple (i.e an arc consistent instance) to be derived based on a value that is assigned to its free attribute.
This algorithm attempts to generate such an instance for each value assigned to the free attribute (lines 4-6).
When generating an instance, it iterates through the available rules (line 9) and attempts to derive an arc consistent value (lines 10-20) for each non-free attribute (line 7).
If a derived value is arc consistent, both the value and the rule used to derive it are stored in a temporary array (lines 13 and 16).
If not, the corresponding elements of the two arrays are reset and another value is derived using a di erent rule (line 19).
Finally, every derived arc consistent instance is placed in a list along with the rules used for the derivations (line 26).
The complexity of Algorithm 2 is polynomial (i.e. v*x*y*z, where v is the number of values assigned to the free-attribute, x is the number of non-free attributes, y is the number attributes semantically related to a given restricted attribute and z is the number of rules).
This algorithm assumes that (i) each attribute is semantically related to a bounded number of attributes, and (ii) a  nite number of domain rules are available.
Once Algorithm 2 is executed, the derived arc consistent instances are obtained from derived values list.
If it is not empty, the services in the slots (of the Slot Lists) that cor-



























approximate(gc, R, SL) {c0.a0, .
.
.
, cn.an}  restrictedAttributes(gc); {atcp, .
.
.
, atcq}  attributeComparisons(gc); for i 0; i<SL[0].length; i++ do initialize values[], rules[]; values[0] SL[0][i]; for each attribute cj .aj   {c1.a1, .
.
.
, cn.an} do for k 0; k<j; k++ do for each rule rm   R do x   derivedAttribute(rx); cx.ax   determinantAttribute(rx); c  x.a  if (ck.ak==cx.ax || isSemanticallyRel  ated(ck.ak, cx.ax)) && (cj .aj ==c  x || isSemanticallyRelated(cj .aj , c  x.a  then x.a  x)) values[j]  derive(ck.ak, cj .aj , values[k], rm); {atcc, .
.
.
, atcd}  includes(cj .aj , {atcp, .
.
.
, atcq}); if isArcConsistent(hvalues[0], .
.
.
, values[j]i, {actc, .
.
.
, actd}) then rules[j] rm; go to line 9; end else reset(values[j]); rules[j]  N U LL; end end end end end if  containsInitialV alues(values) then derived values list.add(values, rules); end end Algorithm 2: Approximating Independent Global Constraints respond to the values in the instances are combined (like the proposed optimised approach) to form composite services.
The rules used to derive an arc consistent instance are returned with each corresponding composite service.
Both the optimised and derivation based approaches have better complexity than existing techniques, are they are both semantic-based and they locate conforming services in polynomial time.
Hence, they are able to locate conforming composite services e ciently in situations where user requests and service descriptions are syntactically heterogeneous.
However, the main drawback of our approaches is that they retrieve duplicate entries.
A duplicate entry occurs if a composite service that includes a particular sequence of constituent services is retrieved more than once.
Let gc be a global constraint that restricts the attributes ax, .
.
.
, ay, where the services sx, .
.
.
, sy are able to assign the values [vx1, .
.
.
, vy1] and [vx2, .
.
.
, vy2] to the restricted attributes.
If both tuples of values conform to gc (i.e. they are arc consistent instances), one duplicate entry would be retrieved.
In a situation in which n conforming value tuple can be assigned to the restricted attributes by a tuple of services, where n>1, n-1 duplicate entries would be retrieved by these techniques.
However, the number of these duplicate entries only increases at a polynomial rate.
If there are p conforming composite services, the number of duplicate entries that can be generated would be p*q, where q is the number of conforming value tuples assigned to each tuple of restricted attributes.
In this section the experiments we performed to compare the proposed approaches against those in [2] and [11].
The metrics used are performance and recall.
Recall was calculated based on the number of unique conforming composite services retrieved.
The technique proposed in [11] is implemented with JSHOP3 and others were done in Java (JDK
 as a registry to store service descriptions and ontological descriptions.
Experiments were conducted on Pentium IV 3.0 GHz machines with 1 Gigabyte of memory.
Up to our knowledge, there is no standard data set that can be used to evaluate semantic-based service discovery techniques.
We were unable to obtain a real-world data set of semantic-based web service descriptions.
None of the composite matching techniques that we came across [1, 8,
 have therefore tried to generate our own test data set using a  appropriate  methodology which uses the following steps.
Even though this may not be the best way, we believe that it will give us good indication about the quality of the proposed approaches (when compared to existing ones).
Details were extracted from sample ontologies and an ontology that consists of 157 concepts, 19 roles and 27 operations was randomly generated.
2000 substitution graphs and transformations graphs were generated to de ne ontological relationships.
Service descriptions were created with elements that were randomly selected from the ontology.
Each description had an operation, an a ected concept, a role and between 20 to 30 preconditions and post-conditions.
A similar approach was used in [2] to generate test data to evaluate implementations of their semantic-based matching techniques.
Experiments were conducted by varying the number of available service descriptions and service types in composite service templates.
Between 400 to 2000 service descriptions and composite service templates which include between 5 to 25 service types were considered.
Since the technique proposed in [2] employed an exponential algorithm, it was not feasible to execute it in such an environment.
Hence, the experiments that included the exhaustive approach were conducted in a restricted environment, which contained between 20 to 100 service descriptions and composite service templates that include between 2 to 10 service types.
The recall levels achieved by the exhaustive and the proposed optimised approach were higher than that achieved by the syntactic approach.
Unlike the later approach, the semantic-based approaches matched syntactically heterogeneous service descriptions and user requests using ontological relationships.
The exhaustive approach considered all the possible combination of services; and for each combination it employed an exhaustive algorithm to evaluate the values assigned to the restricted attributes (i.e. it checks if the values assigned to the restricted attributes conform to a given constraint).
The proposed approach only considered

 retrieved more services than the proposed approach.
The number of services retrieved by all the techniques decreased, as the number of service types increased.
The values assigned to the restricted attributes of candidate services had to conform to an increasing number of binary attribute comparisons.
The derivation-based approach did not retrieve many services because the rules required to approximate a given constraint were not available.
The used random process did not generate the required rules.
Syntactic Optimised Derivation s e c i v r e
 e t i s o p m o




 s e c i v r e
 e t i s o p m o























 Web Services (a) Normal Environment






















 Web Services

 (b) Restricted Environment Figure 10: Recall - Varying no.
of Available Services s e c i v r e
 e t i s o p m o





 s e c i v r e
 e t i s o p m o

























 Service Types (a) Normal Environment Syntactic Optimised Derivation
























 Service Types (b) Restricted Environment Syntactic Optimised Exhaustive Derivation Figure 11: Recall - Varying no.
of Service Types The performance of the optimised technique was 76% better than that of the syntactic approach in the experiments varied the number of available services.
The syntactic approach used JSHOP, which performs a combinatorial depth rst search to locate conforming composite services.
On the other hand, the proposed local optimisation-based approach determined the values that conform to a given constraint in polynomial time and only combined services that assign those values.
The performance of the syntactic approach was 32% better in the experiments that increased the number of service types in a composite service template.
Since the optimised approach is semantic-based it retrieved more candidate services than the syntactic approach.
The time taken by the devised approach to index services in the Slot Lists increased at a rapid rate with an incrementing number of service types.
The exhaustive approach was the least ef- cient in the restricted environment.
In the two worst cases (with 100 available services and 10 service types) it took around 9 minutes 35 seconds, and and 46 minutes and 25 seconds respectively, whereas the proposed approach only took 1.16 seconds and 1.47 seconds.
) s d n o c e
 ( e m
 i










 Syntactic Optimised Derivation Syntactic Optimised Exhaustive Derivation





 Web Services (a) Normal Environment ) s d n o c e
 ( e m
 i





















 Syntactic Optimised Derivation Exhaustive




 Web Services (b) Restricted Environment Figure 12: Time taken - Varying no.
of Available Services

 Semantic-based approaches retrieving composite services were introduced in [1, 4, 8].
However, the technique in [4] is an approximate approach which does not consider the values assigned to the attributes.
None of the remaining techniques neither consider global constraints nor locate composite services that conform to such constraints.
Wu et al. in [11] and Sirin et al. in [9] considered both local and global constraints.
Their approaches require service descriptions and user requests to be speci ed with OWLS. SHOP-2 (Simple Hierarchical Planner-2) is used to locate an orchestration of services that form a conforming composite service.
First, a  SHOP method  is generated according to the OWLS process in a request.
Then, the request and available service descriptions are converted to operator instances.
Both approaches directly used the uni cation functions of SHOP-2 to match domain instances to operators.
Therefore basic string matching functions were used to match user requests to service descriptions.
The
 Logic reasoner.
However, this is only used to check whether the preconditions of a given operator (in the hierarchy) are entailed by the state of the planner.
Therefore, the approach in [9] locates conforming composite services when a constraint in a request is speci ed with attributes that have di erent scopes, but not when requests and service descriptions are syntactically heterogeneous.
) s d n o c e
 ( e m
 i

 ) s d n o c e
 ( e m
 i













 Syntactic Optimised Derivation









 Service Types (a) Normal Environment
















 Syntactic Optimised Derivation Exhaustive


 Service Types (b) Restricted Environment Figure 13: Time taken - Varying no.
of Service Types Zeng et al. [12] introduced an approach requiring a request (for a composite service) to be speci ed with a state chart diagram, where each state models a service type.
Services were described with a quality of service model that consists of attributes such as execution price, execution duration, reliability, availability, and reputation.
Both local and global constraints were considered in their approach.
However, these constraints were limited to those that can be speci ed with an attribute of the quality of service model.
A syntactic-based integer programming technique that focuses on local optimisation is used to match the user requests to the service descriptions.
This work proposes two service discovery approaches that locate services that conform to independent global constraints.
The  rst approach uses a greedy algorithm to identify conforming values and locate composite services.
However, since this approach is not sound, a second approach that approximates a given constraint is proposed.
This approach uses domain rules to derive values that conform to a given constraint and combines services that assign those values to their restricted attributes.
The domain rules used to derive the conforming values are returned with each service so that context in which it is located can be understood by a user.
Services are indexed in a two dimensional data structure (a set of Slot Lists) to improve the performance of these approaches.
Experimental results showed that the proposed optimised (initial) approach performs better than any existing technique.
It also achieves higher recall than a syntactic-based approach.s As future work, we intend to develop a composite matching technique that considers multiple user constraints of various types.
Acknowledgments We would like to thank the ARC (Australian Research Council) for the support given towards this work, under the Linkage Project no.
LP0667600 titled  An Integrated Infrastructure for Dynamic and Large Scale Supply Chain .
