Con gurable applications for automated processing of syndication feeds (i.e. Atom and RSS) are gaining increasing interest and attention on the Web.
As of writing this paper there are over 30,000 customized feed processing  ows (referred to as  pipes ) published on Yahoo Pipes [15], the most popular service of this kind.
Yahoo Pipes o ers hosted feed processing and provides a rich set of user-con gurable processing modules, which extends beyond the typical syndication tools and includes advanced text analytics such as language translation and keyword extraction.
Yahoo Pipes  Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
Parameter: Search Query URL Builder: Yahoo Answers http://answers.yahoo.com/rss/searchq URL Builder: Yahoo News http://news.search.yahoo.com/news/rss Fetch Feed Truncate
 Fetch Feed Truncate
 Union Sort Output Figure 1: Example of a Flow of Feeds and Services.
service also comes with a visual editor for  ows of services and feeds.
In the example of Figure 1, the feeds are Yahoo Answers and Yahoo News, which can be parameterized, and truncation, union and sort are services.
There exist similar frameworks that are provided as a hosted service (e.g., DAMIA [5]) or as a downloadable server-side software (e.g., /n software s RSSBus [7], IBM Mashup Starter Kit [5] and IBM Project Zero [4]).
This new breed of  ow composition tools and execution runtimes helps lower the entry barrier for user-con gurable data processing, also referred to as data mashup.
However, as friendly as the visual programming environment of Yahoo Pipes is, it still requires careful manual assembly of the processing  ows by the end user.
As noted by technology reviewers, while this new technology makes data mashup more approachable for non-programmers, it still is not as easy as drag and drop [8].
With the goal of drastically enhancing the consumabil-ity of data mashup for the end users, we have developed MARIO (Mashup Automation with Runtime Orchestration and Invocation) tool for automatic composition of  ows of services and feeds.
This tool can be adapted to compose and deploy  ows in a variety of  ow execution runtimes, including Yahoo Pipes.
As is well known, the easiest way for new users to start creating new data mashups is by cloning an existing pipe that roughly matches the needs of the user.
In MARIO we take this practice to another level by building a tool that not only helps the user to  nd an existing  ow that matches the processing needs, but also generates new  ows on demand to match the user s request.
It helps users discover the capabilities of the system by guiding them through the process of expressing composition requirements
 Visual Editor Feeds Flows Feeds Feeds Feeds Execution Runtime Feeds Results Feeds Feeds Services Figure 2: Interaction of MARIO with other systems.
that can be supported by the system.
The tool makes automatic composition approachable by maintaining an abstraction of taxonomy-extended tag-based search in the space of existing and generated  ows.
Using such a search abstraction, the users express their composition requirements as tag queries describing the desired  ow output.
For each request the users are immediately presented with an automatically generated and deployed  ow, along with a number of alternative  ows that users can visualize and deploy.
The tool helps users discover and re ne  ows by providing context-dependent instructions.
The main contributions we present in this paper are:   A new tool for rapid generation of new data mashups that uses a tag-based search abstraction for automatic goal-driven composition of  ows.
  A simpli ed metadata model for describing the semantics of services, feeds and  ows that enables automatic composition.
  An e cient planning algorithm that enables the search abstraction for automatic  ow composition and discovery of system capabilities.
The paper is organized in the following way.
Section 2 presents an overview of MARIO.
Section 3 describes the user interface of MARIO, with the focus on search goal speci cation and re nement.
Section 4 introduces the component model and component speci cation.
Section 5 illustrates some application examples of MARIO.
Section 6 explains the automatic composition engine.
Section 7 discusses related work, and  nally, Section 8 concludes the presentations.
Figure 2 shows a high-level overview of interactions between systems that can be triggered through the user interface.
The end user interacts with MARIO to create a  ow.
The  ow is deployed to the execution runtime.
The run-time executes the  ow by calling services to process feeds and produce results.
In practice, the processing can be activated by a Web service request sent to the runtime, and the runtime can respond with results represented as a feed, similarly to Yahoo Pipes.
The visual editor, if one is available, can be invoked to edit the composed  ow.
To open the  ow composed by MARIO, the editor can retrieve  ow de nition directly from the runtime, or obtain it from MARIO.
We have connected MARIO to our own testing runtime that simulates Yahoo Pipes functionality, but does not include a visual editor.
We evaluate the approach by using MARIO to compose a set of operators that are equivalent to Yahoo Pipes modules, but implemented as services in our runtime.
This experiment demonstrates that the expressiv-ity of semantic descriptions in MARIO is su cient to describe modules de ned within an external system.
We also study the scalability by adding a large number of feeds to the existing con guration.
To support iterative re nement of queries, MARIO extends the tag-based search with the use of tag taxonomies.
Searching for a tag denoting a high-level category in a taxonomy returns results tagged with any subcategory tags.
MARIO does not require the taxonomies to be speci ed explicitly in a top-down fashion.
Instead, taxonomies can emerge implicitly in a bottom-up process that is typical of folksonomies.
Nevertheless, our search mechanism allows an explicitly de ned taxonomy of tags, or a set of such taxonomies, to be added at any time to enhance the search.
The use of tag taxonomies together with context-dependent query re nement interface in MARIO support an intuitive iterative goal speci cation process, where the goals are expressed as general categories at  rst, and are subsequently re ned to more speci c tags as necessary.
On the other hand, it does not prevent the users from jumping to speci c tags directly, e ectively shortcutting the iterations.
Recognizing the di culties associated with obtaining detailed unambiguous descriptions of service semantics, we have taken the approach that relies on lightweight semantic metadata annotations by making use of tags, folksonomies and simple taxonomies to describe the semantics of services, feeds and  ows.
Given these simple annotations, MARIO uses a small set of rules to compute a set of tags that describes each potentially composable  ow.
The use of tag-based descriptions greatly simpli es this task compared to heavier ontology-based approaches proposed in prior work.
Descriptions of feeds can be obtained, for example, from social bookmarking web sites like Syn-dic8.com [1].
The descriptions of services, however, may require slightly more careful and consistent design.
As we show in the paper, this is not an obstacle in practice, especially in applications where the set of services is small compared to the set of feeds.
One of the main bene ts of automatic composition is instant adaptation to changes.
The interface dynamically adapts to the changing set of feeds and services, providing instant feedback to the user.
Just like the information presented in the goal speci cation interface, the feedback about the new or changed capabilities is provided in user-understandable terms, explaining the e ect of the change in terms of the results that can be produced by new data mashups.
With a su ciently evolved taxonomy that includes a good set of abstract concepts, the end users of MARIO are shielded from having to understand the low-level details of speci c feeds or services.
The use of automatic composition together with abstractly speci ed goals also enables instant automatic adaptation of composed  ows to changes in the environment without user s involvement.
This section describes the user interface for composing  ows by specifying processing goals, which is the operation that is most often performed by the end users of MARIO.
There is another group of users that must interact with our
 face, as shown on Figure 4.
New elements display the  ow that matches the goal and a preview of the output produced by that  ow.
The interface also includes a number of other elements that help user understand current system capabilities and re ne the goal.
All user interface elements shown on Figure 4 appear simultaneously on one screen, and user input committed to any element changes the contents of all elements.
The  Current Goal  element displays the set of tags that constitute the goal.
These tags, shown in black font, are referred to in what follows as the current goal.
On Figure 4, the current goal is the set {Sorted, Yahoo Answers, Yahoo News}.
The user can click on each of these tags to remove that tag from the goal.
Each time the user changes the current goal, the composer generates and ranks possible alternative  ows for that goal, computing sets of tags describing these  ows.
It also chooses one  ow with the best rank among the alternatives and submits it to the execution environment.
We will refer to this  ow as the selected  ow.
The description of each of the alternatives must include all tags of the current goal, but may also contain other tags.
These additional tags for the selected  ow are shown in gray font in the  Current Goal  element.
This gives user an indication of how MARIO interpreted the goal.
Being able to see this set of guessed tags is especially helpful when the goal is ambiguous, for example is based on a general concept.
On Figure 4, Sorted was speci ed as part of the goal, and MARIO selected the  ow described by ByTitleAsc (among other tags) to satisfy the goal.
The selected  ow can have one or more parameters.
The selected  ow on Figure 4 has one parameter,  Destination .
The parameters are automatically initialized with default values, but the users can change parameter values using the edit controls inside the  Parameters  element.
Depending on the runtime environment, it can be possible to change the values of the parameters without redeploying the  ow.
In Yahoo Pipes, for example, the parameters can be speci ed in the URL corresponding to the deployed  ow.
The  Composed Flow  element shows a graphical representation of the selected  ow and its con guration parameters.
This is especially useful for the advanced users who have a good understanding of individual service modules, and use MARIO to quickly create a  ow for their needs.
The users who are less familiar with the individual services may be able to get better understanding of the selected  ow functionality from the guessed tags in the  Current Goal  and the contents of  Flow Output .
The  Flow Output  element shows the results produced by the selected  ow.
In our implementation it shows the feed produced by the selected  ow.
Note that this is the only user interface element cannot be populated until the selected  ow is deployed and produces results.
Depending on the runtime, in some cases it may take longer than the Figure 3: MARIO interface for an empty goal.
system for another purpose, namely to input the tag-based descriptions of feeds and services.
We have not developed any graphical tools for that group of users, and in our implementation the required descriptions are provided simply via dynamically loaded con guration  les.
This will be described in Section 4.
The user interface described in this section is not speci c to automatic composition per se in many respects.
It was our intent to develop an interface that can simplify navigation and search in a large set of tagged and ranked objects.
Those objects do not have to be feeds that are generated on the  y   they could also be taken from an external catalog.
It is the e cient planning algorithm that enables the use of this user interface for  ow composition.
It shields the user from the associated complexity, and makes dynamic composition appear as search over a static catalog.
The details of the algorithm will be explained in Section 6.
The end user interacts with MARIO via a web browser.
The  rst screen presented to the user contains a single tag cloud (see Figure 3).
This tag cloud contains tags that are relevant to the application domain.
The user can select one or more tags from the tag cloud to describe the desired results.
Tags shown using large font sizes generally correspond to high-level categories.
For example, the tag Newspaper appears in a larger font than WashingtonTimes.
The larger font size indicates that the selection will constitute a broad goal that will likely need to be re ned by adding other tags.
Clicking on a tag in the tag cloud adds that tag to the current goal, which is initially empty.
The tag cloud shows only those tags that can be added to the goal such that the new goal can be planned, i.e., at least one  ow can be composed to satisfy the goal.
In further sections we will discuss how this is achieved.
Practically it means that the tag cloud re ects the current capabilities of the system.
Due to screen space constraints the tags that would otherwise appear in the smallest font may be completely removed from the screen.
To accommodate advanced users who want to enter these tags directly, MARIO interface includes a search string where tags can be typed in.
The search string also lets users add more than one tag to the goal.
Goal re nement is the main mode of interaction between MARIO and its users.
When one or more tags are speci ed
 Add to goal Modify goal Current goal Alternatives Composed Flow Parameters Flow Output Figure 4: MARIO interface for goal {Sorted, YahooAnswers, YahooNews}.
user is willing to wait.
In those cases the element can display a preview of the results obtained by other means.
The  Add To Goal  element shows a tag cloud similar to the one shown in Figure 3, but computed in the context of the current goal.
In other words, the tag cloud in Figure 4 only shows the tags that can be combined with the current goal, such that there will exist at least one  ow satisfying the new goal.
Both the set of tags in the tag cloud and the size of the fonts used to display the tags in  Add To Goal  element may change depending on the current goal.
Clicking on a tag in the tag cloud adds the tag to the current goal, which results in composition and deployment of a new selected  ow and changes the contents of all user interface elements.
The  Modify Goal  element allows specifying a new goal using a search string.
This can be especially useful for experienced users who may  nd it tedious to click tags in  Add To Goal  or  Current Goal  elements to add or remove tags one by one.
When the set of tags is large, the tag cloud may not show all of those tags, and several steps of goal re ne-ment may be necessary to add a tag that is initially hidden.
On the other hand, it can be the only way for the end user to discover that the tag exists and is supported by the system.
The users who already know about the tag can type it directly into  Modify Goal  without intermediate re nement steps.
After clicking on  Go  button, the set of tags entered in the search string becomes the new goal.
current goal.
Some of the alternative  ows can be subopti-mal, i.e. there may exist better ranking  ows with exactly the same description.
Hence, the preferred way of selecting another  ow is to modify the goal using other user interface elements, which guarantees that the selected  ow is optimal for the selected goal.
The user interface provides access to a set of commands that operate on the selected  ow (the commands are located above the  ow graph in Figure 4).
The set of commands depends on the functionality supported by the runtime.
For example,  Edit  command can be used to open the Visual Editor, and  Publish  command can be used to make the  ow public, i.e. accessible by others.
This section deals with the formal de nition of the com-positional semantics of a  ow.
We address this issue by de ning a model for deriving the semantic description of a  ow based on the descriptions of its individual components.
A key characteristic of our model is that it captures not only the semantics of inputs and outputs, but also the functional dependency between the outputs and the inputs.
This model can also be expressed using SPPL formalism (Stream Processing Planning Language, [10]) for describing planning tasks, which allows us to use an e cient planning algorithm for  ows composition.
The list of alternative  ows, their rankings and tag annotations are provided as reference to power users.
Selecting and clicking one  ow in the list of alternatives replaces the selected  ow with the selected  ow without changing the
 A taxonomy T = {t} is a set of tags (i.e. keywords) t. An object o is described by a set of tags d(o)   T selected from
 bookmark, as in del.icio.us [12], or a feed, as in Syndic8 [1].
In the simplest case, for example if T is formed as a folksonomy, by people specifying one or more tags to describe certain objects, the tags in T are unrelated and T is completely unstructured.
Introducing a taxonomy structure in T , however, enhances query expressivity, as we explain below, and also helps keep tag-based descriptions succinct.
The structure of the taxonomy is described by specifying sub-tag relationship between tags.
The following de nition is the standard de nition of a taxonomy sub-tag relation applied to tagging.
De nition 1.
A tag t1   T is a sub-tag of t2   T , denoted t1 :: t2, if all objects described by t1 can also be described by t2.
The sub-tag relation is transitive, i.e.
if t1 :: t2 and t2 :: t3 implies t1 :: t3 for  t1, t2, t3   T.
For example, NewYorkTimes :: Newspaper.
For notational convenience we will further assume that each tag is a sub-tag of itself, i.e.
 t   T, t :: t.
If two tags t1, t2   T are such that t1 :: t2 and t2 :: t1, these tags are synonyms, since by de nition they describe the same set of objects.
We will denote this as t1   t2.
Queries are used to describe the desired results produced by a composition (i.e., composition goals), or to specify the input conditions of an operator.
De nition 2.
A tag query q   T selects a subset Qq(O) of an object set O = {o} such that each object in the selected subset is described by all tags in q, taking into account sub-tag relationships between tags.
Formally, Qq(O) = {o   O| t   q  t    d(o) such that t  :: t}.
Note that this de nition of a query remains equally e ec-tive in taxonomies with explicitly stated sub-tag relationships, as well as in con gurations with implicit taxonomies, where the sub-tag relationships are not explicitly stated, but can be inferred from joint appearance of tags.
For example, consider a set of objects O1 and a taxonomy T1 where NewYorkTimes :: Newspaper, and some objects in O1 are annotated with NewYorkTimes.
Assume that O2 is created from O1 by annotating every object in the set {o   O1|{NewYorkTimes}   d(o)} with Newspaper tag, and taxonomy T2 is the same as T1 but with the sub-tag relationship between Newspaper and NewYorkTimes removed (thus de n-ing an implicit taxonomy).
As a result, for q ={Newspaper} the selected subset will be the same in both sets of objects.
This is a very important property of the proposed approach.
It allows mixing implicit taxonomies, typical of folksonomy-like bottom-up modeling approaches, with much more structured and elaborate top-down modeling, which is typical of taxonomies and ontologies.
By e ectively enabling an easy gradual transition from implicitly formed to explicitly stated sub-tag relationships between tags, as the model evolves, it greatly reduces the e ort required for creating a  rst working set of descriptions compared to the top-down ontology-based modeling approaches, where the signi cant cost of de ning taxonomies must be paid upfront.
An operator is a basic unit in the composition.
Generally, it creates one or more new objects from a subset of existing objects.
An operator can require no inputs.
When one or more inputs are required, an input condition is speci ed for each input.
The input condition is speci ed as a tag query, which must be satis ed by the corresponding object provided as input.
The outputs are described by specifying tags that are added to and removed from the description of the new objects produced by the output.
For example, consider a service that truncates an RSS feed to speci ed number of items.
This service can be modeled by an operator that includes FullFeed in its input condition, and removes it from the output object description, adding ShortFeed.
The descriptions of the new objects functionally depend on descriptions of input objects.
There are two methods of propagating information from the input to the output.
The  rst, explicit, method involves using a typed tag variable that can be bound to one of the tags describing the input object, and then using this variable to describe one or more of the outputs.
The type of the variable is a tag, and the variable can be bound to any single sub-tag of its type.
In certain cases, however, operators must propagate sets of tags unrelated to the operator.
For example, the truncation operator needs to propagate any tags describing feed origin, such as Newspaper.
To enable the second method of propagation, a special  sticky  tag   is de ned to serve as a label for automatically propagating tags.
If any sub-tag of   appears in at least one input object description, it will be automatically added to the description of all output objects.
The following de nition captures all of the properties of an operator explained above.
Let   p(f )   0 be the number of operator variables for operator f ;   ~t(f ) = {tk(f )|tk(f )   T }p(f ) k=1 be an array of tags representing the types of operator variables ~v for operator f ;   n(f )   0 be the number of inputs of operator f ;   ~q(f, ~v) = {qi(f, ~v)|qi(f, ~v)   T }n(f ) i=1 be an array of tag queries that de ne input conditions of operator f ;   m(f )   1 be the number of outputs of operator f ;   ~a(f, ~v) = {aj(f, ~v)|aj(f, ~v)   T }m(f ) j=1 be an array of sets of added tags for outputs of operator f ;   ~r(f, ~v) = {rj(f, ~v)|rj(f, ~v)   T }m(f ) j=1 be an array of sets of removed tags for outputs of operator f .
Given the above parameters of an operator, and   an object set O;   an array of tags ~v = {vk}p(f ) k=1 assigned to operator variables, such that vk   T and vk :: tk(f );   an array of input objects ~o   O satisfying the input conditions parameterized with ~v, i.e., such that ~o = {oi}n(f ) i=1 and oi   Qqi(f,~v)(O) we de ne the operator as follows.
De nition 3.
Operator f = hp, ~t, n, ~q, m, ~a, ~ri is a function on the object set, de ned as f (O, ~v, ~o) = O   O , where O  = {o  is the set of new objects produced by the operator, and where j|o 6  O}m(f ) j=1 d(o  j) =     n(f ) [ i=1 {t    d(oi)|t  ::  }      aj(f, ~v) \ rj(f, ~v).
scriptions of new objects produced by the operator: the description of each object is the union of automatically propagated tags derived from   and operator-output-speci c added tags, minus the set of operator-output-speci c removed tags.
A composition of operators is de ned simply as the result of applying one operator to the object set produced by another operator.
De nition 4.
The composition of l operator instances formed by operators f1, f2, .
.
.
fl applied to object subsets ~o1, ~o2, .
.
.
, ~ol and parameterized with tags ~v1, ~v2, .
.
.
, ~vl correspondingly is the composite operator f =  fj , j = 1..l de ned as f (O) = fl(.
.
.
(f2(f1(O, ~v1, ~o1), ~v2, ~o2)), ~vl, ~ol).
Notice that f (O) = O   O  i is the set of new objects produced by operator fi.
Also note that input objects for each subsequent operator can be selected from the object set produced by the preceding operator, i.e.
l, where O 



 ~o1   O0   O ~o2   O1   O   O 
 ...
~ol   Ol 1   O   O 



 l 1 De nition 5.
The composition is valid when the input conditions of each operator instance fj are satis ed by the object array ~oj, i.e.  i, j oji   Qqji (fj , ~vj )(Oj 1).
Subsequent instances of operators may use objects produced by preceding operators as inputs, i.e. there could exist i and j, i < j such that ~oj  O  i 6=  .
In other words, there is a data dependency between ~oj and ~oi.
Data dependencies between operator instances within a composition can be represented using a data dependency graph where arcs connect operator outputs to inputs of other operators, similarly to the  ow graph in Figure 1.
Note that under this model the directed data dependence graphs will always be acyclic.
The problem of goal-driven composition can now be simply de ned as the problem of  nding a composition of operators that produces an object satisfying a given query.
As an additional simplifying assumption, we assume that the composition is applied to an empty object set.
This assumption is not signi cantly constraining, since the initial objects can always be produced by operators that do not require any input objects.
On the other hand, the assumption allows uniform modeling of both feeds and services as operators.
Given a composition problem P(T, F , g), where:   T is a tag taxonomy,   F = {f } is a set of operators,   g is a composition goal speci ed as a tag query, g   T , the solution set is de ned as follows.
  Qg(F ( )) 6=  ;   for all operator instances in F , at least one object produced by this instance serves as input to another operator instance, or satis es the goal query.
The second condition in the de nition above helps eliminate from consideration ine cient compositions that have dead-end operator instances producing unused objects.
Before the set of compositions S(T, F , g) can be presented to the user, the compositions must be ranked, with those most likely to satisfy user s intent appearing  rst in the list.
The ranking is based on a heuristic metric re ecting composition quality.
Each operator f   F is assigned a  xed cost c(f ).
Cost of an operator instance in a composition is equal to the cost of the corresponding operator.
De nition 7.
Rank rank(  f ) of the composition  f (O) = fn(.
.
.
(f2(f1(O)) .
.
.)
is the sum of the costs of operator instances, i.e.
rank(  f ) = n
 i=1 c(fi).
By default for all operators c(f ) = 1.
Hence, the best compositions are the shortest ones.
During con guration of the system, the c(f ) can be changed for some operators to re ect feed or service quality.
The re nement tag cloud, as shown in  Add to Goal  area of user interface in Figure 4, provides valuable help to the user in re ning the goal.
The tag cloud is simply a popularity-weighted set of tags computed over the descriptions of outputs of all compositions in a solution set S(T, F , g).
In theory, if the goal g is empty, the tag cloud is computed over all valid compositions.
Although the set of all compositions may indeed be very large, the set of compositions with di erently described outputs is much smaller.
The planner that we describe later in this paper can compute the tag cloud without constructing all compositions.
Note that the queries in our model behave as though the super-tags from the taxonomy are always included in object description with the corresponding sub-tags.
The same approach should be used during tag cloud computation.
Even if the super-tags are not included in object description explicitly, they are added to the description automatically for the purposes of computing the weights in the tag cloud.
This ensures that even if certain tags do not accumulate enough weight to appear in the visible portion of the tag cloud, they add weight to their super-tags, and will still be accessible through those super-tags.
In this section we describe how the concepts introduced at an abstract level in the previous section can be applied in practice, using the set of Yahoo Pipes modules as an example of a set of feed processing services.
De nition 6.
The set of solutions S(T, F , g) to the goal-driven composition problem P(T, F , g) is the set of all valid compositions F of operators in F such that
 The Yahoo Pipes modules for processing feeds are only available through the visual editor.
Therefore, MARIO can
 <flowInput name="SearchQuery"/> <call name="yAnswers" class="com.example.URLBuilder"> <input name="prefix" value="http://answers.yahoo.com/rss/searchq"/> <input name="suffix" link="SearchQuery"/> </call> <call name="yNews" class="com.example.URLBuilder"> <input name="prefix" value="http://news.search.yahoo.com/news/rss"/> <input name="suffix" link="SearchQuery"/> </call> <call name="fetchNews" class="com.example.FetchFeed"> <input name="url" link="yNews"/> </call> <call name="fetchAnswers" class="com.example.FetchFeed"> <input name="url" link="yAnswers"/> </call> <call name="truncNews" class="com.example.Truncate"> <input name="feed" link="fetchNews"/> </call> <call name="truncAnswers" class="com.example.Truncate"> <input name="feed" link="fetchAnswers"/> </call> <call name="union" class="com.example.Union"> <input name="feed1" link="truncAnswers"/> <input name="feed2" link="truncNews"/> </call> <call name="sort" class="com.example.Sort"> <input name="feed" link="union"/> </call> <flowOutput link="sort"/> </flow> Figure 5: Example  ow description.
compose a  ow of Yahoo Pipes modules, but cannot deploy it as a pipe.
Deploying a  ow is necessary, however, to show the preview of  ow output in MARIO interface (Figure 4).
To overcome this di culty, as part of our implementation we have built a simple Java-based runtime that plays the same role.
Each service in this runtime implements interface Service with a single public method named process that receives and returns a hashmap containing input and output object values: interface Service { Map<String,Object> process(Map<String,Object> inputs); } The set of hashmap keys used to identify input and output objects in the input and output hashmaps is speci c to each service.
A separate description is provided to specify the hashmap keys recognized by the service, as well as tag-based annotations on inputs and outputs.
This description is then used to construct a description of an operator.
Service implementation can invoke web services for advanced processing, such as language translation, when necessary.
A simple XML format is used to de ne a  ow and deploy it in the runtime.
Once deployed, the  ow can be called with user-de ned values of parameters, and will produce results.
Figure 5 presents a sample description corresponding to the  ow shown on Figure 1.
Flow de nition consists of  ow inputs (i.e., external parameters), calls (i.e., operator instances) and a  ow output.
The call elements instruct runtime about the Java classes to be used to process data, and the input objects to be included in the input map.
The objects can be speci ed as string values by specifying value attribute, or linked to outputs of other calls by specifying a link.
In the example above, each output map contains just one element, so specifying the name of the call is su cient to describe a link.
Otherwise, for operators that produce more than one object,  callName.elementName  notation is used.
MARIO requires descriptions of services, feeds, parameters, and taxonomies.
These descriptions are translated into tag {_URL - _Format} tag {_Feed - _Format} tag {_Source - _StickyTag} tag {FrontPage - _Source} tag {Opinion - _Source} tag {Travel - _Source} tag {News - _Source} tag {Newspaper - News} tag {Blog - _Source} tag {NewYorkTimes - Newspaper} tag {NYTFrontPage - NewYorkTimes FrontPage} tag {Yahoo - _Source} tag {TruncatedFeed - _FeedLength} tag {FullFeed - _FeedLength} tag {InForeignLanguage -_Language} tag {InEnglish - _Language} tag {InFrench - InForeignLanguage} tag {Sorted - _SortOrder} tag {_NotSorted - _SortOrder} tag {NaturalOrder - _NotSorted} tag {Unsorted - _NotSorted} Figure 6: Fragment of a tag taxonomy.
operators and other elements of the model described in Section 4, which is then used by the planner to generate  ows.
All descriptions can be speci ed in one  le or broken into multiple  les, which are then automatically combined into one logical  le before processing.
Taxonomies are described by specifying sub-tag relationships between tags.
A tag does not need to be explicitly declared before it is used, but a tag{} statement is necessary to declare parents of a tag, which follow after  - , for example: tag {NYTFrontPage - NewYorkTimes FrontPage}.
Tag names beginning with underscore     are hidden tags that are never displayed in user interface, but otherwise behave as normal tags.
Hidden tags can be used to express composition constraints that are internal to the system, for example, type constraints.
The special tag   is represented as _StickyTag.
Figure 6 shows a fragment of tag taxonomy used in our experiments.
In the example of feed description below the output annotation uses tags to describe the content of the feed, as well as its language.
feed NYTFrontPage { output{ NYTFrontPage InEnglish _URL } url {http://www.nytimes.com/services/ xml/rss/nyt/HomePage.xml} } Such descriptions can be generated automatically, for example using Syndic8 tags and default values for language.
The description is translated into an operator that has no inputs, and produces a single output object tagged with all tags used in output annotation.
If this operator is included in a  ow composed by the planner, during  ow execution the runtime will bind the corresponding operator instance to a builtin service that returns the URL string as a single entry in the hashmap of output objects.
Service Descriptions Each service can have a number of inputs and outputs.
Service description is directly translated into an operator that requires and produces the corresponding number of objects.
For example, the following describes a FetchFeed service.
service TranslateEnFr { java {com.example.FetchFeed} var {?lang - _Language} input[url]{ ?lang _URL } output{?lang FullFeed NaturalOrder _Feed Text} } This description uses a variable ?lang of type _Language, and declares an input and an output.
The output list enumerates tags added by the operator.
Tags that are preceded with ~ are interpreted as removed tags.
Note that sub-tags of _Language are not sticky (i.e. are not derived from the special tag   represented as _StickyTag), and therefore must be propagated explicitly from input to output using a variable.
However, if FetchFeed operator is applied to the output of the feed operator in the example above, NYTFrontPage tag will be propagated to the output of FetchFeed as well, since that tag is sticky according to the taxonomy in Figure 6.
Each input and output in the description can have a port name speci ed in square brackets.
In this example only the input has a port name  url .
The port name is the name of the entry in the hashmap that is used to carry the corresponding input or output object.
Since there is only one output port, the runtime does not need to know the name of the output object.
Finally, java description element speci- es the name of the Java class that implements the service.
Flows that take external parameters can also be composed using the same framework.
When two or more services within a  ow are parametric, the planner can decide whether to expose the service parameters as one input parameter of the  ow, or as several separate parameters.
This is achieved by using tags to describe service input parameters (as inputs to services), and representing parameter values similarly to feeds, i.e. as operators that produce a single object described by tags.
The following is an example of service description that has an external parameter.
param Destination { default{London} output{_SearchQuery Travel} } service YNewsSearchURL { java {com.example.URLBuilder} input[prefix]{"http://news.search.yahoo.com/news/rss"} input[suffix]{_SearchQuery} output{_URL YahooNews InEnglish} } Service YNewsSearchURL has two inputs, but the corresponding operator will have only one input.
The constant string in quotes is used to initialize the prefix parameter to a constant.
In the plan suffix parameter will be connected to the object produced by the operator corresponding to Destination service.
Note that including constants into the description makes it possible to specify di erent semantic descriptions for di erent con gurations of the same service.
The following examples from the sample application further illustrate di erent services that can be described in this model.
service Truncate10 { java {com.example.Truncate} var {?lang - _Language} var {?sort - _SortOrder} input[feed]{_Feed input[length]{"10"} output{_Feed ?lang ShortFeed ?sort} } ?lang FullFeed ?sort} java {com.example.Translate} var {?len - _FeedLength} input[feed]{_Feed input[fromLanguage]{"en"} input[toLanguage]{"fr"} output{_Feed InFrench ?len NaturalOrder} } InEnglish ?len NaturalOrder} service Union2 { java {com.example.UnionOfTwoFeeds} var {?lang - _Language} var {?len - _FeedLength} input[feed1]{_Feed input[feed2]{_Feed output{_Feed ?lang ?len Unsorted} } ?lang NaturalOrder ?len} ?lang NaturalOrder ?len} These descriptions were used in the application shown in Figure 4.
In addition to the goal shown in that  gure, the application supports a set of interesting goals, such as NewYorkTimes InFrench, Technology News ByDate, NewYork-Times Flickr Image, etc.
We will continue using this application for illustration in the next section, where it is used as a benchmark to evaluate planner performance.
To compose  ows according to the semantic model described in Section 4, we have developed an improved version of SPPL planner [11] by proceeding with both plannability exploration and analysis of related goals.
We also added functionality necessary for generating tag clouds.
The semantic model naturally maps to SPPL formalism, which describes the planning domain as a set of actions that can be composed by the planner.
The set of actions is created based on the set of operators.
Action preconditions, described by predicates, are created based on operator input conditions.
Tags are represented as types in SPPL, and preconditions are speci ed using a variable of the corresponding type.
Action e ects also are mapped to operator outputs.
SPPL predicate propagation mechanism is used for propagation of sticky and regular tags.
During the presolve phase the planner performs action grounding and obtains results of preliminary problem structure analysis that are later used for optimizing the search.
Intelligent Grounding.
Grounding of actions during presolve may lead to a combinatorial explosion in the number of actions.
To avoid the explosion, the planner performs grounding intelligently.
First, it analyzes the set of ground actions in the  rst tier, i.e. those actions that can be applied directly in the initial state.
Next, it creates the set of possible groundings for actions that can be applied to the results of the actions in the  rst tier.
This procedure is repeated, until a steady state is reached, and no new ground actions are created.
Source Grouping.
Source actions are actions that do not have inputs.
Such actions correspond to operators without inputs, and most often correspond to feeds.
In certain cases it is possible to combine multiple sources into one action to reduce the total number of actions considered by the planner.
In particular this is possible when the output description of two sources cannot be distinguished using any of the input conditions of other actions, i.e. all input conditions are either satis ed or not satis ed by both sources.
Source grouping procedure is carried out after grounding,
  gurations with large number of sources.
Construction of an Action Graph.
The planner analyzes compatibility of inputs and outputs of ground actions by comparing the e ect and precondition predicates.
This procedure helps the planner to eliminate connections between incompatible actions during search.
The result of this domain preprocessing is an action graph where directed edges represent potential connections between an e ect of one ground action and precondition of another ground action.
Action graphs can contain cycles.
An important property of the action graph is that for any connection between action instances in any valid plan there is a directed edge between the corresponding ground actions of the action graph.
In addition to speeding up the search, an action graph can be used for reachability analysis.
If the planning task has a solution there must be a path from all goals in G to at least one of the initial state object.
During presolve, the planner builds shortest path trees from the goals to all nodes of the action graph.
Actions that are not on any of the paths from goal to initial state are labeled as disconnected and are not considered during plan search.
The shortest distances to the goal in action graph are used to direct plan search.
The planner searches for plans using a forward search strategy.
It creates new objects by applying actions that have satis ed preconditions.
At the initialization of the algorithm the current set of objects S is empty.
A set of actions  L is also created, containing the ground actions for which all preconditions can be satis ed by objects contained in S. The planner applies actions from  L one by one.
The ground action to be applied next is an action from  L that has the least distance to the goal based on reachability analysis.
The action is skipped if the cost of the associated subplan is higher than the cost bound ~B.
When applied, a new action instance produces a set of new objects, one object for each e ect.
The predicates on the new objects are computed using predicate propagation rules, and the objects are added to S. New candidate action instances are determined using the action graph and added to  L.
Algorithm SPPL Planner( ) Presolve Action set  A   Intelligent Grounding( ).
 A   Source Grouping(  A); G(  A)   Action Graph(  A); Forward Search S   I;  L   (cid:8) a    A |prec( a)   S (cid:9); for each  a    L for each  a   instances( a, S, G(  A)) if ~cost(subplan( a))   ~B and (cid:2) o   e ect( a) : o 6  S or
 (cid:2)p   subplan( a) and ~cost(subplan( a))   ~cost(p)(cid:3)(cid:3) S   S   {e ect( a)} ;  L    L   n a     A|prec( a )  G(  A) e ect( a)o; if  g   G : e ect( a)  G(  A)  g and G   S add plan candidate((subplan( a)));  L    L \ { a} ;











 The same object can be produced by many di erent sub-plans, and each time the same object is produced, a sub-plan (i.e. a set of action instances and their connections) for producing the object is registered.
The subplan has an associated cost vector.
Once a subplan is registered, the action graph is used to create a list of candidate new actions that can be applied next.
The search algorithm terminates when no actions can be applied and no new objects can be produced.
An important optimization technique used during plan search is a veri cation step (line 7) that prevents registration of a new subplan, if the same object can be produced by a subset of that subplan with lower or equal cost.
For many actions the predicates of the output satisfy the input preconditions, and without this veri cation step the search would cycle producing new identical instances of the same object.
Hence, the number of action instances created by the planner is signi cantly reduced in those cases.
The original backward search based SPPL planner [10] does not perform the comparison step, which is di cult to implement in backward search, and our forward search planner is therefore signi cantly more e cient on this type of planning tasks.
The result of the search is a set of candidate plans that satisfy the goals.
The candidate plans are then sorted by cost, and only the best plans are returned.
Note that the search can be terminated early, producing only a subset of possible candidate plans.
Hence, it is possible to obtain a number of suboptimal plans before the search  nishes, which can be important if planning time is limited.
The same algorithm can be enhanced to generate tag clouds while searching for plans.
The tag weight computation for the tag cloud uses tag membership statistics that are collected from descriptions of outputs of candidate plans.
As is shown in [10], SPPL planner performs much better in typical  ow composition problems than AI planners.
Problems that are easily solved by SPPL planner can at the same time be very di cult for the best general AI planners.
By making objects a part of the domain model, SPPL planner avoids unnecessary grounding and symmetries, and the search space is reduced by an exponential factor as a result.
However, the problem of  nding optimal plans remains a di cult one.
In general, there do not exist optimal or constant-factor-approximation SPPL planners that can guarantee termination in polynomial time on all tasks unless
 In particular, Bylander has shown that STRIPS planning, which is a special case of general SPPL planning, is PSPACE-complete [3].
Nevertheless, we have shown empirically that our planner can  nd plans for large tasks in very short time [11].
We have measured the response time of the  ow composer by measuring the time it takes to generate a  ow and a tag cloud for a given goal.
In MARIO user interface this is a measure of the delay between user changing the current goal using one of the controls, and rendering of the next screen.
Since the performance of the runtime can be variable, we did not include the time to deploy the  ow, run it and render results.
The measurements were taken on a PC with a dual-core Intel CPU at 1.86GHz and 1GB RAM.
As a  rst experiment we have created descriptions of several feeds and Yahoo services modules (including translation, sorting, truncation, union and keyword extraction) together with descriptions of external input parameters resulting in

 the user interface took 5 seconds or less.
To experiment with larger sets of descriptions, we have imported additional descriptions of feeds from Syndic8.com.
Planning times (in seconds) for several sample goals in this setting are presented in the table below.
The columns correspond to the number of described feeds.
 rst tag cloud ( any feed  goal) {Sorted, Travel, YAnswers, YNews} {NewYorkTimes, InFrench} {NewYorkTimes, Image}














 As these results show, MARIO can provide instantaneous response to user requests while analyzing large sets of feeds and creating complex  ows and tag clouds, and quickly generate user interface screens, such as Figure 4.
Work has been done on automatic goal-driven composition in the past, especially within the AI planning and semantic web communities.
Some of this work uses ontologies and associated standards such as OWLS to describe components used in composition [13].
Other work uses process models or transition systems [9].
In this work we developed a radically simpli ed tag-based component description approach to reduce the knowledge engineering work required upfront in order to start using an automatic composer.
Other di erences of our approach are the innovative  wishful search  abstraction and the underlying formalism of planning using tag taxonomies and actions that create new objects.
In prior work, earlier versions of this formalism called SPPL were used for stream processing and ontology-based semantic web service composition [10, 11, 6].
In the current work we have signi cantly extended the SPPL planner to add support for tag taxonomies, tag-based operator descriptions, added tag cloud computation functionality, and developed an innovative user interface based on tag clouds.
A formalism that is similar in expressivity to SPPL, and in certain aspects exceeds it, has been proposed in Semantic Streams system [14], which allows users to pose queries based on the semantics of sensor data.
We believe that SPPL planners are a better choice MARIO, since they can be extended to compute tag clouds and have been shown to be highly scalable with the number of operators [10, 11].
Interesting results have also been published on intelligent and incremental interaction with users, that are in the same spirit as the interactive goal re nement in MARIO.
ACE [2] helps users incrementally formalize text statements by making formalization suggestions based on ontologies.
RIA [16] can interpret multimodal inputs, including typed-in text, and dynamically  nds information that is tailored to user s interaction context, including interaction history.
However, we are not aware of any prior work that proposed taxonomy-supported iterative re nement of composition goals and making use of planner output generated for partial goals.
We have developed MARIO, a tool for automatic data mashup composition that implements a new  wishful search  pattern of interaction with the user.
In a wishful-search-enabled catalog of feeds and services, users state their wishes by selecting tags that describe a feed that they would like to subscribe to.
The composer then matches their request to an existing feed, as in regular search, or, if such a feed does not yet exist, it  grants the wish  by producing a new feed using an automatically composed  ow.
It also helps users understand what they can wish for, by providing context-dependent controls for re ning the requests.
In this paper we show that all of this can be done very e ciently and in real time, which opens many application possibilities.
We believe that wishful search is a general user interaction pattern that can be implemented in a wide variety of systems.
To become useful within a system, it only requires the system to have documents and components that process documents.
One important application is Web Service composition.
In that scenario, the pattern also helps addresses the problem of dynamic web service discovery, by re ect-ing changes to service descriptions in the results of wishful search.
Other potential application areas include Stream Processing and Grid, or any other component-based system where the end users will bene t from interactive goal-driven composition provided by wishful search.
