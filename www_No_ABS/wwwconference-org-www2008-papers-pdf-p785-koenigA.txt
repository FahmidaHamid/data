The Web Services Business Process Execution Language (WS-BPEL, or BPEL for short) o ers a standards-based approach to build distributed applications for business-to-business interactions.
A BPEL process implements one Web service by specifying the interactions with other Web services.
This allows for building  exible business processes by orchestrating multiple other Web services.
Such applications then follow the architectural pattern of a service-oriented architecture (SOA).
Business processes implemented in BPEL are a key element in an SOA infrastructure.
The BPEL speci cation [3] distinguishes two di erent kinds of business processes: executable processes and abstract processes.
Whereas executable processes must contain all the details that are necessary to be executed by a BPEL engine, abstract processes are not executable and can have parts where things are left unspeci ed or explicitly marked as opaque (i. e., hidden).
For abstract processes, the BPEL standard provides two concrete pro les: the Abstract Process Pro le for Observable Behavior (APPOB) and the Abstract Process Pro le for Templates (APPT).
This is done for di erent reasons: The APPOB handles the bottom-up way of providing a protocol description generated out of an executable process, where in contrast the APPT describes a top-down re nement use case where abstract processes can be used as an exchange format between di erent roles within an enterprise.
The abstract process pro les are used to de ne permitted completions of abstract BPEL processes to executable BPEL processes.
Figure 1 illustrates the relationship between abstract and executable processes as well as abstract process pro les.
Both use cases for abstract processes have in common that the abstract process de nition is regarded as a spec-i cation, where an executable process can then be seen as one implementation thereof.
When one artifact serves as
 As pointed out in the introduction, both existing pro les are too strict to decide compatibility.
In this section, we will introduce the existing pro les in more detail as well as showing an example to illustrate this problem.
The BPEL standard introduces the notion of abstract processes.
Abstract processes are either used to hide language elements of an executable process, or are not yet fully speci- ed.
As mentioned before, in one use case abstract processes can serve as a protocol description.
While WSDL operations describe stateless interactions, BPEL processes usually implement stateful Web services which require their exposed operations to be invoked in a particular order.
Therefore, in order to interact with a partner, a business process provider must not only provide a description of the stateless WSDL interface, but he also might want to specify the interaction protocol.
This interaction protocol can be represented by an abstract process that shows the externally observable behavior of an executable process while hiding other process model elements.
In other words, it describes a service contract ful- lled by a corresponding executable process and avoids the disclosure of internal (potentially con dential) business process logic.
This is achieved by taking an executable process and making it more coarse grained by omitting everything that does not belong to the actual observable behavior.
A partner interacting with that process would then have to adopt to that behavior in order to deduct his own structure.
For the partner interaction aspect of this, there also has been work [21, 19, 20] on how to (semi-)automatically create such an abstract partner process out of a given executable one.
In a second use case, an abstract process serves as a template for further re nement.
To illustrate this, imagine a business analyst capturing and sketching out a business process, recording it as an abstract process by omitting all the technical details, then handing it o  to an IT department in order to add details required for the process to become executable which are not relevant for the business.
Such an abstract process may have been generated by business-level process modeling tools like IBM s Websphere Business Integration Modeler or even by transforming UML into abstract BPEL, for example by using special UML stereotypes [4].
The BPEL standard de nes the Common Base (cf.
Fig. 1), describing the syntax of an abstract process and two types of transformations between abstract and executable processes.
The  rst transformation is a replacement of explicitly modeled opaque activities of an abstract process by activities of an executable process.
The second transformation consists of inserting entities of an executable process at speci c places in a process model.
Reordering of activities, removing of activities, or changing the control  ow is never permitted.
Based on these transformations, the common base de nes two relations between an abstract process and a set of executable processes, the Executable Completion and the Basic Executable Completion.
The Executable Completion allows using both transformations and requires that the resulting executable process satis es all WS-BPEL static validation rules.
The Basic Executable Completion is a more restrictive executable completion, since it limits the allowed transformations, e.g.
it is not allowed to add start activities.
Beyond these general syntactical transformations, the speci cation further allows de ning additional syntactical restrictions by Figure 1: Relationships between abstract processes, executable completions, and abstract process pro les.
a speci cation and one artifact provides an implementation of that speci cation, obviously there must be a way to ensure that they are compatible.
The BPEL speci cation calls an executable process compatible to an abstract one if  the executable process is one of the executable completions in the set of permitted completions speci ed by the abstract process pro le .
The de nition of an executable completion stops at a syntactical level.
Additional syntactic rules are provided by pro les addressing particular use cases.
These rules restrict the set of allowed executable completions.
It can easily be imagined that a compatibility notion can be created at a behavioral level   a technique that is not provided by the BPEL speci cation and thus not applicable to BPEL processes yet.
Furthermore, especially the APPOB imposes restrictions that are unnecessary and too strict from a behavioral compatibility point of view.
To show this, we will present a formal model for service contracts and will then extend the existing APPOB by de ning two relations, a conformance and an behavioral equivalence relation.
To this end, we de ne a novel abstract process pro le, the Abstract Process Pro le for Globally Observable Behavior (APPGOB, cf.
Fig. 1).
This augmented version of the APPOB will then allow for more  exibility when creating an executable process that conforms to its abstract process.
For this purpose, we use a theory on contract-based service composition based on Petri nets.
It includes a local conformance criterion, an algorithm to decide conformance, and transformation rules to derive an implementation that conforms to a speci cation.
The paper is structured as follows: Section 2 introduces the existing pro les and their restrictions and gives an example why these pro les are regarded as too strict.
Section 3 presents a formal model for services, based on which an augmented, more liberal pro le is presented in Sect.
4.
Section 5 shows the augmented pro le in action by revisiting the initial example.
Finally Sect.
6 and 7 sketch related work and conclude the paper.
common base(syntax rules)AP(set of abstract processes)EC(set of compatibleexecutable processes)APPOB(observable behavior)APPT(templates)APPGOB(the novelpro le)setECOB (cid:15466) ECsetECT (cid:15466) ECsetECGOB (cid:15466) ECbasicexecutablecompletionexecutablecompletionexisting pro les786WWW 2008 / Refereed Track: Web Engineering - Web Service CompositionBeijing, Chinameans of pro les.
These additional rules syntactically specify a subset of executable processes.
As already mentioned, the BPEL speci cation provides two concrete pro les for the two use cases described above, the APPOB and the APPT (cf.
Fig. 1).
In this paper, we will take a closer look at the  rst pro le.
The set of executable completions of an abstract process is restricted by this pro le such that the externally observable interactions de ned in the abstract process are preserved in all of its executable completions.
In other words, while creating an executable process, no transformation must be applied that modi es interactions via partner links already de ned in the abstract process.
According to the APPOB, in abstract processes in partner interactions are allowed to be opaque,   join conditions are not allowed to be hidden,   the exit activity must not be inserted,   only attributes referencing variables and message parts   opaque from-specs are allowed,   endpoint references must not be assigned to/from partner links in a way that the interaction behavior across existing partner links is a ected,   the nesting structure of composite activities around any activity in an abstract process remains unchanged (e. g., it is disallowed to insert a loop activity as a new parent of an existing activity),   the ability to introduce new branches, handlers, links to existing activities, or scoped declarations is substantially restricted, in particular, modi cations must be avoided which a ect the branching behavior in a way that con icts with the speci cations in the abstract process, and   the ability to throw new faults is limited to avoid affecting the existing control  ow.
Furthermore, new partner links may be added and used in additional communicating activities.
As an example, consider the abstract BPEL process of Fig. 2.
It describes the abstract process of a travel agency that communicates with three parties: a client service, a hotel service, and an airline service.
After receiving a travel request of the client, the travel agency prepares two orders for the hotel and the airline reservation system.
As these preparations are highly data-dependent and do not a ect the observable behavior of the travel agency, these activities are speci ed opaquely.
Then, the respective orders are forwarded to the hotel and the airline partner which return their respective o er.
Finally these o ers are merged and sent to the client.
The APPOB speci es a set of derivable executable completions of this abstract process.
Being compatible to the abstract process (i. e., the public view) of the travel agency, they have the same observable behavior in common.
The goal of this paper is to introduce a novel abstract pro le that extends the APPOB.
This pro le should extend the set of compatible executable completions and thus make the implementation of the abstract process more  exible.
Considering the travel agency service, the following variations should be allowed:   The opaque activities describing the preparations of the orders for the hotel service and the airline service Figure 2: Abstract process describing the observable behavior of a travel agency service.
do not need to be implemented in two distinct activities.
Instead, a single activity (maybe embedded into a loop) should be allowed in a compatible executable completion.
  The order in which the reservation requests are sent to the hotel and the airline should be more relaxed.
The hotel and the airline do not communicate with each other and therefore cannot realize whether the hotel reservation request is sent before or after the airline reservation request.
Thus, any reordering or even a concurrent execution of the invoke activities sending the requests should be allowed if an asynchronous message binding is assumed.
  Likewise, a reordering or concurrent execution of the receive activities should be allowed, again assuming an asynchronous message binding.
For this and other variations, we will present transformation rules that ensure equivalence of the observable behavior.
In Sect.
5, we present their application to the travel agency service.
In [2], we proposed an approach for a contract-based composition of services which is based on formal models of services.
A formal service model can be generated from a real (BPEL) speci cation using, for instance, the feature-complete Petri net semantics [17] for BPEL which is available as an implemented translation from BPEL to Petri nets using the tool BPEL2oWFN [19].
On the level of service models, a strategy of a given  nite state service S is another  nite state service S(cid:48) with compatible interface such that the composition of S with S(cid:48) forms <process name="travel_agency" ...><partnerLinks><partnerLink name="client" ... /><partnerLink name="hotel" ... /><partnerLink name="airline" ... /></partnerLinks><sequence><receive partnerLink="client"operation="travel_request"variable="##opaque" /><opaqueActivity name="prepare hotel order" /><opaqueActivity name="prepare airline order" /><invoke partnerLink="hotel"operation="hotel_request"inputVariable="##opaque" /><invoke partnerLink="airline"operation="flight_request"inputVariable="##opaque" /><receive partnerLink="hotel"operation="hotel_offer"variable="##opaque" /><receive partnerLink="airline"operation="flight_offer"variable="##opaque" /><opaqueActivity name="merge offers" /><invoke partnerLink="client"operation="travel_offer"inputVariable="##opaque" /></sequence></process>787WWW 2008 / Refereed Track: Web Engineering - Web Service CompositionBeijing, Chinaa deadlock free  nite state system.
In [20], we show that we can compute a  nite representation for the set Strat(S) of all strategies of a given service S. We call this representation an operating guideline for S as it describes all correct interaction scenarios with S. The computation of an operating guideline is implemented in our tool Fiona [19].1 In the approach of [2], a contract is a set of service models (one for each party involved in the contract) such that their composition is deadlock free.
Each of these services is called a public view of one party s contribution to the overall process.
The veri cation of deadlock freedom is indeed feasible as all public views are available to each participating party.
In contrast to a public view, a private view is the actual implementation of a party s contribution to the overall system.
That is, the composition of the private views forms the implementation of the contract.
In order to ensure deadlock freedom of the implementation, we proposed a criterion that relates public and private views of a single party.
A private view Pr conforms to a public view Pu (of the same party) if and only if Strat(Pu)   Strat(Pr ).
Intuitively, this means that every strategy of the public view must be a strategy of the private view.
If all private views conform to their respective public views, we can show that the implementation of a contract inherits deadlock freedom from the contract itself.
The actual value of this approach is that conformance between public and private view can be checked locally by each party (using the concept of operating guidelines mentioned above), thus being able not to disclose trade secrets which might be present in a private view.
In our formal model, we assume asynchronous communication (i. e., messages can overtake each other) between the involved parties.
Some preliminary considerations on synchronous communication, however, suggest that similar results can be obtained for synchronous, or even a mixture of synchronous and asynchronous communication as well.
In [1], we extended this approach with a set of (syntactic) rules for transforming services such that the conformance relation is established between the input of a transformation and the resulting service.
This way, a conforming private view can be systematically derived from a public view.
Using the formal model introduced above, we are able to In par-formally reason about the behavior of a process.
ticular, we are able to de ne rules that restrict the set of permitted executable completions that are motivated by the semantics of a process instead of its syntax.
These rules are less restrictive than the rules of the APPOB and thereby are suitable to extend BPEL s compatibility relation.
The APPOB in BPEL allows adding new partner links and communicating activities using these new partner links.
We introduce a variation of the APPOB that preserves the externally observable behavior globally; that is, the set of all partner links and interactions across these partner links remain invariant.
In order to do so, we take the existing APPOB and introduce a new pro le, the Abstract Process Pro le for Globally
 http://www.informatik.hu-berlin.de/top/tools4bpel.
Observable Behavior (APPGOB).
The only di erence to the existing pro le is that we do not allow adding new partner links as part of the executable completion.
Therefore, in a sense, we thereby restrict the set of executable completions.
Furthermore, in the BPEL speci cation, the common base is too restrictive in only allowing replacements of opaque entities and insertions of additional executable entities.
There exist a number of cases where the reordering of activities as well as the deletion of activities can be tolerated if these transformations do not a ect the main intention of the pro le.
The APPOB (as well as the more restrictive APPGOB) concentrate on interactions across partner links.
Other activities like simple assignments do not need to be handled in such a restrictive fashion.
For example, several assignment operations may be independent in the sense that reordering them has no e ect on the externally observable behavior of the process.
Therefore, we introduce a new relation we call  behavioral equivalence .
The purpose of this relation is to extend the set of executable completions to a set of executable processes exposing the same observable behavior.
We de ne our behavioral equivalence relation as follows: De nition 1.
Let ep1 and ep2 be executable processes.
Then ep1 is behavioral equivalent to ep2 if and only if ep1 can be created out of ep2 by applying zero or more of the following eight transformation rules:







 (cid:121) In the following, we introduce the above mentioned rules.
We distinguish between the  rst four rules on the one hand as they consider only non-communicating activities and the remaining rules for communicating activities on the other hand.
For each rule we present a textual description and an illustrating example by help of a code snippet.
On the left hand side of each example the part of the existing BPEL process is shown while on the right hand side the respective part after applying the transformation is illustrated.
We have identi ed the following four rules for non-com-municating activities: Rule 1: Looping Existing Activity.
Given a sequence of activities, we can embed a present non-communicating activity into a  nite (while/repeatUntil/forEach) loop.
Example for Rule 1: Although the common base already allows for inserting activities, it does not consider that a present non-communica-ting activity can be embedded into a loop.
<sequence><activity1 /><activity2 /><activity3 /></sequence><sequence><activity1 /><while><condition /><activity2 /></while><activity3 /></sequence>788WWW 2008 / Refereed Track: Web Engineering - Web Service CompositionBeijing, ChinaRule 2: Activity Removal from Sequence.
A non-communicating basic or structured activity can be deleted from a sequence of activities.
Example for Rule 2: Rule 6: Receive-Flow Serialization.
A  ow of receive activities can be transformed into a sequence.
Example for Rule 6: Rule 6 is the analogous of Rule 5; that is, n receive activities being concurrently executed in a  ow can be executed in any sequential order without changing the observable behavior.
Rule 7: Invoke and Receive.
A sequence of  rst a one way invoke activity and then a receive activity can be transformed into a  ow.
Example for Rule 7: Applying Rule 7 allows to increase the amount of concurrency in the BPEL process without a ecting the observable behavior.
In case of synchronous binding, a partner has to be the mirrored process, meaning it consists of a sequence of  rst a receive activity and then a one-way invoke activity.
Thus, it will not be a ected by the transformation.
Otherwise, in case of asynchronous binding, a partner can also consist of a  ow embedding a receive activity and a one-way invoke activity which is also not a ected by the rule.
Rule 8: Communicating If-branches If there is a BPEL process P with an if activity, where each branch starts with an invoke activity and P  s partner process has a pick activity in which each branch corresponds to one of the invoke activities in the if activity, then a branch can be removed from the if activity.
Example for Rule 8 (the rule is illustrated on top, below the expected partner is shown): The common base allows for inserting an activity.
That means, we can apply the transformation illustrated in the above example in the other direction as well.
However, also removing an activity from a sequence does not change the observable behavior.
Rule 3: Activity Removal from Flow.
A non-communicating basic or structured activity can be deleted from a  ow.
Example for Rule 3: Like for the last rule, the common base only considers activity insertion but not the removal of an non-communi-cating activity from a  ow.
Rule 4: Activity Reordering.
A sequence of solely non-communicating basic or structured activities can be arbitrarily reordered.
Example for Rule 4: Since we are allowed to remove and to insert non-commu-nicating activities, we can consequently also reorder non-communicating activities that are sequentially ordered.
It is important to mention that applying these rules must not violate data-dependencies between activities.
Next we introduce four additional rules that change the order of communicating activities.
Rule 5: Invoke-Flow Serialization.
A  ow of one-way invoke activities can be transformed into a sequence.
Example for Rule 5: If n one-way invoke activities are concurrently executed in a  ow, then these activities can be executed in any sequential order without changing the observable behavior.
Rule 5 re ects the fact that every permutation of the one-way invoke activities is a possible execution sequence due to the concurrency in the  ow activity.
Informally spoken, applying Rule 5  xes one of these sequences and hence restricts the behavior of the process.
(cid:34)(cid:20)(cid:8)(cid:18)(cid:22)(cid:8)(cid:15)(cid:6)(cid:8)(cid:35)(cid:1)(cid:1)(cid:34)(cid:4)(cid:6)(cid:21)(cid:11)(cid:23)(cid:11)(cid:21)(cid:25)(cid:30)(cid:1)(cid:28)(cid:35)(cid:1)(cid:1)(cid:28)(cid:2)(cid:4)(cid:18)(cid:9)(cid:20)(cid:9)(cid:18)(cid:22)(cid:25)(cid:1)(cid:23)(cid:29)(cid:1)(cid:1)(cid:34)(cid:4)(cid:6)(cid:21)(cid:11)(cid:23)(cid:11)(cid:21)(cid:25)(cid:32)(cid:1)(cid:28)(cid:35)(cid:34)(cid:28)(cid:20)(cid:8)(cid:18)(cid:22)(cid:8)(cid:15)(cid:6)(cid:8)(cid:35)(cid:34)(cid:20)(cid:8)(cid:18)(cid:22)(cid:8)(cid:15)(cid:6)(cid:8)(cid:35)(cid:1)(cid:1)(cid:34)(cid:4)(cid:6)(cid:21)(cid:11)(cid:23)(cid:11)(cid:21)(cid:25)(cid:30)(cid:1)(cid:28)(cid:35)(cid:1)(cid:1)(cid:34)(cid:4)(cid:6)(cid:21)(cid:11)(cid:23)(cid:11)(cid:21)(cid:25)(cid:32)(cid:1)(cid:28)(cid:35)(cid:34)(cid:28)(cid:20)(cid:8)(cid:18)(cid:22)(cid:8)(cid:15)(cid:6)(cid:8)(cid:35)<flow> <activity1 /> <activity2 /> <activity3 /></flow><flow> <activity1 /> <activity3 /></flow><sequence><activity1 /><activity2 /></sequence><sequence><activity2 /><activity1 /></sequence><sequence> <invoke operation="a" /> <invoke operation="b" /></sequence><flow> <invoke operation="a" /> <invoke operation="b" /></flow><sequence> <invoke operation="b" /> <invoke operation="a" /></sequence><flow> <invoke operation="a" /> <invoke operation="b" /></flow><sequence> <invoke operation="b" /> <invoke operation="a" /></sequence><sequence> <receive operation="a" /> <receive operation="b" /></sequence><flow> <receive operation="a" /> <receive operation="b" /></flow><sequence> <receive operation="b" /> <receive operation="a" /></sequence><flow> <receive operation="a" /> <receive operation="b" /></flow><sequence> <receive operation="b" /> <receive operation="a" /></sequence><sequence><invoke operation="a" /><receive operation="b" /></sequence><flow><invoke operation="a" /><receive operation="b" /></flow><flow><invoke operation="a" /><receive operation="b" /></flow><sequence><invoke operation="a" /><receive operation="b" /></sequence><if><condition /><sequence><invoke operation="a" />...</sequence><elseif><condition /><sequence><invoke operation="b" />...</sequence></elseif><else><sequence><invoke operation="c" />...</sequence></else></if><if><condition /><sequence><invoke operation="a" />...</sequence><else><sequence><invoke operation="c" />...</sequence></else></if>(cid:34)(cid:17)(cid:11)(cid:6)(cid:12)(cid:35)(cid:1)(cid:1)(cid:34)(cid:16)(cid:15)(cid:3)(cid:8)(cid:20)(cid:20)(cid:4)(cid:10)(cid:8)(cid:1)(cid:16)(cid:17)(cid:8)(cid:19)(cid:4)(cid:21)(cid:11)(cid:16)(cid:15)(cid:33)(cid:29)(cid:4)(cid:29)(cid:35)(cid:1)(cid:1)(cid:1)(cid:1)(cid:26)(cid:26)(cid:26)(cid:1)(cid:1)(cid:34)(cid:28)(cid:16)(cid:15)(cid:3)(cid:8)(cid:20)(cid:20)(cid:4)(cid:10)(cid:8)(cid:35)(cid:1)(cid:1)(cid:34)(cid:16)(cid:15)(cid:3)(cid:8)(cid:20)(cid:20)(cid:4)(cid:10)(cid:8)(cid:1)(cid:16)(cid:17)(cid:8)(cid:19)(cid:4)(cid:21)(cid:11)(cid:16)(cid:15)(cid:33)(cid:29)(cid:5)(cid:29)(cid:35)(cid:1)(cid:1)(cid:1)(cid:1)(cid:26)(cid:26)(cid:26)(cid:1)(cid:1)(cid:34)(cid:28)(cid:16)(cid:15)(cid:3)(cid:8)(cid:20)(cid:20)(cid:4)(cid:10)(cid:8)(cid:35)(cid:1)(cid:1)(cid:34)(cid:16)(cid:15)(cid:3)(cid:8)(cid:20)(cid:20)(cid:4)(cid:10)(cid:8)(cid:1)(cid:16)(cid:17)(cid:8)(cid:19)(cid:4)(cid:21)(cid:11)(cid:16)(cid:15)(cid:33)(cid:29)(cid:6)(cid:29)(cid:35)(cid:1)(cid:1)(cid:1)(cid:1)(cid:26)(cid:26)(cid:26)(cid:1)(cid:1)(cid:34)(cid:28)(cid:16)(cid:15)(cid:3)(cid:8)(cid:20)(cid:20)(cid:4)(cid:10)(cid:8)(cid:35)(cid:34)(cid:28)(cid:17)(cid:11)(cid:6)(cid:12)(cid:35)789WWW 2008 / Refereed Track: Web Engineering - Web Service CompositionBeijing, ChinaRule 8 is a little bit more restricted, since it can only be applied if knowledge about the structure of the partner is available.
The idea is that since a partner has to be able to receive all sending messages of the corresponding if activity in P , it is still a partner if the number of branches (and therefore the number of invoke activities) in P will be restricted by removing a branch.
Considering executable processes that are behavioral equivalent to an executable process belonging to the set of all executable completions for a given abstract process, we can construct the transitive relationship between all equivalent executable processes and the abstract process.
De nition 2.
Let ap be an abstract process and let ep1 be an executable process, let further EC GOB denote the set of executable completions of ap allowed by the APPGOB.
Then ep1 conforms to ap if and only if there exists an executable process ep2   EC GOB such that ep1 and ep2 are (cid:121) behavioral equivalent.
Each executable process in the set ECGOB of executable completions (cf.
Fig. 1) that conforms to an abstract process exposes the same externally observable behavior.
Figure 3 illustrates the relationship between an abstract process ap, an executable process ep1 that conforms to ap and an executable process ep2 that is behavioral equivalent to ep1 as it is de ned in Def.
2.
Therefore, our proposed conformance notion extends the notion of compatibility presented in the BPEL speci cation, because it allows to relate executable processes ep1 with an abstract process ap if ep1 and ep2 are behavioral equivalent.
That way much more executable processes can be related to an abstract process which can be derived by applying the rules we have presented.
De nition 3.
Let ep1 and ep2 be executable processes.
Then ep1 is relaxed behavioral equivalent to ep2 if and only if ep1 is behavioral equivalent to ep2, or ep1 can be created out of ep2 by applying zero or more of the following three additional transformation rules:


 (cid:121) Rule 9: Invoke-Sequence Reordering.
A sequence of one-way invoke activities can be arbitrarily reordered or it can be transformed into a  ow.
Example for Rule 9: In case of asynchronous binding it is possible that if a process sends  rst a message a and then a message b, then its partner process may receive b before a.
This is caused by the fact that messages can overtake each other on a message channel.
Since a sequence of n send messages can reach the partner in any order, we can arbitrarily reorder a sequence of one-way invoke activities or even embed these activities into a  ow.
Rule 10: Receive-Sequence Reordering.
A sequence of receive activities can be arbitrarily reordered or it can be transformed into a  ow.
Example for Rule 10: For the same arguments as presented for Rule 9, we can arbitrarily reorder a sequence of receive activities or even embed these activities into a  ow by applying Rule 10.
Rule 11: Invoke and Receive.
A  ow that contains a one-way invoke activity and a receive activity can be transformed into a sequence of  rstly the invoke and then the receive activity.
Example for Rule 11: Figure 3: The relationships between compatibility, behavioral equivalence, and conformance.
Asynchronous Bindings The BPEL speci cation makes no assumptions about protocols, bindings, and quality of service attributes of interactions.
So far, all presented transformation rules are valid for both synchronous and asynchronous binding.
However, if we would assume asynchronous bindings, we can relax the behavioral equivalence relationship even further by introducing three additional transformation rules.
We therefore generalize the relation of behavior-equivalence to relaxed behavioral equivalence.
Rule 11 describes in fact the opposite direction of Rule 7.
It is only applicable in case of asynchronous bindings: Assume a process similar to the left hand side of the example.
Further assume a mirrored version of this process as a partner.
Applying Rule 11 to the process in case of an synchronous binding could lead to a deadlocking situation in the case where the message on b sent by the partner arrives before the process has sent the message on a to the partner.
Based on the results presented above, the notion of equivalent behavior can be signi cantly extended beyond BPEL s APPOB.
However, even for our extended conformance notion, there exist limitations, as shown by the following three transformation rules which are explicitly disallowed.
abstractprocessapexecutable processep2executable processep1compatiblebehaviorequivalentconformantsemantic relationsyntactic relation<sequence><invoke operation="a" /><invoke operation="b" /></sequence><sequence><invoke operation="b" /><invoke operation="a" /></sequence><sequence><receive operation="a" /><receive operation="b" /></sequence><sequence><receive operation="b" /><receive operation="a" /></sequence><sequence><invoke operation="a" /><receive operation="b" /></sequence><flow><invoke operation="a" /><receive operation="b" /></flow><flow><invoke operation="a" /><receive operation="b" /></flow><sequence><invoke operation="a" /><receive operation="b" /></sequence>790WWW 2008 / Refereed Track: Web Engineering - Web Service CompositionBeijing, ChinaAnti-rule 1.
A sequence of  rst a one-way invoke and then a receive activity MUST NOT be reordered, or vice versa.
Example for Anti-rule 1: (a) (b) Beside reordering, also a concurrent execution is disallowed: Anti-rule 2.
A sequence of  rst a receive activity and then a one way invoke activity MUST NOT be transformed into a  ow, or vice versa.
Example for Anti-rule 2: (c) (d) Figure 4: Counterexamples justifying the correctness of Anti-rules 1 and 2.
Finally, the addition and usage of new partner links is not permitted.
This anti-rule di ers from the original APPOB where this addition is explicitly allowed.
Anti-rule 3.
New partner links or communicating activities MUST NOT be added.
We discuss the motivation and the validity of the Anti-rules in the next subsection.
So far, we just listed a set of rules and left the task of ver-i cation of their correctness to the reader s intuition.
Correctness can, however, as well be formally veri ed.
To this end, it is possible to map the given rules into the formalism of Petri nets using, for instance, the semantics of [17].
It turns out that the resulting Petri net transformation rules correspond to those that have been proven formally correct in [1].
To justify the Anti-rules we show that applying these rules to a process P would exclude a partner of P in the resulting transformed process P (cid:48).
Consider again Anti-rule 1.
The process depicted in Fig. 4(a) is a partner for the left pattern in the example of Anti-rule 1, but not for the right pattern.
Furthermore, Fig. 4(b) depicts a partner for the right pattern which is no valid partner for the left pattern.
Similar for Anti-rule 2, Fig. 4(c) is a partner of the left hand side of the example in Anti-rule 2 but not for the right hand side.
In contrast, Fig. 4(d) depicts a valid partner for the right hand side but not for the left hand side of Anti-rule 2.
Anti-rule 3 excludes the addition of new partner links and new communicating activities.
While this is permitted in the original APPOB and does not a ect the observable behavior from one partner s point of view, it would change the global observable behavior by introducing  unintended  behavior.
As an example, consider the process depicted in Fig. 5.
The original APPOB would allow the addition of a partner link and the two receive activities (the bold lines of Fig. 5).
Though this addition would not a ect the partner communicating via partner link a, the addition would introduce unintended behavior: A partner communicating via partner link b would have to guess how the condition of the if activity was evaluated to decide whether to send a message Figure 5: Counterexample justifying the correctness of Anti-rule 3.
using operation b1 or b2.
Therefore, the process could either deadlock (in case the wrong operation was used) or would complete with a redundant pending message (in case both operations were used).
Both cases are certainly not desirable, though not excluded by the APPOB.
Summing up, the presented (syntactic) rules are correct, meaning, their application preserves conformance.
Correctness has been proven on the level of our formal service model.
The presented rules are, however, not complete.
In other words, there exist conforming processes that cannot be derived by applying the presented transformation rules.
Developing a complete set of conformance-preserving transformation rules seems to be rather laborious, whereas the practical relevance of such a complete set of rules is questionable.
There are additional rules not presented in this paper which are rather complicate in the sense that many assumptions have to hold and whose practical applicability is not given.
Furthermore, as an alternative to the presented transformation rules, we can check (relaxed) behavioral equivalence between two BPEL processes a-posteriori with our tools BPEL2oWFN/Fiona.
Finally, all presented rules are conceptually independent; that is, none of these rules can be derived from other rules.
<sequence><invoke operation="a" /><receive operation="b" /></sequence><sequence><receive operation="b" /><invoke operation="a" /></sequence><sequence><receive operation="a" /><invoke operation="b" /></sequence><pick><onAlarm><sequence><invoke operation="b" /><receive operation="a" /></sequence></onAlarm><onMessageoperation="a" /><invoke operation="c" /></onMessage> </pick><sequence><receive operation="b" /><invoke operation="a" /></sequence><sequence><receive operation="a" /><invoke operation="b" /></sequence><flow><receive operation="a" /><invoke operation="b" /></flow>(cid:34)(cid:20)(cid:8)(cid:18)(cid:22)(cid:8)(cid:15)(cid:6)(cid:8)(cid:35)(cid:1)(cid:1)(cid:34)(cid:19)(cid:8)(cid:6)(cid:8)(cid:11)(cid:23)(cid:8)(cid:1)(cid:16)(cid:17)(cid:8)(cid:19)(cid:4)(cid:21)(cid:11)(cid:16)(cid:15)(cid:33)(cid:29)(cid:4)(cid:29)(cid:1)(cid:28)(cid:35)(cid:1)(cid:1)(cid:34)(cid:11)(cid:15)(cid:23)(cid:16)(cid:12)(cid:8)(cid:1)(cid:16)(cid:17)(cid:8)(cid:19)(cid:4)(cid:21)(cid:11)(cid:16)(cid:15)(cid:33)(cid:29)(cid:5)(cid:29)(cid:1)(cid:28)(cid:35)(cid:34)(cid:28)(cid:20)(cid:8)(cid:18)(cid:22)(cid:8)(cid:15)(cid:6)(cid:8)(cid:35)<sequence><invoke operation="a" /><receive operation="b" /></sequence><sequence><receive operation="b" /><invoke operation="a" /></sequence><sequence><receive operation="a" /><invoke operation="b" /></sequence><pick><onAlarm><sequence><invoke operation="b" /><receive operation="a" /></sequence></onAlarm><onMessageoperation="a" /><invoke operation="c" /></onMessage> </pick><sequence><receive operation="b" /><invoke operation="a" /></sequence><sequence><invoke operation="b" /><receive operation="a"/></sequence><sequence> <invoke operation="a" /> <receive operation="b" /></sequence><sequence> <receive operation="b" /> <invoke operation="a" /></sequence><sequence> <receive operation="a" /> <invoke operation="b" /></sequence><pick> <onAlarm> <sequence> <invoke operation="b" /> <receive operation="a" /> </sequence> </onAlarm> <onMessage operation="a" /> <invoke operation="c" /> </onMessage> </pick><sequence> <receive operation="b" /> <invoke operation="a" /></sequence>(cid:34)(cid:17)(cid:11)(cid:6)(cid:12)(cid:35)(cid:1)(cid:1)(cid:34)(cid:16)(cid:15)(cid:2)(cid:13)(cid:4)(cid:19)(cid:14)(cid:35)(cid:1)(cid:1)(cid:1)(cid:1)(cid:34)(cid:20)(cid:8)(cid:18)(cid:22)(cid:8)(cid:15)(cid:6)(cid:8)(cid:35)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:34)(cid:11)(cid:15)(cid:23)(cid:16)(cid:12)(cid:8)(cid:1)(cid:16)(cid:17)(cid:8)(cid:19)(cid:4)(cid:21)(cid:11)(cid:16)(cid:15)(cid:33)(cid:29)(cid:5)(cid:29)(cid:1)(cid:28)(cid:35)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:34)(cid:19)(cid:8)(cid:6)(cid:8)(cid:11)(cid:23)(cid:8)(cid:1)(cid:16)(cid:17)(cid:8)(cid:19)(cid:4)(cid:21)(cid:11)(cid:16)(cid:15)(cid:33)(cid:29)(cid:4)(cid:29)(cid:1)(cid:28)(cid:35)(cid:1)(cid:1)(cid:1)(cid:1)(cid:34)(cid:28)(cid:20)(cid:8)(cid:18)(cid:22)(cid:8)(cid:15)(cid:6)(cid:8)(cid:35)(cid:1)(cid:1)(cid:34)(cid:28)(cid:16)(cid:15)(cid:2)(cid:13)(cid:4)(cid:19)(cid:14)(cid:35)(cid:1)(cid:1)(cid:34)(cid:16)(cid:15)(cid:3)(cid:8)(cid:20)(cid:20)(cid:4)(cid:10)(cid:8)(cid:1)(cid:16)(cid:17)(cid:8)(cid:19)(cid:4)(cid:21)(cid:11)(cid:16)(cid:15)(cid:33)(cid:29)(cid:4)(cid:29)(cid:1)(cid:28)(cid:35)(cid:1)(cid:1)(cid:1)(cid:1)(cid:34)(cid:11)(cid:15)(cid:23)(cid:16)(cid:12)(cid:8)(cid:1)(cid:16)(cid:17)(cid:8)(cid:19)(cid:4)(cid:21)(cid:11)(cid:16)(cid:15)(cid:33)(cid:29)(cid:6)(cid:29)(cid:1)(cid:28)(cid:35)(cid:1)(cid:1)(cid:34)(cid:28)(cid:16)(cid:15)(cid:3)(cid:8)(cid:20)(cid:20)(cid:4)(cid:10)(cid:8)(cid:35)(cid:1)(cid:34)(cid:28)(cid:17)(cid:11)(cid:6)(cid:12)(cid:35)<process name="example" ...> <partnerLinks> <partnerLink name="a" ... /> <partnerLink name="b" ... /> </partnerLinks> <sequence> <receive partnerLink="a" operation="a1" ... /> <if> <condition> ... </condition> <sequence> <empty /> <receive partnerLink="b" operation="b1" ... /> </sequence> <else> <sequence> <empty /> <receive partnerLink="b" operation="b2" ... /> </sequence> </else> </if> </sequence></process>791WWW 2008 / Refereed Track: Web Engineering - Web Service CompositionBeijing, China5.
EXAMPLE REVISITED The novel abstract pro le, APPGOB, now allows the mod-i cations motivated in Sect.
2.2.
In particular, the reordering of the communicating activities can now be achieved by applying transformation rules that guarantee observable behavioral equivalence.
Figure 6 illustrates the applied transformation rules and their e ects.
We assume an asynchronous binding for the travel agency service.
Firstly, the opaque activities that organize the message sent from or to the agency are replaced by assign activities.
Then, those activities that prepare the orders for the hotel and airline reservation system are removed (Rule 2).
Instead, a new opaque activity is added and embedded into a while loop (Rule 1).
This loop allows more  exibility and an easy integration of additional parties such as, for example, a car rental agency.
Then, the invoke activities sending the requests to the hotel and the airline are embedded into a  ow activity (Rule 9).
Similarly, the responses of the hotel and the airline services are received concurrently (Rule 10).
the derived executable service (cf.
Fig. 6(b)) is relaxed behavioral equivalent to the executable process in which only the opaque activities are replaced by assign activities.
Furthermore, the executable process derived by applying the transformation rules conforms to the abstract process of the travel agency in Fig. 6(a).
Still, this process would not be considered compatible by the original
 By De nition 3,

 There are many other papers dealing with conformance notions.
Basten and van der Aalst present in [5] the notion of projection inheritance for Petri nets.
Two Petri nets are related under projection inheritance if they have the same observable behavior.
In [1] we have proven that our notion of conformance is a generalization of projection inheritance, meaning projection inheritance implies conformance.
Rules 1 4 for non-communicating activities presented in Sect.
4.1.1 preserve projection inheritance.
All other rules in uence the communicating behavior and therefore do not preserve projection inheritance.
Several authors propose conformance notions using process calculi.
Castagna et al. [14] formalize the absence of deadlocks and livelocks in  nite-state systems.
This notion is called strong compliance.
In contrast to our conformance notion, strong compliance demands the termination of the environment, but not the termination of the service itself.
Bravetti and Zavattaro [10] propose a conformance notion that guarantees the absence of deadlocks, livelocks, and in -nite runs in cyclic systems.
In [11], their correctness criterion is enhanced by ensuring whenever a message can be sent, the other service is ready to receive this message.
Systems that behave this way are called strong compliant.
Strong compliance as in [11] seems to be an adequate correctness criterion for BPEL choreographies in case synchronous bindings are used.
As a main di erence to our conformance notion, [10] and [14] de ne their notions for synchronous communication and they do not explicitly show how asynchronous message passing can be translated into their calculi although it seems to be possible in general.
A more expressive calculi which also supports name passing is used by Carbone at al. [13].
Fournet et al. [16] present stuck-free conformance, a re nement relation between two CCS processes of asynchronous message passing software components.
Stuck-freedom formalizes like our notion of deadlock freedom the absence of deadlocks in the system.
It can be shown that our conformance notion is more general than stuck-free conformance, because Fournet et al. compare the behavior of two processes N and N(cid:48) whereas we compare the set of strategies for N and N(cid:48).
Busi et al. [12] propose branching bisimulation as a notion of conformance between a choreography language based on WS-CDL and an orchestration language based on abstract BPEL.
Conformance can be used to check if the implementation (i. e., the orchestrated system) behaves accordingly the conversation rules of the choreography.
Bonchi et al. [8] model the behavior of services using a special kind of Petri nets, Consume-Produce-Read Nets.
For their model they present saturated bisimulation as conformance relation.
Both branching bisimulation and saturated bisimulation are too restrictive to allow reordering of messages.
The concept of contract conformance is also related to deciding when a service can be substituted by another service.
Most of this work, however, is restricted to synchronous communication [9, 7, 6] whereas our service model considers asynchronous message passing.
Benatallah et al. [6] present four notions of substitutability.
In this paper, we cover two of them: equivalence and subsumption.
Equivalence in our notion means that both services have the same set of strategies and subsumption means the inclusion of the set of strategies (conformance).
Lohmann et al. translate in [18] choreographies speci ed in the choreography language BPEL4Chor [15] into a Petri net model.
This model is then checked for deadlocks using the model checker LoLA [22].
To summarize, most of the work uses a synchronous communication model whereas our model is based on asynchronous message passing thus allowing to identify rules as shown in Sect.
4.3.
Furthermore, except the work on projection inheritance [5] there are to the best of our knowledge no papers about rules to derive from a service S a service S(cid:48) that conforms to S.
In this paper, we have presented a more liberal approach to decide compatibility between an abstract and an executable BPEL process.
Therefore, we de ned a novel pro le for BPEL.
This pro le is not a WS-BPEL language extension.
It should be taken as a new pro le   something that is already allowed by the standard today.
This novel pro le enhances the existing Abstract Process Pro le for Observable Behavior (APPOB) by introducing a notion for behavioral equivalence on the one hand, and restricting it by de ning explicit anti-rules on the other hand.
We have shown that with our novel pro le more executable processes can be considered conformant to an abstract process without the loss of general applicability.
Based on our notion of behavioral equivalence we have identi ed and proven a set of transformation rules.
Given an abstract process ap and an executable process ep that is compatible to ap with respect to the APPOB, these rules can be applied to derive an executable process ep(cid:48) that conforms to ap from ep.
The set of presented rules is twofold.
We have presented transformation rules being applicable
 (b) conforming executable process Figure 6: Application of transformation rules to the abstract travel agency process.
both for synchronous and asynchronous bindings and in addition, we have introduced additional (more relaxed) transformation rules in case that an asynchronous binding is used.
Checking compliance between an abstract and an executable process is not a particular strength of the BPM Tools currently available in the marketplace.
However, in cases where such a functionality is o ered, our approach has bene cial practical implications: The proposed pro le makes it much easier to  nd a compliant executable process for a given abstract one as the set of compliant processes is substantially larger than the set of executable completions in BPEL.
Thus, this may potentially save development time when creating BPM solutions.
