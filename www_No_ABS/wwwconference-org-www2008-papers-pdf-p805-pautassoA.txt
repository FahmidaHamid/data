Many different styles can be used to integrate enterprise applications (Figure 1).
The choice between relying on a shared database, using batched  le transfer, calling remote procedures, or exchanging asynchronous messages over a message bus is a major architectural decision, which in uences the requirements for the underlying middleware platform and the properties of the integrated system [20].
The  Big 1 Web services technology stack [1, 45,
 Security, etc.)
delivers interoperability for both the Remote Procedure Call (RPC) and messaging integration styles [41].
More recently, an alternative solution has been brought forward to implement remote procedure calls across the Web: so-called RESTful Web services [12] are gaining increased attention not only because of their usage in the Application Programming Interface (API) of many Web 2.0 services [32], but also because of the presumed simplicity of publishing and consuming a RESTful Web service [40].
Key architectural decisions in distributed system design, such as the choice of integration style and technology, should be based on technical arguments and a fair comparison of concrete capabilities delivered by each alternative.
Instead, the WS-* vs. REST debate has unfortunately degenerated into biased and religious arguments which create only confusion and expectations that cannot be ful- lled [19].
Application Integration StylesFile TransferShared DatabaseMessage BusRemoteProcedure CallSOAPWS*REST805WWW 2008 / Refereed Track: Web Engineering - Web Service DeploymentBeijing, ChinaIn this paper, we take a quantitative approach to compare the two integration styles technologies based on architectural principles and decisions.
The comparison is based on our industry project and teaching experience with both approaches.
This way, the relative complexity (or simplicity) of WS-* and RESTful Web services can be measured in terms of 1) the number of decisions that have to be made, 2) the number of alternatives (options) that are available, and 3) the relative cost as indicated by development effort required and technical risk involved.
As we will show, decisions may affect one another so that, e.g., deciding to use a RESTful approach at a high level will constrain the options for the choice of asynchronous messaging middleware at a lower level.
Also, in some cases, the lack of options concerning some decisions (e.g., transactional guarantees, or the reliability of the message exchange) in REST may only apparently indicate a reduced complexity because the only choice left is to implement a custom solution, which incurs higher development and maintenance effort and risk.
This paper is organized as follows.
First in Sections 2 and 3 we give background information on WS-* and RESTful Web services.
In Section 4, we introduce our decision-centric comparison methodology.
We then apply it by listing and comparing several important principles (Section 5), conceptual (Section 6) and technology (Section 7) decisions involved in adopting WS-* and REST.
In Section 8, we present related work and in Section 9 we draw our conclusions.
Providing seamless interoperability between heterogeneous mid-dleware technology stacks and fostering the loose coupling of service consumer (requestor, client) and service provider are the major design goals of Service-Oriented Architecture (SOA) concepts and Web services technologies.2
 On the conceptual level, a service is a software component provided through a network-accessible endpoint [16].
Service consumer and provider use messages to exchange invocation request and response information in the form of self-containing documents that make very few assumptions about the technological capabilities of the receiver.
In particular, there is no notion of a remote object reference that would require an object broker to manage a distributed memory address space [43].
On the technology level, SOAP is an XML language de ning a message architecture and message formats, hence providing a rudimentary processing protocol.
The SOAP document de nes a top-level XML element called envelope, which contains a header and a body.
The SOAP header is an extensible container for mes-sage-layer infrastructure information that can be used for routing purposes (e.g., addressing) and Quality of Service (QoS) con gu-ration (e.g., transactions, security, reliability).
The body contains the payload of the message.
XML Schema is used to describe the structure of the SOAP message, so that SOAP engines at the two endpoints can marshall and unmarshall the message content and route it to the appropriate implementation.
there are many ways to implement SOA.
For example, Message-Oriented Middleware (MOM) and, if programming language independence is not a requirement, message-driven Enterprise Java-Beans can be viewed as SOA implementation technologies.
In this paper, however, we concentrate on XML-based Web services as de ned by W3C and OASIS [27] and restrict the discussion to the scope of the WS-I Basic Pro le 1.1 [47].
For more information we refer the reader to [1, 45, 50].
Web Services Description Language (WSDL) is an XML language for de ning interfaces syntactically.
A WSDL port type contains multiple abstract operations, which are associated with some incoming and outgoing messages.
The WSDL binding links the set of abstract operations with concrete transport protocols and serialization formats.
At the time of writing, the only standardized binding uses SOAP over HTTP [21].
Vendors have de ned several additional ones to support messaging protocols as well as proprietary legacy system interfaces.
Service endpoints are addressed either on the transport level, i.e., with Universal Resource Identi ers (URIs) for SOAP/HTTP-bound endpoints, or on the messaging level via WS-Addressing [44].
By default, there is no notion of state.
The interaction with state-ful Web services is covered by the WS-Resource Framework [28], which handles the management of stateful resources behind a Web service interface.
The WS-* technology stack covers also many other QoS features required to ensure the interoperability of advanced middleware systems [45].
Given the modularity and com-posability of the approach, this has led to a fairly large set of WS-* speci cations.
In spite of their perceived complexity, the SOAP message format and the WSDL interface de nition language have gained widespread adoption as the gateway technologies capable of delivering interop-erability between heterogeneous middleware systems.
One advantage of WS-* is protocol transparency and independence.
Using SOAP, the same message in the same format can be transported across a variety of middleware systems, which may rely on HTTP, but also on many other transports.
The transport protocol may change along the way.
Being declared as SOAP headers, QoS aspects such as encryption and reliable transfer can be made independent from the transports used along the path ("end-to-end QoS").
Using WSDL to describe a service interface helps to abstract from the underlying communication protocol and serialization details as well as from the service implementation platform (operating system and programming language).
WSDL contracts provide a machine-processable description of the syntax and structure of the corresponding request and response messages and de ne a  exible evolution path for the service.
As business and technology requirements change, the same abstract service interface can be bound to different transport protocols and messaging endpoints.
In particular, WSDL can model service interfaces for systems based on synchronous and asynchronous interaction patterns.
This kind of  exibility becomes fundamental when building gateways for preexisting legacy systems, which may not always use Web-friendly protocols.
Furthermore, mature SOAP engines and WSDL tools [2, 11] effectively hide the perceived complexity from the application programmer and integrator.
According to our personal project experience [54], it is not required to study the speci cations to be able to develop interoperable services, assuming that the selected runtimes and tools adhere to the WS-I Basic Pro le [47].
Test clients can be generated from the WSDL contracts automatically.
Paradoxically, the power delivered by current WS-* tooling that make it so easy to turn existing software components into Web services can also be misused [35].
Thus, it is important to avoid leakage across abstraction levels.
Interoperability problems can occur when, for instance, native data types and language constructs of the service implementation are present in its interface.
This weakness
 guidelines such as contract rst development.
Given the expressivity of the WS-* stack of standards, early implementations have been plagued by interoperability problems.
Apart from misinterpretations later clari ed by WS-I, these can be partly blamed on the impedance mismatch between XML and existing (object-oriented) programming languages.
For instance, the translation between the XML on the wire and the corresponding memory data structures has been problematic and is the main source of performance inef ciencies [15].
Taking Java as an example, several attempts were necessary (Apache SOAP to JAX-RPC 1.0 and 1.1 to JAX-WS and JAX-B) to produce a stable Web service marshalling layer [25].
Furthermore, XML Schema is a very rich language, making it dif cult to identify the right construct to express a data model in a way that is fully supported by all SOAP/WSDL implementations.
This problem can be avoided with pro ling, identifying a subset of XML Schema types such as sequences which is  good enough  for most integration scenarios and known to be interoperable.
REpresentational State Transfer (REST) was originally introduced as an architectural style for building large-scale distributed hypermedia systems.
This architectural style is a rather abstract entity, whose principles have been used to explain the excellent scalability of the HTTP 1.0 protocol and have also constrained the design of its following version, HTTP 1.1.
Thus, the term REST very often is used in conjunction with HTTP.
In this section we outline the main characteristics of REST focusing on the current interpretation used to de ne  RESTful  Web services.
For more information we refer the reader to [12, 14, 33].
The REST architectural style is based on four principles: Resource identi cation through URI.
A RESTful Web service exposes a set of resources which identify the targets of the interaction with its clients.
Resources are identi ed by URIs [5], which provide a global addressing space for resource and service discovery.
Uniform interface.
Resources are manipulated using a  xed set of four create, read, update, delete operations: PUT, GET, POST, and DELETE.
PUT creates a new resource, which can be then deleted using DELETE.
GET retrieves the current state of a resource in some representation.
POST transfers a new state onto a resource.
Self-descriptive messages.
Resources are decoupled from their representation so that their content can be accessed in a variety of formats (e.g., HTML, XML, plain text, PDF, JPEG, etc.).
Meta-data about the resource is available and used, for example, to control caching, detect transmission errors, negotiate the appropriate representation format, and perform authentication or access control.
Stateful interactions through hyperlinks.
Every interaction with a resource is stateless, i.e., request messages are self-contained.
Stateful interactions are based on the concept of explicit state transfer.
Several techniques exist to exchange state, e.g., URI rewriting, cookies, and hidden form  elds.
State can be embedded in response messages to point to valid future states of the interaction.
RESTful Web services are perceived to be simple because REST leverages existing well-known W3C/IETF standards (HTTP, XML, URI, MIME) and the necessary infrastructure has already become pervasive.
HTTP clients and servers are available for all major programming languages and operating system/hardware platforms, and the default HTTP port 80 is commonly left open by default in most  rewall con gurations.
Such lightweight infrastructure, where services can be built with minimal tooling, is inexpensive to acquire and thus has a very low barrier for adoption.
The effort required to build a client to a REST-ful service is very small as developers can begin testing such services from an ordinary Web browser, without having to develop custom client-side software.
Deploying a RESTful Web service is very similar to building a dynamic Web site.
Furthermore, thanks to URIs and hyperlinks, REST has shown that it is possible to discover Web resources without an approach based on compulsory registration to a (centralized) repository.
On the operational side, it is known how to scale a stateless RESTful Web service to serve a very large number of clients, thanks to the support for caching, clustering and load balancing built into REST.
Due to the possibility of choosing lightweight message formats, e.g., the JavaScript Object Notation (JSON [10]) or, in the extreme, even plain text for very simple data types, REST also gives more leeway to optimize the performance of a Web service.
There is some confusion regarding the commonly accepted best practices for building RESTful Web services.
Hi-REST recommendations have been established informally, but are not always fully followed by so-called Lo-REST implementations: Hi-REST, advocates using all of the 4 verbs (GET, POST, PUT, DELETE)3; recommends the use of (so-called)  nice  URIs; and suggests the use of Plain Old XML (POX) for formatting the content of messages4.
Lo-REST, on the other hand, focuses on the minimum common denominator.
Thus, only 2 verbs (GET for idempotent requests, and POST for everything else) are used.
This is due to the fact that proxies and  rewalls may not always allow HTTP connections that use any other verb.
Also, POST and GET are the only two verbs that can be used in the method attribute of an XHTML form5.
These restrictions have led to a series of workarounds, where the  real  verb is sent using either a special HTTP header (X-HTTP-Method-Override) or   like with Ruby on Rails   a hidden form  eld ( method).
As with most nonstandard workarounds, these may not be understood by all Web servers, and require additional development and testing effort.
Regarding the message payload format, Lo-REST simply enforces the use of MIME-Types, but does not restrict the data to be in a particular format.
Another limitation makes it impossible to strictly follow the GET vs. POST rule.
For idempotent requests having large amounts of input data (more than 4 KB in most current implementations) it is not possible to encode such data in the resource URI, as the server will reject such  malformed  URIs6   or in the worst case it will crash, exposing the service to buffer over ow attacks.
The size of the request notwithstanding, it may also be challenging to encode complex data structures into a URI as there is no commonly accepted marshalling mechanism.
Inherently, the POST method does not suffer from such limitations.
alternative serialization formats (e.g., JSON, YAML, etc.)
guarantees the best interoperability.
Architectural decisions [39] are the key metaphor in our comparison method.
Architectural decisions capture the main design issues and the rationale behind a chosen technical solution; they can informally be de ned as conscious design decisions concerning a software system as a whole or affecting one or more of its core components and determining the nonfunctional characteristics and quality factors of the system [52].
For each architectural decision, one or more architecture alternatives (AAs) enumerate the design options.
In our earlier work, we proposed a structured, proactive approach to architectural decision modeling [52], which extends today s practices of rather informal, retrospective decision capturing for documentation purposes.
When reviewing the SOAP vs. REST debate, it becomes clear that many of the issues discussed and arguments brought forward qualify as recurring architectural decisions that can be modeled.
Architectural decision models have several use cases, for example decision support and governance during architecture design; they can also be used to facilitate technical quality assurance reviews [53].
In the context of this work, we used them as a metric for the REST vs. WS-* technology comparison.
We took the following steps:
 well as online resources such as blog entries of proponents of the two integration styles, identifying candidate decisions and alternatives along the way.
ing the architectural decisions and development steps required when using REST and WS-*.
tion styles from the results of Steps 1 and 2.
view cycle to solicit additional input to make sure that both models actually address the same design issues and are complete enough for the following assessment step.
mine relative complexity and cost (as indicated by required development effort and technical risk) assessments.
options per decision and 3) cost assessment per option.
The two decision models we prepared are organized into four levels of abstraction:
 architectural style such as REST is communicated through its de ning principles [3].
These principles determine how the architectural style addresses its requirements and design goals.
In our comparison models, principles and requirements such as protocol layering, dealing with heterogeneity, and loose coupling are investigated.
A comparison of these principles comprises the  rst step in our comparison (Table 1).
This is the level of abstraction and detail on which most existing comparisons of the two styles reside.
Principles such as dealing with heterogeneity and loose coupling are typically de ned informally; hence, an assessment solely based on these criteria only is bound to be subjective and incomplete.
Therefore, we added three more steps.
conceptual decisions required when following one of the two respective styles (Table 2): we compare how service contract design is supported and discuss the similarities and differences between the methodologies for publishing a service.
ceptual decisions and compare how the two integration styles can be technically realized (Table 3).
plementations tools can be evaluated in the light of the previously discussed decisions.
For instance, we surveyed how contemporary Web browsers and Web servers implement the HTTP speci cation, and which SOAP engines and WSDL tools exist.
Due to space limitations, we could not include these parts of the decision models in this paper.
We start by comparing how REST and WS-* comply with the architectural principles introduced in the previous section.
The  rst architectural principle clari es whether the Web is used as a publishing medium for delivering application services to clients or as a messaging medium for application integration   in other words, whether HTTP is considered as an application or as a transport protocol.
In the context of REST, the Web is seen as the universal medium for publishing globally accessible information.
Applications become part of the Web by using URIs to identify the provided resources, data, and services and by leveraging the full semantics of the four HTTP verbs (GET, POST, PUT, and DELETE) to expose operations on such resources.
Instead, from the perspective of SOAP/WS-*, the Web is seen as the universal transport medium for messages, which are exchanged between Web services endpoints of published applications.
Thus, applications gain the ability to remotely interact through the Web but remain  outside  of the Web.
In other words, the HTTP protocol is used as a tunneling protocol to enable remote communication through  rewalls, but it is not used to convey the semantics of the service interaction.
This can be seen from the way WS-* uses URIs to address messaging endpoints, which typically remain the same for all operations of a service, whereas REST URIs identify resources of the application domain.
In WS-*, both request and response messages are exchanged using only one HTTP verb (POST), the only one which allows to transfer XML payloads in both directions.
This way, the selection of the operation to be performed by the service is no longer done at the HTTP level, but is pushed into the SOAP message7.
The Web is a rather uniform client/server environment, where all components (e.g., browsers, Web servers, proxies, clients) speak the same protocol: HTTP.
Heterogeneity is more related to the competition between different browser vendors that would lead, for
 controversial and discouraged by the WS-I Basic Pro le.
Architectural Principle and Aspects REST WS-* Protocol Layering yes HTTP as application-level protocol
 HTTP as transport-level protocol Dealing with Heterogeneity yes Browser Wars
 Enterprise Computing Middleware Loose Coupling, aspects covered Time/Availability Location (Dynamic Late Binding) Service Evolution: yes
 yes, 3

 Uniform Interface XML Extensibility Total Principles Supported yes, 2





 Table 1: Principles Comparison Summary instance, to different renderings of HTML pages or incompatible JavaScript libraries.
Still, all browsers support the same HTTP protocol and can process a large variety of standard document types.
SOAP and WS-* originate from a more complex and heterogeneous domain, the one of enterprise computing.
This domain can be characterized as a collection of heterogeneous, autonomous, distributed software systems [7].
In organizations having a long history, which may even predate the advent of the Web, these software systems are implemented in many different kinds of technologies.
Examples are legacy COBOL programs running on mainframes that require screen-scraping, transaction processing over Message Queuing (MQ)-based reliable data feeds, and distributed object-oriented programs adhering to the Common Object Request Broker Architecture (CORBA).
From these examples, it can be seen that the heterogeneity addressed by WS-* standardization efforts goes beyond the synchronous client/server protocols used in speci c RPC middleware products, but extends to delivering the interoperability needed to build the plumbing for SOAs integrating technically diverse enterprise applications.
Both WS-* and REST foster the development of loosely coupled distributed systems, albeit according to different de nitions of this rather overloaded term.
There are many aspects to loose coupling: time/availability, location transparency, and service evolution are important dimensions.
A very important aspect of loose coupling concerns the ability for service consumers to interact with a service provider even when the latter is not available (the time/availability aspect of loose coupling).
Thus, in such kind of loosely coupled system, clients are not affected when services suffer from temporary downtime.
When WS-* is used to implement message-based (as opposed to RPC-based) SOAs, the underlying message bus makes it possible to achieve such degree of loose coupling as messages can be transferred using persistent, reliable queues.
Since RESTful Web services exclusively focus on RPC-like, synchronous interactions, this technology cannot hide such failure scenarios.
In other words, when an HTTP server is down, its clients will be affected as their HTTP requests fail; they have to handle such connection timeout failures themselves.
Synchronous interactions can nevertheless show a form of loose coupling, when clients discover the actual location of service providers at runtime.
This location aspect of loose coupling (dynamic late binding) is supported by most WS-* toolkits thanks to the standardization of service registry lookup APIs.
In REST, a form of location transparency can be achieved by DNS address translation, requiring to additional efforts to properly con gure the networking infrastructure.
When it comes to managing the evolution of a Web service, loose coupling implies the ability to make modi cations to a Web service without affecting its clients.
In case of RESTful Web services, it is clear that the uniform  4 verbs  GET, POST, PUT, DELETE are the same for all services and never change.
Freezing the basic protocol allows for complete decoupling of clients from servers, as no change on the server will ever break a client, as such change simply does not happen.
At  rst glance, RESTful Web services might appear to be  more  loosely coupled, as each WS-* service interface publishes a different set of operations and such interface may change over time.
However, independent of whether the set of operations is  xed or not, another important part of a service interface de nition is the message parameter data model, which speci es the format (i.e., the syntax, structure, and in some cases also the semantics) of the message payloads for each operation.
In this case, both WS-* and RESTful POX/HTTP services share the same loose coupling properties of XML [9].
As opposed to a binary protocol, the usage of SOAP or POX messages can give the ability to slightly modify a service interface in non-breaking ways [42].
In summary, as shown in Table 1, both styles support all three principles, albeit with different de nitions and interpretations of the aspects involved.
Therefore, it is too early to reach a conclusion and we need to continue with our comparison at the conceptual and technology levels.
Table 2 summarizes our conceptual comparison.
From a conceptual point of view, WS-* and REST support a different set of integration styles as it was discussed in Section 1.
WS-* and REST take a different approach to the de nition of the Web service interfaces.
In this section, we therefore concentrate on the most important architectural decisions that have to be made when following the respective contract design methodologies.
The importance of having a well-de ned, machine processable interface description has been understood for a long time [6, 24].
Two different practices have emerged in the WS-* community.
Contract rst prescribes to begin the development of a service from the spec-i cation of its interface, whereas Contract-last takes a bottom-up approach, where an existing service implementation is published with an automatically generated contract.
REST constrains the interface of a resource to its generic uniform interface with prede ned operations.
Thus, apparently no decision has to be made concerning what are the available operations (i.e., contract-less development).
Designers are advised to concentrate their effort on de ning the exposed resources.
However, it is still necessary to: 1) assess whether all four verbs are applicable to each resource exposed by the RESTful Web service8 and 2) establish the exact semantics of applying each verb on the resource.
Comparing the complexity of Web service interface design, we can conclude that REST appears to be simpler as it completely constrains the set of operations.
However, the designer is still required to enumerate the set of resources (or the set of operations, for WSDL-based services) to be provided by a Web service.
These are two different kinds of artifacts; however, a non-negligible design effort is still required in both cases.
Allowed  be returned to the client?
Integration Style Shared Database File Transfer Remote Procedure Call Messaging Contract Design Contract rst Contract-last Contract-less Resource Identi cation Do-it-yourself URI Design  Nice  URI scheme No URI scheme Resource Interaction Semantics Lo-REST (POST, GET only) Hi-REST (4 verbs) Resource Relationships Do-it-yourself Data Representation/Modeling XML Schema Do-it-yourself Message Exchange Patterns Request-Response One-Way Service Operations Enumeration By functional domain By nonfunctional properties and QoS By organizational criterion (versioning) Total Number of Decisions, AAs






















 (X)a



 n/a





 n/a n/a n/a n/a








  3 AAs
 aOptional Table 2: Conceptual Comparison Summary Although the methodology used to design a RESTful Web service is rather similar to the one used to design a WSDL-based Web service, it requires architects and developers to make decisions that deal with different abstractions.
To help with the comparison we outline these decisions in the following.
RESTful Web service design entails making these decisions (Table 2):
 (e.g., a book catalog, a purchase order, a bank account) exposing an application as a Web service?
URI scheme [34].
Properties of such URIs include: durability [4], predictability, conciseness, rei cation (prefer nouns to verbs), readability, consistency, and abstraction from implementation details [26].
verbs are applicable to a resource.
For example, should it be allowed to POST on a resource representing a bank account?
In general, this decision can be constrained by distinguishing whether accessing a resource is a read-only operation free of side-effects   and thus GET should be used, or instead accessing a resource involves modifying its state   thus one of the PUT, POST, DELETE verbs should be used.
linking them into several kinds of relationships (e.g., ownership, reference, or containment).
This is useful to incrementally discover the interface of a RESTful Web service by traversing hyperlinks between each of its resource representations.
Likewise, the content of a resource can be revealed gradually, allowing interested clients to follow links to drill-down for more details.
Also, relationships may be used to represent correct state transitions.
Thus clients can correctly interact with a stateful resource as they navigate to the next states listed in the current state s representation.
be chosen among a set of standard formats.
If an XML-based representation is chosen, it is not mandatory to constrain the content using a schema.
The design process behind a WS-* Web service centers upon the de nition of its interface using the WSDL language, which requires to make the following decisions (Table 2):
 exchanged by the service using XML Schema data types.
ation uses a synchronous or an asynchronous interaction pattern   an outgoing message is only required for synchronous message exchange.
exposed by the service interface.
A WSDL port type can contain more than one operation; the service modeler can group related operations by functional area (business domain), by nonfunctional properties such as security requirements (e.g., authorization pro le), or by organizational factors such as change frequency or version management patterns.
The rationale behind these grouping criteria is to achieve high cohesion between the service operations so that as few clients as possible break when the service interface evolves.
The design of the interface of WS-* Web services is a very important decision, as each service is characterized by a speci c set of operations, listed in its WSDL description.
The port type for each service must be designed carefully, so that it describes the service functionality in an understandable way; no pre-de ned semantics for its operations is available.
In this regard, many extensions for annotating service descriptions with additional semantics metadata have been proposed (e.g., SA-WSDL, or WSDL/S).
However, no standard has been agreed upon yet.
There is a tradeoff between modularity/reusability and performance [8].
It is still a challenge to design a reusable Web service interface, which requires a minimal number of interactions to accomplish a certain goal with all of its potential clients [37].
As summarized in Table 2, eight conceptual architectural decisions with only ten alternatives are required for REST.
For  ve decisions, only one alternative exists.
This freedom from choice leads to substantial design and development efforts for decisions with a single do-it-yourself alternative.
Rather surprisingly, the number of decisions is lower for WS-* ( ve).
However, there are many more alternatives for these decisions (more than ten).
Hence, WS-* provides freedom-of-choice within rather strict conceptual boundaries established by the speci cations.
Moreover, the alternatives are easier to implement due to the standardization of the concepts and the available tool support.
(X)b  6 AAs










 (X)c Xd















 many

 Architectural Decision and AAs Transport Protocol
 waka [13]





 Payload Format





 Service Identi cation
 WS-Addressing Service Description Textual Documentation XML Schema

 Reliability HTTPR [38]e WS-Reliability WS-ReliableMessaging Native Do-it-yourself Security
 WS-Security Transactions

 Do-it-yourself Service Composition
 Mashups Do-it-yourself Service Discovery
 Do-it-yourself Implementation Technology .
.
.
Total Number of Decisions, AAs aLimited to only the verb POST bStill under development cOptional dWSDL 2.0 eNot standard
  7 AAs Xa


































 many

 Table 3: Technology Comparison Summary

 Table 3 summarizes the third step of our REST vs. WS-* comparison.
Unlike in the conceptual comparison, the number of decisions required is the same (ten).
However, again WS-* offers more alternatives.
For REST,  ve decisions offer only one alternative.
The Web is de ned by its protocol: HTTP, thus when choosing to build a RESTful Web service, there is no choice but to build services that communicate using HTTP9.
Thus, given the lack of options, no decision is necessary when it comes to choosing the communication protocol.
One of the properties of WS-*, instead, is its transport independence, which allows SOAP messages to be exchanged using a variety of transport protocols.
The WSDL binding element is used to select an appropriate transport protocol (HTTP being one possibility) to bind the operation messages.
The corresponding QoS, security, and transactional policies also have to be de ned.
Table 3 shows a few examples of available transport protocols.
With this approach, messages in a standardized format can be transported using the most suitable protocol [46].
On the one hand, both synchronous (e.g., HTTP) and asynchronous protocols (e.g., JMS) are available, making SOAP suitable for the implementation of both request-response and one-way message exchange patterns.
On the other hand, this creates the need for devising mechanisms such as SOAP headers, delivering certain QoS properties at the message level.
For example, since a SOAP message could be routed both over secure and non-secure communication channels, it has been suggested that the message itself should be protected in order to guarantee certain end-to-end security properties of the communication.
For WS-* Web services, a single standardized message format exists: SOAP.
On the other hand, RESTful Web services currently do not use a single format for representing resources.
Instead they rely on the  exibility provided by the content negotiation features of REST to choose between a variety of MIME document types   which may also include SOAP itself10.
This can complicate and hinder the interoperability of a RESTful Web service, as   for example   clients expecting JSON [10] data will not be able to parse a XML payload.
Also, a RESTful Web service capable of serving resources in multiple representation formats requires more maintenance effort.
However, in our experience the bene t of preferring JSON over XML can outweigh the extra effort and the lack of in-teroperability with a signi cant overhead reduction.
RESTful Web services leverage the URI standard as the naming mechanism to address resources.
The advantage of URIs is that they encapsulate all information required to identify and locate a resource on a global addressing space without the need for a centralized registry.
Furthermore, URIs can be bookmarked, exchanged via hyperlinks and, given their readability, even printed on billboards for advertising [26].
WS-* initially lacked a standard addressing mechanism and also relied on URIs for identi cation of messaging endpoints and WSDL service interface descriptions.
More recently, WS-Addressing [44] was introduced to represent addressing information through the de nition of  endpoint references .
This standard language aug-


lacks the conciseness and readability properties that ensured the success of URIs.
Whereas WS-* Web services rely on a standard, machine-process-able, strongly-typed XML interface description language (WSDL), RESTful Web services have adoped a more human-oriented approach based on informal, textual descriptions, giving developers extensive documentation of the API of the provided service [32].
As a consequence, WSDL tools can automatically generate client stub code for most programming languages, masking the complexity of remotely interacting with a service.
For RESTful Web services, developers have to manually write the code to assemble the resource URIs and correctly encode/decode the exchanged resource representations.
Having good documentation greatly helps to reduce the amount of trial and error involved in the process, but is no substitute for using a compiler of a  real  interface description language.
To address this shortcoming, the Web Application Description Language (WADL [18]) was recently proposed.
Also the latest WSDL version 2.0 could be applied to describe RESTful Web services, thanks to its more  ne-grained control over the HTTP binding and the possibility of supporting non-SOAP message en-codings.
In general, having an interface description language to specify service contracts is not only bene cial for simplifying repetitive development tasks, but also helps to catch incompatibilities caused by changes of service interfaces early in the development process.
Thanks to the strong typing features of WSDL, clients will break at compile time.
This would also bene t RESTful Web services, insofar changes to the URI naming scheme11 and resource representations are concerned, since due to the uniform interface principle the actual set of operations applicable to a resource never changes (as already discussed).
The WS-* stack contains a set of optional speci cations covering the QoS properties of messages exchanged.
These help to guarantee a certain quality level in the communication, in a way which is independent of the underlying transport protocol and which can be handled automatically by the WS-* middleware.
In terms of the effort involved, developers may declare the desired security/reliable messaging/transactional policies associated with a Web service interface and reuse the corresponding WS-* standard implementation to deliver them.
While the WS-* speci cations related to QoS indeed are complex, they should be considered as optional technology choices addressing advanced requirements in enterprise computing scenarios.
For simpler scenarios, the basic guarantees of protocols such as HTTP (best effort) and HTTPS (point-to-point SSL security) are shared by both REST and WS-* styles.
A reliable extension to HTTP (HTTPR [38]) was proposed, but did not complete the standardization process.
No framework for distributed transactions comparable to WS-* has been proposed in conjunction with REST.
Fostering service reuse by means of service composition is one of the central tenets of SOA.
The standardization of the invocation path to a Web service has greatly facilitated their reuse and composition, as opposed to the traditionally fragmented markets for software components (e.g., where EJBs can not be easily mixed with .NET assemblies).
This has also led to the emergence of a
 large number of languages and tools speci cally targeting the composition of WS-* services out of already existing ones (e.g., WS-BPEL [29], JOpera [31], or XL [15]).
Given their lack of formally described interfaces and the possibility of not always using XML messages, RESTful Web services are cumbersome to compose using the WSDL-based invocation abstractions provided by WS-BPEL [30].
The composition of RESTful Web services is the main focus of so-called Web 2.0 Mashups, which are seen as a welcome improvement over screen-scraping the information to be composed out of traditional HTML Web sites [48].
Do-it-yourself build-time lookup is a common choice for both RESTful and for WS-* Web services.
Many successful large-scale industry deployments of Web services use groupware or Web portals supported by databases as their service repositories [54].
WS-* offers Universal Description, Discovery, and Integration (UDDI) registries as an additional technology option.
While this technology has been mature and stable for several years now, it has failed to reach widespread acceptance in the industry.
Several proprietary WSDL-based registry and repository products exist.
A fairly large number of application server platform options exists both for hosting RESTful and WS-* Web services implemented in any programming language.
Likewise, client-side library support for consuming RESTful and WS-* Web services is also available in most programming languages and operating systems.
Due to space limitations we cannot present a complete survey comparing all available implementation technologies.
However, it is worth mentioning that most existing WS-* Web services tools are currently being extended to also provide support for REST.
SOAP vs. REST has been an ongoing discussion for some time on the blogosphere and has also recently gained attention in the academic community.
None of the existing work employs a structured and detailed comparison method based on architectural decisions.
For example, the ECOWS 2005 keynote [17] focused on the reconciliation of WS-* with REST, whereas [55] gives a comparison of the two approaches from the point of view of their application to work ow systems.
A good discussion on whether the Web (and in particular RESTful Web services) can ful ll the requirements of enterprise computing can be found in a recent W3C workshop [23].
A comparison of RESTful Web services and so-called  Big Web Services  is also found in Chapter 10 of [33].
In it, a critical look to the WS-* stack is given in terms of how it does not  t with the  resource-oriented  paradigm of the Web.
The chapter also attempts to show how simpler RESTful techniques can be used to replace the corresponding WS-* technologies.
The distinction between  resource-oriented  and  service-oriented  architectures was  rst introduced by [36].
Unfortunately, the book does not provide a clear de nition of the terms services and resources, and its technology comparison is not based on measurable, objective criteria such as software quality attributes, design and development effort, technical risk, and QoS characteristics.
Even if HTTP is a synchronous protocol, the comparison presented in [22] argues that RESTful calls are asynchronous from an application layer perspective.
Thus, REST can be seen as favorable solution for simple integration scenarios.
Additional architectural concerns such as the URL design and payload format are not discussed.
another complex design issue in SOA, that of designing transac-tional work ows.
We touched upon the transport protocol selection decision, but did not investigate it in detail.
The paper focused on the rationale behind architectural decision modeling and the usage of decision models as a design method; it did not serve as a technology comparison metric as in this paper.
A framework for the comparison of pre-Web services middle-ware infrastructures (i.e., CORBA vs. J2EE vs. COM+) has been introduced in [49], with the goal of supporting the choice of the most suitable framework given certain application requirements.
In this paper we used architectural principles and decisions as a comparison method to illustrate the conceptual and technological differences between RESTful Web services and WSDL/SOAP-based  Big  Web services.
On the principle level, the two approaches have similar quantitative characteristics.
On the conceptual level, less architectural decisions must be made when deciding for WS-* Web services, but more alternatives are available.
On the technology level, the same number of decisions must be made, but less alternatives have to be considered when building RESTful Web services.
Thus, the perceived simplicity of REST now can be understood from a quantitative perspective   choosing REST removes the need for making a series of further architectural decisions related to the various layers of the WS-* stack and makes such complexity appear as super uous.
Still, if advanced functionality as delivered by WS-* is needed, it will be no simple matter to extend a RESTful Web service to support it in an interoperable manner.
Furthermore, according to our experience several of the decisions that are very easy to make for RESTful services lead to signi cant development efforts and technical risk, for example the design of the exact speci cation of the resources and their URI addressing scheme.
From our comparison it can also be seen that the two styles are rather similar, as long as the same subset of technology decisions is compared, for example when ignoring the more advanced features of the WS-* stack and only comparing POX/HTTP and SOAP/HTTP.
It could even be argued that these two approaches are two technology-level variants of the same conceptual design.
Assuming that the enterprise-level features of WS-* (transactions, reliability, message-level security) are not required, the key decision drivers at present are degree of  exibility and control, but also development efforts and technical risk (in implementation design, development, and maintenance), degree of open source and vendor tool support, and programming interface convenience.
REST scores better with respect to  exibility and control, but requires a lot of low-level coding; WS-* provides better tool support and programming interface convenience, but introduces a dependency on vendors and open source projects.
The main conclusion from this comparison is to use RESTful services for tactical, ad hoc integration over the Web (  la Mashup) and to prefer WS-* Web services in professional enterprise application integration scenarios with a longer lifespan and advanced QoS requirements.
The authors would like to thank Domenico Bianculli, Christopher Ferris, Joachim Hagger, Jana Koehler, Noah Mendelsohn, David N scheler, James Snell, Stefan Tramm, and Tammo van Lessen for their invaluable input and support.
This work is partially supported by the EU-IST-FP7-215605 (RESERVOIR) project.
