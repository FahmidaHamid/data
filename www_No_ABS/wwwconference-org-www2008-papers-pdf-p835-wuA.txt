Since XML gained wide acceptance as the standard for representing web data, it became increasingly important to have a language that provides  exible query capabilities for extracting patterns from XML documents.
Traditionally, a structured query language, such as XPath [1] and XQuery [2], is used to specify path-patterns or tree-patterns against XML data.
A distinguishing characteristic of these patterns is that they require a total order for the elements in every path of the pattern.
Recent applications of XML require querying data where the structure is not fully known to the Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
Timos Sellis NTUA, Greece timos@dblab.ntua.gr user, or integrating XML data sources with different structures [11,
 are adopted that relax the structure of a path in a tree pattern.
Popular solutions are keyword-based languages for XML [11, 15] or structured query languages for XML extended with keyword search capabilities [4, 19].
However, the  rst solution has important limitations: (1) structural restrictions cannot be speci ed in keyword-based queries, and (2) keyword-based queries return many meaningless answers [29, 20].
The drawback of the second solution is that it cannot avoid having a syntax which is complex for the simple user [15, 11, 23].
In any case, in order for all these languages to be useful in practice, they have to be complemented with ef cient evaluation techniques.
In this paper we consider a query language that allows a partial speci cation of path patterns.
The queries of this language are not restricted by a total order for the nodes in the path pattern.
This language is  exible enough to allow on the one side keyword-style queries with no path structure, and on the other side fully speci ed path pattern queries.
The language is general enough since in the general case, queries can be represented only as graphs and not mere trees.
It is important to know that partial path queries can not be expressed by path-patterns or tree-patterns.
Leaving apart the query answer form question, these queries can be expressed in XPath with reverse axes (such as parent axis and ancestor axis).
Figure 1: A partial path query EXAMPLE 1.1.
Consider an XML bibliography which contains several book datasets.
These book datasets organize books differently, grouped either by publisher, or by year, or by author, or by subject.
Suppose that we want to  nd the authors of a book on the subject XML, published by O Reilly in 2007.
In addition, we have the following structural restrictions: (1) author is the child of book; and (2) book has subject, year, and publisher as its ancestors.
Such query can be easily speci ed by a partial path query and it is shown as a directed graph in Fig. 1.
For simplicity, we omit value predicates in the query.
Using reverse axes, we can specify the query in XPath as: //book[ancestor :: publisher and ancestor :: subject and ancestor :: year]/author.
However, it is not dif- cult to see that this query can not be expressed by a tree-pattern query.
queries, where previous evaluation algorithms for tree-pattern queries cannot be applied.
Note that Olteanu et al. [24, 23] showed that XPath queries with reverse axes can be equivalently rewritten as sets of tree-pattern queries.
However, this transformation may lead to a number of tree-pattern queries which is exponential on the query size.
Clearly, it is inef cient to evaluate a partial path query by evaluating an exponential number of tree-pattern queries.
Finding all the occurrences of structural patterns in an XML tree is a key operation in XML query processing.
A recent approach for evaluating queries on XML data assumes that the data is prepro-cessed and the position of every node in the XML tree is encoded [32, 3, 5, 18].
Further, the nodes are partitioned, and an index of inverted lists called streams is built on this partition.
In order to evaluate a query, the nodes of the relevant streams are read in the pre-order of their appearance in the XML tree.
Every node in a stream can be read only once.
We refer to this evaluation model as indexed streaming model.
Agorithms in this model [32, 3, 5, 9, 17, 18, 21, 31, 6, 7] are based on stacks that allow encoding an expo nential number of pattern matches in polynomial space.
However, these existing algorithms focus almost exclusively on path-patterns or tree-patterns, therefore they cannot be used directly for partial path queries.
The problem.
We address the problem of evaluating partial path queries that may contain repeated labels.
This problem is complex because the queries in the general case can be directed acyclic graphs (dags).
A straightforward approach for dealing with this problem would be to produce for a given partial path query Q, a set of path queries that together compute Q.
Such an attempt faces two obstacles: (a) as mentioned above the number of path queries may be exponential on the number of query nodes, and (b) the best known algorithm for evaluating path queries under the indexed streaming model (PathStack [5]) does not account for repeated labels in a path query.
To the best of our knowledge, there are no previous algorithms for this class of queries in the indexed streaming model.
Contribution.
The main contributions of this paper are the following:  We develop an approach, called IndexPaths-R, for evaluating IndexPaths-R generates a set of path a partial path query Q.
queries P which is equivalent to Q.
In order to minimize the number of queries in P , we exploit a structural summary of data, called Index Tree, which is similar to a 1-index [22] without extents.
This approach guarantees that every path query in P corresponds to an existing pattern in the XML tree and therefore, returns a nonempty answer when evaluated on the XML tree.
  The path queries produced by the previous approach may contain repeated labels.
repeated labels in the partial query, we design a new stack-based algorithm, called PathStack-R for path queries with repeated labels.
  We also develop another algorithm for partial path queries, called PartialMJ-R. PartialMJ-R extracts a spanning tree from the query dag.
It populates the stacks for all the nodes in the query.
However, it evaluates the path queries de ned by every root-to-leaf path of the query separately.
The results are joined together to produce the  nal answer.
PartialMJ-R in general, has lower complexity than IndexPaths-R.
However, it may produce intermediate solutions, that is, partial solutions that do not make it to the  nal answer.
  We present a holistic stack-based algorithm for partial path queries, called PartialPathStack-R. PartialPathStack-R exploits multiple pointers of stack entries and a topological ordering of the nodes To account for in the query dag to match dag patterns directly to the XML tree.
PartialPathStack-R avoids the problem of intermediate solutions.
We provide an analysis of PartialPathStack-R, and identify cases when it is asymptotically optimal.
  We implemented all three algorithms, and conducted experiments in benchmark and synthetic data to compare their performance.
The experimental results showed that for partial path queries that are not mere path patterns, PartialPathStack-R always outperforms the other two, while for path queries, its performance is comparable to PathStack-R Paper outline.
The next section discusses related work.
Section 2 overviews the XML data model and the partial path query language and its properties.
In Section 3, we present our three evaluation algorithms.
Section 4 presents and analyses our experimental results.
We conclude and discuss future work in the last section.
In this paper, we focus on the indexed streaming model for the evaluation of queries.
Next, we provide an overview on the relevant evaluation techniques on XML data.
Previous papers focused on  nding matches of binary structural relationships (a.k.a.
structural joins).
In [32], the authors presented the Multi-Predicate Merge Join algorithm (MPMGJN) for  nding such matches.
Al-Khalifa et al. [3] introduced a family of stack-based join algorithms.
These algorithms are more ef cient compared to MPMGJN, as they do not scan the XML data multiple times.
Algorithms for structural join order optimization were introduced in [30].
Structural join techniques can be further improved using various types of indexes [9, 17, 31].
The techniques above can be exploited to evaluate a path-pattern or a tree-pattern query.
This task involves the following phases: (a) decomposing the query into binary structural relationships, (b)  nding their matches, and (c) stitching together these matches.
This approach is inef cient because it generates a large number of intermediate solutions (that is, solutions do not make it to the answer).
To deal with this problem, [5] presented two stack-based join algorithms (PathStack and TwigStack) for the evaluation of path-pattern queries and tree-pattern queries without multiple occurrences of the same node label in the same query path.
Path-Stack is shown optimal for path-pattern queries, while TwigStack is shown optimal for tree-pattern queries without child relationships.
Further, [10] shows that without relaxing the indexed streaming model, it is not possible to develop optimal algorithms for the evaluation of tree-pattern queries.
Several papers focused on extending TwigStack.
For example, in [21], algorithm TwigStackList evaluates ef ciently tree-pattern queries in the presence of child relationships.
Chen et al. [6] proposed algorithms that handle queries over graph-structured data.
Evaluation methods of tree-pattern queries with OR predicates are developed in [16].
In [18], the XR-tree index [17] is used to avoid processing input that does not participate in the answer of the query.
Recently, algorithm Twig2Stack [7] is suggested to evaluate tree-pattern queries on XML data without decomposing a query into root-to-leaf path patterns, and it can handle queries with repeated labels.
Nevertheless, Twig2Stack requires multiple visits to stream nodes, thus, it does not comply with the index streaming model requirements.
Considerable work has been done on the processing of XPath queries when the XML data is not encoded and indexed.
For example, [13] suggested polynomial main memory algorithms for answering full XPath queries.
Under the XML streaming model, evaluation algorithms for different fragments of XPath, which es-
in [25, 8, 14].
Partial tree-pattern queries were initially introduced in [27].
Their containment problem was addressed in [28] and semantic issues were studied in [29].
These papers did not focus on the evaluation of these queries.
Evaluation algorithms are provided in [26] but for a restricted class of partial path queries that do not allow multiple occurrences of nodes with the same label.
In this paper, we show how to ef ciently evaluate partial path queries with repeated labels under the index streaming model.
In this section, we brie y present the XML data model and the partial path query language.
An XML database is commonly modelled by a tree structure.
Tree nodes represent and are labelled by elements, attributes, or values.
Tree edges represent element-subelement, element-attribute, and element-value relationships.
We denote by L the set of XML tree node labels.
Without loss of generality, we assume that only the root node of every XML tree is labeled by r   L. Figure
 case letters.
We use subscripts to distinguish nodes with the same label.
The triplets by the nodes in the  gure will be explained below.
For XML trees, we adopt the region encoding widely used for XML query processing [32, 3, 5, 18].
The region encoding associates with every node a triplet (begin, end, level).
The begin and end values of a node are integers which can be determined through a depth rst traversal of the XML tree, by sequentially assigning numbers to the  rst and the last visit of the node.
The level value represents the level of the node in the XML tree.
The utility of the region encoding is that it allows ef ciently checking structural relationships between two nodes in the XML tree.
For instance, given two nodes n1 and n2, n1 is an ancestor of n2 iff n1.begin < n2.begin, and n2.end < n1.end.
Node n1 is the parent of n2 iff n1.begin < n2.begin,n2.end < n1.end, and n1.level = n2.level   1.
(a) (b) Figure 2: (a) An XML tree T , (b) the index tree of T
 A partial path query speci es a path pattern where the structure (an order among the nodes) may not be fully de ned.
Syntax.
In order to de ne these queries, paths or even trees are not suf cient, and we need to employ directed graphs.
DEFINITION 3.1.
A partial path query is a directed graph whose nodes are labeled by labels in L, and every node is incident to at least one edge.
There is at most one node labeled by r and this node does not have incoming edges.
Edges between nodes can be of two types: child and descendant.
In the rest of the paper, unless stated differently,  query  refers to  partial path query .
Query nodes denote XML tree nodes but we use capital letters for their labels.
Therefore, a query node labeled by A denotes XML tree nodes labeled by a.
In order to distinguish between distinct query nodes with the same label, we use subscripts.
For instance, A3 and A4 denote two distinct nodes labeled by A.
If Q is a query, and X and Y are nodes in Q, the expressions X/Y and X//Y are called structural relationships and denote respectively a child and descendant edge from X to Y in Q.
Figure 3 shows four queries.
Child (resp.
descendant) edges are shown with single (resp.
double) arrows.
Query Q1 is a partial path query which is also a path query since the structural relationships in the query induce a total order for the query nodes.
Notice that a query graph can be disconnected, e.g.
query Q4 in Figure 3(d).
Notice also that no order may be de ned between two nodes in a query, e.g.
between nodes A and C in Q3, or between nodes A1 and A2 in Q4.
(a) (b) (c) (d) Figure 3: Queries (a) Q1, (b) Q2, (c) Q3, (d) Q4 Semantics.
The answer of a partial path query on an XML tree is a set of tuples.
Each tuple consists of tree nodes that lie on the same path and preserve the child and descendant relationships of the query.
More formally: An embedding of a partial path query Q into an XML tree T is a mapping M from the nodes of Q to nodes of T such that: (a) a node in Q labeled by A is mapped by M to a node of T labeled by a; (b) the nodes of Q are mapped by M to nodes that lie on the same path in T ; (c)   X/Y (resp.
X//Y ) in Q, M (Y ) is a child (resp.
descendant) of M (X) in T .
We call image of Q under an embedding M, denoted M (Q), a tuple that comprises all the images of the nodes of Q under M.
Such a tuple is also called solution of Q on T .
The answer of Q on T is the set of solutions of Q under all possible embeddings of Q to T .
Consider query Q2 of Figure 3.
Notice that Q2 is syntactically similar to a tree-pattern query (twig).
However, the semantics of partial path queries is different: when query Q2 is a partial path query, the images of the query nodes R, A1 and C1 should lie on the same path on the XML tree.
Clearly, we can add a descendant edge from node R to every node that does not have incoming edges in a query without altering its meaning.
Therefore, without loss of generality, we assume that a query is a connected directed graph rooted at R. Figure 4 shows the queries of Figure 3 in that form.
Obviously, if a query has a cycle, it is unsatis able (that is, it does not have a nonempty answer on any database).
Detecting the existence of cycle in a directed graph can be done in linear time on the size of the graph.
In the following, we assume that a query is a dag rooted at node R.
(b) (c) (d) Figure 4: Queries (a) Q1, (b) Q2, (c) Q3, (d) Q4 (a) embedding 1 (b) embedding 2 Figure 5: Two embeddings of query Q3 of Fig. 4(c) on the index tree of Fig. 2(b) and the corresponding path queries

 In this section, we present three difference approaches for evaluating partial path queries.
dexes and Path Query Algorithms Our  rst approach, called IndexPaths-R, endeavors to leverage existing algorithms for path queries [5].
It exploits a structural summary of data, called index tree, to generate a set of path queries that together are equivalent to a partial path query.
In order to evaluate these queries, it extends Algorithm PathStack of [5] so that it can work on path queries with repeated labels.
Given an XML tree T , an index tree I for T is an 1-index 1 [22] without pointers to the XML data (i.e., without extents).
Because I has no extents, its size is usually insignicant compared to the data size.
Fig. 2(b) shows the index tree for the XML tree of Fig. 2(a).
Given a query Q and an index tree I, we can generate a set P of path queries that is equivalent to Q by  nding all the embeddings of Q into I.
For example, Fig. 5 shows all the possible mappings of the query Q3 of Fig. 4(c) on the index tree of Fig. 2(b) (there are two of them) and the corresponding path queries.
There is a one to one correspondence between the nodes of a path query and the nodes of Q.
PROPOSITION 4.1.
Let T be an XML tree and I be its index tree.
Let also Q be a partial path query and P = {P1, .
.
.
, Pn} be the set of path queries generated for Q on I.
Then, the answer of Q on T is the union of the answers of all the Pis on T .
The proof is straightforward.
Any of the two algorithms presented later in this paper can be used to  nd the embeddings of a query to an index tree.
However, even a naive approach would be satisfactory given the size of an index tree.
In practice, the number of the path queries for the query Q is expected to be small.
However, in extreme cases, it can be exponential on the number of nodes in Q.
Nevertheless, any one of the path queries represents a pattern that appears in T .
Therefore, it will return a nonempty answer when evaluated on T .
Labels Algorithm PathStack [5] optimally computes answers for path pattern queries under the indexed streaming model (cf.
Section 1).
However, the class of queries considered is restricted in that nodes in a query are assumed to have unique labels.
The PathStack algorithm associates every query node with one stack and one stream
 a tree.
of tree nodes.
For a path query with repeated labels, extending PathStack with multiple streams for each query label (one for each query node with this label) would violate the indexed streaming model requirements, since one stream node might be visited multiple times during the evaluation.
Therefore, we designed Algorithm PathStack-R, which extends PathStack by allowing nodes with the same label to share the same stream.
Notation.
Let Q be a path query, q be a node in Q, and l be a label in Q.
Function nodes(Q) returns all nodes of Q; label(q) returns the label of q in Q. Boolean function isLeaf(q) returns true iff q is a leaf node in Q.
Function parent(q) returns the parent of q in Q; occur(l) returns all nodes in Q labeled by l; label(Q) returns the set of node labels in Q.
With every distinct node label l in Q, we associate a stream Tl of all nodes (positional representation) labeled by l in the XML tree.
The nodes in the stream are ordered by the their begin  eld (cf.
Section 3.1).
To access sequentially the nodes in Tl, we maintain a cursor Cl, initially pointing to the  rst node in Tl.
For simplicity, Cl may alternatively refer to the node pointed by cursor Cl in Tl.
Operation advance(Cl) moves Cl to the next node in Tl.
Function eos(Cl) returns true if Cl has reached the end of Tl.
Cl.begin denotes the begin  eld in the positional representation of node Cl.
We associate a stack Sq with every query node q in Q.
A stack entry in Sq consists of a pair: (positional representation of node from Tlabel(q), pointer to an entry in the stack of q s parent).
The expression Sq.k denotes the entry at position k of stack Sq.
We use the following stack operations: push(Sq,entry) pushes entry on Sq; pop(Sq) pops the top entry from Sq; and top(Sq) returns the position of the top entry of Sq.
PathStack-R. Algorithm PathStack-R is presented in Algorithm 1.
PathStack-R gradually constructs matchings to Q and compactly encodes them in stacks, by iterating through stream nodes in ascending order of the begin values.
Thus, the query nodes are matched from the query root to the query leaf.
In line 2, PathStack-R identi es the stream node to be processed.
Line 3 calls cleanStacks to remove partial matchings that cannot become  nal solutions.
Line 5 (moveStreamToStack) is an important step, which is also the key difference from PathStack.
It determines whether the iden-ti ed stream node Cl quali es for being pushed on stack Sq, where q is a query node labeled is L. The stream node Cl can be pushed on stack Sq iff (1) q is the root, or (2) q is not the root and the structural relationship between Cl and the top stack entry of q s parent p satis es the structural relationship between p and q in the query.
This ensures that stream nodes that do not contribute to answers will not be stored in the stacks and processed.
Since Q can contain repeated labels, it is possible that l matches more than one node in Q and thus Cl can be pushed to more than one stack.
Note that the order of pushing Cl to stacks is important.
As discussed, in order
 if isLeaf(q) then Algorithm 1 PathStack-R 1 while  end() do
 l = getNextQueryLabel()
 cleanStacks(Cl) for every q   occur(l) in the descending order do





 Function end()
 Function getNextQueryLabel()
 Procedure cleanStacks(Cl)

 showSolutions(Sq) pop(Sq) advance(Cl) pop all entries in Sq whose nodes are not ancestors of Cl in the XML tree Procedure moveStreamToStack(l, q) 1 p = parent(q)



 push(Sq, (Cl, pointer to Sp.top(Sp))) return then to determine if Cl can be pushed on a stack, the parent stack will be checked.
In order to prevent Cl from  seeing  its own copy in the parent stack, moveStreamToStack should be called on the matched nodes in their descending order in Q (line 4).
We illustrate this by an example below.
Whenever an incoming stream node Cl is pushed onto the stack of the leaf node, procedure showSolutions iteratively produces solutions encoded in stacks (line 6-8).
The details are omitted here and can be found in [5].
EXAMPLE 4.1.
Consider a path query Q5 on the data path shown in Fig. 6.
The input streams for a and b are: Ta={a1, a2}, Tb = {b1, b2, b3}.
Initially, the two cursors Ca and Cb point to a1 and b1 respectively.
When a1 is read, it is not pushed on SA2, since the push condition (line 2 in moveStreamToStack) is not sat-is ed: the stack SB2 is empty.
When b2 is read, it is pushed  rst on stack SB2 and then on SB1.
If we do not follow this sequence and push b2 on SB1  rst, then b2 will not be pushed on SB2 anymore (line 4 in moveStreamToStack).
This would result in missing one solution for Q5.
Finally, after a2 is read and pushed on SA2, procedure showSolutions is invoked to output the query answer {a1b1b2a2, a1b2b3a2}.
Analysis of IndexPaths-R.
Given a node q in a path query Q, we call the path from the root of Q to q the pref ix path of q.
Given a stream node x of an XML tree T , we say that x matches q iff x is the image of q under an embedding of the pre x path of q to T .
PROPOSITION 4.2.
Let q be a query node in Q and x be a stream node with the same label.
x is pushed on stack Sq by Algorithm PathStack-R iff x matches q.
As a result of Proposition 4.2, Algorithm PathStack-R will  nd and encode in stacks all the partial or complete (q is a leaf node in Q) solutions involving x.
When at least one complete solution is encoded in the stacks, procedure showSolutions is invoked to output them.
Therefore, Algorithm PathStack-R correcly  nds all the solutions to Q.
Given a path query Q and an XML tree T , let input denote the sum of sizes of the input streams, output denote the size of the Figure 6: PathStack-R running example answers of Q on T , height denote the height of T , and maxOccur denote the maximum number of occurrences of a query label in Q.
The time complexity of PathStack-R depends mainly on the number of calls to moveStreamToStack, and the time to produce answers.
For each stream node, procedure moveStreamToStack is invoked at most maxOccur times, and each invocation takes O(1).
As Algorithm PathStack-R does not generate any intermediate solutions, the time it spends on producing all the answers is proportional to output.
Therefore, PathStack-R has time complexity O(input   maxOccur + output).
The space complexity of PathStack-R depends mainly on the number of stack entries at any given point in time.
Since the worst-case size of any stack in PathStack-R is bounded by min(height, input), PathStack-R has space complexity O(min(height, input) 
 THEOREM 4.1.
Algorithm PathStack-R correctly evaluates path queries with repeated labels.
It has time complexity O(input   maxOccur + output) and space complexity O(min(height, input)   |Q|).
The time complexity of IndexPaths-R is the product of the time complexity of PathStack-R and the number of path queries in P .
Algorithm Given a partial path query Q, Algorithm PartialMJ-R extracts a spanning tree of Q.
Then, it  nds matches for all root-to-leaf paths of the spanning tree against the XML tree by using Algorithm PathStack-R.
The solutions for each path of the spanning tree are merge-joined by guaranteeing that (a) they lie on the same path in the XML tree, and (b) they satisfy the structural relationships that appear in the query graph and not in the spanning tree.
Fig. 7(b) shows the graph of a query Q6, and Fig. 7(c) shows a spanning tree Qs of Q6.
Edge B5//A6 of Q6 is missing from Qs.
Any two solutions from the two root-to-leaf paths of Qs that are on the same path of the XML tree can be merged to produce a solution for Q6, if they satisfy the identity conditions on R and A1 and the structural condition B5//A6.
PartialMJ-R is shown in Algorithm 2.
Compared to PathStack-R, PartialMJ-R has two additional important steps: (1) Line 1 produces a spanning tree for the given partial path query and records the set of structural relationships presented in the query but are missing in the spanning tree; and (2) whenever a set of solutions for a root-to-leaf path in the spanning tree is produced, they are merge-joined with solutions produced earlier using Procedure join-
A partial path query Q can be represented as a dag rooted at R.
Let q be a node and l be a label in Q.
Since now we are dealing with graphs, we replace the functions isLeaf(q) and parent(q) of Section
 additional function children(q) returns the set of child nodes of q in Q.
The rest of the functions are similar to those de ned for Algorithm PathStack-R.
As with PathStack-R, we associate every distinct node label l with a stream Tl and maintain a cursor Cl for that stream.
Unlike PathStack-R, we now associate a stack Sl with every distinct node label l. The structures of a stack entry are now more complex in order to record additional information.
Before describing the data structures used by stack entries, we de ne an important concept, which is key to the understanding of the PartialPathStack-R algorithm.
DEFINITION 4.1.
Let Q be a partial path query, q be a node in Q, and T be an XML tree.
The sub-dag of Q that comprises q and all its ancestor nodes is called pre x query of q and is denoted as Qq.
We say that a node x in T plays the role of q if x is the image of q under an embedding of Qq to T .
For every role that a stream node can play, we maintain a chain of pointers and record in the chain the nodes that play this role.
Let p1, .
.
.
, pk be the parent nodes of all nodes labeled by l in Q.
Note that it is possible that for some or all of these pis, label(pi) = l. An entry e in stack Sl has the following three  elds: (1) nl: the positional representation of a node from Tl.
(2) ptrs: a set of k pointers labeled by p1, .
.
.
pk.
Each pointer denotes a position in a stack.
A pointer labeled by pi points to an entry in stack Slabel(pi).
It is possible that a pointer is null.
It is also possible that an entry has multiple pointers to the same stack.
In this case, these pointers are labeled by different query nodes.
(3) prevP os: an array of size |occur(l)|.
Given a node q   occur(l), prevP os[q] records the position of the highest entry in Sl below e that plays the role of q (i.e., prevP os[q] points to the previous entry in the chain).
If q is the only node labeled with l, prevP os[q] refers to the entry just below e.
The bottom of each stack has position 1.
The expression Sl.k denotes the entry at position k of stack Sl.
The expression Sl.k.pi refers to the position of the entry in stack Slabel(pi) pointed to by the pointer labeled pi in the entry Sl.k.
With every stack Sl, we associate an array lastP osl of size |occur(l)|.
The  eld lastP osl[q] records the position of the highest stack entry in Sl that plays the role of node q (the beginning of the chain).
If q is the only node labeled with l, lastP osl[q] refers to the top entry in stack Sl.
Algorithm PartialPathStack-R is presented in Algorithm 3.
A key feature of PartialPathStack-R is that it employs a topological order of the query nodes, i.e., a linear ordering of nodes which respects the partial order induced by the structural relationships of the query.
This order is exploited when producing query answers.
In the algorithm, query nodes of Q are indexed from 1 to |Q| based on their position in the topological order.
Algorithm PartialPathStack-R calls in line 5 procedure getRoles(l).
For a stream node Cl under consideration, getRoles(l)  nds all the roles that Cl can play and records the information in an object which is  nally returned to the algorithm.
More speci cally, for each query node q in occur(l), Cl plays the role of q iff for each q s parent p, there exists an entry e in the stack Slabel(p) such that the structural relationship between e and Cl satis es the structural relationship between p and q in the query (line 8-17).
Note that we can (a) (b) (c) Figure 7: (a) data path (b) query Q6 (c) Q6 s spanning tree Qs do not appear in Qs Algorithm 2 PartialMJ-R
 2 while  end() do
 l = getNextQueryLabel()
 cleanStacks(Cl) for every q   occur(l) in the descending order do






 showSolutionsWithBlocking(Sq ) joinPathSolutions() pop(Sq) advance(Cl) moveStreamToStack(l, q) if isLeaf(q) then Procedure joinPathSolutions()
 duced in the current loop (lie on the same path of the XML tree) and satisfy the structural relationships in E PathSolutions (line 9).
When Q is a path, Algorithm PartialMJ-R reduces to PathStack-R.
Compared to the approach IndexPath-R, Algorithm PartialMJ-R also evaluates the query by populating query stacks in one single pass of input streams.
Nevertheless, this approach may generate many intermediate solutions that are not part of any  nal answer.
A solution is called intermediate, if either it cannot be merged with any other solutions on a same data path or it does not satisfy structural conditions in Q that are not present in Qs.
Considering evaluating the query Q6 of Fig. 7(b) on the data of Fig. 7(a), four partial solutions are produced: {ra1c2b3a4, ra1d5b6, ra4d5b6, ra1c2b3a7} in order of their construction.
Among them, the  rst and fourth are solutions for the path RA1C2B4A6 and the rest are solutions for the path RA1D3B5.
The third solution cannot be merged with the  rst and fourth solutions, since the identity condition on R and A1 is not satis ed.
The  rst cannot be merged with the second, since the structural relationship between b6 and a4 does not satisfy B5//A6.
Therefore ra1c2b3a4 and ra4d5b6 are intermediate solutions.
The answer of Q6 is {ra1c2d5b3b6a7}.
Clearly, the intermediate solutions affect negatively on the worst case time and space complexity for PartialMJ-R.
To overcome the problem of intermediate solutions of Algorithm PartialMJ-R, we developed a holistic stack-based algorithm called PartialPathStack-R for the evaluation of partial path queries.
In contrast to PartialMJ-R, PartialPathStack-R does not decompose a query into paths, but tries to match the query graph to an XML tree as a whole.
Also, unlike PathStack-R, PartialPathStack-R exploits multiple pointers per stack entry to avoid redundantly storing multiple copies of stream nodes in different stacks.
Algorithm 3 PartialPathStack-R
 2 while  end() do
 l = getNextQueryLabel()
 cleanStacks(Cl)
 e = getRoles(l) if (R == l or e.ptrs (cid:5)=  ) then






 if (O (cid:5)=   and   q   nodes(Q): isSink(q)   lastPoslabel(q)[q] (cid:5)= 0) then if (isSink(q) and lastPosl[q] (cid:5)= 0) then push(Sl, e)
 for (q   occur(l)) do O += {q} if (n   O) then else outputSolutions(O, n, lastPoslabel(n)[n])








 i = lastPoslabel(n)[n] repeat outputSolutions(O, n, i) i = Slabel(n).i.prevPos[n] until (i==0) advance(Cl) lastPosR[1]=1 /*we are at the root node*/ for (q   occur(l)) do pptrs =   hasRole = true for ( p   parents(q)) do i = lastPoslabel(p)[p] entry = Slabel(p).i if (i (cid:5)= 0) then Function 4 getRoles(l)


 4 else
















 22 return e else hasRole = f alse if (hasRole) then if (hasRole) then e.ptrs += pptrs e.prevPos[q] = lastPosl[q] lastP osl[q] = top(Sl)+1 if (p/q   Q) and (entry.level (cid:5)= Cl.level+1) then hasRole = f alse pptrs += {pointer labeled by p to entry} ef ciently  nd the entry e through the value of lastPoslabel(p)[p] (line 10) without exhaustively visting the stack entries.
If Cl plays the role of q, a set of labeled pointers to all q s parents is generated and recorded (line 19).
The values of lastP osl[q] and prevP os[q] are accordingly updated as well (line 20-21).
PartialPathStack-R uses the information returned by getRoles(l) to determine if the stream node Cl is quali ed for being pushed on its stack Sl.
The stream node Cl can be pushed on its stack iff it plays at least one role w.r.t a query node in occur(l) (line 6-7).
By populating stacks in this way, we ensure that at any given point in time, the nodes in stacks represent partial solutions that could be further extended to  nal solutions as the algorithm goes on.
The timing for producing solutions is important in order to avoid generating duplicate solutions.
Whenever node Cl that plays the role of a sink node in the query (lines 9-11) is pushed on a stack, and for every sink node in the query there is an entry in the stacks that plays this role (line 12), it is guaranteed that the stacks contain at least one solution to the query.
Subsequently, procedure curN ode, outputSolutions(outputSinkN odes, m, lastP oslabel(m)[m]) output(Slabel(1).solution[1],...,Slabel(n).solution[n]) Procedure 5 outputSolutions(outputSinkN odes, stackP os)











 13 else




 until (i==0) i = minargc {Slabel(c).solution[c].m}, c   children(m) repeat outputSolutions(outputSinkN odes, m, i) i = Slabel(m).i.prevPos[m] outputSolutions(outputSinkN odes, m, i) i = Slabel(m).i.prevPos[m] i = lastPoslabel(m)[m] repeat until (i==0) outputSolutions (Procedure 5) is invoked to output all the solutions that involve Cl (lines 14 and 18).
Note that since every time solutions are produced, they involve the newly pushed node Cl, PartialPathStack-R does not generate duplicate solutions.
Procedure outputSolutions gradually produces the nodes in each solution in an order that corresponds to the reverse topological order of the query nodes.
This way, the image of a query node is produced in a solution after the images of all its descendant nodes in the query are produced.
Procedure outputSolutions takes three parameters: outputSinkNodes, curNode, and stackPos.
A solution under construction by outputSolutions is recorded in an array solution indexed by the query nodes.
The image of curNode recorded in solution[curN ode] is the position of an entry in stack Slabel(curNode).
WHen recursively processing the next query node curNode-1, denoted as m, we consider three cases: (1) If m is in outputSinkNodes (which implies m is a sink node), we output solutions that involve the last quali ed entry in stack Slabel(m) (line 6).
(2) If m is a sink node not in outputSinkNodes, we output solutions that involve all the quali ed entries in stack Slabel(m) (line 7-12).
(3) If node m is an internal query node, the highest entry e in stack Slabel(m) that can be used in a solution as an image of m is the lowest ancestor in the XML tree of the images of the child nodes of m in the query.
Since the child nodes of m have already been processed, their images are recorded in solution.
Entry e is identi- ed by the lowest position in stack Slabel(m) pointed to by pointers from stack entries that are images of the child nodes of m in the solution under construction (line 14).
The chain of entries that play the role of m in stack Slabel(m) starting with e are used as images of m for constructing solutions (lines 15-18).
Note that if there is a child relationship from m to another node, only a single recursive call to outputSolutions needs to be invoked.
We omit the details in the algorithm for the interest of space.
EXAMPLE 4.2.
Fig. 8 shows a running example for Partial-PathStack-R, where the stack for the query root R is not shown for simplicity.
We do not show the lastP os and prevP os of query nodes with a single occurrence in the query.
We use for Q6 the topological order: R, A1, C2, D3, B4, B5, A6.
The input streams are Ta: {a1, a4, a7}, Tb: {b3, b6}, Tc: {c2}, and Td: {d5}.
The initial value for the input stream cursors Ca, Cb, Cc, and Cd in that order is a1, b3, c2, d5.
Fig. 6(a) shows the state of the stacks after a4 is read.
At this point, there is no entry in stack Sa that plays the role of A6.
Therefore lastP osa[A6] is 0.
Similarly, lastP osb[B5]
 O(input  indegree  maxOccur + outdegree  output) time.
Based on the above theorem, PartialPathStack-R is asymptotically optimal if the indegree, outdegree, and maxOccur of the query are bounded by a constant.
Clearly, for the case of a query whose dag is a tree, only the outdegree and maxOccur need to be bounded by some constants for PartialPathStack-R to be asymptotically optimal.
We ran a comprehensive set of experiments to measure the performance of IndexPaths-R, PartialMJ-R and PartialPathStack-R.
In this section, we report on their experimental evaluation.
Setup.
We evaluated the performance of the algorithms on both benchmark and synthetic data.
For benchmark data, we used the Treebank XML document2.
The XML tree of Treebank consists of around 2.5 million nodes having 250 distinct element tags, and its depth is 36.
For synthetic data, we generated random XML trees, using IBM s AlphaWorks XML generator3.
The number of distinct element tags used in all synthetic trees was  xed to 5.
For each measurement on synthetic data, f ive different XML trees with the same number of nodes were used.
Each value displayed in the plots is averaged over these f ive measurements.
Fig. 9 shows the queries used in our experiments.
Queries Q1 to Q4 include only descendant relationships, while queries Q5 to Q8 include child relationships as well.
Our query set comprises a full spectrum of partial path queries, from simple path-pattern queries to complex dag queries.
The queries are appropriately modi ed for the Treebank dataset, so that they can all produce solutions.
Thus, node d2 is removed, and node labels r, a, b, c and d are changed to F ile, S, V P , N P and N N, respectively.
We implemented all algorithms in C++, and ran our experiments on a dedicated Linux PC (AMD Sempron 2600+) with 2GB of
 r a1 ( ) a2 b1 ( ) b2 c1 ( ) c2 d1 ( ) d2 (a) Q1(Q5) r a1 ( ) a2 b1 ( ) b2 r a1 ( ) a2 ( ) c1 c2 b1 ( ) b2 r a1 ( ) a2 b1 ( ) b2 c1 ( ) c2 d1 ( ) d2 c1 ( ) c2 (b) Q2(Q6) d1 ( ) d2 d1 ( ) d2 (c) Q3(Q7) (d) Q4(Q8) Figure 9: Partial path queries.
Execution time on  xed datasets.
We measured the execution time of IndexPaths-R, PartialMJ-R and PartialPathStack-R for evaluating all queries in Fig. 9 on Treebank and on two synthetic 2http://www.cis.upenn.edu/ treebank 3www.alphaworks.ibm.com/tech/xmlgenerator Figure 8: PartialPathStack-R on Q6 and data in Fig. 7(a) for stack Sb is 0, since the entry b3 can only play the role of B4.
Since a4 plays the role of A1, its prevP os[A1]  eld points to the lower entry a1 in Sa that plays the role of A1.
Fig. 6(b) shows the state of stacks after a7 is read.
As a7 plays the role of A6, the entry for a7 has two outgoing pointers which respectively point to b3 and b4 in stack Sb, and its stack position is recorded in lastP osa[A6].
Since A6 is a sink node of Q6, a7 triggers the generation of solutions.
Note that when A1 is processed by outputSolutions, a1 is chosen as a value for A1 in the solution under construction, since a1 has lower position than a4 in stack Sa (line 13 in outputSolu-tions).
The  nal answer for Q6 is {ra1c2d5b3b6a7}.
PROPOSITION 4.3.
A stream node x is pushed on stack Sl iff x plays the role of a query node labeled by L.
It is easy to see that for each stream node x stored in stack Sl, the above proposition along with De nition 4.1 ensures that Algorithm partialPathStack-R will  nd all solutions in which x matches one of its roles.
Given a query Q and an XML tree T , let indegree denote the maximum number of incoming edges to a query node and outdegree denote the maximum number of outgoing edges from a query node.
Other parameters are the same for the analysis of IndexPaths-R.
Since PartialPathStack-R does not generate any intermediate solutions, the time complexity of PartialPathStack-R depends mainly on the number of calls to getRoles and outputSolutions.
For each stream node, getRoles takes time O(indegree maxOccur).
Procedure outputSolutions spends O(outdegree) on each query node, since in line 13 it computes the lowest stack position among the entries of the children of the query node.
Thus it takes O(outdegree  output) to produce all the solutions.
Therefore, PartialPathStack-R has time complexity O(input   indegree   maxOccur+ outdegree   output).
The space complexity depends mainly on how many entries are stored in stacks at a given point in time and the number of pointers associated with these entries.
The total number of stack entries at any time is O(min(height, input)).
For each stack entry, the maximum number of outgoing pointers is O(indegree   maxOccur).
Therefore, the number of pointers in stacks is bounded by min(height, input)   indegree   maxOccur.
THEOREM 4.2.
Algorithm PartialPathStack-R correctly evaluates a partial path query Q on an XML tree T .
The algorithm
 consist of 1.5 million nodes.
All trees in SD2 have depth 20 and consist of 1 million nodes.
For path-pattern queries Q1 and Q5, we also measured the execution time of PathStack-R.
Fig. 10(a), 10(b) and 10(c) present the evaluation results.
Fig.
10(d) shows the number of results obtained per query in each dataset.
Algorithm PartialPathStack-R is ef cient for all types of queries.
As expected, IndexPaths-R, PartialMJ-R and PartialPathStack-R perform almost as fast as PathStack-R in the case of the path-pattern queries Q1 and Q5.
The execution time of algorithm IndexPaths-R is high for queries with a large number of path queries generated from the index tree, that is, for queries Q3, Q4, Q7 and Q8.
The performance of both PartialMJ-R and PartialPathStack-R in all datasets is affected by the number of solutions.
This con rms our complexity results that show dependency of the execution time on the input and output size.
In the case of queries Q2 and Q4 on SD2 (Fig. 10(c)), where the number of solutions is high (Fig.
Execution time varying the input size.
We measured the execution time of IndexPaths-R, PartialMJ-R and PartialPathStack-R for evaluating queries Q2, Q4 and Q8 of Fig. 9 on random XML trees of various sizes.
Fig. 11 presents the execution time and the results obtained on XML trees whose node stream sizes vary from 0.5 to
 PartialPathStack-R clearly outperforms IndexPaths-R and Parti-alMJ-R regarding queries Q2 and Q4 (IndexPaths-R is out of range in Fig. 11(b)).
For query Q8, the performance of PartialPathStack-R is similar to that of PartialMJ-R.
This is due to the small number of results produced (Fig. 11(f)).
An increase in the input size results in an increase in the output size (Figures 11(d), 11(e) and 11(f)).
Also, when the input and the output size go up, the execution time of all algorithms increases (Figures 11(a), 11(b) and 11(c)).
This con rms the complexity results that show dependency of the execution time on the input and output size.
In the experimental evaluation of query Q4, the output size (Fig.
higher in the evaluation of Q4 (Fig. 11(b)) than in the evaluation of Q2 (Fig. 11(a)).
In contrast, the execution time of PartialMJ-R is strongly affected.
In this paper, we addressed the problem of evaluating partial path queries with repeated labels under the indexed streaming model.
Partial path queries generalize path-pattern queries and are useful for integrating XML data sources with different structures and for querying XML documents when the structure is not fully known to the user.
Partial path queries are expressed as dags and can be speci ed in XPath with reverse axes.
We designed three algorithms for evaluating partial path queries on XML data.
The  rst algorithm, IndexPaths-R, exploits a structural summary of data to generate an equivalent set of path patterns of a partial path query and then uses a stack-based algorithm, PathStack-R, for evaluating path-pattern queries with repeated labels.
The second algorithm, PartialMJ-R, extracts a spanning tree from the query dag and uses PathStack-R to  nd the matches of the root-to-leaf paths in the tree.
These matches are progressively merge-joined to compute the answer.
Finally, the third algorithm, PartialPathStack-R, exploits multiple pointers of stack entries and a topological ordering of the nodes in the query dag to apply a stack-based holistic technique.
To the best of our knowledge, PartialPathStack-R is the  rst holistic algorithm that evaluates partial path queries with repeated labels.
We analyzed to the three algorithms and conducted extensive experimental evaluations to compare their performance.
Our results showed that PartialPathStack-R has the best theoretical value and has considerable performance superiority over the other two algorithms.
We are currently working on extending our approaches for evaluating partial tree-pattern queries under the indexed streaming model.
