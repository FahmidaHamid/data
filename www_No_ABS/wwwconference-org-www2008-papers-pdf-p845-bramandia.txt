Recent interests on XML, Semantic Web, and Web ontology, among other topics, have sparked a renewed interest on graph-structured databases.
There has been some work on large XML repositories [18], ontology data on the Web [11], graph networks [3], and classical graph databases with recursive query language support.
A fundamental query on graphs is the reachability test.
Specifically, given two nodes u and v of a graph, the test returns true if and only if v is reachable from u.
This query evidently cannot be expressed by  rst order languages, e.g., SQL.
For all the reasons that reachability tests are important in classical graph databases, it is also useful to XML and the Semantic Web.
In particular, the Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
descendant axis,  // , in XPATH can be considered a special application of reachability tests.
The descendant axis in XPATH determines a set of the nodes that are reachable from a set of input nodes (the context nodes).
This can be implemented by simply extending the reachability test to support sets of nodes.
Another example of graphs is the Semantic Web.
Resources [23] on the web can be naturally represented as a graph.
We sketch an example of resources on the Web in Figure 1.
One may want to ask: What resources/services are related/reachable to Resource A?
In addition, reachability test can also be used in implementing OWL queries, a W3C recommendation for Semantic Web [24].
Various techniques have been proposed to implement reachabil-ity tests ef ciently.
On the one hand, reachability tests on a graph can be evaluated using a traversal of the entire graph.
However, this method cannot handle data at Web-scale.
On the another hand, one may precompute and materialize the transitive closure of the graph.
Then, the reachability test becomes a simple selection on the transitive closure.
However, the size of the transitive closure may be large, O(|G|2) in the worst case.
Previous work on indexes for reachability tests has mainly focused on optimizing query performance and the size of the transitive closure, e.g., [1].
Recently, a number of indexes for reachability tests have been proposed for optimizing the query performance and/or index size on trees (e.g., [29]), DAGs (e.g., [25]) or arbitrary graphs (e.g., [21]).
Web data is often cyclic.
Thus, we focus on methods that support arbitrary graphs.
This paper studies a popular indexing technique for reachability tests on arbitrary graphs called 2-hop labeling, originally proposed by [9] and later studied in [20, 21, 7], among others.
When data evolves, there is a need for maintenance of 2-hop labeling.
We study the incremental maintenance of such labeling, which receives little attention.
For ease of presentation, we may use 2-hop labeling and 2-hop interchangeably.
Previous work on 2-hop labeling has mainly focused on time-ef cient index construction and optimization of the index size.
However, determining the 2-hop labeling with the minimum size is an NP-hard optimization problem [9].
To minimize the index size, all previous work used SET COVER as a heuristics for computing a minimal 2-hop labeling of an input graph [9, 20, 21, 7].
Unfortunately, it is also known that the heuristic construction of 2-hop labeling is computationally intensive.
For example, [21] reported that the original algorithm [9] spends almost two days to construct the 2-hop labels for a subset of the DBLP XML document   a bibliography repository for Computer Science publications.
A divide-and-conquer approach [21] and a geometric approach [7] have been proposed to improve the performance of 2-hop construction with a small tradeoff in index size.
Since the construction of 2-hop labeling is costly, it is not feasible to rebuild the labels in response to each single update of the




 Figure 1: Semantic Web example v
 v
 v
 v
 v
 v
 Lout(v1)={v8,v6,v5,v3,v2} Lout(v2)={v5} Lout(v1)={v6,v4,v2,v3} Lout(v3)={v8,v6,v4} v
 Lout(v3)={v6,v4} Lout(v4)={v6} Lin(v5)={v4,v2} v
 Lin(v7)={v6} Lin(v8)={v6} Lin(v9)={v6,v8} Lout(v4)={v8,v6} Lout(v6)={v8} Lin(v3)={v1} Lin(v5)={v4} Lin(v7)={v6} Lin(v9)={v8} b) graph.
What is desirable is an ef cient 2-hop label maintenance algorithm.
To the best of our knowledge, the only work that studied incremental maintenance of 2-hop labeling is [21].
[21] determines the elements in the transitive closure that are affected by an update (deletions or insertions).
Then, a 2-hop construction is applied to the affected elements.
Since a single deletion (or insertion) of a graph may affect many elements in the transitive closure, the corresponding updates of its 2-hop labeling is not trivial.
In Section 4, we perform a case analysis of the affected elements of the deletion of a node and determine the bottleneck of deletions in 2-hop labeling.
(We skip the analysis on insertions since it is simple).
Since the heuristics for the construction does not take update into considerations, the incremental maintenance of 2-hop labeling can be inef cient.
Based on a case analysis on updates, we de ne a node-separation property of 2-hop labels.
When 2-hop labeling satis es this property, the deletion of 2-hop labeling can be simpli ed, as the inef -cient cases in deletion are no longer necessary.
(In any case, insertions are simple.)
In this paper, we propose a few heuristic functions, derived from cut vertex or minimum graph bisection, that produce 2-hop labeling that satis es the node-separation property.
The drawback of such heuristics is that it has a relatively remote relationship with the index size, when compared to the heuristics using SET COVER.
As a consequence, the size of our 2-hop la-belings is relatively larger than those in [21, 7].
We derive some properties of our heuristics that facilitate many hybrids 2-hop labeling of our and previously proposed 2-hop labeling.
We yield a family of updatable 2-hop labeling, called u2-hop labeling, and the hybrids of 2-hop labeling from these heuristics.
The main contributions of this paper are the followings:   We illustrate inef cient cases in deletions of 2-hop labeling and propose a simple algorithm for processing them;   We present the node-separation property that leads to ef -cient 2-hop maintenance.
Based on this, we present two heuristic algorithms derived from graph connectivity for 2-hop labeling construction and analyze their complexities.
The size of our 2-hop labels, however, is often larger than the previous proposed 2-hop labels;   We propose hybrids of 2-hop labels from different heuristics;   We propose a novel incremental maintenance algorithm for deletion that works very ef ciently on our updatable 2-hops.
In addition, the algorithm is extended to work on arbitrary 2-hop labels.
We also present an insertion algorithm that works on arbitrary 2-hop labels;   We conduct extensive experiments on updates of various versions of our 2-hop labeling to verify the effectiveness of our heuristics and illustrate their performance characteristics.
Organization.
The structure of the paper is as follows.
Related work is discussed in Section 2.
Section 3 brie y reviews 2-hop labeling and other preliminaries of this work.
Section 4 analyzes deletions of 2-hop labeling.
In Section 5, we present the de nition Figure 2: An example graph G0 and two possible 2-hop covers v
 a) of two updatable 2-hop labeling due to graph connectivities and the hybrid of 2-hop labeling.
The construction and incremental maintenance algorithms of the updatable 2-hop labeling are presented in Section 6.
Section 7 presents an experimental study of the up-datable 2-hop labeling to illustrate its characteristics.
We conclude and present future work in Section 8.
There has been a host of works on 2-hop label construction with heuristics derived from SET COVER and its simpli cations [7, 8,
 In Section 4, we illustrate that such constructions generate
 consequence, previous maintenance algorithms [4, 21] for the 2-hop labels required isolating the elements of the transitive closure affected by an update and applying a 2-hop construction algorithm on the affected elements, which can often be large.
In comparison, our heuristics are based on node-separation property that is optimized for update.
Hence, incremental maintenance algorithms can be simpler than the previous ones.
Incremental maintenance of 2-hop labeling has only been discussed in [21].
The labeling was constructed with graph partitioning.
Each partition and its transitive closure  t into main memory and a heuristics, based on SET COVER, is reused for the construction of 2-hop labels for each partition.
An objective of [21] is to scale the construction of 2-hop labels.
Since SET COVER is part of the heuristics proposed, the 2-hop labels generated by this method have the same problems as the ones discussed above.
In comparison, we study heuristics that produce update-ef cient 2-hop labels.
A number of techniques have been proposed to support reacha-bility tests on trees, e.g., [26, 29, 12].
While there have been studies on updates of the index proposed in [29], e.g., [10], there is a lack of its extension on the support of arbitrary graphs.
Recently, [26] has been extended to support DAGs [25, 22, 6].
However, there is no discussion on the extension of the update algorithm of [26] to DAGs.
[22, 6] propose very ef cient index construction algorithms.
When there are a lot of updates, rebuilding the index in response to all of the updates may be more ef cient than our incremental maintenance approach It is worth-mentioning that there has been work in matching patterns in graphs [27, 28, 5].
The queries considered subsume reach-ability tests.
Reachability tests can be considered as a primitive operation of pattern matchings.
There is another stream of work, e.g., [16], on mining structures from Web graphs, where Web pages and hyperlinks are nodes and edges of a Web graph.
Research on Internet computing has proposed methods to detect authorities (nodes with a large number of incident edges) and hubs (nodes with a large number of outgoing edges) from Web graphs.
While authorities and hubs may imply a reasonable 2-hop labels, it remains open whether there is a direct relationship between these structures and space-/update-ef cient 2-hop covers.
There has also been work on graph clustering, in particular, clustering/mining evolving graphs [17].
However, there is a lack of a study on the cluster properties and reachability tests.
In this section, we provide some background on 2-hop labeling and show how reachability test is ef ciently supported.
Since the reachability information of the nodes in a strongly connected component in a graph is trivial, we assume that each strongly connected component in the graph is reduced to a node.
This can be ef ciently done by Tarjan algorithm in one scan of the graph.
The reduced graph is a directed acyclic graph (DAG).
Our subsequent discussions always assume the reduced graph.
We denote a directed graph as G(V , E).
Each node v in V is associated with a label L, which are two lists of nodes Lin(v) and Lout(v).
The two lists are called 2-hop labels.
The nodes that are stored in Lin(v) (resp.
Lout(v)) are some nodes that can reach (resp.
are reachable from) v. We often refer to the nodes in either Lin(v) or Lout(v) as center nodes.
Given two nodes u and v, v is reachable from u, denoted as u ; v, if and only if Lin(v)   Lout(u) is nonempty.
To ensure that the 2-hop labels contain all reachability information of G, the 2-hop labels must cover all elements in the transitive closure T (G) of G. The re exive closure is implicitly encoded by Lin(v) and Lout(v).
The 2-hop labels that cover all elements in T (G) is called 2-hop cover H(G) of G. Obviously, there are many correct 2-hop covers of a graph.
We may omit v from Lin(v) and Lout(v), and G from T (G) and H(G) when they are clear from the context.
Next, we illustrate how 2-hop labeling works with an example.
Consider the graph G0 in Figure 2 and the nodes v1 and v9.
We show one possible 2-hop labels of v1 and v9 in Figure 2 (a): Lout(v1) = {v2, v3, v4, v6} and Lin(v9) = {v6, v8}.
The labels can be interpreted as follows: v2, v3, v4 and v6 are reachable from v1; and v9 is reachable from v6 and v8.
Lout(v1)   Lin(v9) = {v6} means that there is a path from v1 to v9 via the center node v6.
(cid:2) Previous work has mainly focused on minimizing the size of a v V |Lin(v)| + |Lout(v)|.
In the original 2-hop cover, de ned as proposal of 2-hop labeling, Cohen et al. [9] proved that  nding the
 heuristics have been proposed to determine space-ef cient 2-hop cover iteratively.
In particular, we brie y describe [9, 21, 7], which are essential to our discussion on updates.
(cid:3) (cid:3) (cid:3) (cid:3) In [9, 21, 7], a variable T stores the uncovered elements in T .
and is empty.
= T .
Elements are iteratively removed from T Initially, T heuristic algorithms terminate when T In [9], an undirected bipartite graph Gw(Aw, Dw, Ew) is constructed for each node w. u   Aw and v   Dw and (u, v)   Ew if and only if (u, v) is in T and v is reachable from u via w. Then, the SET COVER heuristics  nds an induced subgraph Gi(Ai, Di, Ei) of Gw with r = |Ei T (cid:2)| |Ai Di| maximized.
This is exactly the problem of  nding the densest subgraph of Gw.
At each iteration of the algorithm, a node w having the largest r is picked as a center node.
Then, we add w to Lout of nodes in Ai and Lin of nodes in Di and remove (a, w) and (w, d), where a   Ai and d   Di, from T |Ei T (cid:2)| |Aw Dw| returned space-ef cient 2-hop cover, the time and memory requirements for computing Gw are prohibitive.
One of the results in [7] showed that the division in this heuristics has minor impact on the size of 2-hop cover.
Hence, [7] proposed a simpler heuristics where |Ei   T (cid:3)| is maximized, which leads to more ef cient 2-hop construction.
While (cid:3) .
[21] proposed to (recursively) partition a graph into partitions, where each of the partition  ts into main memory.
A 2-hop cover H i of the intra-partition edges is constructed by using [9].
A supplement cover  H is constructed for the interconnections between partitions   the skeleton graph.
The 2-hop cover proposed in [21] is the union of H i s and  H.
                                       
 ...
a ...
x ...
D d        d               
        ...
Figure 3: Illustration of deletion of x Despite the  rst effort on incremental maintenance of 2-hop labels by [21], to date, there has not been heuristics that considers updates of the 2-hop labels when they are constructed.
In the next section, we shall analyze updates of 2-hop labeling and illustrate how maintenance of 2-hop labels becomes inherently complicated if special efforts are not spent on the construction of 2-hop labels.
In this section, we perform a case analysis on the steps required to update 2-hop labels after the deletion of a node of a graph.
The aim is to highlight the inef cient steps among them.
For 2-hop labeling, insertions are simpler than deletions (see Section 6.2).
Therefore, in this section, we focus on deletions.
Consider a deletion of a node x   V .
The nodes in G can be partitioned into three disjoint sets with respect to x (see Figure 3): (1) A(x) = {a | (a, x)   T }; (2) D(x) = {d | (x, d)   T }; and (3) R(x) = V - A(x) - D(x).
We omit x from A(x), D(x) and R(x) when it is clear from the context.
Since the updates of 2-hop labels of D are symmetric to those of A, we shall discuss the updates of
 element (a, d) in T , where d   Lout(a), belongs to one of these four disjoint sets: (1) E1 = {(a, d) | a, d   A}; (2) E2 = {(a, d) | a   A, d   R}; (3) E3 = {(a, d) | a   A, d   D}; and (4) E4 = {(a, x) | a   A}.
Cases 1 and 2.
When x is deleted, E1 and E2 are not affected.
Case 3.
To illustrate the updates on E3, we describe a procedure for processing the deletion of x.
Consider (a, d)   E3 and d   Lout(a).
We need to check if d should still be in Lout(a) after the deletion of x.
We check whether or not some of the children of a can reach d via some path(s) that do not pass through x.
For all edges in E3, this can be ef ciently checked in a topological order of nodes in A, starting from x.
If a can no longer reach d after the deletion of x, then d would be removed from Lout(a) and we need to perform some additional check to the descendants of d. We do this by Procedure check_All_Lin: Consider a descendant (cid:3) uses d as a center node.
For each d such d ) as follows: We need to , we perform check_Lin(a, d (cid:3) that do not pass through check if there are some paths from a to d x.
If there is such a path, then d should be added into Lin(a) to (cid:3) ) may have been removed maintain the connectivity.
Note that (a, d from the 2-hop cover due to the removal of d from Lout(a).
In the worst case, we need to consider |A|   |D| check_Lin cases.
Case 4.
We consider (a, x) and (x, d) for all a   A and d   D together.
We de ne two sets: P : {p | x   Lout(p), p   A} and Q: {q | x   Lin(q), q   D}, where x is the node to be deleted.
For each p   P and q   Q, we need to use check_Lin (in Case 3) to check if (p, q) is still in T after x is deleted.
Hence, Case 4 requires at most |P| |Q| check_Lins.
In addition, we would remove x from Lout(p) and Lin(q).
of d where d   Lin(d ), i.e., d (cid:3) (cid:3) (cid:3) (cid:3) (cid:3)
 requires |P| |Q| check_Lins in Case 3.
Hence, simpli cations on Case 3 have a signi cant impact on the overall performance.
Based on the analysis in Section 4, we present the de nition of a family of updatable 2-hop labeling (or simply u2-hops) that are derived from graph connectivities, in particular, cut vertex and minimum bisection.
We present the node-separation property and merging property that lead to simpli ed deletions, speci cally, for Case 3 and 4.
The heuristics of u2-hops are derived from the node-separation property: We say that a set of nodes X separate u and v if and only if u can reach v and the removal of all nodes in X disconnects u and v. We de ne the center nodes of u and v to be {x | x   Lout(u)  Lin(v)}.
A 2-hop cover satis es the node-separation property if and only if for each element (u, v) in T , the center nodes of u and v separate u and v.
When a 2-hop cover satis es the node-separation property, the processing of E3 and E4 can be simpli ed as follows: (1) check_All_Lin is no longer required for E3; (2) x can simply be removed from Lout(a) and Lin(d) for E4.
There is no insertion of nodes into the 2-hop labels required.
These can be easily derived from the de nition of the node-separation property.
Example 5.1: Consider the example graph G0 shown in Figure 2 (a).
The 2-hop cover, as shown, does not exhibit the node-separation property because the centers node of v1 and v8 is {v6}, which does not separate v1 and v8.
After the removal of v6, v1 can still reach v8 through v3.
Similarly, the center nodes of v1 and v9, and the center nodes of v3 and v8 do not satisfy the node-separation property.
After the deletion of v6, the 2-hop labels need to be updated by deleting v6 from Lin and Lout of all nodes.
In addition, it is necessary to insert v3 into Lin(v8) and Lin(v9) to cover the paths from v1 and v3 to v8 and v9.
In comparison, suppose that v8 is added to Lout(v1) and Lout(v3) and v3 is added to Lin(v8).
The resulting 2-hop cover satis es the node-separation property.
For example, {v3, v6} separates v1 and v8.
In this case, the deletion of v6 could be processed by simply removing v6 from Lin and Lout of all nodes.
i=1..mTi=T .
Next, we discuss the merging property that is used in the construction of u2-hops that satis es the node-separation property.
Consider a possibly overlapping subsets of T (G): T1, T2,..., Tm, where each Ti represents partial connectivity of a graph G and Each Ti is covered by the 2-hop labels Hi.
Reachability query can be done by independently querying His.
The merging property states that if T is covered by H1, H2..., Hm and each Hi satis es the node-separation property, then we can merge Hi for i = 1..m into a single 2-hop Hall and Hall also satis es the node-separation property.
The merging is de ned as follows: Lout(a) = (cid:3) i=1..m Lout(a) of Hi.
We can de ned Lin(a) in a similar man-(cid:3) ner.
It is immediate that Hall is still a correct 2-hop cover of T .
The correctness of this property can be easily derived from the fact that the center nodes of a and b in some His, (a, b)   T , already separate a and b.
Adding more nodes into the 2-hop labels does not violate the node-separation property.
In the next subsection, we describe two heuristic functions that satisfy the node-separation property.
First, we consider X as a singleton set   a cut vertex of a subgraph.
Second, we consider X as a bisection cut in G.
v v v v v v





 v v v



 v3
 v6 v v v v v v v






 v v v v v





 v2
 v5 v
 v v v v



 v v v v



 v
 v
 v
 v v v


 v v v v v





 v1
 v4 v v

 v v v v




 v7
 v8
 v9 Figure 4: Bipartite graph Gx for each node x   G0
 We  rst introduce the de nition of a new 2-hop cover, namely u2-hop-A, that is based on cut vertex.
For each node x   V , we construct a bipartite graph Gx(A, D, Ex), where A and D are A(x) and D(x) respectively and the edges Ex are {(a, d) | x separates a and d, a   A, d   D}.
(cid:3)   A (cid:3)   D that x separates.
From the de nition of Gx, this is in which there is an edge (a, d), (cid:3) .
Note that the induced subgraph of A is a biclique in Gx.
Hence, our problem is equivalent to Given a bipartite graph Gx, we are interested in  nding A (cid:3) and d   D and D (cid:3) (cid:3) (cid:3) (cid:3) and D equivalent to  nding A for all a   A and D  nding a biclique in Gx.
Lin(d), for all a   A (cid:3)
 (cid:3)|   |D (cid:3)| + |A (cid:3) (cid:3) (cid:3)
 (cid:3)).
and d   D (cid:3)| elements of T .
Consider a biclique Bx(A (cid:3)| + |D u2-hop-A is constructed by iteratively  nding biclique Bx(A If we add x to Lout(a) and , to cover Bx, then x covers (cid:3))
 and augmenting u2-hop-A to cover Bx s until T is fully covered.
Similar to other heuristic algorithms, to minimize the index size, (cid:3)| + we  nd the node x whose biclique Bx(A (cid:3)| in each iteration.
That is, we greedily maxi-
mize the number of elements of T that are covered.
We remark that a node v can be chosen as a center node multiple number of times.
This does not cause any problem due to the merging property discussed previously.
More importantly, this guarantees that the u2-hop-A construction terminates and covers all elements of T .
It is straightforward that the 2-hop cover constructed by this (cid:3)) maximizes |A (cid:3)|   |D (cid:3)| + |A
 (cid:3) heuristics satis es the node-separation property.
Example 5.2: Figure 4 shows the bipartite graph Gx constructed from each x   V0.
Consider Gv4 in Figure 4.
It shows the bipartite graph Gv4 .
From the graph G0 depicted in Figure 2, v4 separates v3 from v5, v6 and v7.
Hence, there is an edge from v3 to v5, v6 and v7 in Gv4 .
Note that it is possible that Gx does not have any edge, e.g., Gv2 in Figure 4.
It is also possible that one side of the graph is empty, e.g., Gv1 in Figure 4.
The biclique Bv8 ({v1, v3, v4, v6}, {v9}) covers 4 + 1 + 4   1 = 9 elements.
This is the maximum among all possible bicliques in Gx for all x.
Another biclique Bv1 ({},{v2, v3, v4, v5, v6, v7, v8}) only covers 7 + 0 + 7   0 = 7 elements.
We  nd that given a bipartite graph G,  nding a biclique B in G that covers the maximum number of elements in the transitive closure T is intractable.
Speci cally, we proved the following theorem.
(Note that it is neither the maximal independent set problem of a bipartite graph nor the maximum edge biclique problem.)
ing a biclique B(BX, BY ) that maximizes f(B) = |BX| +|BY | + |BX|   |BY | is NP-complete, where BX   A and BY   D.
PROOF.
(Sketch) Our reduction is established from an NP-complete problem, namely, the maximum edge bipartite problem (MEBP) [19]: Given a bipartite graph G(A, D, E), MEBP  nds a biclique B(BX, BY ) having g(B) = |BX|   |BY | k.
Note that for both problems, we only need to consider maximal biclique B, otherwise the biclique can be extended and produce larger value of f(B) and g(B).
Given an instance of MEBP on an input graph G(A, D, E), we generate |A|   |D| instances of MSEBP.
Speci cally, for each pair of nodes a   A and d   D, we generate an instance of MSEBP Ga,d as follows: We remove (1) a and d; (2) d is not (cid:3)   A where a (cid:3) adjacent to a, e.g., there is no edge (a, d (cid:3) is not adjacent to d, e.g., there is no edge (a , d).
The graph induced by the remaining nodes is an instance of MSEBP.
(cid:3)
 ) (cid:3)| = k. In every instance Ga,d, there exists some nodes
 in B but not in Ga,d.
We refer to the subgraph of B in Ga,d as the (cid:3) reduced biclique, denoted as Bred(A red).
We show that 1) in all Ga,d generated, f(Bred)   k   1 and 2) there are some Ga,d having f(Bred) = k   1.
Consider any maximal biclique B(A (cid:3)|   |D (cid:3)   D where d ) in G having g(A ); and (3) a (cid:3) red,D
 (cid:3) (cid:3) (cid:3) (cid:3) (cid:3) v
 v
 v

 v v v v v




 v
 v
 v
 v v

 v
 v
 v v

 v
 v v v


 a) Bred b) Bred c) Bred d) Figure 5: (a) The input graph for MEBP (b) An instance of MSEBP generated from v2 and v6 (c) An instance of MSEBP generated from v1 and v4 (d) An instance of MSEBP generated from v2 and v5 (cid:3) (cid:3) (cid:3) (cid:3)| |D (cid:3)|  1) = |A and d   D (cid:3) and D (cid:3)|  1)  (|D (cid:3) red=A (cid:3)|   1) + (|D , respectively, that is not in Ga,d, e.g., A (cid:3) \ {d}.
Hence, f(Bred) = (|A We  rst give a proof of 2).
Consider an instance Ga,d, where a   A .
In this instance, there is exactly one node in (cid:3) \ {a} (cid:3)
 (cid:3)|   1) + (cid:3) red=D and D
 (cid:3)|  1 = k-1.
This is illustrated in Figure 5.
Consider the biclique B and the reduced biclique Bred in Figures 5 (a) and 5 (b).
The values of g(B) and f (Bred) are 6 and 5, respectively.
We then prove 1).
In any Ga,d, there is at least one node in A (cid:3) (cid:3)|   1, and D
 red|   |D (cid:3)|   1) + (cid:3)
 (cid:3)|  1   k-1.
This is illustrated (cid:3)|  1)  (|D in Figures 5 (c) and 5 (d), where the values of f (Bred) are 3 and 1.
Hence, the answer of MEBP is true if and only if there is at least one instance of MSEBP that contains a biclique Bred having f(Bred) k   1.
, respectively, that is not in Ga,d, e.g., |A (cid:3)|   1.
Hence, f(Bred)   (|A (cid:3)|   1) + (|D (cid:3)|  1)   |A red|   |A (cid:3) (cid:3)| |D In response to this, we reuse an approximation algorithm [2] for MSEBP as the heuristics for u2-hop-A construction (Section 6).
Next, we generalize u2-hop-A to u2-hop-B in this subsection.
Speci cally, as opposed to choosing a single-node separation, we use a node separation which may be a set of nodes.
We were tempted to use min-cuts for construction.
However, the construction algorithm may be guided by numerous small cuts and the resulting 2-hop cover can be large.
To reduce the number of cuts, we opt to use the minimum graph bisection.
This leads to relatively smaller number of iterations and tend to produce smaller 2-hop covers.
While  nding the minimum graph bisection is also a classical NP-hard optimization problem, there has been a number of heuristics for solving this problem [15].
In particular, we used [14] to determine a small bisection.
Suppose the bisection B, B   E, divides the graph G into G1(V1, E1) and G2(V2, E2), where |G1|   |G2|.
We construct 2-hop labels as follows.
We cast B into an undirected bipartite graph.
We determine the minimum vertex cover C of B.
Since we are dealing with bipartite graph, the minimum vertex cover can be computed in PTIME using the network  ow technique.
Consider a node c in C. For each ancestor a of c, we insert c into Lout(a).
Similarly, for each descendant d of c, we add c into Lin(d).
Next, we construct u2-hop-B recursively on G1 and G2, respectively, until the transitive closure is entirely covered.
Due to the merging property, the 2-hop labels obtained can be merged into a single 2-hop cover.
Discussions.
It is immediately true that the previous two heuristics generate u2-hop covers that satisfy the node-separation property.
It should also be remarked that all center nodes in the 2-hop cover are selected in a special way such that simple deletions for u2-hop-A and u2-hop-B become possible: u2-hop-A ensures that a node w that separates many (uncovered) node pairs are selected earlier than the others.
In contrast, when there are multiple alternative paths P from u to v, u2-hop-B enforces (at least) one node on each alternative path in P is included in both Lout(u) and Lin(v).
A deletion becomes simply the maintenance of the node separation between pairs of nodes.
The two u2-hops introduced in the previous subsections have different properties.
u2-hop-A requires the construction of a large number of bipartite graphs as in [9] that may be memory-bound and computationally intensive.
In contrast, u2-hop-B may result in large 2-hop covers as the bisection can often be relatively large when the input subgraphs is relatively small.
The reason is that the minimum bisection of a small graph may often be a large subset of the edges of the graph.
Therefore, we propose a hybrid approach of u2-hops that takes advantages of both u2-hops.
Recall the merging property discussed earlier.
We can mix u2-hop-A with u2-hop-B.
The hybrid of these 2-hop covers still satis- es the node-separation property.
There are two simple alternatives for combining the u2-hops.
Firstly, we propose to  rst use u2-hop-B to build 2-hop recursively until u2-hop-B becomes inef cient in terms of space.
Then, we use u2-hop-A to cover the remaining elements in T .
The inef ciency of u2-hop-B can be estimated as follows: In the worst case, the size of T is |V |2.
Suppose C is the vertex cover of the bisection cut of G1 and G2.
The size of u2-hop-B of a given C, denoted as |u2-hop-B(C)|, can be estimated as |V1|   |C| + |V2|   |C| + |V1|2 + |V2|2.
Through experimental studies on the size of T and u2-hop-A of random graphs, we can obtain the average size of u2-hop-A when compared to T , say |u2-hop-A|   X%   |T|.
Hence, we use u2-hop-B recursively until |u2-hop-B(C)|   X%   |T|.
Secondly, we can use u2-hop-B recursively until the size of the graph is small enough that the graph together with its transitive closure and bipartite graphs can be stored in the main memory.
Then, u2-hop-A is used.
Hybrid of updatable and arbitrary 2-hop labeling.
Similarly, a hybrid of updatable and arbitrary 2-hop labeling, not necessarily updatable, can be easily de ned.
One scenario is to apply the u2-hop-A construction algorithm un-
ements in T is smaller than certain threshold.
Then, the remaining elements are covered by any 2-hop construction technique.
Since this hybrid 2-hop labeling does not entirely satisfy the node-separation property, the merging property is not applicable here.
However, we can store/maintain the two 2-hops separately.
As veri ed by our experiment, this hybrid 2-hop labeling yielded a better index size when compared to u2-hops.
However, the construction of the smallest hybrid of 2-hop is no easier than that of u2-hops.
For example, consider the hybrid of u2-hop-A and [9].
To avoid having numerous  small  center nodes in the resulting
 two nodes, where the node-separation property does not offer any advantage on deletions of E3 and E4.
Then, we have the following.
Theorem 5.2: Finding the hybrid of u2-hop-A and [9] with the minimum size is NP-hard.
Theorem 5.2 can be obtained by using the reduction from 3-SAT due to Cohen et al. [9].
The graph obtained from a 3-SAT instance is dense where an empty u2-hop-A is obtained.
This graph is not modi ed and we need to  nd its minimum 2-hop cover [9], which is NP-hard.
We have discussed the de nition of a family of u2-hops in the previous section.
In this section, we describe the construction and maintenance algorithms for these u2-hops.
Construction of u2-hop-A.
The key issue in constructing a reasonable u2-hop-A with a small size is to  nd a reasonable approximation for MSEBP for each bipartite graph of each node.
We associate a weight to an element of T .
Weight 0 (resp.
1) means that the associated element in T has been covered (resp.
has not been covered).
Initially, all elements of T have not been covered and thus have a weight of 1.
In addition, we also associate a weight to all nodes and edges in the bipartite graph Gx(A, D, E).
The weight of a node a   A in Gx is the weight of (a, x) in T .
Similarly, the weight of a node d   D in Gx(A, D, E) is the weight of (x, d) in T .
Whereas, the weight of an edge (a, b) in E is the weight of (a, b) in T .
The weights are updated in each iteration of the algorithm as T is updated.
Our heuristic function for each bipartite graph is to  nd a bi-clique with the maximum sum of weights.
This problem can be solved by a 2-approximation algorithm given in [2], namely (2,2)-deletion problem.
Note that this problem is a more general problem than MSEBP.
(cid:3) (cid:3) Putting these together, we present a greedy algorithm for u2-hop-A construction in Figure 6.
The algorithm operates as follows.
At Line 01, we construct the bipartite graph Gv for each v   G. T (cid:3) is used to record the uncovered elements in T .
Initially, T
 (Line 02).
max stores the center node of Bmax that would cover T the most.
Initially, Bmax is initialized to an empty biclique with is not fully covered, the iteration weight 0 (Line 03).
As long as T repeats.
At each iteration, we compute an approximation of the biclique with the maximal weight of the bipartite graph for each node, as discussed above and in Section 5.1.
Then, we determine the biclique Bmax and the center node max with the largest weight among other bicliques (Lines 05-08).
At the end of each iteration, we select max as a center node to cover connections between the nodes in Vmax1 and Vmax2 in Bmax (Lines 09-10).
We update and the weights of all bipartite graphs before the next iteration
 (Lines 11 and 12).
(cid:3) (cid:3)
 construct bipartite graph Gv Procedure u2-hop-A-construction Input: a directed graph G: (V , E) Output: u2-hop-A of G: (Lin, Lout)









 construct max weight biclique Bv(V1, V2) of Gv if totalweight(Bv) > totalweight(Bmax) Bmax = Bv; max = v for each v   V is not empty (cid:3) Lout(a) = {max}   Lout(a), Lin(d) = {max}   Lin(d), where a   Vmax1 where d   Vmax2 (cid:3)


 update T update the weights of Gv for v   V according to T according to Bmax (cid:3) Figure 6: A greedy algorithm for u2-hop-A construction v v v v v v





 v v v



 v3
 v6 v v v v v v v






 v v v v v





 v2
 v5 v
 v v v v



 v v v v



 v
 v
 v
 v v v


 v v v v v





 v1
 v4 v v

 v v v v




 v7
 v8
 v9 Figure 7: Updated weights of bipartite graph Gx for each node x   G0.
Dotted edges and no ll nodes are with weight 0.
Solid edges and  lled nodes are with weight 1.
(cid:3) Example 6.1: Consider G0, as shown in Figure 2.
The bipartite graphs Gv constructed in Line 1 is shown in Figure 4.
All the nodes and edges have weight 1.
As described in Example 5.2, in the  rst iteration, we obtain max = v8, Vmax1 ={v1, v3, v4, v6} and Vmax2={v9}.
Then, in Line 9 and 10, v8 is added to Lout of v1, v3, v4 and v6 and Lin of v9.
Then, the weights of T is updated.
Subsequently, the weights of the bipartite graphs are updated.
Figure 7 shows the updated weights after the  rst iteration.
At the next iteration, the biclique having the maximal weight is ({v1, v3, v4},{v7}) with center node v6.
Subsequent iterations would choose the following bicliques and their center nodes in this order: ({v3},{v5}) with center v4, ({v1, v2}, {}) with center v5, ({v1}, {}) with center v3, ({v1}, {}) with center v2 and,  nally, ({}, {v3}) with center v1.
The resulting 2-hop cover is shown in Figure 2 (b).
Complexity.
The initial construction of a bipartite graph is as costly as computing the transitive closure, O(|V | (|V | + |E|)).
To compute all bipartite graphs, it takes O(|V |2 (|V | + |E|)).
The approximation algorithm that we used takes O(|V +|E|).
We adopted the priority queue implementation to optimize the for-loop (Lines
 Input: a directed graph G: (V , E), (cid:3)
 : the uncovered elements of T Output: u2-hop-B of G: (Lin, Lout)










 for v in V if v ; c then Lout(v) = Lout(v)   {c} else if c ; v then Lin(v) = Lin(v)   {c} (cid:3) u2-hop-B-construction(G1, T u2-hop-B-construction(G2, T according to Lines 06-07 is not empty ) ) (cid:3) (cid:3) (cid:3) Figure 8: A greedy algorithm for u2-hop-B construction (cid:3) (cid:3)
 step in the construction is Line 01.
Construction of u2-hop-B.
The construction of u2-hop-B also uses to keep track of the uncovered elements in T .
We assume that
 = T initially.
We use [14] to compute the minimum bisection
 B of G (Line 01).
Then, we use a classical algorithm to determine the minimum vertex cover C of B (Line 03).
Next, we add 2-hop (cid:3) labels as discussed in Section 5.2 (Lines 04-07).
We updated T according to the elements of T covered by C (Line 08).
If T is not entirely covered, the construction procedure is called recursively with the subgraphs de ned by B, G1 and G2 (Lines 09-11).
Complexity.
In Lines 01-08, the dominating step is the approximation algorithm for  nding the minimum bisection of a graph [14].
Denote M to be the time complexity for the algorithm.
The construction is called at most |V | times in the worst-case.
The overall complexity is O(M |V |).
However, note that M depends on the size of the input graph, which decreases as the recursion proceeds.
u2-hop Labeling Next, we describe our incremental maintenance algorithms for u2-hop labeling.
Deletions for u2-hops.
The deletion algorithm of u2-hops is presented in Algorithm delete in Figure 9.
The inputs of Algorithm delete are a directed graph G, its u2-hop cover H and a node to-be-deleted x.
The output of the algorithm is the updated
 move x from Lin(v) and Lout(v) for all v   V (Line 01).
This deals with Case 4 in Section 4.
We obtain the ancestors and descendants of x with the help of the input graph G (Line 02).
We sort the ancestors and descendants based on the topological ordering (Line 03-04).
Next, we gather the edges that belong to Case 3 in E3 (Line 05-06).
We perform deletions of edges in Case 3 in (cid:3) topological order.
We sort the edges of E3 by their indexes in A and D (Line 07).
Hence, when we process an edge (a, d) in E3, the relevant 2-hop labels have been correctly updated.
Then, we (cid:3) scan through the edges in E
 (cid:3) 3, there are only two possible cases: (i) d belongs to edge (a,d) in E Lout(a) or (ii) a belongs to Lin(d) (Lines 09 and 12).
(i) For the  rst case, we check if a can still reach d after the deletion of x.
The checking is done by using the 2-hop cover to test if any child ca of a can reach d. Speci cally, Lout(ca)   Lin(d) (cid:9)= {}.
If no child of a can reach d, we remove d from Lout(a) (Lines 10-11).
(ii) For (cid:3) Procedure delete Input: a directed graph G, an u2-hop cover of G and x a vertex to-be-deleted (cid:3) (cid:3) Output: the updated u2-hop cover






 (cid:3)
 (cid:3)

 := sort A in reverse topological order ( bottom up ) := sort D in topological order ( top down ) and a   A (cid:3) and d   D (cid:3) (cid:3)
 where a = A if d   Lout(a) [i] and d = D (cid:3) 3 in order






 if ca (cid:9); d for all children ca of a (after deletion) remove d from Lout(a) if a (cid:9); pd for all parent pd of d (after deletion) remove a from Lin(d) if a   Lin(d) [j] (cid:3) (cid:3) Figure 9: Deletion of u2-hop labeling the second case, we remove a from Lin(d) if a cannot reach d after the deletion of x (Lines 13-14).
The checking is done by utilizing the parents of d in a similar manner.
We emphasize that the 2-hop cover can be used for reachability tests in Lines 10 and 13 because the 2-hop cover has been correctly updated in previous steps.
Example 6.2: Consider a deletion of v6 in the graph G0 presented in Figure 2.
We use the 2-hop cover depicted in Figure 2 (b).
Note that the 2-hop cover satis es the node-separation property.
The deletion algorithm removes v6 from Lout of v1, v3 and v4 as well as Lin(v7) (Line 01).
The set of ancestors and descendants are obtained: A={v1, v3, v4} and D={v7, v8, v9}.
The topo-={v4, v3, v1} and logically sorted representation is as follows: A ={v7, v8, v9}.
The set of edges in Case 3, E3 is {(v1, v8), (cid:3)
 (v3, v8), (v4, v8)}.
The sorted E3, E Note that all of these edges will be processed by Lines 10-11.
Next, (cid:3) 3 in sequence: 1) process (v4, v8): we check if v4 can we process E still reach v8 after deleting v6.
The only remaining child of v4 is v5.
Since Lout(v5)   Lin(v8) is empty, v5 can not reach v8, thus we remove v8 from Lout(v4).
2) process (v3, v8): since v8 is a child of v3, then we keep v8 in Lout(v3) (a node is implied in the Lin and Lout of the node itself).
3) process (v1, v8): v1 has three children, v2, v3 and v4.
v2 cannot reach v8.
But, as we have processed in Step 2), v3 can reach v8.
Thus, we keep v8 in Lout(v1).
(cid:3) 3, is {(v4, v8), (v3, v8), (v1, v8)}.
(cid:3) (cid:3)).
Thus, if a can still reach d (cid:3) We also remark that Algorithm delete can be extended to handle deletions of arbitrary 2-hop covers, including those proposed by [21, 7].
This can be implemented with check_All_Lin, as described in Section 4.
Speci cally, if d is to be removed from (cid:3)   D having d   Lout(a) (Lines 11 and 14), then we check all d Lin(d after the deletion of x (again, this checking is done through 2-hop reachability test), then we need to Lout(a) to restore back the reachability information.
to add d These additional operations must be performed consistently to the edge order in E ) is already covered by the current 2-hop labels after the removal of d from Lout(a), the previous steps can be skipped.
Similarly, if a is to be removed from Lin(d) (Line 14), a symmetric processing is needed.
(cid:3)
 (cid:3) (cid:3) From the discussion above, it is clear that the deletion algorithm can also be extended to work on the hybrid of u2-hop and non-u2-hop, e.g., the hybrids of 2-hops described in Section 5.3, and has
 Input: a directed graph G, an u2-hop cover, an edge to-be-inserted (x, y) Output: the updated u2-hop cover
 Lin(y) := Lin(x)   {x}

 Lout(x) := Lout(y)   {y}

 compute A: A(x) and D: D(y)
 cx:= |{a|x (cid:9)  Lout(a), a   A}   {d|x (cid:9)  Lin(d), d   D}|
 cy:= |{a|y (cid:9)  Lout(a), a   A}   {d|y (cid:9)  Lin(d), d   D}|
 if cx < cy then t = x, else t := y

 for a in A


 Lout(a) := Lout(a)   {t} Lin(d) = Lin(d)   {t} for d in D Figure 10: Insertion of u2-hop labeling been used in our experiment.
To extend the algorithm to work on hybrids of 2-hop that do not satisfy the node-separation property, the two 2-hop covers are to be updated in parallel.
Complexity.
Sorting the nodes or edges in some topological order can be implemented ef ciently.
The dominating steps in Algorithm delete are Lines 8-14.
For each edge in E3, we performed at most O(|V |) 2-hop lookups, Lines 10 and 13.
Hence, the complexity of the deletion is O(|E3| |V |) 2-hop lookups.
However, in practice, the number of lookups required is much fewer than this.
Insertions for u2-hops.
Algorithm insert, as shown in Figure 10, handles insertions of u2-hops.
We aim at an insertion algorithm that preserves the node-separation property.
For simplicity, we assume that the insertion would not introduce cycles to the graph.
Consider a single-edge insertion (x, y).
Suppose x already exists in the graph and y is new (Line 01).
All nodes that can reach x can also reach y.
Hence, we put Lin(x) together with x in Lin(y) (Line 02).
Case
 Case 3 deals with insertions of an edge between two existing nodes.
The insertion can be processed by adding either x or y to i) Lout of of ancestors of x and 2) Lin of descendants of y.
It is easy to see that this procedure would preserve the node-separation property.
Among the two choices (x and y), we pick the one that minimizes the increase in the size of the updated 2-hop labels.
Based on these, the algorithm proceeds as follows.
A and D are the ancestors of x and the descendants of y respectively (Line 06).
Next, the increase of index size with respect to x and y is computed (Lines
 of A and Lin of D are updated accordingly (Lines 10-13).
Complexity.
The dominating step is Lines 07-08 and Lines 10-13.
In the worst case, A and D comprise of all nodes in the graph.
The complexity is O(|V |) 2-hop lookup and update.
Insertion of a subgraph.
We end this section with a discussion on the insertion of a subgraph g into an existing graph G. This can be implemented by using Algorithm insert.
First, we build the 2-hop cover of the induced subgraph of the new nodes in g. Second, we handle the insertion of crossing edges between the 2-hop covers of g and G which can be handled by Case 3 of Algorithm insert.
Our experimental evaluation focused on the effects of graph size (|G|) and edge to vertex ratio (|E|/|V |), as a measure of graph density, on the index size and update performance of various versions of 2-hop labeling and the effectiveness of the proposed updatable 2-hop labeling.
We used the 2-hop labeling of [21] (denoted as SC-II) and [7] (denoted as SCI) as well as their respective deletion algorithm implemented by [4].
u2-hop-A, u2-hop-B and the hybrid of the two are denoted as UH-A, UH-B and UH-B-A, respectively.
We tried UH-B-A on a large number of random graphs and selected a constant X for switching between UH-B and UH-A.
The hybrid of u2-hop-A and SC is H-A-SC.
For H-A-SC, we switched from UH-A to SCI when UH-A did not offer more than 10% compression.
All these labelings have been implemented in C++.
The experiments were run on a system with a 3.4GHz Pentium processor with 3G bytes of RAM running Windows XP operating system.
We use both synthetic directed acyclic graphs randomly generated by [13] as well as real-world graphs obtained from [3].
acteristics of the 2-hop labeling.
We set the edge to vertex ratio of the graphs to be 2 and varied the size of the synthetic graphs.
The size of the 2-hop covers of the graphs are reported in Figure 11 (a).
It shows that UH-B and UH-B-A were consistently larger than SC-II, SCI and H-A-SC.
The reason is that the latter three uses SET COVER for index construction, which is optimized for index size.
UH-B produced 2-hop covers with the largest size.
As expected, UH-B-A returned 2-hop covers that were smaller than UH-B but larger than UH-A.
UH-A and UH-B-A sometimes produced smaller indexes than SC-II, SCI and H-A-SC.
This depends on the structure of the graph, most notably the number of cut vertices.
UH-A is small for these particular random data graphs.
As veri ed by Table 2 and 4, UH-A is often larger than SC-II, SCI and H-A-SC.
The runtime of the 2-hop label constructions are reported in Figure 11 (b).
Our construction algorithms were not as scalable as SC-II and SCI.
The construction increased more rapidly when compared to SC-II and SCI.
This is due to the computation of the initial bipartite graphs for UH-A and H-A-SC.
UH-B and UH-B-A were comparable to SC-II and SCI since they did not require building a large number of bipartite graphs.
Next, we set |V | = 1000 and varied the density of the graphs.
We observed that UH-A, UH-B and UH-B-A were more sensitive to graph density than the others.
The reason for UH-A is that there were few cut vertices in a dense graph; for UH-B and UH-B-A, we noted that the bisections were large.
H-A-SC remained ef cient because, when only few cut vertex were found, it switched to SCI.
In the next experiment, we studied the impact of the threshold for switching from UH-B to UH-A in index construction.
We set |V | as a constant: |V | = 8000.
We present X as the number of nodes for switching.
When X = 0 (resp.
8000) , the index is UH-B (resp.
UH-A).
The result is reported in Figure 12 (a).
It shows that the index size decreased gradually as we increased X.
Figure 12 (b) shows the construction time for UH-B-A as we varied X.
As X increased, we computed more (and possibly large) bipartite graphs and the time increased rapidly.
Deletion performance.
The next experiment veri ed the ef ciency of Algorithm delete.
The deletion algorithm for H-A-SC is the extended version of Algorithm delete as described previously.
We generated three graphs G1, G2 and G3 where |V | was set to 4000 and their edge to vertex ratios were roughly 3, 4 and 6, respectively.
The statistics of the 2-hop covers constructed by different techniques is presented in Table 2.
In order to observe the performance difference, we generated a long deletion sequence consisting of 100 random deletions and applied this workload to the three graphs.
The total deletion times are reported in Table 1.
The result shows that UH-B, UH-B-A, UH-A and H-A-SC outperformed SC-II and SCI.
For the large graph G3, deletions on these 2-hop covers





 e z i s x e d n













 (a) Index size by varying the graph size








 ) s d n o c e s ( e m
 i











 e z i s x e d n




















 (b) Construction time by varying the graph size (c) Index size by varying |E|/|V | Figure 11: (a) and (b) Index performances with |E|/|V |=2; (c) Index construction with |V |=1000 ) s d n o c e s ( e m i t g n i d l i u









 a t l e












 Threshold Threshold e z i s x e d n













 -50000 -100000 -150000 -200000


 (a) Index sizes by varying X (b) Index construction times by varying X (c) Change in index sizes after deletions Figure 12: (a) and (b) Index performances by varying X; (c) Change in index size e z i s x e d n








 Graph


 Graph


 Table 1: Total deletion time in seconds



















 Table 2: Initial Index size

































 could be more than one order of magnitude faster as no (partial)
 ef cient for G3, although the extended algorithm performed more computation.
The reason is that the sizes of UH-A, UH-B and UH-B-A are larger than that of H-A-SC.
Even though H-A-SC required more steps for deletions, it operated on a small index.
A counter-intuitive fact about deletions is that previous deletion algorithms did not always reduce the size of the index.
We reported the change of index size due to the deletion workload in Figure 12 (c).
Note that UH-A, UH-B, UH-B-A and H-A-SC always return a smaller 2-hop cover after deletions.
In comparison, since
 index size may increase after deletions.
The decrease in H-A-SC is smaller than UH-A, UH-B and UH-B-A since only part of H-A-SC satis ed the node-separation property.
Insertion performance.
The next experiment veri ed the insertion performance of UH-A, UH-B, UH-B-A and H-A-SC.
Insertion of SC-e z i s x e d n i a t l e
 Delta due to crossing edges New nodes index size










 Figure 13: Insertion performance varying crossing edges



 Number of crossing edges Table 3: Real graphs used in the experiment Graph














 II was brie y discussed in [21] and that of SCI was not discussed in [7].
Thus, in this experiment, we skipped SC-II and SCI.
We used G2 for this experiment.
The newly inserted graph has 1000 nodes and 4000 edges.
Then, we ranged the number of crossing edges, that connect the new graph to G2, from 5 to 100.
The insertion times is roughly 4 seconds among all workload and all 2-hop labeling.
This is because these 2-hop labels used the same insertion algorithm.
We then studied the impact of the number of crossing edges in the insertion workload.
We presented the results in Figure 13.
Since the number of nodes in the new graph is  xed, we reported the index size of the new graph and the index size due to the crossing edges separately.
Figure 13 shows that the index size increased gradually with the number of crossing edges.
Experiment with real-world graphs.
We have tested the deletion performance on three real-world graphs.
The sizes of the graphs



 Table 4: Initial index size















 Table 5: Total deletion time in seconds Graph
















 and their indexes are described in Table 3 and Table 4, respectively.
As before, we have randomly chosen 100 nodes and sequentially delete these nodes from the graph.
The total time taken to perform this workload is presented in Table 5.
The result shows the effectiveness of UH-A and H-A-SC.
Both UH-A and H-A-SC were consistently faster than SC-II and SCI.
The index sizes of SC-II and SCI were larger after deletion.
For UH-A and H-A-SC, the updated index size was smaller.
H-A-SC required more operations but operated on a smaller index.
In this paper, we have proposed two heuristics based on cut vertex and minimum bisection for 2-hop label construction.
The 2-hop covers constructed by such heuristics exhibit the node-separation property that lead to a simple incremental maintenance algorithm.
We analyze deletions of existing 2-hop labeling and proposed a simple deletion algorithm for handling such deletions.
We have presented incremental maintenance algorithms for our 2-hop labeling.
Extensive experiments have been conducted to show the characteristics of various versions of 2-hop labeling.
The results showed that the incremental maintenance algorithms are ef cient and the hybrid of our and existing 2-hop can achieve both good update performance and small index size.
u2-hop-A construction is computationally intensive, for a similar reason presented in [9].
We have submitted a followup work on scalable u2-hops for publications.
implementation of 2-hop labelings [21, 7] used in [4].
We thank anonymous referees for their invaluable comments.
