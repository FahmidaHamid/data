The Telecom business model is evolving.
With the market reaching saturation and revenues from voice calls decreasing rapidly, Telecom operators are aggressively looking at newer Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
sources of revenue.
This includes partnerships with third-party providers to o(cid:11)er alternate services such as gaming applications, news, ringtones, etc.
In recent years, however, these services are facing strong competition from similar technologies and applications provided by Internet Content providers.
These applications can be accessed through a browser-enabled phone, while paying only for the connectivity charges, and thereby adversely a(cid:11)ect revenues from the paid-for-services hosted on the Telecom operator portal.
Examples of such services range from VoIP and telephony conferencing services to various content services (maps, ringtones, etc.).
An increasing number of mobile users are now using browser-enabled phones to access these services, bypassing the Telecom portal.
For example, it has been estimated that 60% of the mobile content tra(cid:14)c in US and 90% in Europe is o(cid:11)-portal [10].
Telecom operators, however, have an edge over Internet service providers in terms of their still unmatched core functionalities of Location, Presence, Call Control, etc., characterized further by carrier-grade Quality-of-Service (QoS) and high availability.
Therefore, a potential channel for the operators to increase their revenue is to o(cid:11)er these functionalities as services to developers for creating new innovative applications.
These developers can belong to not only the select partners of the Telecom operator, but also those involved in creating a variety of long{tail applications [18].
Moreover, with the underlying IP and telephony networks converging, developers can compose these functionalities with third party services available on the IP network.
For example, Location and Presence information from Telecom can be clubbed with Google Maps to provide new workforce management solutions for mobile settings [15].
To support the basic operations such as voice and SMS, many of the building blocks of a Telecom infrastructure location registries (HLR/VLR), accounting and billing services, etc.
- are already in place.
However, these are not easy to utilize in new applications because they are not exposed using standardized frameworks and component models.
Towards this, Telecom operators are steadily adopting Service-Oriented Architecture (SOA) that would let developers access these services without knowledge of the underlying platform implementation.
Web services, as an instantiation of SOA, have received much interest in the community due to their potential in facilitating seamless business-to-business or enterprise application integration [22].
The Parlay consortium has de(cid:12)ned a standard, called Parlay-X [8], that exposes Web service interface for core Telecom functionali-
provides a reference framework to expose these functionalities as services to Web-engineered systems using SIP [19].
Although e(cid:11)orts like Parlay-X and IMS are a step in the right direction, rapid development of applications that utilize Telecom functionality still faces a number of challenges in a realistic setting.
Firstly, one needs to provide interfaces that shield the application developer from di(cid:11)erent Telecom protocols (Parlay-X, SIP, etc.
), including the legacy ones.
Secondly, one needs to package the Telecom functionalities so that they can be readily used in di(cid:11)erent programming styles (Java, HTML/JavaScript, etc.)
other than pure Web service based composition (like BPEL).
Finally, one also needs to encapsulate the invocation of Telecom functionality with various coordination rules, for example, those that correspond to managing the usage of a service, including monitoring, metering and access control.
In this paper, we present SewNet, a framework that addresses the above challenges to enable rapid composition of Telecom services.
Our main contributions in SewNet can be summarized as: (cid:15) We propose the Telecom Service Reference, Encapsulation and Coordination (T-Rec)  Proxy  model.
This enables developers to seamlessly incorporate Telecom functionality and apply various coordination rules.
(cid:15) We design a service composition environment based on the T-Rec model, and implement a prototype.
(cid:15) We demonstrate how SewNet can be used by di(cid:11)er-ent categories of developers, including Java, BPEL and HTML/JavaScript programmers.
It is important to note that although we focus on Tele-com in this paper, the T-Rec proxy model is generic and applicable to third-party services available on the Web.
The rest of this paper is organized as follows.
In Section 2, we motivate the reader towards challenges and issues in composing Telecom functionality in di(cid:11)erent applications.
We then propose and describe our T-Rec model in Section 3, followed by SewNet s architecture in Section 4, and implementation in Section 5.
Section 6 illustrates the use of SewNet for two use-case scenarios, while Section 7 provides a discussion of related work.
We conclude in Section 8.
We illustrate the problem with respect to the component-oriented diagram of a service that utilizes Telecom functionality, as shown in Figure 1.
In general, such an application can be broken into two major blocks.
Firstly, there are Tele-com blocks (represented as red rectangular boxes in the (cid:12)g-ure) that invoke a Telecom network functionality (for example, invoking the location service or capabilities like SMS, Third Party Call Control).
The others are non-Telecom blocks, where the developers can embed various constructs (depicted by green hexagonal boxes in the (cid:12)gure).
For example, in a workforce management solution, these blocks can contain logic for scheduling agents on the basis of Location and Presence information provided by Telecom operator.
Alternatively, these blocks can be UI constructs, for instance those enabled by various Ajax-based platforms.
Finally, the non-Telecom blocks can also be invocation points Receive SMS Location
 service Send SMS Start App Logic Presence End App Logic UI Construct Figure 1: Model of a Telecom Service for orchestration with third party services available over the Web.
Also, as the (cid:12)gure shows, to bind these Telecom and non-Telecom blocks, speci(cid:12)cation of complex control and data (cid:13)ows is also required during the service design.
We believe that for application development utilizing Tele-com blocks composed with the non-Telecom ones, the following challenges need to be addressed: Firstly, functionality available within a Telecom operator is, in general, exposed using multiple protocols.
For example, Presence related information can be accessed via the SIP protocol, and Messaging capabilities using SMPP protocol.
As a step towards hiding protocol heterogeneity and complexity, the Parlay consortium has come up with the Parlay [9] and the subsequent Parlay-X standards [8].
Parlay-X exposes a Web Services interface for several Telecom functionalities.
However, it does not cover the whole gamut of functionalities that can be o(cid:11)ered by the Telecom operator, especially those requiring session control.
Further, some of the Telecom functionality can also be exposed through legacy protocols.
Therefore, we need an abstraction model that provides interfaces shielding the application developer from the underlying protocols.
This model should also allow seamless switching between di(cid:11)erent protocols, for example, when moving from legacy interfaces to the Parlay-X ones.
Secondly, developers who want to utilize Telecom functionality in their application can belong to di(cid:11)erent categories [18].
More speci(cid:12)cally, composite applications modeled in Figure 1 can be written in Java, BPEL, HTML/JavaScript, etc.
Although editors corresponding to the various programming styles provide the developer with constructs for the non-Telecom blocks, they still require the Telecom functionalities packaged in a format suitable for incorporation.
For example, in the case of Java applications, a developer needs a Java interface to invoke these functionalities (while a Java-based programming environment lets her code much of the non-Telecom blocks).
Similarly, developers require a WSDL interface for a BPEL-based composition, JavaScript for a HTML/JavaScript based composition, etc.
Therefore, the abstraction model (outlined above) for core Telecom functionalities needs also to be broad to cover a range of programming styles.
Thirdly, even though interfaces like WSDL (for Parlay-X) and SIP have tools to generate \clients" for invoking the corresponding functionalities, in real life, however, there is e(cid:11)ort required to integrate these clients within the application.
For example, code needs to be written to incorporate the client in the application code, while taking care of tertiary library dependencies for this client.
It would help the developer immensely if the abstraction model pre-generates the clients corresponding to di(cid:11)erent programming styles, and packages them in a structured manner.
Having a well-de(cid:12)ned structured format would enable any application de-
Java/ JavaScript/
 Telecom Block Reference Encapsulation Coordination Parlay-X/
 Legacy Protocols       T-Rec Proxy Figure 2: T-Rec  Proxy  Model velopment environment (with some extensions to interpret this structure) to integrate these clients seamlessly.
Finally, when Telecom functionality gets used in an application, Telecom operator as well as the application developer want to coordinate its usage.
For instance, one needs mechanisms for embedding logic for charging, specifying access control policies, etc.
Furthermore, with recent trends suggested by Web 2.0, application developers should be able to contribute, implicitly or explicitly, to the enrichment and re(cid:12)nement of the exposed Telecom functionality (and its usage).
Therefore, the abstraction model needs to be rich enough to enable all of this.
A number of operators are already moving in the direction of making their core functionalities available for application development.
For example, British Telecom has released a Software Development Kit [11] that enables its network services to be utilized in Web mashups.
However, what is missing is an abstraction model which is broad, structured and rich, as motivated above.
We propose such a model next, and thereafter describe a service creation framework on top of this model.
Figure 2 represents the basic concept of our Telecom Service Reference, Encapsulation and Coordination (T-Rec)  Proxy  model.
In essence, once an application has been broken down into Telecom and non-Telecom blocks, this model is used to realize the Telecom blocks, considering the programming style, while also enabling mechanisms for coordination and enrichment.
In practice, these proxies would be created by a Telecom operator and made available to application developers over the Web (or a converged IP network).
Our rich, structured T-Rec Proxies consist of the following elements: (cid:15) Proxy Representation.
Contains signatures of the methods (APIs) exposed by the proxy along with a textual description of the service it represents.
The APIs are designed to hide protocol speci(cid:12)c details and abstract the Telecom functionality to the programming language level.
As discussed before, APIs corresponding to multiple styles (Java, BPEL, JavaScript) should be created to support di(cid:11)erent environments.
(cid:15) Implementation.
This module connects to the Telecom service using the underlying protocol, and is available in di(cid:11)erent formats.
For example, the implementation could be in the form of a .jar (cid:12)le for a Java proxy, a .js (cid:12)le for JavaScript, or could be encapsulated by visual constructs, such as widgets, and used inside HTML pages.
(cid:15) Con(cid:12)guration File.
Proxies come with a default setting but can be further con(cid:12)gured by developers.
This includes assigning default values for some of the parameters in an API, specifying the access control list, etc.
Such settings could also be functionality speci(cid:12)c, for instance, restricting the size of SMS messages.
(cid:15) Metadata.
To enable easy look up, keywords and tags related to the proxy functionality are associated with it.
New tags can be added to the proxies if required; for example when a developer utilizes a proxy in a way that was not originally foreseen by its creator.
(cid:15) Utility Snippets.
The proxies are populated with multiple code snippets on top of the basic functionality.
For example, a  Presence  proxy may have a program fragment that parses the returned response (usually an XML document) for di(cid:11)erent attributes.
These utilities can be suggested, in an appropriate manner, to developers who wish to use the proxy.
(cid:15) Unit Test Code.
Proxies contain codes that let di(cid:11)er-ent APIs supported in the proxy be tested in isolation.
These are very helpful during testing and debugging.
(cid:15) Link to Blogs.
Each proxy is linked to a blog entry where developers can log their experience of using the proxy.
If multiple proxies are suggested during a look up, analyzing the blog entries can help the developers choose the most appropriate one for their task.
Intuitively, a T-Rec proxy acts as a  wrapper  for Telecom functionality, including its underlying protocol.
Using this wrapper, the proxy creator can provide several bene(cid:12)ts to application developers.
APIs de(cid:12)ned in a proxy can hide protocol speci(cid:12)c details from the developer.
For example, interfaces in Parlay-X throw exceptions with error codes that require knowledge of Parlay-X for interpretation.
As an instance, an application developer using Parlay-X would need to know that the error code SVC0004 stands for invalid addresses in a message.
Using the proxy model, we can encapsulate these error codes with higher level exceptions, such as throwing InvalidAd-dressException whenever error code SVC0004 is returned.
Moreover, using proxies, similar APIs can be exposed across di(cid:11)erent protocols.
For example, various APIs in the Location proxy can have similar signatures for Parlay-X and SIP-Presence based implementations1.
When Telecom proxies get used in an application, Telecom operator as well as the developer can manage and meter its usage.
For instance, whenever the proxy corresponding to Location information gets invoked within an application, the Telecom operator can authenticate the developer and also charge some amount.
In this case, proxies are con(cid:12)gured to collect the relevant information, for example developerId, from the developer and send to the operator.
Similarly, the
 the presence information, and parsing the returned document.
We can wrap this under a getLocation() interface.
) s ( o i d u t
 n o i t i s o p m o


 a v a



 ``!abc dbef jf `k



 / t p i r c
 a v a





 ``!a b)c d)bef jf `k

   Web e r o
 t e
 w e
      Call Forwarding Messaging Call Control Location VoIP Payment   &)' .
)/ &)*+ !
" (!01 #
 &'





 ;?l o!K =m= qLDr =n;=>)= tu :?@ vwD)x y>)=)8 ~u }L;w=>)=


 :?@    8
  <;w=>)=:)?@
 Figure 3: SewNet Architecture developer can con(cid:12)gure the Location proxy to cache the location information locally within itself, and avoid connecting to the operator s infrastructure at each invocation.
The proxy model also provides an easy mechanism to incorporate various business contracts between the operator and the developer.
For example, implementation module in a proxy can be extended to make the proxy display advertisements on behalf of the operator, whenever it is invoked.
In this case, logic can be such that the proxy picks what to advertise on a real{time basis.
Using the proxy model, developers can collaborate, share and contribute towards enriching Telecom functionality.
For instance, user of the Location proxy in an application can publish a utility to parse the output of this service.
This utility can be reused by other developers while incorporating this proxy in their applications.
Similarly, the proxies can be con(cid:12)gured to provide updates to a developer about new entries on the blog, utilities published recently and bug (cid:12)xes, etc.
In the case of bug (cid:12)xes, logic can be embedded in the proxy to automatically download the latest implementation modules.
In this section, we present SewNet, a framework that utilizes the rich, structured T-Rec proxy model to enable seamless weaving of Telecom functionality with application logic and other constructs required to develop a service.
As Figure 3 shows, SewNet has two main architectural components - SewNet Core and Composition Studio(s).
SewNet Core forms the backbone architecture that exposes Telecom functionality to developers through simple, intuitive interfaces for lookup and select while allowing for developer participation and feedback through publishing and blogging.
Telecom Repository consists of proxies for di(cid:11)erent functionalities exposed by the Telecom operator.
These proxies are available in various implementation styles, for example, Java proxies to be used inside Java applications, JavaScript proxies to run on a Web browser, etc.
As mentioned earlier, each proxy hides the underlying protocol (Parlay-X, SIP, etc.)
and o(cid:11)ers a rich set of APIs to facilitate integration with the application being developed.
Metadata Manager helps the Telecom Repository organize and maintain relevant metadata (keywords and tags, textual description, etc.)
associated to a proxy and the APIs it o(cid:11)ers.
This information is used to suggest proxies on a look up.
Blog Manager organizes and stores free-form textual comments associated to a proxy and its APIs.
These inputs are presented to the developer while browsing and selecting proxies from the Telecom repository.
Analytics Manager maintains qualitative information about proxies, including a rating and ranking of each proxy.
We envision this manager containing tools to analyze blogs by di(cid:11)erent developers, collect usage statistics, etc.
and making such information available to application developers.
Publish Manager de(cid:12)nes the interface to publish new proxies as well as new artifacts associated to an existing proxy; published items become available to other developers.
Developers wishing to use Telecom proxies exposed by SewNet need to integrate their development environments (or composition studios) with SewNet Core.
These studios range from programming platforms (e.g.
Eclipse environment) to model driven tools (such as those containing UML editors for service design and representation) to work(cid:13)ow editors allowing services to be composed in a language like BPEL.
For integration with SewNet Core, a studio needs extensions along three dimensions.
Firstly, its service design (or programming) editor should provide the ability to identify the Telecom blocks from the non-Telecom blocks.
Secondly, it should o(cid:11)er Lookup, Publish and Blogging interfaces for proxies provided by SewNet core.
Thirdly, once proxies have been selected for di(cid:11)erent Telecom blocks, a Code Generator module should traverse the structured format of each proxy to seamlessly integrate it with rest of the application code2.
It is interesting to note that a particular composition studio may use one or more di(cid:11)erent types of proxies.
For example, while creating a JSP page, developers can incorporate Java as well as JavaScript proxies.
Once a composition studio has been integrated with SewNet Core, the following steps illustrate the process that application developers follow to compose Telecom services:
 drag-and-drop or other mechanisms supported on the design editor.
In this step, Component services, Logic blocks, Control (cid:13)ow (sequencing, fork, join), etc.
are de(cid:12)ned by the developer (c.f.
Figure 1).
tains a set of matching proxies from repository, based on keywords, input-output, or both.
SewNet, the developer selects those that best (cid:12)t the requirement.
Proxy selection is based on suitability
 code generation capabilities.
In this case, we just need to extend these capabilities to incorporate the proxy model.
 $ % & ( % , -









\
 _ g h i


 \
 _ g h i l
 p s





 z l { |

   

 u
 u
 p
  

 { }
   r

  
  
  


 Service Design Proxy Look up, Select         Transformation    The code produced depends on the programming language.
For example, while for Java, it creates a class with an invoke method that internally calls the proxy API, for BPEL, it generates an invoke statement.
Further, Code Generator also analyzes the method signature of each API to understand the exceptions being thrown and organizes appropriate exception-handling blocks around it.
Finally, Unit Test codes available with each proxy are included in the code generated.
Figure 4: Code Generation

 (for e.g.
metadata (QoS parameters like reputation, etc.
).
reading more about each proxy) and other
 various service coordination rules with each proxy.
For example, she speci(cid:12)es the time-period after which cached location information is to be refreshed by the Location proxy.
vice (BPEL, Java, JavaScript inside HTML, etc.).
This step is described in more detail in the next subsection.
appropriate application logic, UI elements, etc.
to complete the service.
At this point, developer also takes care of data-(cid:13)ow between di(cid:11)erent constructs.
From a developer s view, once a service has been designed and relevant proxies for the Telecom blocks selected, she expects the composition environment to generate a skeleton code that not only captures the service (cid:13)ow, but also integrates code for the selected proxies.
Further, this code should provide her the extension points to include application logic and other constructs for the non-Telecom blocks.
We divide this process of  Code Generation  into three steps:
 a structured document, that we call processDoc.
Further, for each Telecom block, processDoc stores information about the proxy that was selected, and the API that was chosen under this proxy.
It should be noted that the structure of processDoc and the information it stores is dependent on the programming style of the application.
More speci(cid:12)cally, it should be able to represent each programming construct of that style.
Doc and transforms it to a concrete, fully-compiled code.
For this purpose, Code Generator parses pro-cessDoc and converts each element into the corresponding programming construct.
While parsing this document, it creates place holders for the non-Telecom blocks and adds comments to aid the developer when she examines the generated code.
For the Telecom blocks, it populates the proxy code, as described next.
Generator imports the relevant implementations of the proxies from the Telecom Repository and generates the code necessary to invoke the selected API in the proxy.
In this section, we describe an implementation of SewNet, including various Telecom proxies, a composition studio to develop services using these proxies, and generation of code in two di(cid:11)erent programming styles - Java and BPEL.
In our current implementation, we have built T-Rec proxies corresponding to SMS, Location and Presence functionality and are in the process of creating a proxy for Third-party Call Control (3PCC).
While SMS, Location and 3PCC are designed on top of Telecom Web Services Server3 (TWSS), Presence proxy is developed on SIP interfaces exposed by WebSphere Presence Server (WPS)4.
TWSS is an o(cid:11)ering from IBM that enables Telecom operators to provide developers with controlled, reliable access to network capabilities such as Location, SMS and Call Control through standards-based Parlay-X Web Services.
On the other hand, WPS is an application that collects, manages, and distributes real-time presence information to applications and users based on the SIP protocol.
Proxies for each functionality were created in three programming styles - Java, WSDL and JavaScript.
As noted earlier, each proxy has an implementation module that connects to the service through the underlying protocol, a service representation object (including metadata about the proxy), a module to test the proxy in isolation and (cid:12)nally a set of attached utilities.
All proxies are available through a repository implemented on top of DB2 5.
This repository provides various interfaces for integration with a composition studio - proxy lookup and import, publishing of new proxies and utilities, blogs indexed per proxy per API, etc.
We are currently in the process of including the capability to analyze blogs and feedback received for di(cid:11)erent proxies.
For SMS and Location, BPEL proxies were created by using the WSDL interfaces de(cid:12)ned by Parlay-X, these provide su(cid:14)cient information for invoking the corresponding functionality from a BPEL work(cid:13)ow.
On the other hand, Java proxies were implemented by generating Java clients from these WSDL descriptions (using standard IBM tools) and wrapping inside our proxy structure.
For Presence proxy based on SIP, we used the JAIN SIP standard and rendered the interfaces in Java for publish, subscribe (with noti(cid:12)ca-tion handling), etc.
This implementation was also exposed as a Web service, using which a WSDL interface was obtained for the BPEL proxy.
For Parlay-X based functionality (SMS and Location), JavaScript proxies can be created by including standard SOAP over HTTP calls from within a JavaScript code frag-3http://www-306.ibm.com/software/pervasive/serviceserver/ 4www.ibm.com/software/pervasive/presenceserver/ 5www.ibm.com/db2
         "!
#$   #   Location LogicBlock2    Start ReceiveSms SmsType Join End        LogicBlock1 Presence LogicBlock3      Figure 6: Proxy Look Up and Publish Figure 5: SewNet Composition Studio ment.
However, for SIP based proxies like Presence, the above procedure does not work since SIP messages are exchanged over TCP/UDP.
To create a JavaScript proxy in this case, we (cid:12)rst implemented a servlet (to be hosted on the operator s infrastructure) that talks to the Presence Server using SIP (over UDP) messages.
In turn, the Presence JavaScript proxy interacts with this servlet to fetch presence-related information while shielding the developer from speci(cid:12)cs of SIP protocol.
Apart from proxies, our repository contains a Telecom Constructs Library (TCL) to o(cid:11)er developers with ready-to-use constructs that can be utilized in a variety of Telecom applications.
For example, this library consists of datatype de(cid:12)nitions based on the TeleManagement Forum s Shared Information/Data (SID) model6 for the Telecom industry.
TCL also contains de(cid:12)nitions of various exceptions related to the Telecom domain, such as NetworkBusyException, Un-knownEndPointException, etc.
These exceptions encapsulate various protocol speci(cid:12)c error codes, like those de(cid:12)ned in the Parlay-X standard (c.f.
Section 3.2.1).
Figure 5 gives a snapshot of a prototype Composition Studio for SewNet along with an annotation of its di(cid:11)erent components.
The Constructs palette o(cid:11)ers constructs to help build services, for example, those for specifying start and end blocks, di(cid:11)erentiating a Telecom block from application logic block, a condition statement, a join, etc.
On the other hand, Telecom palette exposes proxies for accessing functionalities of the Telecom network, and currently supports SMS, Location and Presence.
The Design Canvas lets the developers design their services through simple drag-and-drop of various constructs and Telecom functionality.
The Properties View displays attributes attached to di(cid:11)erent components of a service design.
Once the service has been completely designed and the proxies chosen, developer can generate code by invoking the Code Generator.
Currently, code can be generated in Java and BPEL.
The Composition Studio provides service developers the
 facility to look up existing proxies and also publish new ones.
The proxy look up and publish interfaces are shown in Figure 6.
The look up is enabled by SewNet s Metadata Manager and can be invoked using simple keywords.
The results (cid:12)rst display a brief description of the suggested proxies following which the developer can ask for more details for the ones that match her requirements.
At this point, developers can also check blogs to bene(cid:12)t from other users  experience.
The publish interface, on the other hand, provides an easy mechanism for developers (operators in the case of Telecom functionality) to package their services as a proxy, and publish the same in the repository.
These proxies can be looked up and reused by others, thereby fostering a collaborative environment.
To guide the developers in their composition process, Composition Studio also includes a set of application templates.
These templates range from being simple applications utilizing core Telecom functionality to workforce management solutions and other such services making extensive use of Location and Presence information.
Developers using SewNet have the option of starting with these templates, and re-(cid:12)ning them in the design canvas as per their requirement.
Code Generator can then output code for these.
The entire Composition Studio is implemented as a plugin to the Eclipse platform7.
Eclipse is an open source meta IDE built using Java and can be used for building other IDEs.
By becoming part of the Eclipse framework, this studio becomes immediately available to the large community of Eclipse users.
Moreover, the plugin based approach allows tapping into various existing and future components being added to the Eclipse platform.
For example, generated Java code is directly editable using plugins included in Eclipse.
As discussed before, developers can coordinate various aspects of their usage of Telecom functionality through the proxy model.
The current implementation of these proxies helps developers coordinate their execution (in the developed application) with respect to testing, billing and con(cid:12)g-uring various application speci(cid:12)c requirements.
A major challenge for developers in Telecom domain is to perform the tasks of testing and debugging without going  live  on the network.
Towards this, SewNet provides an implementation of proxies for a Telecom simulator8.
This simulator mocks the basic operations of SMS, Call Control, etc.
7http://www.eclipse.org 8http://www.openapisolutions.com/
                         %           based on a back-end network emulator and can be used to simulate various Telecom settings and con(cid:12)gurations.
Such  simulator  proxies can be used by developers for correctness and functionality testing, and debugging, before moving on to  real  network proxies.
In this case, developers do not need to change their service design, albeit just switch to the corresponding proxies for real network.
Telecom operators spend a signi(cid:12)cant amount of time provisioning a new service and connecting it to their billing system.
In SewNet, we have exposed the Charging functionality of the Telecom operator (on top of the de(cid:12)ned Parlay-X interfaces) using the T-Rec proxy model, and made it available through the repository.
A well encapsulated proxy for billing helps the operator in populating charging rules corresponding to a proxy user.
Furthermore, billing proxy can also be o(cid:11)ered to a developer who can utilize it to charge users of her application.
The charging models supported by the Billing proxy are of various types; for instance, charging could be based on a contract basis or a per usage basis.
SewNet proxies include a set of con(cid:12)gurable attributes to suit a variety of applications.
For example, in SMS the developer can restrict the size of message sent by a user.
For Location, the developer can con(cid:12)gure the period of time for which the location information is cached within the proxy.
Similarly, default handlers are de(cid:12)ned for exceptions thrown by di(cid:11)erent interfaces.
For instance, on encountering a Net-workBusyException, the default rule can be to wait for a certain amount of time before retrying.
These attributes can be utilized and con(cid:12)gured by the proxy user at any stage of the service development process to suit her requirements.
SewNet s Composition Studio allows the developers to output the service code in two di(cid:11)erent programming styles - Java and BPEL.
In each of these cases, the service design is captured using a processDoc (described earlier in Section 4.3) based on the BPEL Schema.
BPEL is an XML-based programming language to describe high level business processes and has many constructs to capture service design, including invocation, fault handling, correlation, and support for conditional logic.
Service design captured in processDoc is converted into a Java project that can be imported inside the Eclipse programming environment.
For this purpose, we (cid:12)rst make a skeleton of an Eclipse project including creation of a package structure and the metadata (cid:12)les .project and .classpath.
A Java class is generated for each of the Telecom and non-Telecom blocks occurring in processDoc, while a main class is created to capture the (cid:13)ow of the service.
During population of the main class, constructs from the processDoc (invoke, switch, etc.)
are transformed to the corresponding ones in Java.
While for the classes generated for non-Telecom blocks, the developer is expected to embed her application logic, for the Telecom blocks, SewNet populates the classes with code for invoking the chosen proxy.
For this purpose, we (cid:12)rst import the underlying implementation jars from the repository, add the corresponding import statements in the Java class9, add statements to instantiate the underlying proxy object, and capture the output of API chosen by the developer.
Further, we parse the API invoked to import the data-types corresponding to input and output variables, and to add try-catch blocks for handling the exceptions that can be possibly thrown.
In general, the code produced is well-formatted and documented to smoothen the task of ordinary Java programmers.
While the code generated acts as a template for the composite service, it needs to be examined and modi(cid:12)ed by the developer to ensure that the data (cid:13)ow between component services (input-output type matching, ordering of parameters, etc.)
is handled properly.
Further, it should be noted that since we are using a processDoc based on BPEL schema to capture service design, the code that can be outputted in Java is restricted to those constructs that can be represented using BPEL structure.
We are currently investigating extensions to this schema that would enable a richer Java code.
In this case, we assume the Telecom blocks to be realized by Web services and BPEL becomes the  glue  to bind these Web services into a cohesive business solution.
From the service design in processDoc, we (cid:12)rst generate the WSDL description that provides the name and interface for the composite service and describes the port types and partner link types for stitching together the di(cid:11)erent blocks (components) in this service.
The next step is the generation of a concrete BPEL structure that captures the invocation of di(cid:11)erent components in the manner as described by the processDoc i.e., the control-(cid:13)ow of the service.
Further, we populate the Telecom blocks using speci(cid:12)c details from the corresponding WSDL descriptions.
For example, we introduce variables that capture the input and output of each of these blocks.
Similarly, we automatically import the schemas containing de(cid:12)nitions of the various used data-types.
For the non-Telecom blocks, the developer has the option of either wrapping them as Web services or utilize extensions to BPEL supporting inline Java code.
Finally, similar to the case of code generation in Java, the developer needs to edit this template BPEL work(cid:13)ow (for data-(cid:13)ow, etc.)
before it is actually deployed.
We now illustrate how SewNet can be used for rapidly developing new Telecom applications.
We demonstrate composition of two services.
While the (cid:12)rst one involves utilizing core Telecom functionality glued together by rich application logic, the second service is a mashup of Telecom functionality and a third party service.
Telecom operators with their de(cid:12)ned presence and location frameworks can enable a  dynamic, real-time  Yellow-Pages service.
In essence, this service would provide matches in response to a customer request seeking  nearby ,  available  vendors (such as tourist looking for a cab) by using Telecom network to determine the availability and location of the subscribed vendors.
Business Finder [17] is an example of such a Yellow-Pages service.
9entries are added to the .classpath meta(cid:12)le also
 Presence Matchmake Start RecvSms Parse Condition Feedback Join SendSms End UpdateAvailability Availability Figure 7: Yellow Pages Design Figure 7 illustrates the design of this service on SewNet s Composition Studio.
The service receives request messages via the  receive SMS  functionality, and proceeds to parse the content of these messages.
The incoming requests can be categorized into three types.
The (cid:12)rst type corresponds to a customer s request for a nearby, available vendor.
For this, the service determines the current location and presence information of the subscribed vendors and formulates its response based on its internal matchmaking logic.
The second type of request is a feedback from a customer while the third type is from a vendor asking to update her availability status.
Finally,  send SMS  is used to return the response to the requester.
Once the service has been designed, the developer proceeds to look up appropriate proxies for each of the Telecom blocks.
In this case, proxies are selected for SMS, Location and Presence functionalities.
From the service design, code can be generated either in Java or as a composite BPEL.
Figure 8 presents a snapshot of the code generated in Java for the designed Yellow-Pages service.
As the code structure in the left panel of the (cid:12)gure shows, a class is created for each of the Telecom and non-Telecom blocks.
While the classes for SMS, Availability and Location are populated with code to invoke the underlying proxy, classes for Parse, Matchmake, Feedback and Up-dateAvailability correspond to the application blocks, and act as placeholders for the service developer to incorporate her application speci(cid:12)c logic.
YellowPages.java is the main class that coordinates the control (cid:13)ow of the service.
This class has the code to call each proxy and application logic block using the invoke keyword.
It also contains the transformation for constructs like switch, fork, join, etc.
used by the developer in designing the service.
Finally, as shown, the code also includes the Telecom constructs library (c.f.
Section 5.1) and a unit test code for each Telecom proxy.
The right section of Figure 8 presents the code generated to handle invocation of the Location proxy, including the block to instantiate the proxy object, import statements to de(cid:12)ne the used data-types, and handler blocks for the exceptions thrown.
In this example, we have also incorporated calls to the Billing service (for monetizing the usage of Location proxy).
As outlined earlier, the code produced can be easily imported as a project and enhanced inside the Eclipse development environment.
Figure 8: Code for Yellow Pages
 SewNet proxies can also be used to compose mashups involving Telecom functionality and third party services.
An example is demonstrated in Figure 9 that combines the Location proxy in JavaScript format along with the popular Google Maps service.
This simple mashup receives updates on the location information and displays it on Google Maps.
Note that this currently has no application logic component.
However, the same can be incorporated to develop a variety of di(cid:11)erent solutions, such as a mobile workforce management system [15]10.
We are in the process of extending an existing mashup editor, called QEDWiki [3], to enable seamless incorporation of SewNet JavaScript proxies in the mashups designed.
More speci(cid:12)cally, this editor needs to add statements to import the implementation (locationProxy.js (cid:12)le that contains getLocation() function), include JavaScript code to invoke the proxy (call getLocation() that internally subscribes callback() to receive location updates), de(cid:12)ne variables to capture the invocation output, etc.
All this shall be automatically done through interpretation of the JavaScript proxy structure.
In this section, we put SewNet under the perspective of various current and past e(cid:11)orts towards service composition.
While some of these pertain to Web applications in general, others are more speci(cid:12)c to the Telecom domain.
Composition using Web Services.
The literature on Web service composition is extensive.
Triana [20] aims to facilitate Web service composition by providing a higher level of abstraction and guiding developers in creating composed
 the Conference on IP Multimedia Subsystems Architecture and Applications (IMSAA-2007).
livery platform that hide low level Telecom protocol speci(cid:12)c constraints and allow creation of Managed network mashups.
However, both these lack a structured and rich format like our T-Rec proxy model.
Telecom Standards and Platforms.
The (cid:12)rst wave of e(cid:11)orts along exposing core Telecom functionality primarily focused on creation of open standards and APIs.
For example, Session Initiation Protocol (SIP) is an open standard being widely adopted across service providers to create Voice-over-IP services.
Many Telecom operators are now moving towards implementing the IMS framework [4] to expose their core functionalities (voice service, SMS service, Call control) using SIP.
JSR-289 [6] has been proposed by Sun and Ericsson to enhance existing SIP Servlet speci(cid:12)-cation and support development of composed applications involving both HTTP and SIP servlets.
E(cid:11)orts are being undertaken to come up with platforms that support concurrent execution environments for di(cid:11)erent standard-based protocols (e.g.
SOAP, SIP over HTTP) and business logic written in several languages (Java, BPEL, etc.).
For example, the IBM WebSphere Application Server product suite11 implements a converged SIP and SOAP servlet container, while enabling tailored message processing and policy enforcement for these protocols.
Alcatel is also exploring the option of SOA/REST APIs on top of its Telecom Application Server [1].
From SewNet s perspective, the proxy model can encapsulate di(cid:11)erent standards, while the implementation module can be based on available platforms.
Telecom Device Functionality.
A generic model of Telecom services is described in [18], where apart from core Telecom network functionality and third party o(cid:11)erings, services also make use of device functionality and information such as calendar, user pro(cid:12)le and location (e.g.
cell site information).
Currently, there are a plethora of end-user devices in a Telecom environment, ranging from basic (offering only the capabilities of messaging and voice) to sophisticated, state-of-the-art devices like iPhone12.
There are efforts to promote an open mobile phone software stack that abstracts hardware di(cid:11)erences and o(cid:11)er a uniform set of APIs for accessing many of the functions of a mobile phone (calendaring, date, etc.).
JSR 248 speci(cid:12)cation, contributed signi(cid:12)cantly by Sun Microsystems, is a step towards that direction.
To compose richer Telecom applications within SewNet, we can wrap the device functionality using the proxy model and make them available to a developer during the composition process.
In this case, such  device-side  proxies will not only ease the access to device functionality, but also shield the developer from the heterogeneity of the underlying device itself.
We wish to investigate device proxies based on JSR 248 in the near future.
Web 2.0 and SewNet.
The phrase Web 2.0 refers to a perceived business revolution in the Web community caused by the movement to Internet as a platform.
In essence, Web 2.0 changes the way in which businesses interact with its customers, by advocating the following core principles: a) provide power to the developers by o(cid:11)ering rich, intuitive, and interactive interfaces for services based on Ajax or similar frameworks; b) create an architecture of participation that encourages consumers to add value to a service as they 11www.ibm.com/software/webservers/appserv/was/ 12http://www.apple.com/iphone/ Figure 9: Mashup Code Fragment services.
The paper presents a case study that investigates how this environment can be used in a Telecom setting.
Syn-thy [14] demonstrates composition of a workforce management application enabled over a Telecom network, where core functionalities like Location are exposed as semantically annotated Web services and orchestrated using AI planning techniques.
The Meteor-S [23] framework looks at a number of aspects related to composition of Web services, including capture of semantic requirements of the process and choosing components under given constraints.
Zeng et al. [24] propose a method for choosing component services during Web service composition based on a generic QoS model (based on price, duration, reliability, etc.)
and established linear programming techniques.
As noted earlier, in a Telecom environment, we need a broader model than pure Web services to cover di(cid:11)erent protocols.
In any case, SewNet s T-Rec proxy model is rich enough to apply many of these techniques.
For example, each proxy can be annotated with QoS guarantees regarding its reliability, response time, etc., using which developers can estimate the QoS parameters of their composed services according to [16].
Tools for Mashup Applications.
One of the most commonly used terms for Web 2.0 applications is a \mashup" an application that combines content from more than one source into an integrated experience.
Content is picked up from multiple servers (data sources) using technologies like Ajax and REST, and composed (or rendered) in the same user interface (UI), typically a browser.
There are several tools that aid in the creation of such mashup user interfaces.
Examples are QEDWiki [3], Yahoo Pipes [12], Aqualogic [2], and PrestoStudio [5].
These tools cater to a class of application developers who prefer \drag-and-drop" operations to create their own mashups.
Most of these tools are not Telecom speci(cid:12)c and can bene(cid:12)t by incorporating SewNet s proxies.
Web21C [11] from British Telecom allows developers to integrate core Telecom functionality with other Web services into a single application, while allowing application speci(cid:12)c logic to bind the component services.
Like our work, Web21C hides the complexity of Parlay-X or SIP by exposing these Telecom functions as higher level APIs.
Similarly, Connected Services Framework Sandbox [7] from Microsoft
 collaboration and sharing among users through communities and social networks.
We argue that SewNet, based on T-Rec proxies, incorporates these core Web 2.0 principles.
With several providers and community developers contributing towards development of services and its associated artifacts, it is important to help a developer with e(cid:11)ective tools for inferencing and recommendation.
While there has been a lot of work in the domain of inferencing and collaborative (cid:12)ltering [13, 21], SewNet opens up a new environment for applying current work as well as identifying interesting problems, for instance, those related to selection and recommendation of utility snippets for a proxy.
With Telecom market reaching saturation, Telecom operators can take advantage of their core functionalities like Location, Call Control, etc.
These can be exposed as services and used by developers to compose rich, innovative applications.
We believe that although operators are making e(cid:11)orts in this direction, a number of challenges still need to be addressed - existence of multiple protocols, di(cid:11)erent categories of developers, and the need to coordinate the usage of these functionalities.
In this paper, we presented SewNet, a framework for creating applications exploiting Telecom functionality exposed over a converged IP network.
We (cid:12)rst provided an abstraction model, called the T-Rec  Proxy  model, for encapsulating invocation, coordination and enrichment of the Telecom functionalities, and thereafter rendered a service creation architecture based on this model.
We also demonstrated the e(cid:11)ectiveness of SewNet for di(cid:11)erent categories of developers with the help of two use-case scenarios.
In the future, we wish to integrate SewNet with other development studios, including various mashup environments and UML-based model driven composition tools.
We also want to create proxies for some popular third party services available over the Web.
Finally, we plan to encapsulate device capability under our proxy model and include the same in our service composition framework.
We would like to acknowledge Himanshu Agrawal for developing SewNet s composition studio, and our colleagues in IBM Haifa Research Lab for helping us re(cid:12)ne our ideas.
