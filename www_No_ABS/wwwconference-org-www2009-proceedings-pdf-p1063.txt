Keyword search provides a simple and user-friendly query interface to access XML data in web and scienti c applications [4, 2, 8, 7, 5, 6].
In an existing XML keyword search system, a user composes a query, submits it to the system, and retrieves relevant answers.
This information-access paradigm requires the user to have certain knowledge about the content of the underlying data.
In the case where the user has limited knowledge about the data, often the user feels  left in the dark  when issuing queries, and has to use a try-and-see approach for  nding information.
Many systems are introducing various features to solve this problem.
One of the commonly used methods is autocomplete, which predicts a word or phrase that the user may type in based on the partial string the user has typed.
In this paper, we extend autocomplete and propose an interactive keyword-search method in XML data, called Inks.
Inks searches XML data on the  y as users type in queries Copyright is held by the author/owner(s).
Inks can signi cantly save users typing e ort.
and provides a friendly interface for users exploring XML data.
In contrast, one limitation of autocomplete is that the system treats a query with multiple keywords as a single string, thus it does not allow keywords to appear at di erent places.
For instance, consider the search box on Apple.com.
Although a query  itunes  can  nd a record  itunes wi-  music store,  a query  itunes music  cannot  nd this record, because the two keywords appear at di erent places.
CompleteSearch [1] interactively searches on a set of documents.
Inks extends autocomplete and CompleteSearch to  nd relevant subtrees in XML data by supporting multiple keywords.
We give an example to show how Inks works.
Assume there is an XML document that resides on a server.
A user accesses and searches the data through a Web browser.
Each keystroke that the user types invokes a query, which includes the current string the user has typed.
The browser sends the query to the server, which computes and returns to the user the best answers ranked by their relevancy to the query.
Assume a user types in a query  db mic  letter by letter on the XML data in Figure 1.
The string is tokenized to keywords using delimiters.
The keywords are assumed as partial keywords, as the user may have not  nished typing the complete keyword.
For the partial keywords, we would like to know the possible words the user intends to type.
We identify a set of words with this partial keyword as a pre x.
This set of keywords are called the predicted words.
For instance, for the partial keyword  mic,  its predicted word could be  mices,   mich,  etc.
Then based on the predicted words, we identify the relevant subtrees in XML data that contain the predicted words.
We call these relevant subtrees predicted answers.
Apparently, Inks can signi cantly save users time and e orts, since they can  nd answers even if they have not  nished typing all complete keywords.
We propose a lowest common ancestor(LCA) based interactive-search method.
We use the semantics of exclusive LCA (ELCA) [4] to identify relevant answers for predicted words.
We use a trie to index the tokenized words in XML data.
For a query with a single keyword, we  rst  nd the corresponding trie node.
Then we locate the leaf descendants of this node, and retrieve the corresponding predicted words and the predicted XML elements on their inverted lists.
For a query with multiple keywords, we  rst tokenize the query string into keywords, k1, k2, .
.
.
, k(cid:2).
For each keyword ki (1   i   (cid:2)), there are multiple predicted words.
Suppose there are qi predicted words for ki, and their corresponding XML element lists are Ii1 , Ii2 , .
.
.
, Iiqi .
We  st com-bib
 conf
 jour
 name
 year
 paper
 paper
 chair
 name
 year
 paper
 chair Lucy

 title

 author bib
 title
 author author


 title Mary

 author author
 Bob
 name
 conf
 year IR DB Tom Smith Tohn Mich
 Tohn Smith Lucy Mich
 paper


 title
 author
 Tom Mices Figure 1: An XML document pute the predicted XML element lists of the partial keyword, i.e., the union of these lists Ui =  qi j=1Iij .
Then, we compute the predicted answers, i.e., the subtrees of ELCAs on U1, U2,  , U(cid:2).
We use the binary search based method to compute ELCAs and corresponding answers [8].
We use the tf*idf based ranking functions [4] to rank the answers.
Assume a user types in a query  db mic  letter by letter.
For query  d,  we locate the trie node for  d  and identify predicted word  db  and predicted XML elements 13 and
 predicted words  mices  and  mich  for m  and predicted elements 14, 18, and 26.
Finally, we compute ELCAs on {13,


 Existing XML keyword-search algorithms [4] have two main limitations.
First, they use the default  AND  semantics between input keywords.
Second, they  nd candidate nodes  rst before ranking them, and this approach is not e cient for computing the best answers.
To address these limitations, we develop novel ranking techniques and e cient search algorithms.
In our approach, each node on the XML tree could be potentially relevant to a keyword query.
For each keyword in the tree, we index not only the content nodes containing the keyword, but also those quasi content nodes whose descendants contain the keyword.
Given a keyword and node n, a pivotal node is a content node for the keyword, which has a minimal distance to n. The path from node n to this node is called the pivotal path.
We introduce the notion of minimal-cost tree (MCT for short) to de ne the answer to the query for node n. The minimal-cost tree is the subtree rooted at n that includes all pivotal paths for input keywords and node n.
For example, for  DB,  we index nodes 13, 16, 12, 15, 9, 2,

 node for node 12 and  DB,  and its pivotal path is 12-13.
Node 14 is the pivotal node for node 12 and  Tom,  and its pivotal path is 12-14.
For query  DB Tom,  to identify the top-2 answers, we  rst  nd nodes 12 and 15 based on the index and then construct MCTs based on pivotal paths.
Now we discuss how to rank an MCT.
Intuitively, we  rst evaluate the relevance between node n and each input keyword, and then combine these relevance scores as the overall score of the MCT.
We can use the idea of tf*idf to score the relevance of the content nodes, but cannot rank a quasi content node.
Given a quasi content node, we combine its pivotal node s tf*idf score and the distance between the quasi content node and its pivotal node for e ective ranking.
We propose how to do progressive search in considering  OR  predicate.
In the trie index, for leaf nodes, we keep content nodes and quasi content nodes, and corresponding scores and pivotal paths, sorted by their scores.
For each internal node, we cache top-n relevant ones among (quasi) content nodes in its subtree.
Given a query, for each keyword, we  rst locate the corresponding node on the trie.
Then, we retrieve top-n (cached) relevant elements.
We use the threshold-based algorithm [3] to identify the top-k an-If we can guarantee that we have found the top-k swers.
answers using the cached elements, we can do early termination; otherwise, we retrieve the predicted XML elements and use the threshold-based method to  nd top-k answers.
We have implemented our method on real dataset DBLP with the size of 470 MB.
We set up a server using Apache and FastCgi.
The server was running a program implemented in C++ using a GNU compiler.
We conducted the evaluation on a PC running a Ubuntu Linux with an Intel(R) Xeon(R) CPU X5450@3.00 GHz CPU and 4 GB RAM.
We selected ten queries on the dataset.
We  rst evaluate result quality by human judgement.
Answer relevance of the selected queries was judged from discussions of twenty randomly selected person.
Figure 2 shows the top-10 precision.
We observe that the progressive method achieves higher result quality than LCA based methods (We implemented XRank to generate answers for LCA based methods).
This is attributed to our e ective ranking functions.
We then evaluate the server running time.
Figure 3 gives the total server time for di erent queries.
We observe that our progressive method achieves higher e ciency.
) % ( n o i s i c e r


 p o
 ) s m i ( e m
 d e s p a l












 Progressive









 Figure 2: Top-10 precision Queries









 Progressive









 Figure 3: Elapsed server time Queries

 This work is partly supported by the National High Technology Development 863 Program of China under Grant No.2007AA01Z152, the National Grand Fundamental Research 973 Program of China under Grant No.2006CB303103, and 2008 HP Labs Innovation Research Program.
