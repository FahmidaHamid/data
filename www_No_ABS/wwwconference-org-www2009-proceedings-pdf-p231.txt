Sponsored search is a large and thriving market with three distinct players.
Users go to search engines such as Yahoo!
or Google and pose queries; in the process, they express their intention and preferences.
Advertisers seek to place advertisements and target them to users  intentions as expressed by their queries.
Finally, search engines provide a suitable mechanism for doing this.
Currently, the mechanism relies on having advertisers bid on the search issued by the user, and the search engine to run an auction at the time the user poses the query to determine the advertisements that will be shown to the user.
As is standard, the advertiser only pays if the user clicks on their ad (the  pay-per-click  model), and the amount they pay is determined by the auction mechanism, but will be no larger than their bid.
In this paper, we assume the perspective of the advertiser.
The advertisers need to target their ad campaigns to users  queries.
Thus, they need to determine the set S of queries of their interest.
Once that is determined, they need to strategize in the auction that takes place for each of the queries in S. A lot of research has focused on the game theory and optimization behind these auctions, both from the search engine [1, 16, 6, 2, 10, 4] and advertiser [3, 8,
 research on how advertisers target their campaign, i.e., how they determine the set S.
The criterion for choosing S is for the advertiser to pick a set of keyphrases that searchers may use in their query when looking for their products.
The central challenge then is to match the advertisers keyphrases with the potential queries issued by the users.
It is di cult if not impossible for the advertisers to identify all possible variations of keyphrases that a user looking for their product may use in their query.
As an example, consider a vendor who chooses the keyphrase tennis shoes.
Users searching for them may court footwear ), may misspell ( tenis shoe ), use extensions ( white tennis shoes ) or reorder the words ( shoes lawn tennis ).
In fact, users may even search using words not found in the keyphrase ( Wimbledon gear ,  US Open Shoes ,  hard court soles ), and may still be of interest to the advertiser.
These artifacts such as plurals, synonyms, misspellings, extensions, and reorderings are very common, and the problems get compounded since typical ad campaigns comprise several keyphrases, each with its own set of artifacts.
Major search engines help advertisers address this challenge by providing a structured bidding language.
While the speci c details di er from search engine to search engine [17, 20, 19], at the highest level, the bidding language supports two match types: exact and broad.
In exact matchtype (called  exact  in MSN AdCenter and Google, and  standard  in Yahoo), ad would be eligible to appear when a user searches for the speci c keyphrase without any other terms in the query, and words in the keyphrase need to appear in that order.
In broad matchtype (called  broad  in MSN, related to  phrase  and  broad  in Google, and  advanced match type  in Yahoo), the system automatically makes advertisers eligible on relevant variations of their keyphrases including for the various artifacts listed earlier, even if the search terms are not in the keyphrase lists.
Thus, the search engines automate the aspect of detecting artifacts and matching the query to keyphrases of interest to adver-tisers.1 Thus the task of advertisers becomes determining the keyphrases and choosing the match type on each.
The question we address here is, how does an advertiser bid in presence of these match types?
Say each query q has a value v(q) per click for the advertiser that is known to the advertiser and is private.
Further, we let c(q) be the expected price per click and let n(q) be the expected number of clicks.
These are statistical estimates provided by the search engines [18, 23, 21].
Then, we consider two optimization problems: (i) in one variant, we assume that the advertiser not exceed the budget.
c(q))n(q), and (ii) in the other variant, given a budget B for the advertiser, we assume that the advertiser wishes to wishes to maximize their expected pro t, that is,2q(v(q)   maximize their expected value, that is,2q v(q)n(q) subject to the condition that the expected spend2q c(q)n(q) does The technical challenge arises due to query dependencies.
When one bids on a keyphrase for query q, as a result of a broad match, it may apply to query q(cid:48) as well.
The advertiser has di erent values v(q) and v(q(cid:48)) on these because users for q and q(cid:48) di er on their intentions and therefore on their respective values to the advertiser.
So, the advertiser may make good pro t on q and may wish to bid on that query, but is then forced to implicitly bid on q(cid:48) as well, and may even make negative pro t on q(cid:48)!
Under what circumstances is it now desirable for the advertiser to bid for q?
Note that query dependence is a fundamental aspect of sponsored search since advertisers can realistically only choose and strategize on a small set of keyphrases because of the
 that the ad be not shown on occurrence of certain keywords in the query; this feature (called  negative  in MSN and Google or  excluded  by Yahoo) and other targeting criteria associated with keyphrase campaigns do not change the discussion and the results here.
e ort involved, and have to typically rely on the search engine to carefully apply their strategy to variants of their keyphrases.
But beyond that, even an ad campaign that is willing to exert a lot of e ort and use a large number of keyphrases or relies on a search engine to provide rich bidding languages [9] will still  nd it impossible to include all search variations of the keyphrases as exact matches, and must necessarily rely on broad match for the variations that search users develop and prefer over time.
Thus, the advertisers bid implicitly on queries on which they can not directly control the tradeo  between the cost and the value.
Query dependence introduces a complex optimization problem of trading o  the bene ts of bidding on a keyphrase against the impact of bidding on its dependent queries.
In the sponsored search world, there is a keen awareness of this complexity of bidding, and most search engines and third-party bidding agents provide detailed tips and guidelines for advertisers [24, 22].
Beyond these guidelines, what is missing is a clear theoretical understanding of the tradeo s and the complexity of the bidding problem that advertisers face.
We initiate principled study of bidding in presence of broad matches.
Speci cally, our contributions are as follows.
guage models   to study bidding optimization problems.
In the query language model, the advertiser bids directly on user queries and wishes to determine which query if any to bid on, to maximize expected pro t.
This models both the theoretical extreme where an advertiser can bid on any of the queries the search engine will see, and the practical reality where the advertiser has a select set of queries in mind and wishes only to optimize within that set.
In the keyword language model, advertisers may bid only on a subset of queries, and broad match implicitly derives bids as needed.
This directly models the common reality.
the bid optimization problem under these two models.
In query bidding, we get a polynomial-time algorithm that maximizes the pro t, using a reduction to the well-known Min-Cut problem in graphs.
This is in contrast to the poor performance of natural greedy algorithms for this problem.
We also study the budgeted variant of the problem, and propose a novel strategy using two distinct budgeted ad campaign that gets the optimal pro t.
We do so by studying the structure of the basic feasible solutions of a corresponding linear programming formulation of the problem.
For keyword bidding, we show that even limited instances are NP-Hard to not only optimize, but even to approximate; to deal with this hardness result, we present a constant-factor approximation when advertisers pro t following an optimal bid is considerably greater than her cost.
This result is based on applying a randomized rounding method on the optimal fractional solutions of the linear programming relaxation of the problem.
These represent the  rst known theoretical results for the problem of bid optimization in presence of broad matches, a problem advertisers face now since this feature is o ered tion for advertisers [3, 5, 13] primarily focused on determining suitable bids for exact match types and does not study the query dependence and implicit bids; [8, 11] studied the problem of maximizing the number of clicks, and not the pro t which is the more standard metric.
At the technical core, our challenge is to tradeo  positive pro t from bidding on a keyphrase that applies to one query q against possibly a negative pro t from the implied bids of broad match on queries q(cid:48).
This query dependence is a novel feature in sponsored search auctions, not explicitly studied in prior literature, and our results for this problem may have applications beyond, in the general auction theory area.
Finally, we report experimental results on a small family of instances of the bid optimizations problem, and compute the optimal bidding using the integer linear programming formulation.
Our main observation in these experiments is that by considering only the broad match, we do not lose much in the maximum pro t of the solution.
This supports our hope that under reasonable circumstances (similar to the ones in our experiments), considering only broad match is e ective, and in turn, that would enable advertisers to focus on campaigns with small lists of keyphrases.
We consider the optimization problems that an advertiser faces while bidding in an auction for queries with a broad match feature.
The Advertiser.
We consider a single advertiser who is interested in showing her ad to users after they search for queries from a set Q.
The advertiser has some utility from having a user click on her ad.
In reality, clicks associated with di erent queries may have di erent utility to the advertiser; The advertiser has a value of v(q) units of monetary value associated with a  click  that follows a query q   Q.
We assume a posted price model where prices are posted and the search volume of every query as well as its click through rate (i.e., the probability that users would click her ad) are known to the advertiser.
Namely, every query q is associated with a pair of parameters, known to the advertiser, (c(q), n(q)), where c(q) is the per click cost of q, and n(q) is the expected number of clicks that would result from winning q (the expected number of clicks can be determined from the search volume of q and the advertiser s speci c click through rate for q).
Thus, when an advertiser wins a query q, her overall pro t 2 from winning, denoted w(q) is w(q) = (v(q)   c(q)) n(q) .
Note that although each query has a positive value, winning it may result in an overall negative pro t.
Bidding languages.
A bidding language is a way for an advertiser to specify her value or willingness to pay for queries.
Eventually, the auctioneer needs to have a bid for every possible query 3.
The choice of a bidding language is critical
 changably.
a case where the advertiser is not explicitly interested in a query q and nor in queries that q match broadly.
for the auction mechanism.
At the one extreme, it may be infeasible to allow an advertiser to specify explicitly her value for every possible query.
On the other hand, a language that is too restrictive would not allow an advertiser to communicate her preferences properly.
In order to study the complexity of the optimal bidding in the broad match framework while taking into account the intersections among broad matches for di erent keywords, we  rst consider a bidding language in which an advertiser can specify a bid for every query q but only as a broad-match.
We refer to this language as the query language.
To allow the most accurate description of an advertisers value per query, the ultimate way is to let the advertiser specify all possible queries with exact or broad match, and a monetary bid for each of them.
If an advertiser is allowed to bid on each type of query as an exact match as well as broad match, she can decide for each query independent of the other queries, and the complexity of the bidding problem is not captured in such a bidding language.
To capture the complexity of the optimal bidding problem and the fact that advertisers may only bid on a subset of queries, we study the keyword language that allows advertisers to place a bid only on (single) keywords or short phrases.
More precisely, in the keyword language, we assume that advertisers are allowed to bid only on a subset S   Q of queries.
A further improvement of this language would allow the advertiser to specify, besides a value bid for s   S, whether s is to be matched exactly or broadly.
+ in some bidding language is associated with a set of  winning queries  denoted by  (b) = {q   Q | b(q)   c(q)}.
A subset T of queries which is a winning set of some bid b is referred to as a feasible winning set.
The utility associated with a winning set T is A bid b   R|Q| where v( ) and n( ) are advertiser speci c.
A feasible winning set with optimal utility is referred to as an optimal winning set.
The Auction.
For every query, the auctioneer should decide the bid of every advertiser.
This decision is easy for queries on which the advertiser bids explicitly (as an exact match).
However, for the queries that the advertiser has not bid directly, but only through a broad match framework, the auctioneer should compute an appropriate bid for the advertiser to participate in the auction.
A natural way for setting such a value is to aggregate the bid values of all the phrases matched by the query.
While there are several choices for the aggregation method, in this paper, we consider the max aggregation operator   when a query q matches phrases w1, .
.
.
, wk (as a broad match) from the advertiser list of phrases, its bid is interpreted as b(q) = maxi b(wi).
We can now state formally the bid optimization problem.
Given advertiser s speci c data (A set Q, value for queries v, search volume and click through rates n( ) ) and a bidding language L, an optimal bid b , is a feasible bid in the language L that maximizes the advertisers  utility from winning a set  (b) of queries.
Formally,     argmaxb L{u( (b))}.
b (2.1) (v(q)   c(q)) n(q), u(T ) =:q T query q(cid:48) if winning query q(cid:48) implies winning query q.
In the broad match auction in which the bid interpretation strategy is done using the max operator, this happens if q matches q(cid:48) broadly, and its cost c(q) is less than that of c(q(cid:48)).
In other words, if a bid b wins q(cid:48), it must be that b(q(cid:48))   c(q(cid:48)), but the interpreted bid for q is then at least b(q(cid:48))   c(q) since c(q(cid:48))   c(q), hence the bid b must be winning q as well.
As a result, the cost structure incurs a set of pairs (q(cid:48), q) where the  rst entry of each pair q(cid:48)   S is a valid phrase in the bidding language and the second entry is a valid query in the set of queries Q such that winning query q(cid:48) implies winning query q.
This set of pairs is denoted by C and formally: C = {(q (cid:48) , q)|q (cid:48)   S, q   Q, q matches q (cid:48) broadly , c(q (cid:48) )   c(q)}.
Moreover, we de ne D(q) = {q(cid:48)|(q(cid:48), q)   C}, and N (q) = {q(cid:48)|(q, q(cid:48))   C}.
Budget-constrained Ad Campaigns.
A variant of the optimal bidding problem in the broad match framework is to  nd a set of queries to bid on that maximizes the total value of the queries won by the advertiser subject to a budget constraint, i.e, our goal is to bid on a subset T of queries assume that one can run a budget-constrained ad campaign by bidding on a subset T of keywords and setting a budget B.
in this budget-constrained ad campaign: (i) If B(cid:48)   B, the auction is run in a normal way and the value from this ad to maximize2q T v(q)n(q) subject to the budget constraint
 Assuming B(cid:48) =2q T c(q)n(q), there are two possibilities campaign for the advertiser is2q T v(q)n(q), (ii) On the gets is2q T v(q)n(q) B(cid:48) other hand, if B(cid:48) > B, we assume that the queries arrive at the same rate and as a result, for each query, we get B(cid:48)
 fraction of the value of an ad campaign without the budget constraint.
In other words, the value that the advertiser B .
We can also interpret the above assumption by a throttling method in which, in order to cope with the budget constraint, at each step, we let the advertiser participate in the auction with probability B(cid:48)


 In this section, we study the query language that allows placing a bid on every query.
We observe that in the query language, the task of computing an optimal bid is equivalent to that of computing an optimal winning set: Given an optimal feasible set T set a bid b(q) = c(q) for every query q   T with positive weight and b(q) = 0 otherwise.
Lemma 3.1.
A bid b derived from an optimal winning set T , as described above, is an optimal bid.
Proof.
By construction, the bid b wins all the queries with positive weight from T , and every other query must belong to T (otherwise T would not be feasible).
We therefore consider algorithms for computing an optimal feasible winning set.
First, we consider a greedy algorithm, denoted by Max-Margin Greedy.
Initially, Max-Margin Greedy sets the winning set to be empty.
Then, iteratively, it adds a bid on a query with the highest marginal bene t to the winning set utility.
Unfortunately, Max-Margin Greedy fails to compute an optimal winning set due to the following example.
Example.
Consider a set Q of queries which contains n keywords and another n 2 queries, each of which is a pair of keywords.
The cost of each query is set to $1.
Hence, the query dependencies is such that winning a keyword implies winning the set of n   1 queries made of pairs of keywords in which this keyword appears.
The value of a keyword is set to $2; The value of a each pair is set to 1   1.5/n.
So, every keyword attains a positive utility of $1, and every pair causes a loss of $1.5/n.
Initially, Max-Margin Greedy s bid is empty.
At this point Max-Margin Greedy is stuck   every single query it adds to the winning set results in a negative overall utility.
Thus, this instance, Max-Margin Greedy would yield 0 utility.
An optimal solution wins all the n  1) = n 3
 One can explore other variants of greedy algorithms for this problem.
For example, a natural greedy algorithm is Max-Rate Greedy algorithm: Initially set the winning set to the empty set, and then iteratively, add a bid on a query with the highest ratio of marginal pro t over the marginal cost, or the query with the highest ratio of marginal value over marginal cost.
We note that all these iterative greedy algorithms pefrom poorly for the above example.
Even a signi cant look-ahead will not resolve this bad example.
queries and has a utility of n (2 1)  n
 We turn to the next algorithm OptBid1 for computing an optimal winning set.
OptBid1 is a solution to the following integer linear program: ILP : max:qi Q Xqi w(qi) For every pair (qj, qi)   C : Xqi   Xqj   0  qi   Q : Xqi   {0, 1} (3.1) For every query q, an integral variable Xq is a 0-1 variable which is equal to 1 if and only if q belongs to the winning set of queries.
In order to solve the above ILP, we relax it to a linear program where instead of integer 0-1 variables, we have fractional Xq variables with values between 0 and 1 (0   Xq   1).
Here, we observe that the integrality gap of this linear programming relaxation is 1, i.e., for any instance of this linear program, there exists an optimal solution X  q   {0, 1} for all q   Q.
in which all the values are integer X  Lemma 3.2.
The integrality gap of the linear programming relaxation of the ILP 3.1 is one.
Proof.
The lemma follows from the fact that the constraint matrix of the LP relaxation of ILP 3.1 is totally uni-modular4.
A su cient condition for a matrix to be totally uni-modular is that every row has either two nonzero entries, one is 1 and the other  1, or a single non zero entry with value 1 or  1.
An integer program whose constraint matrix is totally uni-modular and whose right hand side is integer can be solved by linear programming since all its basic feasible solutions are integer (see [12] pp.
316).
The above lemma implies the following polynomial-time algorithm OptBid1 for optimal bidding in the query language: compute a basic feasible solution X  of the LP relaxation of ILP 3.1, and  nd a bidding strategy corresponding to the winning set of X , i.e., {q   Q|X 
 of it is uni-modular, i.e., every submatrix has a determinant of 0, 1 or +1.
q = 1}.
every (q, q(cid:48))   C, set Yq,q(cid:48) := fq,q(cid:48) and for every q   Q+, verify that this is a feasible solution of DUAL with value set Zq := w(q)  2q(cid:48)|(q,q(cid:48)) C Yq,q(cid:48) .
It is straightforward to
 Now, observe that T is a feasible set in the query language.
For every pair (q, q(cid:48))   C, we have that if q   T then also q(cid:48)   T .
Otherwise, the edge (q, q(cid:48)), with weight  , would be part of the cut.
Thus, the value of the min cut is c = :q Q T w(q) = :q Q+ |w(q)| + :q Q+\T wq   :q Q+\T wq   c.
w(q).
w(q) + :q Q T w(q) and therefore, u(T ) = :q T = :q Q+ We already found a feasible solution for the dual of ILP, with the same value.
We therefore conclude, using the weak duality theorem, that T is an optimal solution of ILP.
In this section, we study optimal bidding for the keyword language, where the advertiser is restricted to bid on a subset of (possibly short) queries S   Q.
Note that in the case that all queries have positive utility, the optimal bid is trivial by simply placing a high bid for every query in S. In addition,  nding the optimal bid when all queries are associated with a negative utility is trivial (a bid of $0 for every phrase in S is optimal).
Moreover, in the case of uniform value from every query, the optimal bid is easy   a uniform bid equal to the uniform value guarantees winning every query with positive weight and losing every query with negative weight, which is of course optimal.
In realistic settings, some queries have positive utility and some have negative utility.
In this case the problem of  nding the optimal bid becomes intractable.
More precisely, as we show now, even when the set of queries Q is made up from single keywords and pairs of keywords, this problem becomes hard to approximate within a factor of |S|1 , for every  > 0: Theorem 4.1.
In the keyword language broad match framework, it is NP-hard to approximate the optimal value of the optimal bidding problem within a factor of |S|1 , for any  > 0.
Proof.
We give a factor-preserving reduction to the independent set problem.
Given a graph G with n nodes, and m edges, we construct the following instance of our problem: put a singleton keyword for each node v of G with weight wv =  (deg(v)   1), and put a query consisting of a pair of keywords corresponding to each edge e of G with weight 1.
The maximum value we can get from picking a keyword is 1, and we get this value if all of its neighbors do not appear in the output.
It can be seen that the optimum solution is an independent set of nodes (since otherwise, we get zero or negative from a picked node), and as a result, the maximum value is the same as the size of the independent set.
In this section, in light of the above hardness result, we design a constant-factor approximation algorithm for a special Figure 1: An example of running algorithm Opt-Bid2 on the set of queries (with the following pro t: {(a, 11), (b, 8), (ab, 8), (abc, 9), (ef, 7), (ef g, 5), (ef h, 4)}), and dependency graph as illustrated.
ObtBid2 will choose the winning set {a, b, ab, abc}.
The optimal bid is {(a, 11), (b, 8)}.
The running time of Algorithm OptBid1 is that of solving a linear program with  (|Q|2) constraints, which although polynomial in |Q|, might be ine cient.
Next, we present a faster algorithm, OptBid2.
For the purpose of presenting Algorithm OptBid2, we de- ne a weighted  ow graph G = (V, E), derived from the input.
The vertex set of G is V = {s, t}   Q+   Q , where s is a source node, t is a target node and Q+ and Q  are the sets of queries with positive/non-positive weights respectively, i.e., Q+   {q | w(q) > 0}.
The source vertex s is connected to each vertex q   Q  with an edge of weight |w(q)| = |(v(q)   c(q))n(q)|.
The target vertex t is connected with each vertex p   Q+ with an edge of weight w(p).
Two vertices q   Q , p   Q+ are connected with an edge of weight   if and only if (p, q)   C.
Algorithm OptBid2
 the cut.
T \{t}, that is, the set of queries that are on the same side of the cut as t is an optimal winning set.
The running time of Algorithm OptBid2 is that of min-cut, i.e., O(|Q|3) [14].
Theorem 3.3.
Algorithm OptBid2  nds an optimal winning set.
Proof.
We show T is an optimal winning set using the dual program of ILP.
DUAL : min :q Q+  q   Q+ : :q(cid:48):(q,q(cid:48)) C : :q:(q,q(cid:48)) C )   C : Yq,q(cid:48)   0  q   Q+ : Zq   0 (cid:48)   Q    q  (q, q (cid:48) Zq Yq,q(cid:48) + Zq   w(q) Yq,q(cid:48)    wq(cid:48) (Notice that wq(cid:48)   0) (cid:1)a(cid:2)(cid:1)b(cid:2)(cid:1)e f (cid:2)(cid:1)e f h (cid:2)(cid:1)e f g (cid:2)(cid:1)a b (cid:2)(cid:1)a b c(cid:2)8(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)9548711stQ(cid:1)Q (cid:2)(cid:2)(cid:3)WWW 2009 MADRID!Track: Internet Monetization / Session: Sponsored Search235case of the optimal bidding problem in the keyword language in which the cost part of the optimal solution is less than 1 c of the value part of the optimal solution, for some constant c > 1.
Recall that D(q) = {q(cid:48)|q(cid:48)   S, (q(cid:48), q)   C}.
Our algorithm is constant-factor approximation if for any query q   Q \ S, |D(q)| is less than a constant c(cid:48).
We present our result for the case that each query q   Q can be in the broad-match set of at most two queries q1, q2   S, i.e., |D(q)|   2.
However, our result can be extended to more general settings in which query q   Q can be the broad match for a constant number of queries q1, .
.
.
, qc(cid:48)   S (for a constant c(cid:48)).
Based on the above discussion, we assume that |D(q)|   2 for any query q   Q.
Note that the hardness result of the keyword language holds even for instances in which |D(q)|  
 algorithm is based on a linear programming relaxation of the optimal bidding problem for the keyword language.
The integer linear program is as follows: s + Rs)ws ILP-Approx: max2s S(Z c(s) +2q Q\S Yqwq s =2t E,t p W t Yq   Z c(q) Yq   Z c(q) s + Z c(q) Z p s s r s + Rs   1 Z p Yq   {0, 1} Rs   {0, 1} s , Z p s   {0, 1} W p  s   S, p, p  q   Q \ S, (s, q)   C, (r, q)   C  q   Q \ S, (s, q)   C (cid:48)   E  s   S, p   E  q   Q \ S  s   S  s   S, p   E (4.1) Where the variables correspond to the following:   W p s for any s   S is the indicator variable correspond  Z p ing to the bid of p on query s as a broad match, s for any s   S is the indicator variable corresponding to the bid of at most p on query s as a broad match,   Rs for any s   S is the indicator variable corresponding to the exact match bid on query s (Rs = 1 if the advertiser bids on query q as an exact match) ,   Yq for any q   Q \ S is the indicator variable corresponding to winning query q (as a result of bidding on queries in S).
We relax the integer 0-1 variables in this integer linear program to fractional variables between zero and one, and then compute an optimal fractional solution for this LP relaxation.
Then we round this fractional solution to construct a feasible (integral) bidding strategy.
Rounding to an Integral Solution.
Given a fractional solution (V, Z, W, Y ) to the LP, we round it to an integral solution (V (cid:48), W (cid:48), Z(cid:48), Y (cid:48)) as follows: for every query s   S, we set V (cid:48) s = 0 otherwise.
If s = 0 for all p   E. Otherwise, for each s   V (cid:48) s = 1, we set W (cid:48)p S, for all p    E, we choose p  with probability proportional to W p  s (1   ) (for an appropriate small constant  that will be determined later) and set W (cid:48)p  s = 1, and for any p (cid:54)= p , we set W (cid:48)p s = 0.
After setting all W (cid:48) variables, for each s = 1 with probability 1, and V (cid:48) (cid:48)c(q) s q = 1 if and only if Z s =2t E,t p W (cid:48)t p   E and s   S, we set Z(cid:48)p s .
Finally, for any q   Q \ S, Y (cid:48) = 1 for some s   S, such that s   D(p) (or equivalently (s, q)   C).
It is not hard to see that the above rounded integral solution correspond to a feasible bidding strategy.
In particular, we can implement this bidding strategy by putting an exact match bid of b(s) = c(s) for any s   S if R(cid:48) s = 1 (i.e., with probability Rs) and then by putting a broad match bid of b(s) = p for query s   S if W (cid:48)p s = 1 (i.e., with probability s (1   )).
W p A query s   S is selected if bid b(s) for this query is at least c(s).
As a result, a query s   S is selected with probability (1   )Z c(s) s + Rs.
Moreover, for a query q   Q \ S for which (s, q)   C and (r, q)   C, query q is selected if the bid for either of the queries s or r is at least c(q), i.e., with probability
 (1   )(Z c(q) s + Z c(q) r Pr[ query q is selected ] = s )(1   (1   )Z c(q) r Z c(q) )   (1   )2Z c(q) s r .
) = Therefore, the expected utility of the solution after implementing the integral solution (V (cid:48), W (cid:48), Z(cid:48), Y (cid:48)) (or bidding as desribed above) is: ((1   )Z c(s) + Rs)ws+ :s S s + Z c(q) r )   (1   )2Z c(q) s Z c(q) :q Q\S;r,s D(q) (1   )(Z c(q) r  wq Next, we derive a lower bound and an upper bound on the probability that the bid generated as above, wins query q.
We will show that Yq(1   )(1   1
 (1   ))   Pr[q is selected ]   (1   )2Yq.
(4.2) Consider the following set of inequalities that hold for every query q that depends on queries s, r   D(q): s Z c(q) Z c(q) s + Z c(q) Z c(q) r r  GZ c(q)   Yq   Z c(q) s Z c(q) r   s + Z c(q) r ,
 (4.3) r   The  rst inequality follows the constraints 0   Z c(q) 1 and the second inequality is the arithmetic geometric mean inequality.
The third inequality follows the summation of   Yq and the last the inequalities Z c(q) inequality appears as a constraint in the LP.
  Yq and Z c(q) , Z c(q) s s r The left hand side in Inequality 4.2 follows since (1   )(Z c(q) s + Z c(q) r (1   )2Yq   (1   )2Z c(q) )   (1   )Z c(q) s Z c(q) (1   )Z c(q) r   r   (1   )2Yq s (1   )(Z c(q) s + Z c(q) r (1   )(Z c(q) s + Z c(q) r (1   )(Z c(q) )   (1   )2Z c(q) s Z c(q) s + Z c(q) r r   )   (1   ))   (1   )).
)   (1   )2 1 (Z c(q)
 )(1   1 s + Z c(q)
 Yq(1   )(1   1
 r In the summation that describes the overall utility from the queries, the probability for selecting query q, is multiplied by both the value and the cost of q.
Using Inequality 4.3, we get a lower bound on the expected value from q and an upper bound on the expected cost of q.
Let us denote the optimal utility any bidding strategy can achieve by U  = V     C , where V   and C  are the value and cost part of the objective utility function, respectively.
Let U  = U  B where U  E is the utility resulting from the exact match bidding, and U  B is the utility from the broad match bidding.
Similarly we de ne U  E, and

 B (where V and C correspond to the value and the cost of each part of the solution).
Knowing that for each query w(q) = v(q)n(q)  c(q)n(q), the expected utility of the above algorithm based on randomized rounding of the LP is at least:



 (1   )(1   1

 (1   )(1   1

  

       max(1, 2   2)C  
    
 .
Lemma 4.2.
By setting  = 0 or  = 1/2 in the above algorithm, we get that U ALG   1 C , respectively.
Given the above lemma, we conclude the following: Theorem 4.3.
For instances of the optimal bidding problem in which C    V   4 and each query depend on at most 2 other queries (i.e., |D(q)|   2 for each q   Q\ S), the above randomized algorithm is a 1 6 approximation algorithm.
inequality Yq  2s D(q) Z c(q) In order to extend the above result for the more general case in which |D(q)|   c(cid:48) for a constant c(cid:48), we should add the , and then one can generalize the above result to the following: For any constant c(cid:48), there exist two constants c and c(cid:48) such that for instances of the optimal bidding problem in which C    V   c and |D(q)|   c(cid:48) for each q   Q\ S, there exists a constant-factor approximation algorithm.
s

 In this section, we study the problem with an additional budget constraint, i.e, we have a budget limit B and the total cost of our bidding strategy should not exceed this limit(B).
Our goal is to maximize the total value subject to this budget constraint.
More formally, the problem is as follows: Figure 2: An illustration of a bidding problem with a large integrality gap (k = 3).
Xqi v(qi)n(qi)  (qj, qi)   C : Xqi   Xqj   0 Budgeted   IP max : max:qi Q :qi Q  qi   Q : Xqi   {0, 1} Xqi c(qi)n(qi)   B (5.1) Similar to IP 3.1, for every query q, an integral variable Xq indicates whether q belongs to the set of queries won by an the optimal solution or not.
There are two di erence between the above IP and the IP for query language without the budget constraint: One di erence is in the objective function in which instead of w(qi), we have v(qi), and the more important di erence is the extra budget constraint.
Because of this extra linear constraint, the following linear programming relaxation of this IP is not totally unimodular anymore.
For every pair (qj, qi)   C : Xqi   Xqj   0 Budgeted   LP : max:qi Q :qi Q  qi   Q : 0   Xqi   1 Xqi c(qi)n(qi)   B Xqi v(qi)n(qi) (5.2) In fact, we can show that the integrality gap of this LP can be very large, and thus one cannot round the fractional solution of this linear programming relaxation to a good integral solution (as we did for IP 3.1).
Lemma 5.1.
The integrality gap of linear programming relaxation 5.2 can be arbitrarily large.
Proof.
Consider the following instance of the bidding problem with a budget constraint in the query language: Let the set of queries Q = R L T where R = {r1, r2, .
.
.
, rk+1}, L = {l1, l2, .
.
.
, lk+1}, and T = T1   T2       Tk+1, where Ti = {ti1, ti2, .
.
.
, tin}.
For any query q   L, we have c(q) = c and v(q) = M , and for q   R, c(q) = c(cid:48) and v(q) = 1.
We assume that c >> c(cid:48) >> n >> 1.
For any q   T , v(q) = 0, RL(c,M)T(cid:1)T2T3T4(c`,1)(1,0)(1,0)(1,0)nWWW 2009 MADRID!Track: Internet Monetization / Session: Sponsored Search237and c(q) = 1.
Also, let the query dependency structure be: C = {(ri, lj)|1   i, j   k + 1, i (cid:54)= j}  {(ri, ti1|1   i   k + 1}  {(tij, ti(j+1)|1   i   k + 1, 1   j   n   1}.
It is easy to check that C matches the cost and query de nitions.
We also set the budget B = c + kc(cid:48) + n. In this instance of the bidding problem, the optimal integer solution can pick at most one node from the set L (given the budget constraint of B and the fact that c >> c(cid:48) >> n >> 1), and thus the optimal integer solution is M + k.
x = (c+kc(cid:48)+n) On the other hand, as a fractional solution, we can set ((k+1)c+(k+1)c(cid:48)+n) .
The value of this fractional solution ((k+1)c+(k+1)c(cid:48)+n) which is approximately is [(k+1)M +k+1] (k + 1)M .
As a result, the ratio between the optimal fraction solution and the integral solution can be as large as k.
This proves that the integrality gap of the LP is arbitrarily large.
(c+kc(cid:48)+n) In fact, not only the LP for the budgeted problem is not integral, but also the optimal bidding problem with a budget constraint is an NP-hard problem even in the query language.
The NP-hardness follows from the fact that this problem is harder than the knapsack problem.
In fact, the knapsack problem is a special case of this problem in which the set of queries are only the keywords and C =  .
Despite the large integrality gap of the above LP and NP-hardness of the problem, in the following we show how one can use a certain set of optimal solutions of this LP to implement two budget constrained ad campaigns for an ad auction with broad-match, that achieves the optimal fractional solution of the above LP.
We show this fact by proving the existence of optimal solutions for the LP with certain structural properties.
The key structural lemma is the following: Lemma 5.2.
The Linear Program 5.2 has at least one optimal solution X  for which there exists a value X such that: q   {0, 1, X}.
Moreover, this optimal so-for each query q, X  lution can be found in polynomial time.
Proof.
We prove this fact by showing that an optimal basic feasible solution of the LP satis es the desired properties.
From standard linear programming theory, we know that such a basic solution exists, and can be found in polynomial time.
Consider an optimal basic feasible solution X  of the LP 5.2.
Since the LP has |Q| variables, a basic feasible solution can be uniquely characterized by |Q| tight In other words, there is a set P of |Q| inde-inequalities.
pendent linear equations among the linear constraints that characterize X .
Let P1   P be a set of these |Q| linear equations of the form X  qi = 1.
Each linear equation in P1 corresponds to an integral variable X  qi .
Let S1 be the set of queries qi corresponding to these integral qi .
Also let P2   P be a set of these |Q| linear variables X  equations of the form X  qj .
We construct a graph G(X , P2) whose vertex set V (G) is the set of variables X  for all queries qi   Q as follows: we put an edge between a qi vertex X  qj is a linear equation in P2.
Thus, if there is path between two nodes
 qi and X  qj .
Let the connected components of G be G1, G2, .
.
.
, Gt.
As a result, for any two variables X  qj in the same connected component Gp for 1   p   t, we have X  qj (since there is a path qj in G, we have X  qi and X  qj if and only if X  qi to a vertex X  qi = 0 or X  qi = X  qi = X  qi = X  qi = X  between any two nodes in the same connected component.)
We say that a connected component Gp is a bad component if none of the nodes in Gp are in S1.
Otherwise, we say that Gp is a good component.
In the following, we show that the number of bad components is at most one, and this will prove the lemma.
In order to prove this claim, we need to prove the following lemma: Lemma 5.3.
Graph G as de ned above does not have any cycle.
i+1 for 1   i   v   1, and X  Proof.
For contradiction, assume that there exists a cycle X 

 v in graph G. Thus, all linear equations
 i = X 
 But these v equations are not independent, and this cycle contradicts the fact that P is a set of independent linear equations.
v = X  Let Y be the set of variables X  Lemma 5.3 proves that graph G is a forest, and thus connected components Gi for 1   i   p are all trees, and each has |V (Gi)|   1 edges.
Now, we observe that for any good component Gi, there exists exactly one equation in P1.
For any good component Gi, there are |V (Gi)| 1 equations corresponding to edges of Gi, and at least one equation in P1.
If there two such equations in P1 for nodes of Gi, then the union of these two equations and equations corresponding to edges of Gi form |V (Gi)| + 1 equations in P all de ned on only variable on V (Gi).
As a result, these equations cannot be independent, which contradicts with the fact that P is a set of independent equations.
As a result, each good component Gi corresponds to exactly |V (Gi)| equations in
 qi in good connected components of G(X , P2).
Thus, Y corresponds to a set of all integral variables X  qi .
The above discussion implies that there are exactly |Y | equations in P characterizing all variables in Y .
As a result, there are |P| |Y | equations uniquely identifying all the (fractional) variables in Q\Y .
Noting that |P| = |Q|, we conclude that |Q\Y | equations uniquely identify all the (fractional) variables in Q\Y , and none of these equations are of the form X  qi = 1.
At most one of these equations correspond to a tight budget con-qi c(qi)n(qi) = B), and thus we have at least |Q\Y | 1 equations of the form X  qj on variables Q\Y in bad components.
Since there is no cycle in graph G and vertices in Q\Y have at least |Q\Y |   1 edges amongst them, they should all belong to the same connected component (i.e, the only one bad connected component), and thus have the same value X  qi = X.
This completes the proof of the lemma.
straint (2qi Q X  qi = 0 or X  qi = X  Using Lemma 5.2, we can show that in the query language model, one can implement the optimal fractional solution using two budget-constrained ad campaigns.
To formally show this, we assume that queries arrive at the same rate, and by putting a budget constraint on an ad campaign (that includes a set of queries), the budget on all queries is consumed at the same rate until it gets used completely.
Theorem 5.4.
In the query language model, there exists a polynomial-time algorithm that computes two budget-constrained ad campaigns that implement an optimal bidding strategy achieving the maximum value for the advertiser given a budget constraint.
that X  qi   {0, 1, X} for all queries qi.
qi = 1, responding integral variables X  respectively.
qi = 0 and X 

 qi c(qi)n(qi).
(a) A campaign with budget B1 on queries in S1.
(b) A campaign with budget B   B1 on queries in
 Lemma 5.2 shows that the  rst step of this algorithm can be done in polynomial time.
To show the correctness of the algorithm, note that assuming that queries arrive at the same rate, and based on the de nition of the budget-constrained ad campaign, the value from these two ad campaigns is: B(cid:48)
 v(q)n(q), v(q)n(q) + :q S1 :q Q\(S0 S1) where B(cid:48) =2q Q\(S0 S1) c(q)n(q).
Note that X  qi   S1, we have B1 =2qi S1 qi c(qi)n(qi) =2qi S1 and thus B1 +2q Q\(S0 S1) Xc(q)n(q) = B, therefore,



 .
B(cid:48) qi = 1 for c(qi)n(qi), Thus, the value of the optimal solution is: =
 v(q)n(q) + :q Q\(S0 S1) :q Q\(S0 S1)
 B(cid:48) :q S1 :q S1 v(q)n(q) + v(q)n(q).
Xv(q)n(q) = Hence, the total value from these two campaigns is the same as the optimal fractional solution, as desired.
Finally, we observe that the optimal bidding problem with a budget constraint is APX-hard for the keyword language.
Theorem 5.5.
The optimal bidding problem with a budget constraint is APX-hard for the keyword language.
Moreover, this problem is not approximable within a factor better than a multiplicative factor 1   1 e .
family of k subsets Sa1 , .
.
.
, Sak that maximizes2e i kSai Proof.
We give a simple reduction from the maximum coverage problem.
In an instance of the maximum coverage problem, we are given a family of subset S1, .
.
.
, Sk   V , and a value w(e) for each element e   V .
The goal is to  nd a .
Given an instance of the maximum coverage problem, we de ne an instance of optimal bidding problem as follows: for each subset Si (1   i   k) in the maximum coverage problem, we put a keyword sSi in the set S of keywords in the optimal bidding problem.
The cost c(s) of each keyword in S is 1 and its value is zero.
We also put a query qe   Q corresponding to each element e   V of the maximum coverage problem.
The value of query qe   Q \ S is one and the cost of each query is zero.
Moreover, we say that a query qe corresponding to an element e can be broadly matched with any query sSi   S corresponding to any subset Si of the maximum coverage problem that includes the element e, i.e., e   Si.
Finally, we set the budget constraint B to k.
It is not hard to see that the maximum value bidding strategy on keywords in this instance with the total cost at most B corresponds to the maximum value set-coverage of at most k sets in the original problem.
This reduction implies that our problem is not approximable within a factor better than 1  1 e unless P=NP, since the maximum coverage problem is NP-hard to approximate within a factor better than 1   1 e [7].
In this section, we report results from an experimental study to address how much an ad campaign loses by using solely broad match rather than a combination of exact and broad match types.
Our simulation is composed of 30 keywords, where we consider all pairs of keywords as the set of possible queries.
Therefore, while there are  only  30 keywords an advertiser who is interested in managing all possible queries will have 435 keywords to consider, which is tedious for small advertisers.
Most advertisers will prefer a campaign with a small set of keywords which they can easily track and evaluate, which in our simulation is represented by the core 30 keywords.
The setup is very simple.
All queries have the same cost.
The net value of a query is determined as follows.
The value of a keyword is drawn from a standard normal distribution.
The net value of a query is either (1) the average net value of its keywords, or (2) the max value among its keywords, or (3) the min value among its keywords; the precise net value of a query is decided according to 1   3 uniformly at random.
This setting is loosely motivated by the intuition that some queries just average the keywords in the query (like  Canon or Nikon ), some are valued as the best among the keywords (like  Canon DSLR ), and some valued as the worst among the keywords (like  Canon calculator ).
Running the simulation 15 times, we obtain that the average value obtained by solving the integer linear program while allowing both exact match and broad match was 120.9 while allowing only broad match was 119.2.
Furthermore we obtain that the maximum ratio between the two was less than 4 percent.
This simple simulation supports our initial hope that not using exact match may be a realistic assumption for some advertisers, in particular, small to medium advertisers.
We must remark that a more detailed experimental study is needed to be more conclusive.
Our hope is that our LP-based algorithms can indeed be run with reasonably sized problems for this purpose.
Our work initiates the study of the bid optimization problem for advertisers in presence of a common feature in sponsored search, ie., the broad match type.
The central technical issue is that choosing to bid on a keyphrase may yield positive pro t from some queries, but may commit one to implicitly bid on queries in which the pro t may be small or even negative.
We propose LP-based polynomial-time algorithms for this problem which is optimal under the query guage model for certain cases while it is NP-Hard to even approximate the optimal solution to any factor, in general.
Our work leaves open several research problems.
A technical problem is to extend the results here to the multi-slot case.
More precisely, given a  landscape  that is a function of bids and gives estimated clicks and cost, obtain the pro t-maximizing bidding strategy.
A conceptual problem is to determine a suitable approach for broad match auctions where search engines are able to provide faithful estimates for clicks and cost associated with the broad matches, so advertisers can bid accurately.
This involves averaging over many related queries.
A principled approach to formulating this notion will be of great interest.
Finally, a speci c technical question that remains open in this paper is the approximability of the budget-constrained version of the optimal bidding problem in the keyword language.
An interesting aspect of this problem is the following relation to submodular optimization.
Given a subset T   S of keywords on which we can bid, let us denote the total cost and value of the queries that we win as a result of bidding on keywords in T by C(T ) and V (T ).
One can check that both the value and cost functions V, C : 2S   R are set-cover-type set functions, and thus they are monotone and submodular.
5 The optimal bidding problem with a budget constraint in the query language is, therefore, to  nd a subset T   S of keywords that maximizes the submod-ular function V (T ) subject to the submodular constraint C(T )   B. Constant-factor approximation algorithms are known for maximizing a general monotone submodular function subject to a knapsack (modular) constraint [15], but maximizing submodular functions subject to a submodular constraint (as in our case) is an open question.
