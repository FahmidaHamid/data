The service-oriented computing paradigm and its realization through standardized web service technologies provide a promising solution for the seamless integration of business applications to create new value-added services.
Industrial Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
practice witnesses a growing interest in the ad-hoc service composition in the areas of supply chain management, accounting,  nances, eScience as well as in multimedia applications.
With the growing number of alternative web services that provide the same functionality but di er in quality parameters, the composition problem becomes a decision problem on the selection of component services with regards to functional and nonfunctional requirements.
Figure 1: Web Service Composition Example Consider for example the personalized multimedia delivery scenario (from [21]) in Figure 1.
A smartphone user requests the latest news from a service provider.
Available multimedia content includes a news ticker and topical videos available in MPEG 2 only.
The news provider has no adaptation capabilities, so additional services are required to serve the user s request: a transcoding service for the multimedia content to  t the target format, a compression service to adapt the content to the wireless link, a text translation service for the ticker, and also a merging service to integrate the ticker with the video stream for the limited smartphone display.
The user request can be associated with some end-to-end QoS requirements (like bandwidth, latency and price).
The service composer has to ensure that the aggregated QoS values of the selected services match the user requirements at the start of the execution as well as during the execution.
However, dynamic changes due to changes in the QoS requirements (e.g.
the user switched to a network with lower bandwidth) or failure of some services (e.g.
some of the selected services become unavailable) can occur at run-time.
Therefore, a quick response to adaptation requests is important in such applications.
The performance of the service selection middleware can have a great impact on the overall performance of the composition system.
Figure 2 gives a conceptual overview of the QoS-aware service composition problem.
Given an abstract composition request, which can be stated in a work ow-like language (e.g.
BPEL [19]), the discovery engine uses existing infrastructure (e.g.
UDDI) to locate available web services for each task in the work ow using syntactic (and probably semantic) functional matching between the tasks and service descriptions.
As a result, a list of candidate web services is obtained for each task.
The goal of QoS-aware service selection middel-lected.
The global selection problem can be modeled as a Multi-Choice Multidimensional Knapsack problem (MMKP), which is known to be NP-hard in the strong sense [20].
Consequently, it can be expected that an optimal solution may not be found in a reasonable amount of time [16].
The exponential time complexity of the proposed solutions [24, 25, 5, 6] is only acceptable if the number of service candidates is very limited.
Already in larger enterprises and even more in open service infrastructures with a few thousands of services the response time for a service composition request could already be out of the real-time requirements.
Contribution of the Paper Since the QoS requirements (e.g.
response times, throughput or availability) are only approximate, we argue that  nd-ing a  reasonable  set of services that avoid obvious violations of constraints at acceptable costs is more important than  nding  the optimal  set of services with a very high cost.
In addition, we advocate that the selection of component services should be carried out in a distributed fashion, which  ts well to the open web service environment, where central management is not feasible.
The contribution of this paper can be stated as follows:   A distributed QoS computation model for web services.
Unlike existing solutions that model the QoS-aware service composition problem as a conventional global optimization problem, we exploit the special structure of the web service composition problem to reduce the cost of QoS optimization.
The QoS optimization in our model is carried out by a set of distributed service brokers.
The idea is to decompose QoS global constraints into a set of local constraints that will serve as a conservative upper/lower bounds, such that the satisfaction of local constraints by a local service broker guarantees the satisfaction of the global constraints.
  An e cient QoS-aware service selection approach.
We propose an e cient and scalable mechanism for selecting web services for a given composition request from a collection of service candidates, such that the ful llment of user s end-to-end QoS requirements and preferences can be ensured.
By combining global optimization with local selection our approach is able to e ciently solve the selection problem in a distributed manner.
Experimental evaluations show that our hybrid approach is able to reach close-to-optimal results much faster than existing  pure  global optimization approaches.
The rest of the papers is organized as follows.
In the next section we discuss related work.
Section 3 introduces the system model and gives a problem statement.
Our approach for e cient and distributed QoS-aware service selection is presented in Section 4.
Performance analysis and experimental evaluations for comparing our solution against existing solutions are presented in Section 5.
Finally, Section 6 gives conclusions and an outlook on possible continuations of our work.
Figure 2: Conceptual Overview ware is to select one component service from each list such that the aggregated QoS values satisfy the user s end-to-end QoS requirements.
In service oriented environments, where deviations from the QoS estimates occur and decisions upon replacing some services has to be taken at run-time (e.g.
in the multimedia application above), the e ciency of the applied selection mechanism becomes crucial.
The focus of this paper is on the selection of web services based on their nonfunctional properties and the performance of the applied techniques.
Local Selection vs.
Global Optimization Two general approaches exist for the QoS-aware service composition: local selection and global optimization.
Local Selection: The local selection approach is especially useful for distributed environments where central QoS management is not desirable and groups of candidate web services are managed by distributed service brokers [8, 14].
The idea is to select one service from each group of service candidates independently on the other groups.
Using a given utility function, the values of the di erent QoS criteria are mapped to a single utility value and the service with maximum utility value is selected.
This approach is very e cient in terms of computation time as the time complexity of the local optimization approach is O(l), where l is the number of service candidates in each group.
Even if the approach is useful in decentralized environments, local selection strategy is not suitable for QoS-based service composition, with end-to-end constraints (e.g.
maximum total price), since such global constraints cannot be veri ed locally.
Global Optimization: The global optimization approach was recently put forward as a solution to the QoS-aware service composition problem [24, 25, 5, 6].
This approach aims at solving the problem on the composite service level.
The aggregated QoS values of all possible service combinations are computed, and the service combination that maximizes the aggregated The requirements for composition of web services can be stated in a work ow language such as Business Process Execution Language (BPEL) [19].
In [26, 9] ontology-based representations for describing QoS properties and requests were proposed to support semantic and dynamic QoS-based discovery of web services.
Quality of service management has been widely discussed in the area of middleware systems [7,
 and management.
Recently, the QoS-based web service selection and composition in service-oriented applications has gained the attention of many researchers [24, 25, 5, 6, 15,
 tation model that supports open and fair management of QoS data.
The problem of QoS-based composition is not addressed by this work.
The work of Zeng at al. [24, 25] focuses on dynamic and quality-driven selection of services.
The authors use global planning to  nd the best service components for the composition.
They use (mixed) linear programming techniques [18] to  nd the optimal selection of component services.
Similar to this approach Ardagna et al. [5, 6] extends the linear programming model to include local constraints.
Linear programming methods are very effective when the size of the problem is small.
However, these methods su er from poor scalability due to the exponential time complexity of the applied search algorithms [16].
In [23] the authors propose heuristic algorithms that can be used to  nd a near-to-optimal solution more e ciently than exact solutions.
The authors propose two models for the QoS-based service composition problem: 1) a combinatorial model and 2) a graph model.
A heuristic algorithm is introduced for each model.
The time complexity of the heuristic algorithm for the combinatorial model (WS HEU) is polynomial, whereas the complexity of the heuristic algorithm for the graph model (MCSP-K) is exponential.
Despite the sig-ni cant improvement of these algorithms compared to exact solutions, both algorithms do not scale with respect to an increasing number of web services and remain out of the real-time requirements.
Any distributed implementation of these algorithms would raise a very high communication cost.
The WS HEU for example, is an improvement of the original heuristic algorithm for solving general Multi-Choice Multidimensional Knapsack problems named M-HEU [1].
The WS HEU algorithm starts with a pre-processing step for  nding an initial feasible solution, i.e. a service combination that satis es all constraints but not necessarily is the best solution.
A post-processing step improves the total utility value of the solution with one upgrade followed by one or more downgrades of one of the selected component services.
Applying this algorithm in a distributed setting where the QoS data of the di erent service classes is managed by distributed service brokers would raise very high communication cost among these brokers to  nd the best composition.
In this paper, we propose a heuristic algorithm that solves the composition problem more e ciently and  ts well to the distributed environment of web services.
In our model we assume that we have a universe of web services S which is de ned as a union of abstract service classes.
Each abstract service class Sj   S (e.g.
 ight booking services) is used to describe a set of functionally-equivalent web services (e.g.
Lufthansa and Qantas  ight booking web services).
In this paper we assume that information about service classes is managed by a set of service brokers as described in [15, 14].
Web services can join and leave service classes at any time by means of a subscription mechanism.
As shown in Figure 2 we distinguish in the composition process between the following two concepts:   An abstract composite service, which can be de ned as an abstract representation of a composition request CSabstract = {S1, .
.
.
, Sn}.
CSabstract refers to the required service classes (e.g.
 ight booking) without referring to any concrete web service (e.g.
Lufthansa  ight booking web service).
  A concrete composite service, which can be de ned as an instantiation of an abstract composite service.
This can be obtained by binding each abstract service class in CSabstract to a concrete web service sj , such that sj   Sj .
We use CS to denote a concrete composite service.
In our study we consider quantitative nonfunctional properties of web services, which can be used to describe the quality criteria of a web service [24, 15].
These can include generic QoS attributes like response time, availability, price, reputation etc, as well as domain-speci c QoS attributes like bandwidth for multimedia web services as long as these attributes can be quanti ed and represented by real numbers.
We use the vector Qs = {q1(s), .
.
.
, qr(s)} to represent the QoS attributes of service s, where the function qi(s) determines the value of the i-th quality attribute of s. The values of these QoS attributes can be either collected from service providers directly (e.g.
price), recorded from previous execution monitoring (e.g.
response time) or from user feedbacks (e.g.
reputation) [15].
The set of QoS attributes can be divided into two subsets: positive and negative QoS attributes.
The values of positive attributes need to be maximized (e.g.
throughput and availability), whereas the values of negative attributes need to be minimized (e.g.
price and response time).
For the sake of simplicity, in this paper we consider only negative attributes (positive attributes can be easily transformed into negative attributes by multiplying their values by 1).
The QoS value of a composite service is decided by the QoS values of its component services as well as the composition model used (e.g.
sequential, parallel, conditional and/or loops).
In this paper, we focus on the sequential composition model.
Other models may be reduced or transformed to the sequential model.
Techniques for handling multiple execution paths and unfolding loops from [10], can be used for this purpose.
The QoS vector for a composite service CS is de ned as QCS = {q0 i(CS) represents the estimated value of the i-th QoS attribute of CS and can be aggregated from the expected QoS values of its component
 r(CS)}.
q0 gregation functions: 1) summation, 2) multiplication and 3) minimum relation.
Table 1 shows examples of these aggregation functions.
Examples Function Aggregation type Summation q0(CS) = Pn j=1 q(sj) with Response time Price Reputation Multiplication Availability Minimum Reliability Throughput q0(CS) = 1/n Pn q0(CS) = Qn j=1 q(sj ) j=1 q(sj) q0(CS) = minn j=1 q(sj) Table 1: Examples of QoS aggregation functions
 Global QoS constraints represent user s end-to-end QoS requirements.
These can be expressed in terms of upper (and/or lower ) bounds for the aggregated values of the different QoS criteria.
As mentioned earlier, we only consider negative QoS criteria.
Therefore in our model we only have upper bound constraints.
De nition 1.
(Feasible Selection) Let CSabstract be a given composition request and C 0 = {c0 m}, 0   m   r, be a vector of global QoS constraints on CSabstract.
Let CS be an instantiation of CSabstract, in which a concrete web service is selected for each service class.
We consider CS k   C 0, i.e. all global a feasible selection i  q0(CS)   c0,  c0 constraints are satis ed.
1, .
.
.
, c0
 In order to evaluate the multidimensional quality of a given web service a utility function is used.
The function maps the quality vector Qs into a single real value, to enable sorting and ranking of service candidates.
In this paper we use a Multiple Attribute Decision Making approach for the utility function: i.e. the Simple Additive Weighting (SAW) technique [22].
The utility computation involves scaling the QoS attributes  values to allow a uniform measurement of the multidimensional service qualities independent of their units and ranges.
The scaling process is then followed by a weighting process for representing user priorities and preferences.
In the scaling process each QoS attribute value is transformed into a value between 0 and 1, by comparing it with the minimum and maximum possible value according to the available QoS information of service candidates.
For a composite service CS = {S1, .
.
.
, Sn}, the aggregated QoS values are compared with minimum and maximum possible aggregated values.
The minimum (or maximum) possible aggregated values can be easily estimated by aggregating the minimum (or maximum) value of each service class in CS.
For example, the maximum execution price of CS can be computed by summing up the execution price of the most expensive service candidate in each service class in CS.
Formally, the minimum and maximum aggregated values of the k-th QoS attribute of CS are computed as follows: Qmin0(k) = Qmax0(k) = n
 j=1 n
 j=1 Qmin(j, k) (1) Qmax(j, k) Qmin(j, k) = min  sji  Sj qk(sji) Qmax(j, k) = max  sji  Sj qk(sji) (2) where Qmin(j, k) is the minimum value (e.g.
minimum price) and Qmax(j, k) is the maximum value (e.g.
maximum price) that can be expected for service class Sj according to the available information about service candidates of this class.
Now the utility of a component web service s   Sj is computed as U (s) = r
 k=1 Qmax(j, k)   qk(s) Qmax(j, k)   Qmin(j, k)   wk (3) and the overall utility of a composite service is computed as
 r
 k=1 Qmax0(k)   q0 Qmax0(k)   Qmin0(k) k(CS)   wk (4) with wk   R+
 represent user s priorities.
k=1 wk = 1 being the weight of q0 k to De nition 2.
(Optimal Selection) The optimal selection for a given web service composition request CSabstract and a given vector of global QoS constraints C 0 = {c0 m}, 0   m   r, is a feasible selection (according to De nition 1) with the maximum overall utility value U 0.
1, .
.
.
, c0 However,  nding the optimal composition requires enumerating all possible combinations of service candidates.
For a composition request with n service classes and l service candidate per class, there are ln possible combinations to be examined.
Performing exhaustive search can be very expensive in terms of computation time and, therefore, inappropriate for run-time service selection in applications with many services and dynamic needs.
The problem of  nding the best service composition without enumerating all possible combinations is considered as an optimization problem, in which the overall utility value has to be maximized while satisfying all global constraints.
Formally, the optimization problem we are addressing can be stated as follows: For a given composition request CSabstract = {S1, .
.
.
, Sn} and a given set of m global QoS constraints C 0 = {c0 m},  nd an implementation CS = {s1, .
.
.
, sn} by binding each Sj to a concrete service sj   Sj such that: 1, .
.
.
, c0

 k(CS)   c0 k,  c0 k   C 0

 The use of mixed integer programming [18] to solve the QoS-aware service composition problem has been recently proposed by several researchers [24, 25, 5, 6].
Binary decision variables are used in the model to represent the service candidates.
A service candidate sij is selected in the optimal composition if its corresponding variable xij is set to 1 in the solution of the model and discarded otherwise.
By rewriting (4) to include the decision variables, the problem of solving the model can be formulated as a maximization problem of the overall utility value given by r
 k=1 Qmax0(k)   Pn j=1 Pl i=1 qk(sji)   xji Qmax0(k)   Qmin0(k)   wk (5) subject to the global QoS constraints n l

 j=1 i=1 qk(sji)   xji   c0 k, 1   k   m   wk (6) while satisfying the allocation constraints on the decision variables as l
 i=1 xji = 1, 1   j   n.
(7) Because the number of variables in this model depends on the number of service candidates (number of variables = n l), this MIP model may not be solved satisfactorily, except for small instances.
Another disadvantage of this approach is that it requires that the QoS data of available web services be imported from the service broker into the MIP model of the service composer, which raises high communication.
To cope with these limitations, we divide the QoS-aware service composition problem into two sub-problems that can be solved more e ciently in two subsequent phases.
Figure 3 gives an overview on our approach.
In the  rst phase, the service composer decomposes each global QoS constraints into local constraints on the component services level and sends these constraints to the involved service brokers.
These constraints also include user s preferences, which are expressed in terms of weights of the QoS attributes.
In the second phase, each service broker performs local selection to  nd the best component services that satisfy these local constraints.
The two phases of our approach are described in the next subsections in more details.
To ensure the ful llment of global QoS constraints in a service composition problem without enumerating all possible combinations of component web service, we decompose each QoS global constraint c0 into a set of n local constraints c1, .
.
.
, cn (n is the number of abstract service classes in the composition request).
The local constraints serve as a conservative upper bounds, such that the satisfaction of local constraints guarantees the satisfaction of global constraints.
A naive decomposition algorithm would be to divide each global constraint c0 into n equal local constraints such that: cj = c0/n, 1   j   n. However, as di erent service classes can have di erent QoS value ranges, a more sophisticated decomposition algorithm is required.
Furthermore, in order to avoid discarding any service candidates that might be part of a feasible composition, the decomposition algorithm needs to ensure that the local constraints are relaxed as much as possible while meeting global constraints.
We solve this problem by modeling the QoS constraint decomposition problem as an optimization problem.
The goal of this optimization problem is to  nd a set of local constraints for each service class that cover as many as possible service candidates, while their aggregation does not violate any of the global constraints.
To this end, we divide the quality range of each QoS attribute into a set of discrete quality values, which we call quality levels.
We then map each global be used as local constraints by the local service selection algorithm.
For example, given a set of candidate web services and their execution prices, we create a list of price levels for that service class (the following subsection describes how levels are determined).
The global constraint on total execution price is then mapped to the price levels of service classes.
We use mixed integer program (MIP) [18] solving techniques to  nd the best mapping of global constraints to local quality levels.
Unlike the MIP model in [24, 25, 5, 6], our MIP model has much less number of variables (i.e. the quality levels instead of actual service candidates) and can be, therefore, solved much faster.
Quality levels are initialized for each service class Sj by dividing the value ranges of each QoS attribute qk into a set of d discrete quality values as depicted in  gure 4 Qmin(j, k)   q1 jk   .
.
.
  qd jk   Qmax(j, k).
jk a value pz The quality levels are determined such that they represent the data collection of each service class.
We  rst divide the range of attribute values into d sub-ranges.
From each sub-range we randomly select one sample value.
The more frequent a given value is, the higher the probability that it is selected as a quality level.
We then assign each quality level qz jk between 0 and 1, which estimates the bene t of using this quality level as a local constraint.
This value is determined as follows.
First, we compute h(qz jk), i.e. the number of candidate services that would qualify if this level was used as local constraint.
Second, we calculate the utility value of each service candidate in the service class using the utility function (3) and determine u(qz jk), i.e. the highest utility value that can be obtained by considering these quali ed services.
Finally, pz jk can be calculated as pz jk = h(qz jk) l u(qz jk) umax   (8) where l is the total number of service candidates of service class Sj, and umax is the highest utility value that can be obtained for this class by considering all service candidates.
The value pz jk indicates how many web services would qualify if the z-th level was used as local constraint for the k-th QoS attribute in service class Sj , and estimates the highest obtainable utility value for that class.
Figure 4: Quality Level Selection
 We use MIP model to  nd the best decomposition of QoS constraints into local constraints.
Therefore, we use a binary decision variable xz jk such that jk for each local quality level qz xz jk = 1 if qz attribute qk at the service class Sj, and xz jk is selected as a local constraint for the QoS jk = 0 otherwise.
Therefor, we use the following allocation constraints in the model:  j,  k : d
 z=1 xz jk = 1 , 1   j   n , 1   k   m (9) Note that the total number of variables in the model equals to n   m   d, i.e.
it is independent of the number of service candidates.
If the number of quality levels d sat-is es m   d   l we can ensure that the size of our MIP model is smaller than the size of the model used in [24, 25, 5, 6] (where the number of decision variables is n   l), thus can be solved much faster.
The objective function of our MIP model is to maximize the p value (as de ned in 8) of the selected local constraints to minimize the number of discarded feasible selections.
Therefore, the objective function can be expressed as follows: maximize n m

 pz jk j=1 k=1 , 1   z   d (10) We use the logarithmic function to linearize (10) in order to be able to use it in the MIP model: maximize n m d


 j=1 k=1 z=1 ln(pz jk)   xz jk (11) The selection of the local constraints must ensure that global constraints are still satis ed.
Therefore, we add the following set of constraints to the model:  k : n d

 j=1 z=1 qz jk   xz jk   c0 k , 1   k   m (12) By solving this model using any MIP solver methods, we get a set of local quality levels.
These quality levels are then sent to the distributed set of involved service brokers to perform local selection.
After decomposing global QoS constraints into local ones, the second step of our solution is to perform local selection for each service class independently.
Upon the receipt of local constraints and user  preferences from the service composer, each service broker performs the local selection and returns the best web service candidate to the service composer.
The received local constraints are used as upper bounds for the QoS values of component services.
Web services that violate these upper bounds are skipped from the selection.
A list of quali ed services is created and sorted by their utility values.
The use of (3) for this purpose is not appropriate for the following reason.
This utility function compares the distance Qmax(j, k)   qk(sji) between the quality value of a service candidate sji and the local maximum value in its class Sj with the distance Qmax(j, k)   Qmin(j, k) between the local minimum and maximum values.
This scaling approach can be biased by local properties leading to local optima instead of global optima.
Therefore, we compare the distance Qmax(j, k)   qk(sji) with the distance Qmax0(k)   Qmin0(k).
This scaling method ensures that the evaluation of service candidates is globally valid, which is important for guiding local selection in order to avoid local optimums.
The scaling process is then followed by a weighting process for representing user s over the di erent QoS attributes.
We compute the utility U (sji) of the i-th service candidate in class Sj as U (sji) = r
 k=1 Qmax(j, k)   qk(sji) Qmax0(k)   Qmin0(k)   wk (13) with wk   R+ represent user s priorities.
k=1 wk = 1 being the weight of qk to

 The aim of this evaluation is to validate our hypothesis that our approach achieves close-to-optimal results with a much lower computation time compared to  pure  global optimization approach as proposed by [15, 25, 6].
In the following we use the label  hybrid  to refer to our solution and the label  global  to refer to the  pure  global optimization approach.
The scalability of QoS-based service composition systems is a ected by the time complexity of the applied algorithm.
There are three factors that determine the size of the composition problem: the number of required service classes n, the number of service candidates per class l, which we assume to be equal for all classes, and the number of global QoS constraints m. As the problem can be modeled as a Multi-Choice Multidimensional Knapsack problem (MMKP), which is known to be NP-hard [20], the time complexity of any exact solution is expected to be exponential.
Existing global optimization solutions model the service selection problem as a standard mixed integer program (MIP).
The worst case time complexity of MIP solvers using the simplex method is an exponential function O(2n l) [16], which restricts the applicability of these solutions to small size composition problems, where the number of service candidates l is very limited.
Returning back to the given service composition scenario in section 1, already with a few hundreds of web service candidates that provide the same functionality (e.g.
transcoding web services), the response time of this approach to QoS-optimized service selection (or replacement) requests can be out of the run-time requirements.
In our Hybrid approach, we use mixed integer programming to solve part of the problem, namely, the decomposition of the global QoS constraints into local ones.
The actual selection of services, however, is done using distributed local selection strategy, which is very e cient and scalable.
The local utility computation for service candidates has a linear complexity with respect to the number of service candidates, i.e. O(l).
As service brokers can perform the local selection in parallel, the total time complexity of this step is not a ected by the number of service classes, hence, the complexity of the second step remains O(l).
The time complexity of our approach is dominated by the time complexity of the constraint decomposition part.
The number of decision variables in our MIP model is n   m   d, where n is the number of service classes, m is the number of global QoS constraints and d is the number of quality levels.
Consequently, the time complexity of our approach is independent on the number of available web services, which makes it more scalable than existing solutions that rely on  pure  global optimization.
By selecting a low number of quality levels d with 1 < d << l m we ensure that the size of the MIP is much smaller compared to the MIP model used in the global optimization approaches in [15, 25, 6].
We have conducted extensive simulations to evaluate the performance of the proposed QoS-aware service selection approach, which we describe in this section.
Evaluation Methodology We have created several test cases of the QoS-based service composition problem.
Each test case consists of a service composition request with n service classes, l service candidates per class and m global QoS constraints.
By varying these numbers we created a collection of test cases, where each unique combination of these parameters represents one test case.
We  rst solved each test case using the global optimization approach to  nd the optimal selection of component services that satisfy all global QoS constraints, while maximizing the overall utility value.
We recorded the required computation time tglobal and the obtained utility value uglobal by this method for each test case.
We then provided the same test cases to our hybrid service selection method and compared its computation time thybrid and the aggregated utility value of the returned selection uhybrid with tglobal and uglobal for the same test case respectively.
In order to study the e ect of the chosen number of quality levels in the hybrid approach, we solved each test case several times with di erent number of quality levels.
The number of quality levels in this experiment was set to 10, 20, 30, 40 and 50 levels.
The Dataset In our evaluation we experimented with two QoS datasets.
The  rst dataset is the QWS real dataset from [2, 3, 4].
This dataset includes measurements of 9 QoS attributes for 2500 real web services.
Table 2 lists the QoS attributes in this dataset and gives a brief description of each attribute.
The dataset was measured using commercial benchmark tools for Table 2: QoS attributes in the QWS dataset Of Description At-QoS tribute Response Time Availability Throughput Likelihood of success Reliability Compliance of invoca-successful Time taken to send a request and receive a response Number tions/total invocations Total number of invocations for a given period of time Number of response/number of request messages Ratio of the number of error messages to total messages To which extent a WSDL document follows the WSDL spec.
Best Practices To which extent a web service follows the Web Services Interoper-ability (WS-I) Basic Pro le Time the server takes to process a given request Latency Documentation Measure of documentation (i.e. de-percent scription tags) in WSDL Units Measurement millisecond percent invocations / second percent percent percent percent millisecond Figure 6: Performance comparison w.r.t.
the number of web service classes web services, which were located using public sources on the Web, including UDDI registries, search engines and service portals.
For more details about this dataset we refer the reader to [3, 4].
In order to make sure that the results of our experiments are not biased by the used QWS dataset, we experimented with a second dataset.
The second dataset was created by assigning arbitrary QoS values to 20000 arti cial web services.
The QoS values were normally distributed in the range between 1 and 100.
Experiment Settings We used the open source (Mixed Integer Programming) Lp-Solve system lpsolve version 5.5 [17] for solving the MIP model in both approaches.
The experiments were conducted on a HP ProLiant DL380 G3 machine with 2 Intel Xeon
 ning under Linux (CentOS release 5) and Java 1.6.
Performance Results In Figure 5 we compare the performance of our hybrid approach and the global optimization approach with respect to the number of service candidates.
The graphs show the measured computation times tglobal and thybrid for each test case.
The number of service candidates per class l varies from 50 to 500 for the QWS dataset and from 100 to 2000 services per class.
In this experiment, the number of service classes n is  xed to 5 for the QWS dataset and to 10 classes for the random dataset in all test cases.
The number of QoS constraints in all these test cases was  xed to 3 constraints.
The results indicate that the hybrid approach signi cantly outperforms the global approach for both datasets.
By increasing the number of service candidates, the required computation time of the hybrid approach increases very slowly compared to the global approach, which makes our solution more scalable.
The results also show that increasing the number of quality levels in the hybrid approach increases the computation time.
We also notice that with small number of service candidates, increasing the number of quality levels  more than necessary  (i.e. to 50 quality levels in this case) can lead to longer computation time than in the global approach.
This is an expected behavior as we already discussed in Section 5.1.
According to our analysis, the number of quality levels d must be less than l/m.
In the aforementioned situation this was not the case (in the random dataset for example, d = 50, whereas l/m = 33.3).
In the experiment shown in Figure 6 we study the performance of both approaches with respect to the number of service classes n in the composition.
The number of service classes varies from 5 to 25 for the QWS dataset and from
 Figure 8: Optimality w.r.t.
the number of web service classes service candidates per class l in this experiment is  xed to
 The results of this experiment show that our approach still outperforms the global approach in all test cases.
Optimality As our hybrid solution is an approximate solution, we have evaluated the quality of the results obtained by our solution by comparing it with the optimal results obtained by the global optimization approach.
We compute the optimality of the results of the hybrid approach by comparing the overall utility value (uhybrid) of the selected services to the overall utility value (uglobal) of the optimal selection obtained by the global approach, i,e.
: optimality = uhybrid/uglobal Figure 7 shows the achieved optimality in several test cases with di erent number of service candidates, while Figure 8 shows the achieved optimality in several test cases with a varying number of service classes.
The results indicate that the hybrid approach was able to achieve above 96% optimality in average.
The results also show that in average, increasing the chosen number of quality levels improves the achieved optimality.
This improvement does not come without cost as we can see from Figures 5 and 6.
There is a trade-o  between optimality and performance.
Nevertheless, in average, the hybrid approach is able to reach a close-to-optimal results with very low cost.
In this paper we presented an e cient heuristic for the QoS-based service composition, which is known to be NP-hard.
We combine global optimization with local selection methods to bene t from the advantaged of both worlds.
Our proposed method allows to dramatically reduce the (worst case) e orts compared to existing solutions.
Our evaluations show a signi cant improvement in terms of computational time, while achieving close to optimal results.
This is especially useful for applications with dynamic changes and real-time requirements.
In the current approach the number of service levels is  xed and need to be de ned beforehand.
Currently we are studying the impact of the applied method as well as the number of the selected quality levels on the performance and quality of the obtained results.
We also aim at developing a self-adaptive approach, which optimizes itself by determining the best number of quality levels at run-time based on the available QoS information.
A protocol for coordinating the distributed service brokers, which are involved in a QoS optimization process, is also part of our future work.
