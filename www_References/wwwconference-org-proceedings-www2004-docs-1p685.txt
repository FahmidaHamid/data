[1] T. Berners-Lee. A Road Map to the Semantic Web,

September 1998. W3C
http://www.w3.org/DesignIssues/Semantic.html.

[2] T. Berners-Lee. Ideas about web architecture - yet another

notation notation 3, 2001. W3C
http://www.w3.org/DesignIssues/Notation3.html.

[3] T. Berners-Lee, J. Hendler, and O. Lassila. The semantic

web. In Scientiﬁc American, May 2001.

[4] T. Despeyroux. Executable Speciﬁcation of Static Semantics.

In Semantics of Data Types, Lecture Notes in Computer
Science,Vol. 173, June 1987.

[5] T. Despeyroux and B. Trousse. Semantic veriﬁcation of web
sites using natural semantics. In RIAO 2000, 6th Conference
on “Content-Based Multimedia Information Access”,
College de France, Paris, France, April 2000.

[6] T. Despeyroux and B. Trousse. Maintaining semantic

constraints in web sites. In AACE WebNet 2001 Conference,
Orlando, Florida, October 2001.

[7] D. Fensel, J. Angele, S. Decker, M. Erdmann, H.-P. Schnurr,

R. Studer, and A. Witt. On2broker: Lessons Learned from
Applying AI to the Web. Technical report, Institute AIFB,
1998.

[8] D. Fensel, R. Decker, M. Erdman, and R. Studer.

Ontobroker: the Very High Idea. In Proceedings of the 11th
International FLAIRS Conference (FLAIRS-98), May 1998.

[9] M. F. Fernandez, D. Florescu, A. Y. Levy, and D. Suciu.

Verifying integrity constraints on web sites. In IJCAI, pages
614–619, 1999.

[10] C. A. Gunter. Semantics of Programming Languages. MIT

Press, 1992.

[11] H. Hosoya and B. Pierce. Xduce: A typed xml processing
language. In Proceedings of Third International Workshop
on the Web and Databases, May 2000.

[12] G. Kahn. Natural Semantics. In Proceedings of the Symp. on

Theorical Aspects of Computer Science, TACS, Passau,
Germany, 1987. LNCS 247, Springer-Verlag, Berlin. also
Inria Research Report 601, February 1987.

[13] E. Meijer and M. Shields. XM(cid:21): A functional programming
language for constructing and manipulating xml document,
1999. Draft, http://www.cse.ogi.edu/ mbs/pub/xmlambda/.

[14] J. Peer. A logic programming approach to RDF document

and query transformation. In Workshop on Knowledge
Transformation for the Semantic Web at the 15th European
Conference on Artiﬁcial Intelligence, Lyon, France, 2002.

[15] G. D. Plotkin. A structural approach to operational
semantics. Technical Report DAIMI FN-19, Aarhus
University, 1981.

[16] R. M. Stallman and R. McGrath. GNU Make: A Program for

Directing Recompilation, for Version 3.79. Free Software
Foundation, 675 Mass Ave., Cambridge, MA 02139, USA,
Tel: (617) 876-3296, USA, 2000.

[17] E. Szabo. The Collected Papers of Gerhard Gentzen.

North-Holland, Amsterdam, 1969.

[18] F. van Harmelen and D. Fensel. Practical Knowledge

Representation for the Web. In D. Fensel, editor,
Proceedings of the IJCAI’99 Workshop on Intelligent
Information Integration, 1999.

[19] F. van Harmelen and J. van der Meer. Webmaster:

Knowledge-based Veriﬁcation of Web-pages. In Twelfth
International Conference on Industrial and Engineering
Applications of Artiﬁcial Intelligence and Expert Systems
IEA/AIE’99, 1999.

[20] W3C. Xml, xsl, xml schema and rdf recommendations or

submissions. W3C http://www.w3.org/.

[21] W3C. Daml+oil (march 2001) reference description, 2001.

W3C http://www.w3.org/TR/daml+oil-reference.

APPENDIX
A. OUR SPECIFICATION LANGUAGE

SYNTAX

This appendix contains the source ﬁle of our parser. It uses a
home made extension of Deﬁne Clause Grammars. This extension
has three advantages: it handles left recursions; it takes advantage
of prolog hash-coding over some arguments; it produces a structure
which is rich enough to allow precise error messages with some
back references to the source that is analysed (it can be used in
particular to retrieve line numbers).

The production

attr(attr(N,V)) :- name(N), [’=’], value(V).

is equivalent to the traditional grammar rule

attr --> name ’=’ value.

attr(N,V) is a regular prolog term and explains how the parse tree
is constructed from subtrees.

The call to stoken is the interface with the lexer which is im-

plemented using ﬂex.

Beside the speciﬁcation language itself, we can recognize the
syntax of prolog terms (non terminal term) and XML elements
(non terminal element). Traditional elements are extended with
variables as in <$varname>. The sign <* is used to comment
easily some complete rules.

entry(A) :- rules(A).

rules([]).
rules([A|B]) :- rule1(A), rules(B).

%-------

rule1(skip(A)) :- [’<*’], rule(A).

691rule1(A) :- rule(A).

variable(var(A)) :- [’$’], name(A).

rule(ruleenv(A,B)) :-

left(A), [’=>’], right(B), [’;’].

rule(ruletest(A,B)) :-

% -----

sstring(string(V)) :-

left(A), [’?’], test(B), [’;’].

stoken(’STRING’,string(V)).

left(left(A,B)) :-

element(A), [’&’], cond_s(B).

left(left(A,[])) :- element(A).

sstring(string(V)) :-

stoken(’STRING2’,string(V)).

name(name(A)) :- stoken(’NAME’,string(A)).
text(text(A)) :- stoken(’TEXT’,string(A)).

cond_s([A|B]) :- cond(A), [’&’], cond_s(B).
cond_s([A]) :- cond(A).

cond(contains(A,B)) :-

variable(A), [’contains’], element(B).

cond(eq(A,B)) :- name(A), [’=’], term(B).

B. SOURCE FOR CHECKING SOME PART

OF AN ACTIVITY REPORT

This appendix contains the source ﬁle for our activity report
checker. This is the real source, and it may differ from what ap-
pears in the text.

right(right(A,B)) :- act(A), [’&’], right(B).
right(right(A,[])) :- act(A).

act(assign(A,B)) :- name(A), [’:=’], term(B).
act(A) :- term(A).

test(ifnot(A,B)) :- term(A), [’/’], conseq(B).
test(if(A,B)) :- term(A), [’->’], conseq(B).

conseq(A) :- element(A).
conseq(A) :- term(A).

%-------

term(term(Op,Args)) :-

name(Op), [’(’], term_s(Args), [’)’].

term(A) :- sstring(A).
term(var(A)) :- [’$’], name(A).

term_s([]).
term_s([A]) :- term(A).
term_s([A|Q]) :- term(A), [’,’], term_s(Q).

%-------

element(A) :- text(A).
element(empty_elem(A,T)) :-

[’<’], name(A), attr_s(T), [’/>’].

element(elem(A,T,L)) :-

[’<’], name(A), attr_s(T), [’>’],
element_s(L),
[’</’], name(B), [’>’].

element(var(A)) :- [’<$’], name(A), [’>’].

<raweb>

<accueil>

<$_>
<$_>
<projet><$P><$_></projet>
<$_>

</accueil>
<$_>

</raweb>
=> project := $P;

<raweb year=$X> <$_> </raweb>
=> year := $X & defperso := "false";

<catperso> <$_> </catperso>
=> defperso := "true";

<pers prenom=$P nom=$N> <$_> </pers>
& defperso = "true"
& project = $Proj
=> personne($P,$N,$Proj);

<pers prenom=$P nom=$N> <$_> </pers>
& defperso= "false"
& project = $Proj
? personne1($P,$N,$Proj) /
<li>

Warning: <i> <$P> <$N> </i>
does not appear in the list of project’s

members; line <$SourceLine> in
<$SourceFile>.

<p> </p>
</li> ;

element_s([E|L]) :- element(E), element_s(L).
element_s([]).

<citation from=$X> <$_> </citation>
=> citationfrom := $X;

attr_s([E|L]) :- attr(E), attr_s(L).
attr_s([]).

attr(attr(N,V)) :- name(N), [’=’], value(V).

value(V) :- sstring(V).
value(V) :- variable(V).

<citation> <$A> </citation>
& $A contains <btitle>

<$Title>
<$_>

</btitle>

=> title := $Title ;

<byear> <$Byear> <$_> </byear>

692& citationfrom = "year"
& year = $Year
& title = $Title
? sameyear($Byear,$Year) /
<li>

Warning: The citation <i> "<$Title>" </i>

line <$SourceLine>

in file
<$SourceFile>
has not been published during this year
(published in <$Byear>).

<p> </p>
</li> ;

<btitle> <$Title> <$_> </btitle>
& citationfrom = "year"
& project = $Proj
=> pub($Title,$Proj) ;

<btitle> <$Title> <$_> </btitle>
& citationfrom = "year"
& project = $Proj
? pubbyotherproject($Title,$Proj,$Otherproj)

->
<li>

Hourra! the citation <i> "<$Title>" </i>

line

<$SourceLine>
in file
<$SourceFile>

has been published in cooperation with
<$Otherproj>.
<p> </p>
</li> ;

<xref url=$URL><$_></ref>
? testurl($URL,$Answer1,$Answer2) ->
<li>
Testing of URL <i> <$URL> </i> line

<$SourceLine>
in file
<$SourceFile> replies:

<$Answer1>
<$Answer2>.
<p> </p>
</li> ;

The predicates personne1, sameyear, pubbyotherproject,

and testurl are deﬁned directly in Prolog. The last one makes a
call to the program wget with some timeout guard.

693
