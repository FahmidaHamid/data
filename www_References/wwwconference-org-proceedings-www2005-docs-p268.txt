[1] The Third Generation Partnership Project (3GPP).

http://www.3gpp.org.

[2] S. Abiteboul, B. Alexe, O. Benjelloun, B. Cautis,

I. Fundulaki, T. Milo, and A. Sahuguet. An Electronic
Patient Record “on Steroids”: Distributed,
Peer-to-Peer, Secure and Privacy-conscious. In VLDB,
2004. (demo track).

[3] S. Abiteboul, A. Bonifati, G. Cobena, I. Manolescu,

and T. Milo. Dynamic XML Documents with
Distribution and Replication. In SIGMOD, 2003.

[4] C. Barton, P. Charles, D. Goyal, M. Raghavachari,
M. Fontoura, and V. Josifovski. Streaming XPath
Processing with Forward and Backward Axes. In
ICDE, 2004.

[5] M. Benedikt and I. Fundulaki. Speciﬁcation and

Composition of Subtree Queries. Technical Report,
Bell Labs. http://db.bell-labs.com.

[6] E. Bertino, S. Castano, and E. Ferrari. Securing XML

[16] I. Manolescu and Y. Papakonstantinou, editors.

Documents: The Author-X Project . In SIGMOD ,
2001 (demo track).

[7] F. Bry, F. Coskun, S. Durmaz, T. Furche, D. Olteanu,
and M. Spannagel. The XML Stream Query Processor
SPEX. In ICDE, 2005.

Proceedings of the First International Workshop on
XQuery Implementation, Experience and Perspectives
<XIME-P/>, June 2004, Paris, France, 2004.

[17] A. Marian and J. Simeon. Projecting XML

Documents. In VLDB, 2003.

[8] P. Buneman, S. B. Davidson, W. Fan, C. S. Hara, and

[18] M. Petropoulos, A. Deutch, and Y. Papakonstantinou.

W. C. Tan. Keys for XML. In WWW, 2001.

[9] D. Chamberlin, D. Florescu, J. Robie, J. Simeon, and
L. Stefanescu. XQuery: A Query Language for XML.
http://www.w3.org/TR/xquery, February 2001.
[10] J. Clark and S. D. (eds.). XML Path Language

Query Set Speciﬁcation Language (QSSL). In
Informal Proc. WEBDB, 2003.

[19] R. Ramakrishnan and J. Gehrke. Database
Management Systems. McGraw Hill, 2003.

[20] J. Rosenberg. The Extensible Markup Language

(XPath) Version 1.0, 1999.
http://www.w3c.org/TR/xpath.

[11] W. Fan, C.-Y. Chan, and M. Garofalakis. Secure XML

(XML) Conﬁguration Access Protocol (XCAP). IETF
draft, Feb 2004. http://www.jdrosen.net/papers/
draft-ietf-simple-xcap-02.txt.

Querying with Security Views. In SIGMOD, 2004.

[21] A. Sahuguet, B. Alexe, P.-Y. Laligand, A. Shikfa, and

[12] M. Fernandez, Y. Kadiyska, D. Suciu, A. Morishima,

and W.-C. Tan. SilkRoute: A framework for
publishing relational data in XML . TODS,
27(4):438–493, 2002.

I. Fundulaki. User Proﬁle Management in Converged
Networks (Episode II): Share your data, Keep your
secrets. In CIDR, Asilomar, CA, USA, January 2005.
Online Proceedings.

[13] I. Fundulaki and A. Sahuguet. Share your data, keep

[22] A. Sahuguet, R. Hull, D. Lieuwen, and M. Xiong.

your secrets. In SIGMOD (Demo), 2004.

[14] Liberty Alliance Project.

http://www.projectliberty.org.

[15] Liberty Alliance ID-WSF Data Services Template

Speciﬁcation, Version 1.0.
http://www.projectliberty.org/specs/
liberty-idwsf-dst-v1.0.pdf, 2002.

Enter Once, Share Everywhere: User Proﬁle
Management in Converged Networks. In CIDR,
Asilomar, CA, USA, January 2003. Online
Proceedings.

[23] A. R. Schmidt, F. Waas, M. L. Kersten, D. Florescu,

M. J. Carey, I. Manolescu, and R. Busse. Why and
How to Benchmark XML Databases. ACM SIGMOD
Record, 3(30):27–32, September 2001.

Q1) /site/regions/europe/item/mailbox

Q2) /site/regions/europe/item[shipping][payment](mailbox/mail/text ∪ description)
Q3) /site/regions/europe/(item/payment ∪ item[not(shipping)])
Q4) /site/(people/person[homepage] ∪ closed_auctions/closed_auction[annotation]/seller)
Q5) /site/( open_auctions/( open_auction[not(reserve)] ∪ open_auction[privacy])

∪ regions/europe/item/description[parlist/listitem])

Figure 9: Queries used to compare evalution strategies.

Q1)
I: /site/regions
O: /site/regions/europe/item/mailbox
C: /site/regions/europe/item/mailbox

Q2)
I: /site/regions/europe/item[location]/description/parlist/listitem[text]

O: /site/( regions/europe/item[description] ∪ open_auctions/open_auction[not(reserve)] )

C: /site/regions/europe/item[location][description]/description/parlist/listitem[text]

Q3)
I: /site/( regions/europe/item[mailbox/mail/from]/description/parlist[listitem/text]

∪ open_auctions/open_auction[privacy] )

O: /site/( regions/europe/item[description/parlist] ∪ open_auctions )

C: /site/( regions/europe/item[description/parlist][mailbox/mail/from]/description/parlist[listitem/text]

∪ open_auctions/open_auction[privacy] )

Q4)

I: /site/(regions/europe/(item[not(quantity)] ∪ item/location) ∪ people)
O: /site/(regions/europe/item ∪ people/person[homepage])
C: /site/(regions/europe/(item[not(quantity)] ∪ item/location) ∪ people/person[homepage])

Q5)
I: /site/( regions/europe/item/description[not(parlist)]

∪ closed_auctions/closed_auction[annotation]/seller )

O: /site/( regions/europe/item ∪ closed_auctions/closed_auction )

C: /site/( regions/europe/item/description[not(parlist)]

∪ closed_auctions/closed_auction[annotation]/seller )

Q6)
I: /site/regions/europe/item/description
O: /site/regions/europe/item/mailbox
C: empty query

Figure 10: Queries for sequential vs composition: inner (I), outer(O), composed (C).

XPath:
/a[p1]/b, /a[p1]/c[p2][p3]/d, /a[p1]/c[p2][p3]/e, /a[p1]/c[p2][p3]/f[p4]/g

XQuery:
for $x1 in /* return

if ($x1[self::a[p1][b | c[p2][p3][d | e | f[p4][g]]]])
then <a>

for $x2 in $x1/* return

if ($x2[self::b]) then $x2
else if ($x2[self::c[p2][p3][d | e | f[p4][g]]][not(self::b)])
then <c>

for $x4 in $x2/* return

if ($x4[self::d]) then $x4
else if ($x4[self::e][not(self::d)])
then $x4
else if ($x4[self::f[p4][g]][not(self::d)][not(self::e)])
then <f>

for $x7 in $x4/* return

{

{

{

if ($x7[self::g]) then $x7 else ()

} </f> else ()

} </c> else ()

} </a> else ()
XSLT:
<xsl:stylesheet>

<xsl:template match="node()|@*">
</xsl:template> <!-- rule for default behavior (skip) -->
<xsl:template mode="regular" match="node()|@*">
</xsl:template> <!-- rule for regular behavior (skip) -->
<xsl:template mode="leaf" match="node()|@*">

<xsl:copy>

<xsl:apply-templates mode="leaf" select="@*"/>
<xsl:apply-templates mode="leaf"/>

</xsl:copy>

</xsl:template> <!-- rule for leaf behavior (keep whatever is underneath) -->
<xsl:template match="/">

<xsl:apply-templates mode="regular" select="a[p1]"/>

</xsl:template>
<xsl:template mode="regular" match="a[p1][b | c[p2][p3][d | e | f[p4][g]]]">

<xsl:copy>

<xsl:apply-templates mode="regular" select="b | c[p2][p3][d | e | f[p4][g]]"/>

</xsl:copy>

</xsl:template>
<xsl:template mode="regular" match="b">

<xsl:apply-templates mode="leaf" select="."/>

</xsl:template>
<xsl:template mode="regular" match="c[p2][p3][d | e | f[p4][g]]">

<xsl:copy>

<xsl:apply-templates mode="regular" select="d | e | f[p4][g]"/>

</xsl:copy>

</xsl:template>
<xsl:template mode="regular" match="d">

<xsl:apply-templates mode="leaf" select="."/>

</xsl:template>
<xsl:template mode="regular" match="e">

<xsl:apply-templates mode="leaf" select="."/>

</xsl:template>
<xsl:template mode="regular" match="f[p4][g]">

<xsl:copy>

<xsl:apply-templates mode="regular" select="g"/>

</xsl:copy>

</xsl:template>
<xsl:template mode="regular" match="g">

<xsl:apply-templates mode="leaf" select="."/>

</xsl:template>
</xsl:stylesheet>

Figure 11: Translations for XSQuirrel expression /a[p1]/( b ∪ c[p2][p3]/(d ∪ e ∪ f[p4]/g) )


