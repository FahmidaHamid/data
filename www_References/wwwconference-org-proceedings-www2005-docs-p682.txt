[1] A. Berglund, S. Boag, D. Chamberlin, M. F. Fern´andez,

M. Kay, J. Robie, and J. Sim´eon. XML path language
(XPath) 2.0. W3c working draft, World Wide Web
Consortium, July 2004.
http://www.w3.org/TR/2004/WD-xpath20-20040723.

[2] G. J. Bex, S. Maneth, and F. Neven. A formal model for an
expressive fragment of xslt. In Computational Logic 2000,
pages 1137–1151, London, UK, July 2000.

[3] S. Boag, D. Chamberlin, M. F. Fern´andez, D. Florescu,

J. Robie, and J. Sim´eon. XQuery 1.0: An XML query
language. W3c working draft, World Wide Web Consortium,
July 2004.
http://www.w3.org/TR/2004/WD-xquery-20040723.

[4] DB2. DB2 XML extender.

http://www-306.ibm.com/software
/data/db2/extenders/xmlext/.

[5] M. Fern´andez, A. Malhotra, J. Marsh, M. Nagy, and

N. Walsh. XQuery 1.0 and XPath 2.0 data model. W3c
working draft, World Wide Web Consortium, July 2004.
http://www.w3.org/TR/2004/
WD-xpath-datamodel-20040723.

[6] M. Kay. SAXON 8.0. SAXONICA.com.

http://www.saxonica.com/.

[7] M. Kay. XSL transformations (XSLT) version 2.0. W3c
working draft, World Wide Web Consortium, Nov. 2003.
http://www.w3.org/TR/2003/WD-xslt20-20031112.

[8] S. Maneth and F. Neven. Structured document

transformations based on XSL. In Proceedings of
International Workshop on Database Programming
Languages, pages 80–98, Kinloch Rannoch, Scotland, Sept.
1999.

[9] G. Moerkotte. Incorporating XSL processing into database

engines. In VLDB, pages 107–118, Hong Kong, China, Sept.
2002.

[10] Oasis test suite for XSLT 1.0. http://www.oasis-open.org

/committees /tc home.php?wg abbrev=xslt.

[11] Sarvega XSLT benchmark study and test suite.
http://www.sarvega.com /xslt-benchmark.php.

[12] L. VanVleet, G. K. Holman, and D. Marston. Oasis

XSLT/XPath conformance committee procedures and
deliverables. http://www.w3.org/2001/01/qa-ws/pp
/ken-holman-oasis /xsltconf.htm.

[13] P. Wadler. A formal semantics of patterns in XSLT. In

Markup Languages, Philadelphia, PA, June 2001.

[14] N. Walsh. The docbook document type. Committee

speciﬁcation, Oasis, July 2002.

[15] Xalan XSLT/XPath conformance test suite.

http://xml.apache.org /xalan-j /downloads.html.

[16] XQuery 1.0: An XML query language. W3C Working Draft,

Apr. 2002.

APPENDIX
A. MATCH PATTERN

[]toselect performs the translation of a pattern into the expression
for which an existence test will be performed (by fn:exist()). The
ﬁrst step in the translation consists of obtaining the Equivalent Ex-
pression (EE) deﬁned in XSLT 2.0 [7, §5.5.3]. The EE is an XPath
expression whose ﬁrst step may have attribute-or-top and child-or-
top as axis. The translation rule of an EE is as follows (EPS denotes
a step in the EE deﬁned in [7, §5.5.3]) :

[EPS]toselect = $t2q:dot/(.)[[EPS]match]
[EPS0/.../EPSn]toselect = $t2q:dot/(.)[[EPSn]match][
[[EPSn]axis]inv::node()[[EPSn-1]match]/
.../[[EPS1]axis]inv::node()[[EPS0]match]]

[axis::m[P]]axis=axis
[child]inv=parent
[descendant-or-self]inv=ancestor-or-self
[attribute]inv=parent
[self]inv=self
[axis::m[P]]match=([axis]inv::node()/axis::m[P]=.)
[child-or-top::m[P]]match =if (parent::node)
then (parent::node()/child::m[P]=.)
else self::m[P][not(. instance of attribute())]
[attribute-or-top::m[P]]match=if (parent::node)
then (parent::node()/attribute::m[P] = .)
else ((. instance of attribute()) and [m[P]]test)
[id(value)]match=(id(value) = .)
[root(self::node())]match=(root(self::node())=.)
[key(name,value)]match=([key(name, value)]Const=.)
[KinTest[P]]test=( . instance of KindTest)
and exist((.)[P])
[ncn:*[P]]test=(namespace-uri(.) eq ns)
and exist((.)[P]) - where ncn resolve to ns
[*:localName[P]]test=(local-name(.) eq localName)
and exist((.)[P])
[ncn:localName[P]]test=(namespace-uri(.) eq ns)

and (local-name(.) eq localName)
and exist((.)[P]) - where ncn resolve to ns

[*[P]]test=exist((.)[P])

When the pattern is a union of patterns, then the translation is the

union of the translated patterns.

B. TEMPLATE INSTANTIATION

B.1 Built-in templates

The following XQuery function captures the semantics of select-

ing and invoking built-in templates.

declare function t2q:builtInApplyTemplates(
$t2q:dot as node()?,
$t2q:pos as xs:integer,
$t2q:last as xs:integer,
$t2q:mode as xs:string,
$t2q:param1 as item()*,...,
$t2q:paramp as item()*)
as item()*

{

if (exists($t2q:dot/self::text()
|$t2q:dot/(.)[. instance of attribute()])
then

string-join(

for $t2q:d in data($t2q:dot)
return ($t2q:d cast as xs:string),’ ’)

else if (exists($t2q:dot/self::comment()
|$t2q:dot/self::processing-instruction()))
then ()
else

let $t2q:sequence := $t2q:dot/node() return
let $t2q:inner-last := count($t2q:sequence)
return

for $t2q:inner-dot

at $t2q:inner-pos in $t2q:sequence return
t2q:applyTemplates($t2q:inner-dot,
$t2q:inner-pos,
$t2q:inner-last,$t2q:mode,
$t2q:param1,...,$t2q:paramn)

};
B.2 xsl:next-match instruction

The translation rule generating the XQuery applicator function

corresponding to xsl:next-match is deﬁned as follows:

[(template1, ..., templaten)]
==
declare function t2q:applyNextMatch(
$t2q:dot as node()?,

$t2q:pos as xs:integer,
$t2q:last as xs:integer,
$t2q:mode as xs:string,
$t2q:param1 as item()*, ...,
$t2q:paramp as item()*,
$t2q:impPrec as xs:integer,
$t2q:priority as xs:double)
)
as item()*
{

if ( [template1]priority < $t2q:priority

and [template1]impPrec < $t2q:impPrec
and $t2q:mode = [template1]mode
and exists([template1]toSelect))

then [template1]invoke
...
else if ([templaten]priority < $t2q:priority

and [templaten]impPrec < $t2q:impPrec
and $t2q:mode=[templaten]mode
and exists([templaten]toSelect)) )

then [templaten]invoke
else

t2q:builtInApplyTemplates($t2q:dot,$t2q:pos,

$t2q:last,$t2q:mode,
$t2q:param1,...,$t2q:paramp)

};

where []priority generates the priority of a template and []impPrec
its import precedence. The additional parameters ($t2q:impPrec
and $t2q:priority indicate the import precedence and priority
of the current template. They are used in body of the generated
function to restrict the set of considered templates.

The translation rule for each xsl:next-match instruction is as fol-

lows:

[<xsl:next-match select=’expr’ mode=’mode’>
xsl:with-param*
</xsl:next-match>]Const
==
let $t2q:sequence := [expr]Expr return
let $t2q:inner-last := count($t2q:sequence)
return

for $t2q:inner-dot
at $t2q:inner-pos in $t2q:sequence

return
t2q:applyNextMatch(

$t2q:inner-dot,$t2q:inner-pos,
$t2q:inner-last,
’mode’,
[1]ParamValue(xsl:with-param*),...,
[p]ParamValue(xsl:with-param*),
[.]currentTemplateImpPrec,
[.]currentTemplatePriority)

where [.currentTemplateImpPrec (resp. [.]currentTemplatePriority) generates the
import precendence (resp.
the priority) of the current template
at the location of the invocation of xsl:next-match if it is stati-
cally known; otherwise (e.g.
if xsl:next-match is invoked inside
a named template), it generates the variable $t2q:impPrec (resp.
$t2q:priority), which is always used to indicate the import prece-
dence (resp. the priority) of the current template.
B.3
xsl:apply-imports instruction

The translation of xsl:apply-imports follows the same prin-
ciples presented for xsl:next-match.
In addition to parame-
ters of $t2q:applyTemplates, the XQuery applicator function
implementing xsl:apply-imports logic speciﬁes a parameter
that indicates the import path of the stylesheet module where the
xsl:apply-import is invoked. This is used to restrict the list of
considered templates.


