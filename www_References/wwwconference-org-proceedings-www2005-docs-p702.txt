[1] J. F. Allen. Maintaining Knowledge about Temporal

Intervals. Communications of the ACM,
26(11):832–843, 1983.

[2] C. Bettini, S. Jajodia, and S. X. Wang. Time
Granularities in Databases, Data Mining, and
Temporal Reasoning. Springer-Verlag, 2000.

[3] F. Bry and S. Spranger. Towards a Multi-calendar
Temporal Type System for (Semantic) Web Query
Languages. In Proc. 2nd Int. Workshop Principles and
Practice in Semantic Web Reasoning, LNCS 3208.
Springer-Verlag, 2004.

[4] DARPA Agent Markup Language. A DAML Ontology

of Time, 2002.

[5] N. Dershowitz and E. Reingold. Calendrical

Calculations: The Millennium Edition. Cambridge
University Press, 2001.

[6] T. Fr¨uhwirth and S. Abdennadher.

Constraint-Programmierung. Springer-Verlag, 1997.

[7] B. Ingria and J. Pustejovsky. TimeML: A Formal
Speciﬁcation Language for Events and Temporal
Expressions. 2004.

APPENDIX
A. SYNTAX OF CATTS

A.1

Identiﬁers

t ∈ TyVar
c ∈ CalId
s ∈ CalSigId
f ∈ CalFunId
p ∈ ProgId

type identiﬁers
calendar identiﬁers
calendar signature identiﬁers
calendar function identiﬁers
program identiﬁers

long
long

For each class of identiﬁers X marked “long” there is a
class longX of long identiﬁers; if x ranges over X then longx
ranges over longX. The syntax of the long identiﬁers is given
by the following:

longx ::=

x
c1.

...

.cn.x

long identiﬁers:
identiﬁer
qualiﬁed identiﬁer n ≥ 1

The long identiﬁers constitute a link between declarations

and calendars.

A.2 Grammar

CaTTS grammar, including the syntactic forms for both
language formalisms CaTTS-DL and CaTTS-CL is given in
a BNF-like notation (〈. . . 〉denote n ≤ 0 repetitions).

e ::=

k
n ty
binOp e e
unOp e

alternate x:ty 〈| e → e〉

ce

ce ::=

x
x:ty
ce iRel ce
ce aRel ce
ce && ce

exprs:
constant
duration, n ∈ 
binary op
unary op
alternate
constraints
constraints:
variable
domain constraint
interval relation
arithm. relation
conjunction

binOp ::=

unOp ::=
iRel ::=

aRel ::=

ty ::=

dcl ::=

wspec ::=

shift forward | shift backward |
relative to | + | − | relative in |
∗ | \ | mod | div | max | min
duration of | begin of | end of | index
equals | before | after | starts |
started by | finishes | finished by |
during | contains | meets | met by |
overlaps | overlapped by
== | <= | < | > | >= | ! =

longt
reference
refinement n @ e
aggregate e〈,e〉@ e
select x:ty where e〈e〉
|ty|
ty & ty〈& ty〉
ty | ty〈| ty〉
ty \ ty
ty #< ty
ty #> ty

type t = ty
group t = wspec
dcl;dcl

with ty 〈type t
where e;e for t1=t2〉

types:
type identiﬁer
reference
reﬁne, n ∈ 
aggregation
inclusion
duration
conjunction
disjunction
except
coarser-restrict
ﬁner-restrict
decls:
type
group
sequential
with specs:

caldcl ::=

calbind ::=

cale ::=

fdcl ::=

fbind ::=

sigdcl ::=

sigbind ::=

sige ::=

spec ::=

pdcl ::=

pbind ::=

proge ::=

catdcl ::=

catbind ::=

cate ::=

dcl
calendar calbind

caldcl;caldcl

c〈(:sige)〉= cale

cal caldcl end
longc
f(cale)

cal fun fbind

fdcl;fdcl

f(c:s):s’ = cale

calendar type sigbind

sigdcl;sigdcl

s = sige

sig spec end
s

type t <: ty
type t c : ty
group t c : ty
calendar c:sige
spec;spec

ce
use calendar

〈unqualified〉
longc1 ...longcn ;

import

〈unqualified〉
lib1 ...libn;

use format

〈unqualified〉
cate1 ...caten ;
program pbind
empty
pdcl;pdcl

p proge

prog pdcl end
p

catalog catbind
format fid:ty =

d where e

catdcl;catdcl

cd〈:s〉= cate

cat catdcl end
cd
cate.cd
catalog cd

cal decls:
declaration
calendar
empty
sequential
cal binds:

cal exprs:
generative
identiﬁer
fun appl

fun decls:
generative
empty
sequential
fun binding:

s decls:
generative
empty
sequential
s bindings:

s exprs:
generative
identiﬁer
specs:
aggregation
inclusion
group
calendar
sequential

p decls:
constraint

n ≥ 1

n ≥ 1

n ≥ 1
generative

sequential
p binds:

p exprs:
declaration
identiﬁer

cat decls:
generative
format

empty
sequential
cat binds:

cat exprs:
generative
identiﬁer
qual id
catalog


