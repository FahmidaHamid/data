[1] B. Benatallah, M. Dumas, Q. Z. Sheng, and A. H. H. Ngu.

Declarative composition and peer-to-peer provisioning of dynamic
web services. In Proc. 18th Int. Conf. on Data Eng., 2002.

[2] D. Berardi, D. Calvanese, G. De Giacomo, M. Lenzerini, and

M. Mecella. Automatic composition of e-services that export their
behavior. In Proc. of the 1st Int. Conf. on Service Oriented
Computing, 2003.

[3] A. Betin-Can and T. Bultan. Veriﬁable concurrent programming

using concurrency controllers. In Proc. of the 19th IEEE Int. Conf.
on Automated Software Eng., 2004.

[4] Business process execution language for web services version 1.1.

http://www-106.ibm.com/developerworks/webservices/library/
ws-bpel/, May 2003.

[5] G. Brat, K. Havelund, S. Park, and W. Visser. Java pathﬁnder:

Second generation of a Java model checker. In Proc. Workshop on
Advances in Veriﬁcation, 2000.

[6] T. Bultan, X. Fu, R. Hull, and J. Su. Conversation speciﬁcation: A
new approach to design and analysis of e-service composition. In
Proc. of the 12th Int. World Wide Web Conf., 2003.

[7] Z. Cheng, M. P. Singh, and M. A. Vouk. Verifying constraints on

web service compositions. In Real World Semantic Web
Applications, June 2002.

[8] W. Crawford and J. Kaplan. J2EE Design Patterns. O’Reilly and

Associates Inc., Sebastopol,California, 2003.

[9] H. Foster, S. Uchitel, J.Magee, and J.Kramer. Model-based

veriﬁcation of web service compositions. In Proc. of. the 18th Int.
Conf. on Automated Software Eng., 2003.

[10] X. Fu, T. Bultan, and J. Su. Conversation protocols: A formalism for
speciﬁcation and veriﬁcation of reactive electronic services. In Proc.
of the 8th Int. Conf. on Implementation and Application of Automata,
2003.

[11] X. Fu, T. Bultan, and J. Su. Analysis of interacting BPEL web
services. In Proc. of the 13th Int. World Wide Web Conf., 2004.

[12] J. E. Hanson, P. Nandi, and S. Kumaran. Conversation support for

business process integration. In Proc. of the 6th Int. Enterprise
Distributed Object Computing Conf., 2002.

[13] G. J. Holzmann. The model checker SPIN. IEEE Transactions on

Software Eng., 23(5):279–295, May 1997.

[14] Conversation support for agents, e-business, and component

integration. http://www.research.ibm.com/convsupport

[15] Java API for XML messaging (JAXM).

http://java.sun.com/xml/jaxm/

[16] Java Message Service. http://java.sun.com/products/jms/
[17] P. C. Mehlitz and J. Penix. Design for veriﬁcation using design
patterns to build reliable systems. In Proc. of 6th Workshop on
Component-Based Software Eng., 2003.

[18] L. Meredith and S. Bjorg. Contracts and types. Communications of

ACM, 46(10):41–47, October 2003.
[19] Microsoft Message Queuing Service

http://www.microsoft.com/msmq

[20] S. Nakajima. Veriﬁcation of web service ﬂows with model-checking

techniques. In Int. Symposium on Cyber Worlds: Theories and
Practice, 2002.

[21] S. Narayanan and S. A. McIlraith. Simulation, veriﬁcation and

automated composition of web services. In Proc. of the 11th Int.
World Wide Web Conf., 2002.

[22] OWL-S: Semantic markup for web services.

http://www.daml.org/services/owl-s/1.0/owl-s.html, 2003.

[23] S. K. Rajamani and J. Rehof. Conformance checking for models of

asynchronous message passing software. In Proc. of the Int. Conf. on
Computer Aided Veriﬁcation, 2002.

[24] Web service choreography interface 1.0.

http://www.w3.org/TR/wsci/, August 2002.

[25] Web services description language (WSDL) 1.1.

http://www.w3.org/TR/wsdl

[26] Extensible markup language. http://www.w3.org/XML/

Figure 6: Effect of the Queue Size on the State Space

chines deﬁning the interfaces of these peers are shown in Figure 5.
We veriﬁed the behavior of this example with different queue sizes.
As shown in Figure 6, the state space increases exponentially with
the size of the queues. In fact, the number of reachable states for
this example is inﬁnite if unbounded queues are used. The expo-
nential growth in the state space affects the performance of SPIN
signiﬁcantly. SPIN ran out of memory when the queue size was
set to 15. On the other hand, our automated synchronizability ana-
lyzer identiﬁed this example as synchronizable. Therefore, we can
verify this service by replacing asynchronous communication with
synchronous communication without changing the conversation set
generated by this composite web service. With synchronous com-
munication there are only 68 states and the behavior veriﬁcation
succeeds and uses 1.49 MB memory.

Our experiments show that the modularity in the veriﬁcation pro-
cess based on the Peer Controller Pattern improves the efﬁciency
of the veriﬁcation of composite web services signiﬁcantly. We
can verify asynchronously communicating web service implemen-
tations using reasonable amount of time and memory which are
otherwise too large for a Java model checker to handle. With the aid
of the synchronizability analysis, during the behavior veriﬁcation,
we can reason about the global behavior with respect to unbounded
queues and perform the behavior veriﬁcation efﬁciently. Further-
more, the usage of the stubs during the interface veriﬁcation causes
a signiﬁcant reduction in the state space, thus improving the perfor-
mance of the veriﬁcation process.

7. CONCLUSIONS

In this paper, we presented a veriﬁable design pattern for devel-
oping reliable composite web services. Based on this pattern, we
developed a modular veriﬁcation approach that enables developers
to check both the global behaviors of the composite web services
(behavior veriﬁcation) and the conformance of peer implementa-
tions to their interfaces (interface veriﬁcation). We showed that the
global behavior of a composite web service can be veriﬁed using
the SPIN model checker, by automatically translating the peer in-
terfaces to a Promela speciﬁcation. By adapting the synchronizabil-
ity analysis proposed in [11], we veriﬁed conversations of compos-
ite web services with respect to unbounded queues and improved
the efﬁciency of the behavior veriﬁcation. We showed that the in-
terface veriﬁcation can be performed with the program checker JPF
using the peer interfaces as stubs for the communication compo-
nent. Since these stubs are ﬁnite state machines and abstract the
asynchronous messaging, we achieved a signiﬁcant improvement
in the efﬁciency of the interface veriﬁcation. Another beneﬁt of
the presented approach is the explicit speciﬁcation of the peer in-
terfaces, which can be used to improve interoperability. To support
this, we automatically generated BPEL speciﬁcations from the peer
interfaces.


