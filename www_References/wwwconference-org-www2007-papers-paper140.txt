[1] K. Bhargavan, R. Corin, C. Fournet, and A. D. Gordon.

Secure sessions for web services. In Workshop on Secure
Web Services, pages 56–66, 2004.

[2] D. Dolev and A. Yao. On the security of public-key

protocols. IEEE Transactions on Information Theory,
29:198–208, 1983.

[3] O. Goldreich. The Foundations of Cryptography. Cambridge

University Press, Cambridge, UK, 2004.

[4] J. D. Guttman, J. C. Herzog, J. D. Ramsdell, and B. T.

Sniffen. Programming cryptographic protocols. In Trust in
Global Computing, pages 116–145, 2005.

[5] J. D. Guttman, F. J. Thayer, J. A. Carlson, J. C. Herzog, J. D.

Ramsdell, and B. T. Sniffen. Trust management in strand
spaces: A rely-guarantee method. In European Symposium
on Programming, pages 325–339, 2004.

[6] C. Haack and A. Jeffrey. Pattern-Matching Spi-Calculus. In

Formal Aspects in Security and Trust, pages 55–70, 2004.

[7] X. Leroy, D. Doligez, J. Garrigue, D. R´emy, and J. Vouillon.

The Objective Caml System. INRIA,
http://caml.inria.fr/, 2000. Version 3.00.

[8] J. Matthews, R. B. Findler, P. T. Graunke, S. Krishnamurthi,
and M. Felleisen. Automatically restructuring programs for
the Web. Automated Software Engineering, 11(4):337–364,
2004.

[9] K. Onda, V. T. Vasconcelos, and M. Kubo. Language

primitives and type discipline for structured
communication-based programming. In European
Symposium on Programming, pages 122–138, 1998.

[10] Project EVA. Security protocols open repository.

http://www.lsv.ens-cachan.fr/spore/, 2007.

[11] F. J. Thayer, J. C. Herzog, and J. D. Guttman. Strand spaces:

Proving security protocols correct. Journal of Computer
Security, 7(2/3):191–230, 1999.

being made to Web server performance to handle more simultane-
ous sessions.

7. RELATED WORK

In the introduction, we alluded to a strawman solution involv-
ing uniform modiﬁcation of protocols. That approach corresponds
to past work [8] on compiling sequential interactive programs into
programs that run in Web servers. Their compiler consumes con-
sole programs that present a prompt and react to what the user types
into Web applications that present a form and resume when the
user submits a response. The compiler functions by computing and
storing the continuation at each interaction point, and encoding the
computation’s closure in a combination of hidden ﬁelds, database
records, and cookies. On response, this continuation is invoked
with the client’s response and the program continues, oblivious to
the modiﬁcation. A nonce records which continuation to resume at
each form submission.

This solution is inappropriate for CPPL programs for several rea-
sons. First, CPPL programs need not follow every send with a re-
ceive. Second, CPPL programs may involve more than two partici-
pants. A third, essential, reason why this solution is not appropriate
is that it changes the format of the messages by adding the encoded
continuations. In our environment this corresponds to changing the
protocol itself, which makes existing proofs invalid.

There is another reason why that work is inappropriate here. A
goal of that research is to ensure that continuations may be invoked
safely multiple times, e.g., that the Web browser’s Back button may
be used safely. We expressly do not wish to support this because it
would correspond to replay attacks and violate freshness assump-
tions.

One aspect of our work extends CPPL to include match state-
ments that perform pattern matching. Other languages for program-
ming cryptographic protocols also contain this functionality. Haack
and Jeffrey [6] discuss their pattern-matching system in the context
of the Spi-calculus. They also discuss the subtlety we mention in
Sec. 4.1 regarding whether identiﬁers introduced by EXISTS forms
can be used in an encrypting position in a pattern. Our work is
complementary to theirs in this aspect, as our system is based on a
strand-space semantics and this feature is not our sole contribution.

8. CONCLUSION

We have shown how a CPPLm program can be analyzed and com-
piled into a form that allows it to be used in the context of a Web
server. We have argued that the properties proved on the original
protocol are preserved, and we have presented a dispatching strat-
egy that enables multiple sessions to not interfere with one another.
We have built an implementation that can be used by protocol en-
gineers to produce efﬁcient implementations.

The approach used in this work may be applied to other prob-
lems as well. For example, there is work that produces proto-
cols that guarantee that participants implement session types [1, 9].
We could analyze the constraints of existing protocols and ensure
that they imply that messages contain the appropriate cryptographic
forms that enforce the session type property, thereby allowing this
work to be applied to existing protocols.

We would like to extend our language with regular expressions
types (to represent XML) and extend our analyses to handle them,
then apply our work to XML Web service protocols that exist in
the wild. We would also like to optimize the dispatcher design
presented here to eliminate many tests when many protocol runs
share similar constraints and message patterns, by associating the
shape of incoming messages with existing sessions.

WWW 2007 / Track: Security, Privacy, Reliability, and EthicsSession: Access Control and Trust on the Web696
