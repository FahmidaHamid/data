[1] S. Abiteboul, O. Benjelloun, and T. Milo. Positive

Active XML. In Proc. of PODS-2004, 2004.

[2] M. Alves, C. V. Damásio, W. Nejdl, and D. Olmedilla.

A Distributed Tabling Algorithm for Rule Based
Policy Systems. In Proc. of POLICY-2006, 2006.

[3] T. Berners-Lee, D. Connolly, L. Kagal, Y. Scharf, and
J. Hendler. N3logic: A logic for the web. J. of Theory
and Practice of Logic Programming (TPLP), Special
Issue on Logic Programming and the Web, 2007.

[4] E. Prud’hommeaux, A. Seaborne (eds.). SPARQL

Query Language for RDF.
http://www.w3.org/TR/rdf-sparql-query/, 2007.

[5] E. Sirin and B. Parsia. SPARQL-DL: SPARQL Query

for OWL-DL. In Proc. of OWLED 2007, 2007.

[6] M. J. Franklin, A. Y. Halevy, and D. Maier. From
Databases to Dataspaces: A new Abstraction for
Information Management. SIGMOD Record, 34(4),
2005.

[7] A. V. Gelder. The alternating ﬁxpoint of logic

programs with negation. In Proc. of ACM
SIGACT-SIGMOD-SIGART-1989, 1989.

10http://pipes.deri.org/

[8] H. Stoermer et al. RDF and Contexts: Use of

SPARQL and Named Graphs to Achieve
Contextualization. In Proc. of 2006 Jena User
Conference, 2006.

[9] Harold Boley and Michael Kifer (eds.). RIF Core
Design. http://www.w3.org/TR/rif-core/, 2007.
[10] I. Horrocks et al. SWRL: A Semantic Web Rule

Language Combining OWL and RuleML.
http://www.w3.org/Submission/SWRL/, 2004.
[11] J. Carroll et al. Named Graphs, Provenance and

Trust. In Proc of WWW-2005, 2005.

[12] A. Magkanaraki, V. Tannen, V. Christophides, and
D. Plexousakis. Viewing the semantic web through
RVL lenses. J. Web Semantics, 1(4), 2004.

[13] P. Bouquet et al. Contextualizing Ontologies. J. of

Web Semantics, 1(4), 2004.

[14] P. Hayes (ed.). Rdf semantics.

http://www.w3.org/TR/rdf-mt/, 2004.

[15] J. Pérez, M. Arenas, and C. Gutierrez. Semantics and
Complexity of SPARQL. In Proc. of ISWC-2006, 2006.

[16] A. Polleres. From SPARQL to rules (and back). In

Proc. of WWW-2007, 2007.

[17] S. Schenk. A SPARQL Semantics Based on Datalog.

In Proc. of KI2007, 2007.

[18] S. Schenk and S. Staab. Networked RDF Graphs.

Technical report, 2007. http://uni-koblenz.de/
∼sschenk/publications/2007/ngtr.pdf .

[19] M. Sintek, L. van Elst, S. Scerri, and S. Handschuh.
Distributed Knowledge Representation on the Social
Semantic Desktop: Named Graphs, Views and Roles
in NRL. In Proc. of ESWC-2007, 2007.

[20] A. van Gelder, K. Ross, and J. S. Schlipf. The

Well-Founded Semantics for General Logic Programs.
J. of the ACM, 38(3), 1991.

[21] R. Volz, D. Oberle, and R. Studer. Implementing

Views for Light-Weight Web Ontologies. In 7th
International Database Engineering and Applications
Symposium. IEEE, 2003.

APPENDIX
A. FORMAL SEMANTICS OF

NETWORKED GRAPHS

We limit our deﬁnitions here to well deﬁned graph pat-
terns as deﬁned in [15]. Graph patterns, which are not well
deﬁned introduce another kind of non monotonicity apart
from bound negation, which would complicate the following
deﬁnitions.

Definition 6

(Well Designed Graph Pattern).
A graph pattern P is well designed, if for every occurrence of
a sub-pattern P0 = (P1 OPTIONAL P2) of P and for every
variable ?x occurring in P , the following condition holds: if
?x occurs both inside P2 and outside P0, then it also occurs
in P1.

Further, we forbid the use of result modiﬁers: ORDER
does not make sense as the result of a CONSTRUCT query
is a graph and as such a set. When LIMIT and OFFSET are
used to retrieve only a slice of the query results, the seman-
tics of a query may become unclear, as the result becomes
implementation speciﬁc.

592WWW 2008 / Refereed Track: Semantic / Data Web - Semantic Web IIApril 21-25, 2008 · Beijing, ChinaData Structures

U
R
V
S

The set of all URIs
The set of all URIs, blank bodes and RDF literals
The set of all SPARQL variables
Polarized statement,
R × U × R × {true, f alse}

a quadruple of

the

form

GW Well founded graph, a set of polarized statements
Q
D

A well formed SPARQL query
Dataset, a set of the form
{G, (n1, G1), (n2, G2), ...(nn, Gn)}
Set of interdependent graphs

I

pos(GW )
neg(GW )
dSet(Q)

Auxiliary Functions
{(s, p, o)|(s, p, o, +) ∈ GW }
{(s, p, o)|(s, p, o, −) ∈ GW }
dataset of a query

¬D negation of a dataset

dependsOn(v1, v2)

view dependency

DISet(I) The set of datasets of the views in I

Table 1: Data Structures and Auxiliary Functions

A.1 Datastructures

We start by deﬁning necessary data structures. The se-
mantics is deﬁned on well founded graphs, which consist of
positive and negative statements. Note that we only need
this construct to deﬁne the semantics. We do not need to ex-
press it in RDF. Deﬁnitions 7 and 8 adjust deﬁnitions from
[4]. Deﬁnitions 11 and 12 extend them to sets of NGs.

Definition 7

A polarized statement
R × U × R × {+,−}

(Well Founded Graph).
is a quadruple of

the form:

A well founded graph GW is a set of polarized statements.
We say the positive subgraph pos(GW ) of GW is the set

{(s, p, o)|(s, p, o, +) ∈ GW}.
{(s, p, o)|(s, p, o,−) ∈ GW}.

We say the negative subgraph neg(GW ) of GW is the set

pos(GW ) and neg(GW ) are disjunct.
The RDF interpretation of a well founded graph GW is
pos(GW ). The well founded graph of an RDF graph G is
the set {(s, p, o, +)|(s, p, o) ∈ G}.

Deﬁnition 7 extends to named graphs and Networked

Graphs.

We determine dependencies of views based on the datasets

Definition 8

of SPARQL queries.
A dataset is a set {G, (n1, G1), (n2, G2), ...(nn, Gn)} where
G and each Gi are well founded graphs, and each ni is a
URI. All ni are distinct.

(Dataset).

G is called the default graph of the dataset, deﬁned us-
ing FROM. (ni, G1) are called named graphs, deﬁned using
FROM NAMED. Let Q be a SPARQL query, then dSet(Q)
is the dataset deﬁned in Q

We will use negation and union of datasets.
Definition 9

(Negation of a Dataset).

The negation of a dataset D, written ¬D, is the dataset for
which the following holds:
If (n, G) ∈ D (or G ∈ D) then (n, G(cid:48)) ∈ ¬D (or G(cid:48) ∈ ¬D
Iﬀ (s, p, o, +) ∈ G then (s, p, o,−) ∈ G(cid:48) and
iﬀ (s, p, o,−) ∈ G then (s, p, o, +) ∈ G(cid:48).
Definition 10

respectively) such that for all s, p, o :

(Union of Datasets).

The union of datasets D1 and D2, written D1 ∪ D2 is the

dataset for which the following holds: Let (n, G) ∈ D1

• The default graph of D1∪ D2 is the union of the default

• If there is no (n, G(cid:48)) ∈ D2, then (n, G) ∈ D1 ∪ D2 else

graphs of D1 and D2.

(n, G ∪ G(cid:48)) ∈ D1 ∪ D2.

To evaluate a NG GW we must take into account all

graphs, which GW depends upon.

Definition 11

(Interdependence Set).

We say a view v1 depends on another view v2, written
dependsOn(v1, v2), if G is a graph in the dataset of v1 and
v2 is used in a view deﬁnition in G.

An interdependence set I is a set of NGs, such that for
all view deﬁnitions v1 and v2 the following holds: If v1 is
a view deﬁnition in graph G and G ∈ I and dependsOn(v1,
v2), then all Gi ∈ dSet(v2) are also in I.

Figure 1 in section 4 illustrates the interdependence set
containing mikesProject. We refer to all datasets involved in
evaluating the semantics of an interdependence set as the
dataset of an interdependence set.

Definition 12

(DISet).

The dataset of the interdependence set shown in ﬁgure 1

The dataset of an interdependence set I, written DISet(I)
is the set of the datasets of the views deﬁning graphs in I.
Graphs with equal names in any two datasets in DISet(I)
are equal.
is {{(:bobFOAF, bobFOAF), (:chrisFOAF, chrisFOAF)},
{(:mikesProject, mikesProject), (:DBLP, DBLP)},
{mikesProject}}
A.2 SPARQL Evaluation with Symmetric

Negation

We need a small change to the SPARQL semantics in or-
der to treat negation symmetrically, by explicitly negating
statements instead of using negation by failure. The follow-
ing deﬁnitions 13 - 15 are taken from [4] and extended to
well founded graphs.

The SPARQL speciﬁcation [4] deﬁnes a function eval(D,
GP) as the evaluation of a graph pattern GP with respect
to a dataset D. Basically GP is the graph pattern of a view
and D is the dataset deﬁned in the view. The range of eval
is a solution sequence
Definition 13
A solution mapping, µ, is a partial function µ : V → T
mapping from a set of variables to a set of RDF terms.

(Solution Mapping/Sequence).

A solution sequence is a list of solution mappings.
Let Q be a SPARQL query and µ a solution mapping. Q/µ
is the query obtained by replacing every variable ?x in Q by
µ(?x), if µ(?x) is deﬁned. We say µ is complete for Q, if it is
deﬁned for all variables of Q. Analogously, we deﬁne GP/µ
as the RDF graph obtained by substituting every variable ?x
in a graph pattern GP by µ(?x).

The solution of a CONSTRUCT query is the set of state-
ments obtained by instantiating the CONSTRUCT pattern
using the solution mappings computed by eval. eval is de-
ﬁned for every operator in the SPARQL algebra. It is deﬁned
by recursively applying it to its parameters and using join
and select operations on the results. We do not discuss in
detail how eval is deﬁned, but simply use it as the operator
for the evaluation of a single view in a single iteration in the
following. However, we need to slightly change the deﬁni-
tion of basic graph pattern matching in order to use it with

593WWW 2008 / Refereed Track: Semantic / Data Web - Semantic Web IIApril 21-25, 2008 · Beijing, Chinawell founded graphs. The operator which matches statement
patterns against the dataset is eval(G, BGP), where BGP
is a basic graph pattern consisting only of joins of state-
ment patterns and G is a single RDF graph.
In contrast
to the other operators, basic graph pattern matching is di-
rectly evaluated without subsequent calls of eval — here the
actual matching against the dataset takes place.

Definition 14

(Statement Pattern).

A statement pattern is a triple of the form
(R ∪ V ) × (U ∪ V ) × (R ∪ V ).

We say a statement pattern S enclosed in an OPTIONAL
pattern O of a SPARQL graph pattern P in a query Q is
matched negatively in Q, if the following hold:

• ?x is a variable not used in statement patterns outside
O and at least one of the subject, predicate or object is
?x or S is enclosed in a graph pattern GRAPH ?x {...
S ...} and

• P contains a FILTER expression outside O, which con-
tains the ﬁlter expression BOUND(?x) nested in an odd
number of negations.

We say that a statement pattern is matched positively, if

it is not matched negatively.

The notion of a negatively matched statement pattern for-
malizes bound negation, introduced in section 3. In example
3, (?x foaf:currentProject :SemWebProject) is matched
negatively, all other statement patterns are matched posi-
tively. We redeﬁne basic graph pattern matching, such that
negative statements are matched instead of using negation
as failure, hence treating negation symmetrically. Negative
statements are indirectly introduced in NGs evaluation by
negating the largest unfounded set, as we will see below.

Definition 15

(Basic Graph Pattern Matching).

A Basic Graph Pattern is a set of statement patterns.

Let BGP be a basic graph pattern in a query Q and GW be
a well founded graph. Let posBGP ( negBGP) be the basic
graph pattern containing exactly the positively (negatively)
matched statement patterns in BGP .

eval(GW , BGP ) is a solution sequence. µ is a solution in

eval(GW , BGP ), if it is complete for BGP and

• posBGP/µ ⊆ pos(GW ) and
• negBGP/µ (cid:42) neg(GW ) and
• if a statement pattern S in BGP matches some state-
ment in neg(GW ) then S/µ ∈ negBGP , else µ maps
at least one variable in S to some skolem value

This deﬁnition of basic graph pattern matching treats pos-
itively matched statement patterns as in [4]. The result is
empty, if negatively matched statements are known to be
negative. For single SPARQL queries, the negative state-
ments are exactly the complement of the statements listed
in the RDF graphs in the dataset, so the behavior is also
the same here. If, however, a negatively matched statement
pattern does not match a negative statement (the matched
statement is unknown), a result with skolem values is ob-
tained. This result then is ﬁltered out, because of the bound
negation used in the query. Using standard negation as fail-
ure here as in [4], would let the bound negation succeed.
A.3 Well Founded Semantics of NGs

The extended SPARQL evaluation function deﬁned above
is used to deﬁne the direct consequence operator of the well

founded semantics for true statements. For negative state-
ments the direct consequence is deﬁned using the negation
of the greatest unfounded set.

Definition 16

(Unfounded Set).

Let I be an interdependence set.

We say dataset U is an unfounded set of I, if for every
polarized statement S in any graph GW in U the following
hold:

S = (s, p, o, +) is positive and for every view v in GW
and for every complete solution mapping µ for v, such that
(s, p, o) is in the CONSTRUCT pattern of v/µ, one of the
following holds:

1. some positively matched statement in the graph pattern

of v/µ is negative in I or

2. some ﬁlter expression in the graph pattern of v, which
is not surrounded by an optional pattern, evaluates to
false or

3. some negatively matched statement in the graph pattern
of v/µ is positive in I and no ﬁlter expression inside
the OPTIONAL surrounding the statement evaluates to
false or

4. some positively matched statement in v occurs in U.
The greatest unfounded set of I is the union of all un-

founded sets of I.

The second and third case make sure we treat solutions
correctly, which in principle meet the unfoundedness con-
ditions but are ﬁltered out by some ﬁlter condition, which
is not used to deﬁne bound negation. We deﬁne the direct
consequence operator WI of the well founded semantics for
NGs based on unfounded sets and the evaluation function
eval. WI assumes all statements in the greatest unfounded
set to be negative and thus introduces negative statements
to NGs evaluation.
Definition 17

(Transformations TI, UI and WI).
We deﬁne three transformations TI, UI and WI mapping
from DISets to DISets. Let I be an interdependence set con-
taining a NG GW and D = DISet(I).

• (s, p, o, +) ∈ GW in all datasets in TI (D), iﬀ there is
a view v deﬁning GW , such that the result of v evalu-
ated against dset(v) in D using the SPARQL evaluation
function eval contains (s, p, o).

• UI (D) is the greatest unfounded set of I wrt. D.
• WI (D) = TI (D) ∪ ¬UI (D)
Theorem 4. TI, UI and WI are monotonic.
Proof: directly from the deﬁnitions.
From theorem 4 follows, that TI has a ﬁxpoint [20].
Definition 18.

The semantics of an interdependence set I is deﬁned as the
least ﬁxpoint of WI (I). The semantics of an RDF graph G
in an interdependence set I, deref(G), is the set of positive
statements assigned to the corresponding well founded graph
in the datasets in the DISet of I.

For the ﬁnite case, the least ﬁxpoint is reached in ﬁnitely
many steps [20]. As NG deﬁnitions are ﬁnite, the only source
of non ﬁniteness can be blank nodes created in the CON-
STRUCT patterns of view deﬁnitions. All other generated
statements can only be made of elements of the ﬁnite set
of RDF resources used in statements in the DISet. Hence,
ﬁniteness of NG evaluation can be checked using a simple
syntactic test.

594WWW 2008 / Refereed Track: Semantic / Data Web - Semantic Web IIApril 21-25, 2008 · Beijing, China
