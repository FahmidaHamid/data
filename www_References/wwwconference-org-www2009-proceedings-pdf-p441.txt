[1] M. F. Arlitt and C. L. Williamson. Trace-driven simulation

of document caching strategies for internet web servers.
Simulation J., 68:23–33, 1997.

[2] A. Borodin and R. El-Yaniv. Online Computation and

Competitive Analysis. Cambridge University Press, 1998.

[3] A. Z. Broder, D. Carmel, M. Herscovici, A. Soﬀer, and

J. Zien. Eﬃcient query evaluation using a two-Level
retrieval process. In Proc. 12th CIKM, pages 426–434, 2003.

[4] A. Z. Broder, M. Charikar, A. M. Frieze, and

M. Mitzenmacher. Min-wise independent permutations.
JCSS, 60:630–659, 2000.

[5] P. Cao and S. Irani. Cost-aware WWW proxy caching
algorithms. In Proc. USENIX Symposium on Internet
Technologies and Systems, 1997.

[6] F. Chierichetti, R. Kumar, and S. Vassilvitskii. Similarity

caching, 2008. Manuscript.

[7] M. Datar, N. Immorlica, P. Indyk, and V. S. Mirrokni.

Locality-sensitive hashing scheme based on p-stable
distributions. In Proc. 20th SoCG, pages 253–262, 2004.

[8] T. Fagni, R. Perego, F. Silvestri, and S. Orlando. Boosting

the performance of web search engines: Caching and
prefetching query results by exploiting historical usage
data. ACM TOIS, 24(1):51–78, 2006.

[9] F. Falchi, C. Lucchese, S. Orlando, R. Perego, and

F. Rabitti. A metric cache for similarity search. In Proc.
6th Workshop on LSDSIR, 2008.

[10] M. R. Garey and D. S. Johnson. Computers and

Intractability: A Guide to the Theory of NP-Completeness.
W. H. Freeman and Co., 1979.

[11] T. F. Gonzalez. Clustering to minimize the maximum

intercluster distance. TCS, 38(2-3):293–306, 1985.

[12] P. Indyk. Low-distortion embeddings of ﬁnite metric
spaces. In Handbook of Discrete and Computational
Geometry. CRC Press, 2004.

[13] P. Indyk and R. Motwani. Approximate nearest neighbors:

Towards removing the curse of dimensionality. In Proc.
30th STOC, pages 604–613, 1998.

[14] R. Lempel and S. Moran. Optimizing result prefetching in
Web search engines with segmented indices. In Proc. 28th
VLDB, pages 370–381, 2002.

[15] R. Lempel and S. Moran. Predictive caching and

prefetching of query results in search engines. In Proc. 12th
WWW, pages 19–28, 2003.

[16] X. Long and T. Suel. Three-level caching for eﬃcient query

processing in large web search engines. In Proc. 14th
WWW, pages 257–266, 2005.

[17] E. P. Markatos. On caching search engine query results. In

Computer Communications, pages 137–143, 2000.

[18] R. Motwani and P. Raghavan. Randomized Algorithms.

Cambridge University Press, 1995.

[19] P. C. Saraiva, E. S. de Moura, N. Ziviani, W. Meira,

R. Fonseca, and B. Riberio-Neto. Rank-preserving two-level
caching for scalable search engines. In Proc. 24th SIGIR,
pages 51–58, 2001.

[20] I. Tatarinov, A. Rousskov, and V. Soloviev. Static caching

in Web servers. In Proc. 6th CCN, page 410, 1997.

[21] J. Zhang, X. Long, and T. Suel. Performance of compressed

inverted list caching in search engines. In Proc. 17th
WWW, pages 387–396, 2008.

Note that if the adversary chooses a good element we have
a cache hit with probability at least qe + qc. On the other
hand, if the adversary chooses a bad element, we can lower
bound the probability of a cache hit with qe. Fix a cache
at time t = 0, and a sequence of length ‘. Consider the
queries in the ‘-sequence generated by ξc event:
let B be
the fraction of these queries generated from a bad item. It
is easy to see that the overall hit rate will be qe + qc (1 − B).
We will show that E[B] ≤ (1 + o(1)) 1
2 , thereby completing
the proof.

Let Xt the number of distinct elements that are bad that
are still in the cache at time t, or have been evicted at some
time t0 : t0 ≤ t0 ≤ t. Note that as the sequence progresses,
Xt increases (Xt = Xt−1 +1) iﬀ the adversary chooses a good
item and event ξc happens, and Xt decreases (Xt = Xt−1 −
1) iﬀ the adversary chooses a bad item and ξc happens.4
In case ξe happens, the new item is an exact copy and the
number of distinct bad items stays the same; in case of ξf
the new item is good.
Note that the expected number of changes to Xt after a
sequence of length ‘ is exactly ‘ · qc. Furthermore, since Xt
can never become negative, the total number of decreases is
at most the total number of increases plus k (that is, the k
original cache items, that could all have been bad). Since k is
an additive factor, as ‘ → ∞, the total number of decreases
(and thus the total number of bad adversarial choices that
triggered a ξc event) makes up at most a B = (1 + o(1)) 1
2
fraction of all Xt’s changes, which implies that on almost
half of the ξc events the algorithm will not fault.

Discussion. Recall, that the best ﬁt for the model with
k = 1000 was p = 0.18, α = 0.2 and β = 0.4. Our analysis
tells us that the exact hit rate should be less than 7% and
the similarity caching hit rate with τ = 0.8, must be at
least 14%. Experimentally, the hit rate was 6.4% for exact
caching and 24% for similarity caching. This is a very close
match to the model results, especially taking the fact that
the similarity caching algorithm is much more advanced than
the fifo algorithm analyzed.

6. CONCLUSIONS

We formally deﬁned the problem of similarity caching in
this paper and studied it under two diﬀerent objectives, i.e.,
threshold and smooth. Our proposed caching policies in-
crementally re-organize the cache to ensure that the cached
items cover the similarity space eﬃciently. By conducting
extensive experiments on real data we demonstrated how
similarity caching can signiﬁcantly improve the performance
of content-match systems, without compromising much in
terms of accuracy.

Supplementing our empirical evaluation, we proposed a
simple generative model of content-match page requests. We
validated this model by ﬁtting it to the real data and pro-
vided a theoretical analysis of similarity caching under this
model.

7. ACKNOWLEDGMENTS

We would like to thank Arun Iyengar for his insightful

comments, and Jason Zien for his help with the data.

4Note that if the chosen bad item is also the least recently
used element in the cache, then it is converted into a good
item before eviction by our policy.

WWW 2009 MADRID!Track: Search / Session: Caching and Indices450
